<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="dns-prefetch" href>
  <title>面试问题汇总 | 既白</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="项目自我介绍我叫周思远，大工软院19届，现保研到华科计院。在校期间参加过计算机设计大赛等科创竞赛，也获得过三好学生、优秀毕业生，优秀党员等荣誉。">
<meta name="keywords" content="基础,复习">
<meta property="og:type" content="article">
<meta property="og:title" content="面试问题汇总">
<meta property="og:url" content="/2021/20211001面试汇总/index.html">
<meta property="og:site_name" content="既白">
<meta property="og:description" content="项目自我介绍我叫周思远，大工软院19届，现保研到华科计院。在校期间参加过计算机设计大赛等科创竞赛，也获得过三好学生、优秀毕业生，优秀党员等荣誉。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105022.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105023.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518212123.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518212159.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518212226.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518212304.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105024.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105025.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105026.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105027.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105028.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105029.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105030.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105031.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105032.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105033.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105034.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104735.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104736.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104737.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104738.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104739.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104740.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104741.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210507093240.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104742.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104743.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104744.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104745.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104746.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104747.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104748.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104749.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104750.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104751.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104752.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104753.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104754.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104755.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104756.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104757.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104758.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104759.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104800.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104801.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104802.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104803.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104804.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104805.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104806.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104807.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104808.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104809.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104810.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104812.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104813.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104814.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104815.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104816.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104817.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104818.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104819.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104820.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104821.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104822.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104823.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104818.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104824.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104825.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104826.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104827.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104828.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104829.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104830.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104831.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104832.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104833.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104834.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104835.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104836.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104837.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104838.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104839.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104840.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104841.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104842.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104843.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104844.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104845.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105244.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105245.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105246.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105247.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105248.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105249.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210417165517.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210513111121.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105250.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105251.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105252.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105253.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105254.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105252.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105255.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105256.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105257.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105258.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105259.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105300.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105301.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105302.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105303.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105304.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105305.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105306.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105307.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105308.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105309.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105310.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105311.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105312.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105115.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105116.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105117.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105118.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105119.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105120.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105121.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105122.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105123.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105124">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105125.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105126.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105127.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105128.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105129.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105130.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105131.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105132.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105133.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105134.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105135.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105136.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105137.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105138.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210417163437.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506110557.webp">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506105010.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506105108.jpeg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506111742.jpeg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105140.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105141.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105142.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105143.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105144.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105145.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105146.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105147.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105510.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105511.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105512.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105513.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105514.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105515.webp">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105516.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105517.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105518.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105519.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105520.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105521.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105522.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105523.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105524.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105525.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105526.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105527.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105528.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105529.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105530.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105531.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105532.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105533.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105534.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105535.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105536.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105537.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105538.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105539.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105540.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105541.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105542.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105543.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105544.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105545.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111343.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111344.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111345.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111346.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111347.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111348.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111349.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111350.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111351.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111352.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111353.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111354.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111355.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111356.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111357.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111358.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111359.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111400.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111401.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111402.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111403.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111404.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111405.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111406.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111407.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111408.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111409.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111410.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111411.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111412.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111413.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111414.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111415.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111416.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111417.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111421.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111418.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111419.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111420.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111422.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111423.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111424.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111425.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111426.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506103242.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506104724.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414114329.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414114330.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414114331.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414114332.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110734.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110735.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110736.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110737.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110738.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110739.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110740.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110741.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110742.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110743.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110744.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110745.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110746.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110747.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110748.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110749.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110750.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110751.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110752.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110753.png">
<meta property="og:image" content="c:/Users/zsy/AppData/Roaming/Typora/typora-user-images/image-20210417223000949.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110754.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110755.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110756.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110757.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110758.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110759.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110800.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110801.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110802.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110803.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110804.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110805.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110806.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110807.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110808.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110809.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110810.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110811.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110812.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110813.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110814.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110815.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110816.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110817.jpg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110818.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110819.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110820.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110821.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110822.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110823.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110824.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110825.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110826.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110827.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110828.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110829.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110830.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104632.jpg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104633.jpg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104634.jpg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104635.jpg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104636.jpg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104637.jpg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104638.jpg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104639.jpg">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161114.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161111.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161113.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161112.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161115.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161116.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161117.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210519111500.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210508141930.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210517112628.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518215900.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161120.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210411111534.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210411160039.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210412103924.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161118.png">
<meta property="og:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161119.png">
<meta property="og:image" content="/2021/pics//35b0caf8-6f34-49db-93ed-d505e9eb3d99.png">
<meta property="og:image" content="/2021/pics//931e112e-97d3-4a47-ac64-a86d70844e58.png">
<meta property="og:image" content="/2021/pics//350048d6-20f5-4ca9-8452-3957a09ef3af.png">
<meta property="og:image" content="https://latex.codecogs.com/gif.latex?f(n)=\left\{\begin{array}{rcl}0&&{n=0}\\1&&{n=1}\\f(n-1)+f(n-2)&&{n>1}\end{array}\right.">
<meta property="og:image" content="/2021/pics//080f488c-75ef-49a8-a49d-78fa372ad422.png">
<meta property="og:image" content="https://latex.codecogs.com/gif.latex?x^n=\left\{\begin{array}{rcl}(x*x)^{n/2}&&{n\%2=0}\\x*(x*x)^{n/2}&&{n\%2=1}\end{array}\right.">
<meta property="og:image" content="/2021/pics//72f9bc11-06a9-40b4-8939-14f72e5cb4c3.png">
<meta property="og:image" content="/2021/pics//2a398239-ee47-4ea1-b2d8-0ced638839ef.png">
<meta property="og:image" content="/2021/pics//40d96c0d-156f-4eee-a183-2d597344f1cd.png">
<meta property="og:image" content="/2021/pics//e7d7dc0d-fc22-4f95-8768-b8a216168792.jpg">
<meta property="og:image" content="/2021/pics//79f28233-f5cb-492a-9dc4-696cb714d434.png">
<meta property="og:image" content="/2021/pics//26223561-eea4-463c-8ddb-3bb456c76267.png">
<meta property="og:image" content="/2021/pics//7cfcfdf7-63a7-4111-a677-2eca29fbcf24.png">
<meta property="og:image" content="/2021/pics//8615d9f7-bd1d-4240-8bb4-02b941d54a6f.png">
<meta property="og:image" content="/2021/pics//6afa9796-af1a-4495-9f02-63349ab68a19.png">
<meta property="og:image" content="/2021/pics//c8cdfa3d-d610-4731-9d89-564252378e7d.png">
<meta property="og:updated_time" content="2023-07-18T13:37:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试问题汇总">
<meta name="twitter:description" content="项目自我介绍我叫周思远，大工软院19届，现保研到华科计院。在校期间参加过计算机设计大赛等科创竞赛，也获得过三好学生、优秀毕业生，优秀党员等荣誉。">
<meta name="twitter:image" content="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105022.png">
  
    <link rel="alternative" href="/atom.xml" title="既白" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/img/f.ico">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?a30844fa2bcbce0a9e001fe06cefeddf";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


</head>
</html>
<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="" class="profilepic">
			<img src="/assets/img/touxiang.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">方既白</a></h1>
		</hgroup>
		
		<p class="header-subtitle">常思己过，莫论人非</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/categories/learning">学习</a></li>
	        
				<li><a href="/categories/thinking">生活</a></li>
	        
				<li><a href="/categories/project">项目</a></li>
	        
				<li><a href="/photos">相册</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有</a>
    			
            
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/siyuanzhou" title="github"><i class="icon-github"></i></a>
		        
					<a class="rss" target="_blank" href="/atom.xml" title="rss"><i class="icon-rss"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/img/touxiang.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">方既白</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>常思己过，莫论人非<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/siyuanzhou" title="github"><i class="icon-github"></i></a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss"><i class="icon-rss"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 25%"><a href="/categories/learning">学习</a></li>
		        
					<li style="width: 25%"><a href="/categories/thinking">生活</a></li>
		        
					<li style="width: 25%"><a href="/categories/project">项目</a></li>
		        
					<li style="width: 25%"><a href="/photos">相册</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
<article id="post-20211001面试汇总" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">  
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面试问题汇总
    </h1>
  
	

		
			<span class="archive-article-date">
				阅读量 <span id="busuanzi_value_page_pv"></span>
			</span>
		
        
        <a href="/2021/20211001面试汇总/" class="archive-article-date">
  	<time datetime="2021-03-10T02:36:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-03-10</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><h5 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h5><p>我叫周思远，大工软院19届，现保研到华科计院。在校期间参加过计算机设计大赛等科创竞赛，也获得过三好学生、优秀毕业生，优秀党员等荣誉。</p>
<a id="more"></a>
<p>项目方面，弄过一个毕业论文格式检测系统，在校上线至今检测超4000篇论文，搞过一个类豆瓣的电影推荐系统，现在刚结题一个科技大数据分析项目。<br>个人对后台开发比较感兴趣，学过计网，操作系统等核心课程，掌握Java基础知识及底层实现，了解jvm, java并发，innodb等相关内容。大概就这些。</p>
<h5 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h5><p>http长连接底层，linux内核，循环依赖，java默认排序算法,Redo,Undo,JDK8，Optional 类<br>ZGC,G1</p>
<p>分布式Redis锁</p>
<h5 id="反问："><a href="#反问：" class="headerlink" title="反问："></a>反问：</h5><p>实习生要求？部门实习生进去干啥活如何培养？</p>
<p>职业规划请教：做架构，还是做业务？</p>
<p>问部门要求、问部门定位、问部门发展等关系部门技术吸引力的地方</p>
<p>请问贵部门在应届毕业生的要求上，基础和应用技能更看重哪方面？</p>
<p>请问贵部门在整个集团中是作为一个怎么样的角色与其他部门做交互？网上的资料比较片面，想详细了解下</p>
<h5 id="大数据项目"><a href="#大数据项目" class="headerlink" title="大数据项目"></a>大数据项目</h5><p>爬虫，关键词谷歌爬取？</p>
<p>1.翻墙 自己搭vps</p>
<p>2.通用爬取，结构不同</p>
<p>2.反爬，user-agent模拟，selenium（模拟浏览器）（一个多小时封），换谷歌URL（台湾，香港服务器不同、不同网址有事结构不同），花钱ip代理池（解决），微信-&gt;搜狗搜索—&gt;定向爬取（根据微信id封，id解析真实地址，2000次）-&gt;三方机构爬取（提微信号）</p>
<p><strong>数据处理</strong></p>
<p>不相关，标注软件，每个人不一样（反向标注，修改快）</p>
<p><strong>实体识别</strong></p>
<p>通用性</p>
<h5 id="电影推荐"><a href="#电影推荐" class="headerlink" title="电影推荐"></a>电影推荐</h5><p>DataModel：DataModel 是用户喜好信息的抽象接口，它的具体实现支持从任意类型的数据源抽取用户喜好信息。Taste 默认提供 JDBCDataModel 和 FileDataModel，分别支持从数据库和文件中读取用户的喜好信息。<br>    UserSimilarity 和 ItemSimilarity：UserSimilarity 用于定义两个用户间的相似度，它是基于协同过滤的推荐引擎的核心部分，可以用来计算用户的“邻居”，这里我们将与当前用户口味相似的用户称为他的邻居。ItemSimilarity 类似的，计算内容之间的相似度。<br>    UserNeighborhood：用于基于用户相似度的推荐方法中，推荐的内容是基于找到与当前用户喜好相似的“邻居用户”的方式产生的。UserNeighborhood 定义了确定邻居用户的方法，具体实现一般是基于 UserSimilarity 计算得到的。</p>
<p>​    Recommender：Recommender 是推荐引擎的抽象接口，Taste 中的核心组件。程序中，为它提供一个 DataModel，它可以计算出对不同用户的推荐内容。Recommender是Taste中的核心组件，它可以根据提供的数据模型计算出对不同用户的推荐结果。其中包含的子类可以从内存中缓存其他的推荐结果，因此在低内存情况下可以通过让Java虚拟机取回推荐的结果再输出。在Recommender组件里包含的推荐方法一般会将结果储存在List中，另外estimatePreference()方法还能预估用户对物品的评分。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105022.png" alt="img"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105023.png" alt="image-20191229215007041"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationSuccessHandlerImpl</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication auth)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        UserAuth userAuth = (UserAuth) auth.getPrincipal();</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="keyword">switch</span> (userAuth.getRole()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ADMIN"</span>:</span><br><span class="line">            session.setAttribute(<span class="string">"id"</span>, userAuth.getId());</span><br><span class="line">            session.setAttribute(<span class="string">"name"</span>, userAuth.getUsername());</span><br><span class="line">            session.setAttribute(<span class="string">"role"</span>, <span class="string">"ADMIN"</span>);</span><br><span class="line">            response.sendRedirect(<span class="string">"admin"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"USER"</span>:</span><br><span class="line">            session.setAttribute(<span class="string">"id"</span>, userAuth.getId());</span><br><span class="line">            session.setAttribute(<span class="string">"name"</span>, userAuth.getUsername());</span><br><span class="line">            session.setAttribute(<span class="string">"role"</span>, <span class="string">"USER"</span>);</span><br><span class="line">            response.sendRedirect(<span class="string">"user"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="论文格式检测系统"><a href="#论文格式检测系统" class="headerlink" title="论文格式检测系统"></a>论文格式检测系统</h5><p><strong>文档英文，自己摸索对应关系，有错误的，段落格式，单字格式</strong></p>
<p><strong>瞎搞，把无关的文档往里面传，系统崩溃，try catch</strong> </p>
<p><strong>修改论文，有些不能改，只能给提示</strong></p>
<p>（1） 研究word论文格式与对应的xml映射关系，利用OpenXML等工具研究word下.doc及.docx文件实现过程中用到的标签、类、库，为提取属性及属性对比打下基础。</p>
<p>（2） 如何从xml中提取格式特征,即利用C#语言提取出每个格式特征的XML标签，并运用到检测过程当中。</p>
<p>（3） 上传的的论文与指定的模板进行对比，须分别提取上传论文与给定模板的同种属性，依次完成所有属性的对比。</p>
<p>（4） 全面且准确的将word论文格式封装进库，拟建立一个新的架构层次，避免对比过程中出现耦合，利于系统后期维护与升级。</p>
<p>通过修改docx文件的后缀名为zip并解压，或得到一个名为word的文件夹，其包含了一篇Word文档中的全部内容。Word文件夹下的document.xml文件则包含了文档之中绝大多数的文本内容。</p>
<p><strong>WordprocessingML和命名空间中的类的对照表</strong></p>
<table>
<thead>
<tr>
<th>包部分</th>
<th>WordprocessingML元素</th>
<th>OpenXml SDK中的类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>主文档</td>
<td>document</td>
<td>Document</td>
<td>表示主文档的元素</td>
</tr>
<tr>
<td>页脚</td>
<td>ftr</td>
<td>Footer</td>
<td>表示页脚部分的元素</td>
</tr>
<tr>
<td>页眉</td>
<td>hdr</td>
<td>Header</td>
<td>表示页眉部分的元素</td>
</tr>
<tr>
<td>文档样式</td>
<td>styles</td>
<td>Styles</td>
<td>表示样式定义的元素</td>
</tr>
</tbody>
</table>
<p>通过上述表中的内容分析，<br>Paragraph类表示在当前的XML格式文档之中的段落，并使用&lt;.p&gt;标签来表示，通过使用Paragrapgh类可以而已解析OpenXml文档之中的&lt;.p&gt;标签。在WordprocessingML中，使用段落属性&lt;.pPr&gt;元素来表示段落的属性。段落的属性包括字体、字号、颜色、行距、缩进等。而&lt;.rPr&gt;元素在WordprocessingML中表示的则是文档的运行属性，其与文档的段落属性基本一致。一篇有Word编写的文档在其段落之中通常都会傲寒这大量的文本内容，在WordprocessingML文档所使用的架构中，&lt;.r&gt;元素被用来划分文本块中的那些连续的文字。相对于&lt;.r&gt;元素，&lt;.t&gt;元素则相当于一个容器，代替其保存那些文本化的内容。一段连续的文儿内容通常会有相同的属性，这些属性被称为样式或者格式，使用&lt;.r&gt;元素能够保存这些属性的设置，并将其运用在一段连续文本的整体或者部分之中。每一段连续的文本和段落一样都会有自己的属性，&lt;.r&gt;元素的属性则是通过段落运行属性元素&lt;.rPr&gt;来设置，通过对&lt;.rPr&gt;元素的设置，可以对&lt;.t&gt;元素中保存的文本内容加上例如加粗、下划线、颜色、字体、字号等各种各样的属性。</p>
<p><strong>WordprocessingML表格元素和类的对应关系</strong></p>
<table>
<thead>
<tr>
<th>WordprocessingML元素</th>
<th>OpenXML SDK中的类</th>
</tr>
</thead>
<tbody>
<tr>
<td>tr tblPr gridCol</td>
<td>TableRow TableProperties GridColum</td>
</tr>
<tr>
<td>tblGrid</td>
<td>TableGrid</td>
</tr>
<tr>
<td>tc</td>
<td>TableCell</td>
</tr>
</tbody>
</table>
<p><strong>2.字号</strong></p>
<p>&lt; sz&gt;指出了&lt; r&gt;元素中的文本&lt; t&gt;的字号样式。&lt; sz&gt;的属性Val的值代表了字号的大小，如&lt;w:sz w:val=”24”/&gt;代表字号为24/2=12磅。查询字号对照表【参考文献】得到字号和磅数的对应关系，就可以得到实际的字号为“小四”。</p>
<h4 id="常考题"><a href="#常考题" class="headerlink" title="常考题"></a>常考题</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518212123.png" alt="image-20210518212121074"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518212159.png" alt="image-20210518212156755"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518212226.png" alt="image-20210518212224791"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518212304.png" alt="image-20210518212302615"></p>
<h3 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h3><h4 id="O-1-时间内删除链表节点"><a href="#O-1-时间内删除链表节点" class="headerlink" title="O(1)时间内删除链表节点"></a>O(1)时间内删除链表节点</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105024.png" alt="这里写图片描述"></p>
<h4 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h4><h5 id="怎样对10亿个数字（字符串）快速去重？"><a href="#怎样对10亿个数字（字符串）快速去重？" class="headerlink" title="怎样对10亿个数字（字符串）快速去重？"></a>怎样对10亿个数字（字符串）快速去重？</h5><p>对于海量数据处理，思路基本上是：必须分块处理，然后再合并起来。</p>
<p>方法一：</p>
<p>通过哈希算法，将10亿个电话号码按照哈希值落在多个文件中，</p>
<p>重复的电话号码有相同的哈希值，肯定位于一个文件中，</p>
<p>这样就可以分别对每个文件排序删除重复的电话号码。</p>
<p>方法二：</p>
<p>使用位图来进行处理。比如说这10亿个数的范围为【0-10亿】，那么就申请一个10亿的数组，</p>
<p>数组类型为boolen，只有0和1，0表示没有，1表示有。</p>
<p>这样自然而然的就删掉了重复的部分。</p>
<h5 id="100亿个数取出最大的10000个"><a href="#100亿个数取出最大的10000个" class="headerlink" title="100亿个数取出最大的10000个"></a>100亿个数取出最大的10000个</h5><p>算法：如果把100亿个数全部读入内存，需要100 0000 0000 * 4B 大约40G的内存，这显然是不现实的。　　</p>
<p>我们可以在内存中维护一个<strong>大小为10000的最小堆</strong>，每次从文件读一个数，与最小堆的堆顶元素比较（也可先分割排序），若比堆顶元素大，则替换掉堆顶元素，然后调整堆。最后剩下的堆内元素即为最大的1万个数，算法复杂度为O(NlogN)　　</p>
<p>为了<strong>加速并行处理</strong>，可以先hash为n份，每份求最大的10000个，然后在这n*10000个中用最小堆</p>
<p>实现：从文件读数据有讲究，如果每次只读一个数，效率太低，可以维护一个输入缓冲区，一次读取一大块数据到内存，用完了又从文件接着读，这样效率高很多，缓冲区的大小也有讲究，一般要设为4KB的整数倍，因为磁盘的块大小一般就是4KB。</p>
<h5 id="如何在海量数据中找出重复最多⼀个。（提取出某⽇访问百度次数最多的那个IP）"><a href="#如何在海量数据中找出重复最多⼀个。（提取出某⽇访问百度次数最多的那个IP）" class="headerlink" title="如何在海量数据中找出重复最多⼀个。（提取出某⽇访问百度次数最多的那个IP）"></a>如何在海量数据中找出重复最多⼀个。（提取出某⽇访问百度次数最多的那个IP）</h5><p>通过hash映射为⼩⽂件<br>通过hash_map统计各个⼩⽂件重读最多的并记录次数<br>对每个⼩⽂件重复最多的进⾏建⽴⼤根堆</p>
<h5 id="有10个1G⽂件，每⾏都是⼀个可重复⽤户query，按query频度排序。"><a href="#有10个1G⽂件，每⾏都是⼀个可重复⽤户query，按query频度排序。" class="headerlink" title="有10个1G⽂件，每⾏都是⼀个可重复⽤户query，按query频度排序。"></a>有10个1G⽂件，每⾏都是⼀个可重复⽤户query，按query频度排序。</h5><p>顺序读取⼗个⽂件并采取哈希，将query写⼊10个⽂件中<br>通过hash_map(query, count)统计每个query出现次数，⾄少2G内存<br>通过得到的hashmap 中 query 和 querycount，对query_count排序并将重新输出到⽂件<br>中，得到已排序好的⽂件<br>对⼗个⽂件进⾏归并排序（外排序）</p>
<h5 id="A-B两个⽂件各存放50亿url，每个为64Byte，限制内存4G找出公共url。"><a href="#A-B两个⽂件各存放50亿url，每个为64Byte，限制内存4G找出公共url。" class="headerlink" title="A,B两个⽂件各存放50亿url，每个为64Byte，限制内存4G找出公共url。"></a>A,B两个⽂件各存放50亿url，每个为64Byte，限制内存4G找出公共url。</h5><p>对A和B两个⼤⽂件，先通过url % 1000将数据映射到1000个⽂件中，单个⽂件⼤⼩约<br>320M（我们只需要检查对应⼩⽂件A1 V B1……，不对应⼩⽂件不会有相同url）<br>通过hashset 统计，把 A1 的 url 存储到 hashset中，再遍历对应的B1⼩⽂件，检查是否在<br>hash_set中，若存在则写⼊外存。重复循环处理对应的1000个对。</p>
<h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><p>32位机器上，对于一个整型数，比如int a=1 在内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费，因为我们可以用对应的32bit位对应存储十进制的0-31个数，而这就是Bit-<br>map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。 Bitmap在用户群做交集和并集运算的时候也有极大的便利。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105025.png" alt="image-20210408124030233"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105026.png" alt="image-20210408124139472"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105027.png" alt="image-20210408124156380"></p>
<h4 id="常见的限流算法"><a href="#常见的限流算法" class="headerlink" title="常见的限流算法"></a>常见的限流算法</h4><h5 id="计数器法"><a href="#计数器法" class="headerlink" title="计数器法"></a>计数器法</h5><p>计数器法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个 请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置<br>counter，具体算法的示意图如下：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105028.png" alt="image-20210408124654747"></p>
<p>这个算法虽然简单，但是有一个十分致命的问题，那就是临界问题，我们看下图：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105029.png" alt="image-20210408124747364"></p>
<p>从上图中我们可以看到，假设有一个恶意用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100<br>个请求，那么其实这个用户在 1秒里面，瞬间发送了200个请求。我们刚才规定的是1分钟最多100个请求，也就是<br>每秒钟最多1.7个请求，用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制。用户有可能<br>通过算法的这个漏洞，瞬间压垮我们的应用。</p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p>滑动窗口，又称rolling window。为了解决这个问题，我们引入了滑动窗口算法。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105030.png" alt="image-20210408124904461"></p>
<p>在上图中，整个红色的矩形框表示一个时间窗口，在我们的例子中，一个时间窗口就是一分钟。然后我们将时间窗<br>口进行划分，比如图中，我们就将滑动窗口 划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器counter，比如当一个请求 在0:35秒的时候到达，那么<br>0:30~0:39对应的counter就会加1。<br>那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，而<br>1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触 发了限流</p>
<h5 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h5><p>漏桶算法，又称leaky bucket。首先，我们有一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多 少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率。而且，当桶满了之后，多余的水将会溢出。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105031.png" alt="image-20210408125032043"></p>
<h5 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h5><p>令牌桶算法，又称token bucket。从图中我们可以看到，令牌桶算法比漏桶算法稍显复杂。首先，我们有一个固定容量的桶，桶里存放着令牌（token）。桶一开始是空的，token以 一个固定的速率r往桶里填充，直到达到桶的容量，多余的令牌将会被丢弃。每当一个请求过来时，就会尝试从桶里移除一个令牌，如果没有令牌的话，请求无法通 过。</p>
<p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况<br>下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送(百科)。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105032.png" alt="image-20210408125304994"></p>
<p><strong>计数器 VS 滑动窗口</strong><br>计数器算法是最简单的算法，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格<br>子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间<br>就越大。<br><strong>漏桶算法 VS 令牌桶算法</strong><br>漏桶算法和令牌桶算法最明显的区别是令牌桶算法允许流量一定程度的突发。因为默认的令牌桶算法，取走token<br>是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。<br>令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要具体情况<br>具体分析，只有最合适的算法，没有最优的算法。</p>
<h4 id="分布式环境下全局唯一的发号器"><a href="#分布式环境下全局唯一的发号器" class="headerlink" title="分布式环境下全局唯一的发号器"></a>分布式环境下全局唯一的发号器</h4><h5 id="1、UUID"><a href="#1、UUID" class="headerlink" title="1、UUID"></a>1、UUID</h5><p>常见的方式。可以利用数据库也可以利用程序生成，一般来说全球唯一。<br>优点：</p>
<ol>
<li>简单，代码方便。</li>
<li>生成ID性能非常好，基本不会有性能问题。 \3. 全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更<br>等情况下，可以从容应对。</li>
</ol>
<p>缺点：</p>
<ol>
<li>没有排序，无法保证趋势递增。</li>
<li>UUID往往是使用字符串存储，查询的效率比较低。</li>
<li>存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。</li>
<li>传输数据量大</li>
<li>不可读。</li>
</ol>
<h5 id="2、数据库自增长序列或字段"><a href="#2、数据库自增长序列或字段" class="headerlink" title="2、数据库自增长序列或字段"></a>2、数据库自增长序列或字段</h5><p>最常见的方式。利用数据库，全数据库唯一。<br>优点：</p>
<ol>
<li>简单，代码方便，性能可以接受。</li>
<li>数字ID天然排序，对分页或者需要排序的结果很有帮助。</li>
</ol>
<p>缺点：</p>
<ol>
<li>不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。</li>
<li>在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。</li>
<li>在性能达不到要求的情况下，比较难于扩展。</li>
<li>如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。</li>
<li>分表分库的时候会有麻烦。</li>
</ol>
<p>优化方案：<br>针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个<br>数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以<br>有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。</p>
<h5 id="3、数据库sequence表以及乐观锁"><a href="#3、数据库sequence表以及乐观锁" class="headerlink" title="3、数据库sequence表以及乐观锁"></a>3、数据库sequence表以及乐观锁</h5><p>我们可以单独设置一张表，来存储所有表的下一个主键的值，例如现在有A、B、C三个表，sequence表结构如下</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105033.png" alt="image-20210408205931380"></p>
<p>然后，每当需要获取下一个主键值的时候，首先使用select语句获取主键，然后使用数据库的乐观锁机制去update<br>这个sequence表，更新成功则说明获取主键成功，更新失败则说明存在并发，当前主键被别的机器抢走了，需要<br>重新select出新的主键，载update。例如要获取表B的下一个主键，需要发送sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">sequence</span> <span class="keyword">where</span> <span class="keyword">name</span>=B</span><br><span class="line">//获得<span class="keyword">id</span>=<span class="number">100</span>,更新<span class="keyword">sequence</span>表</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">sequence</span> <span class="keyword">set</span> <span class="keyword">id</span>=<span class="keyword">id</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">name</span>=B <span class="keyword">and</span> <span class="keyword">id</span>=<span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>操作简单，使用乐观锁可以提高性能</li>
<li>生成的id有序递增，连续</li>
<li>可适用于分布式环境，可以进行分库分表</li>
</ol>
<p>缺点</p>
<ol>
<li>需要单独设置一张表，浪费存储空间</li>
<li>数据库更新比较频繁，写压力太大</li>
</ol>
<p>改进方案<br>可以将每次获取一个主键，改为每次获取500个或者更多，然后缓存再当前机器中，用完这500个后，再去请求数<br>据库，做更新操作，可以减少数据库的读写压力，但是会造成主键的不连续</p>
<h5 id="4、Redis生成ID"><a href="#4、Redis生成ID" class="headerlink" title="4、Redis生成ID"></a>4、Redis生成ID</h5><p>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。<br>可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：<br>A：1,6,11,16,21 B：2,7,12,17,22 C：3,8,13,18,23 D：4,9,14,19,24 E：5,10,15,20,25<br>这个，随便负载到哪个机确定好，未来很难做修改。但是3-5台服务器基本能够满足器上，都可以获得不同的ID。<br>但是步长和初始值一定需要事先需要了。使用Redis集群也可以方式单点故障的问题。<br>另外，比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生<br>成一个Key，使用INCR进行累加。<br>优点：</p>
<ol>
<li>不依赖于数据库，灵活方便，且性能优于数据库。</li>
<li>数字ID天然排序，对分页或者需要排序的结果很有帮助。</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。</li>
<li>需要编码和配置的工作量比较大。</li>
</ol>
<h5 id="5、Twitter的snowflake算法"><a href="#5、Twitter的snowflake算法" class="headerlink" title="5、Twitter的snowflake算法"></a>5、Twitter的snowflake算法</h5><p>snowflake 是 twitter 开源的分布式ID生成算法，其核心思想为，一个long型的ID：</p>
<p>41 bit 作为毫秒数 - 41位的长度可以使用69年<br>10 bit 作为机器编号 （5个bit是数据中心，5个bit的机器ID） - 10位的长度最多支持部署1024个节点<br>12 bit 作为毫秒内序列号 - 12位的计数顺序号支持每个节点每毫秒产生4096个ID序号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">sequence</span> <span class="keyword">where</span> <span class="keyword">name</span>=B</span><br><span class="line">//获得<span class="keyword">id</span>=<span class="number">100</span>,更新<span class="keyword">sequence</span>表</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">sequence</span> <span class="keyword">set</span> <span class="keyword">id</span>=<span class="keyword">id</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">name</span>=B <span class="keyword">and</span> <span class="keyword">id</span>=<span class="number">100</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105034.png" alt="image-20210408210308572"></p>
<p>Snowflake图示<br>算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数<br>以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。<br>优点：</p>
<ol>
<li>不依赖于数据库，灵活方便，且性能优于数据库。</li>
<li>ID按照时间在单机上是递增的。</li>
</ol>
<p>缺点：<br>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全<br>局递增的情况。</p>
<h4 id="Java实现线程安全的List"><a href="#Java实现线程安全的List" class="headerlink" title="Java实现线程安全的List"></a>Java实现线程安全的List</h4><p>参考CopyOnWrite 写入时复制，它使一个List同步的替代品，通常情况下提供了更好的并发性，并且避免了再迭代时候对容器的加锁和复制。通常更适合用于迭代，在多插入的情况下由于多次的复制性能会一定的下降。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; <span class="comment">// 加锁 只允许获得锁的线程访问</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 创建个长度加1的数组并复制过去</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); </span><br><span class="line">        newElements[len] = e; <span class="comment">// 赋值</span></span><br><span class="line">        setArray(newElements); <span class="comment">// 设置内部的数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java实现阻塞队列"><a href="#Java实现阻塞队列" class="headerlink" title="Java实现阻塞队列"></a>Java实现阻塞队列</h4><p>阻塞队列的实现原理<br>1、生产者向队尾添加元素<br>2、消费者向队头消费元素<br>3、添加和消费过程是线程安全的</p>
<p>实现一的方法很简单，原理是synchronized+wait+notify实现，但是notify的时候是会唤醒生产者线程和消费者线程的，想象一下，当前生产者线程已经生产了MAX个元素，当他唤醒其他线程的时候，也会唤醒生产者线程，在这里显然是没有必要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBlockingContainer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBlockingContainer</span><span class="params">(<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.MAX=limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size()==MAX)&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();<span class="comment">//释放锁并且阻塞自己，要想唤醒必须先获取锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(t);</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();<span class="comment">//唤醒消费者线程，此时还没有释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T t;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            t=queue.poll();</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现二用AQS的条件队列实现了唤醒线程的灵活性，可以说比实现一更进了一步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBlockingQueueForLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition producer=lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBlockingQueueForLock</span><span class="params">(<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.MAX=limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock=<span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size()==MAX)&#123;</span><br><span class="line">                producer.await();<span class="comment">//响应中断</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(t);</span><br><span class="line">            consumer.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock=<span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        T t;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                consumer.await();<span class="comment">//响应中断</span></span><br><span class="line">            &#125;</span><br><span class="line">            t=queue.poll();</span><br><span class="line">            producer.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h5><!--more-->
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104735.png" alt="image-20200207122805940"></p>
<h5 id="java程序执行"><a href="#java程序执行" class="headerlink" title="java程序执行"></a>java程序执行</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104736.png" alt="image-20210308103111593"></p>
<h5 id="与equals"><a href="#与equals" class="headerlink" title="==与equals()"></a>==与equals()</h5><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)<br>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：<br> 情况 1：类没有覆盖 equals() 方法。等价于通过“==”比较这两个对象。<br> 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true 。</p>
<h5 id="方法参数传值"><a href="#方法参数传值" class="headerlink" title="方法参数传值"></a>方法参数传值</h5><p>方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</p>
<h5 id="final和static"><a href="#final和static" class="headerlink" title="final和static"></a>final和static</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104737.png" alt="image-20210305205122482"></p>
<p>final 的好处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. final 关键字提高了性能。JVM 和 Java 应用都会缓存 final 变量。</span><br><span class="line">2. final 变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</span><br><span class="line">3. 使用 final 关键字，JVM 会对方法、变量及类进行优化。</span><br></pre></td></tr></table></figure>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104738.png" alt="image-20200207131438485"></p>
<p><strong>类型转换</strong>：byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE = <span class="number">0x7fffffff</span> 最大值 (<span class="number">2</span>^<span class="number">31</span>-<span class="number">1</span>)</span><br><span class="line">Integer.MIN_VALUE = <span class="number">0x80000000</span> 最小值 (-<span class="number">2</span>^<span class="number">31</span>)</span><br></pre></td></tr></table></figure>
<p><strong>b3=1 + 2 是正确的。但b3=1+200报错</strong></p>
<p>b3 = 1 + 2 ， 1 和  2 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 1+2 的结果并没有超过byte类型的取值范围，可以赋值给变量 b3 。</p>
<p><strong>short s1 = 1; s1 = s1 + 1;错。 short s1 = 1; s1 +=1;对</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) 对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。</span><br><span class="line"></span><br><span class="line">2) 对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。+= 操作符会进行隐式自动类型转换,</span><br></pre></td></tr></table></figure>
<p><strong>switch语句能否作用在byte上，能否作用在long上，能否作用在string上？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在switch(expr1)中，expr1只能是一个整数表达式或者枚举常量，</span><br><span class="line">整数表达式可以是int基本类型或Integer包装类型。</span><br><span class="line">由于，byte,short,char都可以隐式转换为int，所以，这些类型以及这些类型的包装类型也是可以的。</span><br><span class="line"></span><br><span class="line">long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，</span><br><span class="line">所以，它们不能作用于swtich语句中。</span><br><span class="line">不过，在1.7版本之后switch就可以作用在string上了。</span><br></pre></td></tr></table></figure>
<p><strong>包装类</strong>分成引用和实例，引用在栈（stack）中，具体实例在堆（heap）中，jdk5.0开始增加自动装箱/拆箱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = Integer.valueOf(<span class="number">1</span>); <span class="comment">//手动装箱</span></span><br><span class="line">Integer j = <span class="number">1</span>; <span class="comment">//自动装箱</span></span><br><span class="line">Integer i0 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i1 = i0; <span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> i2 = i0.intValue(); <span class="comment">//手动拆箱</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104739.png" alt="image-20210305202513862"></p>
<p><strong>valueOf陷阱：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double i1 = Double.valueOf(<span class="number">0.1</span>);</span><br><span class="line">Double i2 = Double.valueOf(<span class="number">0.1</span>);</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">//false valueOf方法内部实际上也是new</span></span><br></pre></td></tr></table></figure>
<p><strong>valueOf内部也是用的new方法来构造对象的</strong>。2个new出来的对象，内存地址肯定是不一样的。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104740.png" alt="image-20200207145702858"></p>
<h5 id="包装类缓存机制"><a href="#包装类缓存机制" class="headerlink" title="包装类缓存机制"></a>包装类缓存机制</h5><p>下面的代码运行结果却让人大跌眼镜：（<strong>缓存机制</strong>）</p>
<p>Java对部分经常使用的数据采用缓存技术，在类第一次被加载时换创建缓存和数据。当使用等值对象时直接从缓存中获取，从而提高了程序执行性能。（通常只对常用数据进行缓存）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.valueOf(<span class="number">1</span>) ==Integer.valueOf(<span class="number">1</span>)); <span class="comment">//true </span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="number">999</span>) ==Integer.valueOf(<span class="number">999</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>查看Integer.valueOf方法的源码：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104741.png" alt="image-20200207150009985"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Integer类型有缓存-128-127的对象。缓存上限可以通过`-XX:AutoBoxCacheMax=size`修改</span><br><span class="line">2. Byte,Short,Long类型有缓存(-128-127)</span><br><span class="line">3. Character缓存0-127</span><br><span class="line">4. Boolean缓存TRUE、FALSE</span><br></pre></td></tr></table></figure>
<p> <strong>自动包装时实际上还是调用的valueOf方法</strong>。而上面我们讲过的，valueOf方法用到了缓存池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i4 = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">Integer i5 =<span class="number">1</span>;</span><br><span class="line">System.out.println(i4 == i5); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h5 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210507093240.png" alt="image-20200207172124800"></p>
<h5 id="Java内存计算"><a href="#Java内存计算" class="headerlink" title="Java内存计算"></a>Java内存计算</h5><p><strong>内存公式</strong>：Java对象的内存布 = 对象头(Header) + 实例数据(Instance Data) + 补齐填充(Padding)。</p>
<p>在64位机器上，对象头不开压缩（-XX:-UseCompressedOops）16字节（默认），开压缩12字节；对象引用不开压缩8字节，开压缩4字节；填充到8字节的倍数；数组对象头24字节，压缩后16字节；String包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode</p>
<p><strong>对象头：Instance Header</strong>，Java对象最复杂的一部分，采用C++定义了头的协议格式，存储了Java对象hash、GC年龄、锁标记、class指针、数组长度等信息。</p>
<p><strong>实例数据：Instance Data</strong>，这部分数据才是真正具有业务意义的数据，实际上就是当前对象中的实例字段。在VM中，对象的字段是由基本数据类型和引用类型组成的。<strong>对象引用（ref）类型在64位机器上，关闭指针压缩时占用8bytes， 开启时占用4bytes。</strong></p>
<p><strong>补齐填充</strong>：Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数</p>
<p><strong>包装类（Boolean/Byte/Short/Character/Integer/Long/Double/Float）占用内存的大小 = 对象头大小 + 底层基础数据类型的大小</strong>。包装类和其他引用类一样，会产生一个引用（reference）</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104742.png" alt="image-20200207152330555"></p>
<p><strong>数组内存占用</strong></p>
<p><strong>64位机器上，数组对象的对象头占用24 bytes，启用压缩后占用16字节。</strong>对象数组本身的大小=数组对象头+length * 引用指针大小，总大小为对象数组本身大小+存放的数据的大小之和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[<span class="number">10</span>]:</span><br><span class="line">开启压缩：<span class="number">16</span> + <span class="number">10</span> * <span class="number">4</span> = <span class="number">56</span> bytes；</span><br><span class="line">关闭压缩：<span class="number">24</span> + <span class="number">10</span> * <span class="number">4</span> = <span class="number">64b</span>ytes。</span><br><span class="line"><span class="keyword">new</span> Integer[<span class="number">3</span>]:</span><br><span class="line">关闭压缩：</span><br><span class="line">    Integer数组本身：<span class="number">24</span>(header) + <span class="number">3</span> * <span class="number">8</span>(Integer reference) = <span class="number">48</span> bytes;</span><br><span class="line">    总共：<span class="number">48</span> + <span class="number">3</span> * <span class="number">24</span>(Integer) = <span class="number">120</span> bytes。</span><br><span class="line">开启压缩：</span><br><span class="line">    Integer数组本身：<span class="number">16</span>(header) + <span class="number">3</span> * <span class="number">4</span>(Integer reference) = <span class="number">28</span>(padding) -&gt; <span class="number">32</span> (bytes)</span><br><span class="line">    总共：<span class="number">32</span> + <span class="number">3</span> * <span class="number">16</span>(Integer) = <span class="number">80</span> (bytes)</span><br></pre></td></tr></table></figure>
<p><strong>String内存占用</strong></p>
<p>在JDK1.7及以上版本中，String包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode。字符串”abcde”在开启指针压缩时的大小为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String本身：12(Header) + 4(char[] reference) + 4(int hash) = 20(padding) -&gt; 24 (bytes); </span><br><span class="line">存储数据：16(char[] header) + 5*2 = 26(padding) -&gt; 32 (bytes)         </span><br><span class="line">总共：24 + 32 = 56 (bytes)</span><br></pre></td></tr></table></figure>
<p><strong>复杂对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x; <span class="comment">// 4字节</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y; <span class="comment">// 4字节 </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> flag; <span class="comment">// 1字节</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z; <span class="comment">// 4字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不开压缩40字节 = 16 + (4 + 4 + 1 + 7) + 4 + 7</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104743.png" alt="image-20200207161601497"></p>
<h5 id="String，StringBuffer，StringBuider"><a href="#String，StringBuffer，StringBuider" class="headerlink" title="String，StringBuffer，StringBuider"></a>String，StringBuffer，StringBuider</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 操作少量的数据 = String</span><br><span class="line">2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder</span><br><span class="line">3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer</span><br></pre></td></tr></table></figure>
<p><strong>1. 是否可变</strong> </p>
<ul>
<li>String 不可变: 类为 final，类中 char[] 为final，（在 Java 9 之后，String 类的实现改⽤ byte 数组存储字符串<br>private final byte[] value）</li>
<li>StringBuffer 和 StringBuilder 可变，继承自 AbstractStringBuilder 类，char[] value 没有用 final 关键字修饰</li>
</ul>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104744.png" alt="image-20210305203955846"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104745.png" alt="image-20210305204136342"></p>
<h5 id="String-不可变的原因"><a href="#String-不可变的原因" class="headerlink" title="String 不可变的原因"></a>String 不可变的原因</h5><p><strong>1. 可以缓存 hash 值</strong> </p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 等情况。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong> </p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。如果可变，多个引用指向一个String，修改会影响。</p>
<p><strong>3. 安全性</strong> </p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。<br>String 经常作为 HashMap 的 key，key 对象需要是不可变的。</p>
<p><strong>4. 线程安全</strong> </p>
<p>String 不可变性天生具备线程安全，可以在多个线程中使用。</p>
<h5 id="重写equals还要重写hashcode？"><a href="#重写equals还要重写hashcode？" class="headerlink" title="重写equals还要重写hashcode？"></a>重写equals还要重写hashcode？</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104746.png" alt="image-20210305204307273"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上。</span><br><span class="line">重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。</span><br></pre></td></tr></table></figure>
<h5 id="String-intern"><a href="#String-intern" class="headerlink" title="String#intern()"></a>String#intern()</h5><p>使用 String.intern() 可以保证所有相同内容的字符串变量引用相同的内存对象。</p>
<p>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中，字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中<strong>添加一个新的字符串</strong>，并返回这个新字符串的引用。</p>
<h5 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h5><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并<strong>不会完全复制 value 数组内容</strong>，而是都会指向同一个 value 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> 创建并返回此对象的一个副本。 </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> 指示某个其他对象是否与此对象“相等”。 </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 </span></span><br><span class="line"><span class="function">Class&lt;? extendsObject&gt; <span class="title">getClass</span><span class="params">()</span> 返回一个对象的运行时类。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> 返回该对象的哈希码值。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> 唤醒在此对象监视器上等待的单个线程。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span> 唤醒在此对象监视器上等待的所有线程。 </span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> 返回该对象的字符串表示。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> 导致当前的线程等待，直到其他线程调用此对象的 <span class="title">notify</span><span class="params">()</span> 方法或 <span class="title">notifyAll</span><span class="params">()</span> 方法。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> 导致当前的线程等待，直到其他线程调用此对象的 <span class="title">notify</span><span class="params">()</span> 方法或 <span class="title">notifyAll</span><span class="params">()</span> 方法，或者超过指定的时间量。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> 导致当前的线程等待，直到其他线程调用此对象的 <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> 针对不同的对象返回不同的整数。一般是通过将该对象的内部地址转换成一个整数来实现</span></span><br></pre></td></tr></table></figure>
<h5 id="Runtime-类"><a href="#Runtime-类" class="headerlink" title="Runtime 类"></a>Runtime 类</h5><p>Runtime:运行时，是一个封装了 JVM 的类。每一个 JAVA 程序实际上都是启动了一个JVM 进程，每一个 JVM 进程都对应一个 Runtime 实例，此实例是由 JVM 为其实例化的。<br>所以我们不能实例化一个 Runtime 对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前 Runtime 运行时对象的引用。一旦得到了一个当前的Runtime 对象的引用，就可以调用 Runtime 对象的方法去控制 Java 虚拟机的状态和行为。</p>
<h5 id="Enum类"><a href="#Enum类" class="headerlink" title="Enum类"></a>Enum类</h5><p>使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应public static final Day MONDAY;，同时编译器会为该类创建两个方法，分别是values()和valueOf()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//直接引用</span></span><br><span class="line">        Day day =Day.MONDAY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反编译Day.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的values()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Day[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Day[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Day <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//前面定义的7种枚举实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day WEDNESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Day $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//实例化枚举实例</span></span><br><span class="line">        MONDAY = <span class="keyword">new</span> Day(<span class="string">"MONDAY"</span>, <span class="number">0</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Day(<span class="string">"TUESDAY"</span>, <span class="number">1</span>);</span><br><span class="line">        WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"WEDNESDAY"</span>, <span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Day(<span class="string">"THURSDAY"</span>, <span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Day(<span class="string">"FRIDAY"</span>, <span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Day(<span class="string">"SATURDAY"</span>, <span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Day(<span class="string">"SUNDAY"</span>, <span class="number">6</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Day[] &#123;</span><br><span class="line">            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="finally-代码块和-finalize-方法有什么区别？"><a href="#finally-代码块和-finalize-方法有什么区别？" class="headerlink" title="finally  代码块和 finalize()方法有什么区别？"></a>finally  代码块和 finalize()方法有什么区别？</h5><p>无论是否抛出异常，finally 代码块都会执行，它主要是用来释放应用占用的资源。</p>
<p>finalize()方法是 Object 类的一个 protected 方法，它是在对象被垃圾回收之前由 Java 虚拟机来调用的。它最主要的用途是回收特殊渠道申请的内存。如 JNI(Java Native Interface)调用 non-Java程序（C 或 C++），finalize()的工作就是回收这部分的内存。</p>
<h5 id="comparable和-comparator-接口区别"><a href="#comparable和-comparator-接口区别" class="headerlink" title="comparable和 comparator 接口区别"></a>comparable和 comparator 接口区别</h5><p>Comparable和Comparator接口被用来对对象集合或者数组进行排序。<br>Comparable接口被用来提供对象的自然排序，可使用它来提供基于单个逻辑的排序。<br>Comparator接口被用来提供不同的排序算法，可根据制定字段选择需要使用的Comparator来对指定的对象集合进行排序。</p>
<h5 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h5><p>1，抽象类里可以有构造方法，而接口内不能有构造方法。<br>2，抽象类中可以有普通成员变量，而接口中不能有普通成员变量。<br>3，抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法。<br>4，抽象类中的抽象方法的访问类型可以是public ，protected和private，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。<br>5，抽象类中可以包含静态方法，接口内不能包含静态方法。<br>6，抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static类型，并且默认为public static final类型。<br>7，一个类可以实现多个接口，但只能继承一个抽象类。</p>
<h5 id="session与cookie"><a href="#session与cookie" class="headerlink" title="session与cookie"></a>session与cookie</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104747.png" alt="image-20210305205425880"></p>
<p>cookie 是 Web 服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个 Web服务器存储 cookie。以后浏览器在给特定的 Web 服务器发请求的时候，同时会发送所有为该服务器存储的 cookie。</p>
<h5 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104748.png" alt="image-20210307200727001"></p>
<h5 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h5><p>通过 Proxy 的 ProxyInstance 类创建出一个代理类，这个代理类执行的关于它代理的对象（真正的对象）的方法（代理类可以自己定义自己的方法，要区别）</p>
<p>InvocationHandler 是一个接口，接口中有 invoke 方法，invoke 方法关联到一个真正的对象，然后去执行真正对象的方法，来实现代理。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104749.png" alt="image-20210307221526701"></p>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="Java创建对象四种方法"><a href="#Java创建对象四种方法" class="headerlink" title="Java创建对象四种方法"></a>Java创建对象四种方法</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104750.png" alt="image-20210305203852177"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104751.png" alt="image-20210307193025213"></p>
<h5 id="强、软、弱和虚引用"><a href="#强、软、弱和虚引用" class="headerlink" title="强、软、弱和虚引用"></a>强、软、弱和虚引用</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104752.png" alt="1567505930559"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强引用 即使该对象永远不会被用到，JVM 也不会回收。强引用是造成 Java 内存泄漏的主要原因之一。</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"str"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 软引用 </span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T</span></span><br><span class="line"><span class="comment">//创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。</span></span><br><span class="line"><span class="comment">//运用：用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效避免内存溢出的问题。</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"str"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//弱引用 </span></span><br><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//虚引用</span></span><br><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> PhantomReference&lt;String&gt;(newString(<span class="string">"str"</span>), <span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。<br>封装的一些好处：<br>1) 通过隐藏对象的属性来保护对象内部的状态;<br>2) 提高了代码的可用性和可维护性;<br>3) 禁止对象之间的不良交互提高模块化。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104753.png" alt="image-20200210161241969"></p>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>类似于this，子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量</p>
<p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。</p>
<p>super与this的内存图</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104754.png" alt="03-super与this的内存图"></p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。多态分两种类型：<br><strong>编译时多态</strong>：在编译时能够确定执行多态方法中的哪一个，称为编译时多态； 方法重载是编译时多态。<br><strong>运行时多态</strong>：在执行期间根据实际类型判断并调用相应的属性和方法。主要用于继承父类和实现接口时，父类引用指向子类对象。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104755.png" alt="05-抽象的概念"></p>
<h5 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104756.png" alt="image-20210305202652712"></p>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>内部类可以直接访问外部类的成员，包括私有成员。<br>外部类要访问内部类的成员，必须要建立内部类的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；</span><br></pre></td></tr></table></figure>
<p>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的 .class文件，但是前面冠以外部类的类名<br>和$符号 。比如，Person$Heart.class</p>
<p><strong>匿名内部类</strong><br>匿名内部类就是没有名字的内部类；<br>匿名内部类不能定义任何静态成员、方法。<br>匿名内部类中的方法不能是抽象的；<br>匿名内部类必须实现接口或抽象父类的所有抽象方法。<br>匿名内部类访问的外部类成员变量或成员方法必须用 static 修饰<br>1、匿名内部类因为没有类名，可知匿名内部类不能定义构造器。<br>2、因为在创建匿名内部类的时候，会立即创建它的实例，可知匿名内部类不能是抽象类，必须实现接口或抽象父类的所有抽象方法。<br>3、匿名内部类会继承一个父类（有且只有一个）或实现一个接口（有且只有一个），实现父类或接口中所有抽象方法，可以改写父类中的方法，添加自定义方法。<br>5、当匿名内部类和外部类有同名变量（方法）时，默认访问的是匿名内部类的变量（方法），要访问外部类的变量（方法）则需要加上外部类的类名。</p>
<h5 id="类加载器初始化"><a href="#类加载器初始化" class="headerlink" title="类加载器初始化"></a>类加载器初始化</h5><p>类加载（先父后子,静态代码块（执行一次）—-&gt;非静态代码块(执行多次）—-&gt;成员变量—-&gt;构造函数)</p>
<p>static在涉及到继承的时候，会先初始化父类的static变量，然后是子类的，依次类推。</p>
<p>存在继承的情况下，初始化顺序为：</p>
<ol>
<li>父类（静态变量、静态语句块块 执行一次）</li>
<li>子类（静态变量、静态语句块 执行一次）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">对类的主动使用：</span><br><span class="line">    <span class="number">1</span>. 创建类的实例</span><br><span class="line">    <span class="number">2</span>. 访问某个类或者接口的静态变量，或者对该静态变量赋值。</span><br><span class="line">    <span class="number">3</span>. 调用类的静态方法。</span><br><span class="line">    <span class="number">4</span>. 反射（Class.forName）</span><br><span class="line">    <span class="number">5</span>. 初始化类的子类</span><br><span class="line">    <span class="number">6</span>. java虚拟机启动时被标明为启动类的类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line">test <span class="keyword">static</span></span><br><span class="line">myclass <span class="keyword">static</span></span><br><span class="line">person <span class="keyword">static</span></span><br><span class="line">person Test</span><br><span class="line">test constructor</span><br><span class="line">person MyClass</span><br><span class="line">myclass constructor</span><br><span class="line"></span><br><span class="line">为什么输出结果是这样的？我们来分析下这段代码的执行过程：</span><br><span class="line">找到main方法入口，main方法是程序入口，但在执行main方法之前，要先加载Test类</span><br><span class="line">加载Test类的时候，发现Test类有<span class="keyword">static</span>块，而是先执行<span class="keyword">static</span>块，输出test <span class="keyword">static</span>结果</span><br><span class="line">然后执行<span class="keyword">new</span> MyClass(),执行此代码之前，先加载MyClass类，发现MyClass类继承Test类，而是要先加载Test类，Test类之前已加载</span><br><span class="line">加载MyClass类，发现MyClass类有<span class="keyword">static</span>块，而是先执行<span class="keyword">static</span>块，输出myclass <span class="keyword">static</span>结果</span><br><span class="line">然后调用MyClass类的构造器生成对象，在生成对象前，需要先初始化父类Test的成员变量，而是执行Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>)代码，发现Person类没有加载</span><br><span class="line">加载Person类，发现Person类有<span class="keyword">static</span>块，而是先执行<span class="keyword">static</span>块，输出person <span class="keyword">static</span>结果</span><br><span class="line">接着执行Person构造器，输出person Test结果</span><br><span class="line">然后调用父类Test构造器，输出test constructor结果，这样就完成了父类Test的初始化了</span><br><span class="line">再初始化MyClass类成员变量，执行Person构造器，输出person MyClass结果</span><br><span class="line">最后调用MyClass类构造器，输出myclass constructor结果，这样就完成了MyClass类的初始化了</span><br></pre></td></tr></table></figure>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// T stands for "Type"</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h5><p>使代码可以被不同类型的对象重复使用。典型的使用场景是集合，如果没有泛型，我们要么需要为不同的对象编写集合类，这样存在大量重复代码。或者编写通用的Object集合类，但这样做需要在使用之前进行强制类型转换。另外，在放入元素的时候也没有类型检查，任何类型的对象都可以放入集合，在使用时进行类型转换可能会发生 ClassCastException 类型转换异常。</p>
<p>泛型的好处：</p>
<p>增强代码可读性和安全性（提供编译期类型检查）。</p>
<h5 id="泛型的实现"><a href="#泛型的实现" class="headerlink" title="泛型的实现"></a>泛型的实现</h5><p>java 泛型是伪泛型，是在编译器层面通过<strong>泛型擦除</strong>实现的。在编译期间，所有的泛型信息都会被擦除掉，以类型界限代替。在使用泛型的时候，编译器也会帮我们自动进行类型转换。</p>
<h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p><strong>限定通配符</strong>：对类型进行了限制。</p>
<p>&lt;? extends T&gt; 确保类型必须是T的子类来设定类型的上界。<br><br>&lt;? super T&gt; 确保类型必须是T的父类来设定类型的下界。</p>
<p><strong>非限定通配符</strong>：&lt;?&gt;</p>
<h4 id="文件与IO"><a href="#文件与IO" class="headerlink" title="文件与IO"></a>文件与IO</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104757.png" alt="image-20200220140633788"></p>
<p>1.Java IO是采用的是装饰模式，即采用<strong>处理流</strong>来包装<strong>节点流</strong>的方式，来达到代码通用性。</p>
<p>2.处理流和节点流的区分方法，<strong>节点流</strong>在新建时需要一个数据源（文件、网络）作为参数，而<strong>处理流</strong>需要一个节点流作为参数。</p>
<p>3.<strong>处理流</strong>的作用就是提高代码通用性，编写代码的便捷性，提高性能。</p>
<p>4.<strong>节点流</strong>都是对应抽象基类的实现类，它们都实现了抽象基类的基础读写方法。其中read（）方法如果返回-1，代表已经读到数据源末尾。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104758.png" alt="image-20210305213044888"></p>
<h5 id="IO-NIO-BIO-AIO"><a href="#IO-NIO-BIO-AIO" class="headerlink" title="IO  NIO BIO  AIO"></a>IO  NIO BIO  AIO</h5><p>什么是阻塞和非阻塞，什么是同步和异步</p>
<p>同步和异步是针对应用程序和内核的交互而言的，<br>同步指的是用户进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否就绪</p>
<p>而异步是指用户进程触发 IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知。</p>
<p>阻塞和非阻塞是针对于进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式</p>
<p>阻塞方式下读取或者写入函数将一直等待</p>
<p>非阻塞方式下，读取或者写入函数会立即返回一个状态值。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104759.png" alt="image-20210305205609457"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一般来说 I/O 模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞 IO</span><br><span class="line">同步阻塞 IO：在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。JAVA 传统的 IO 模型属于此种方式！</span><br><span class="line"></span><br><span class="line">同步非阻塞 IO:在此种方式下，用户进程发起一个 IO 操作以后边可返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 JAVA 的 NIO 就属于同步非阻塞 IO。</span><br><span class="line"></span><br><span class="line">异步阻塞 IO：此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！</span><br><span class="line"></span><br><span class="line">异步非阻塞 IO:在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为真正的 IO 读取或者写入操作已经由内核完成了。</span><br></pre></td></tr></table></figure>
<h5 id="NIO原理"><a href="#NIO原理" class="headerlink" title="NIO原理"></a>NIO原理</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104800.png" alt="image-20210316115415231"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104801.png" alt="image-20210305210736184"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104802.png" alt="image-20210305210750572"></p>
<h5 id="select-epoll"><a href="#select-epoll" class="headerlink" title="select/epoll"></a>select/epoll</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104803.png" alt="image-20210305210453472"></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104804.png" alt="image-20210305210951921"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104805.png" alt="image-20210305210931353"></p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104806.png" alt="image-20210305211157202"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104807.png" alt="image-20210305211140190"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104808.png" alt="image-20210305211219663"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104809.png" alt="image-20210305211242847"></p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104810.png" alt="image-20210305204941639"></p>
<h4 id="java各版本的特性"><a href="#java各版本的特性" class="headerlink" title="java各版本的特性"></a>java各版本的特性</h4><h5 id="JDK1-5"><a href="#JDK1-5" class="headerlink" title="JDK1.5"></a>JDK1.5</h5><p>1.<strong>泛型</strong>、2. 自动装箱/拆箱、3. for-each、4. static、import、5. 变长参数、协变返回类型（实际返回类型可以是要求的返回类型的一个子类型）、6. 枚举</p>
<h5 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h5><p>1.<strong>增强的 for 循环</strong>、2. 监视和管理、3. 插入式注解处理、4. 安全性</p>
<h5 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h5><p>1.模块化新特性、2. 多语言支持、3. 改善开发效率、4. 改善执行效率、5. <strong>提供了新的垃圾回收器 G1</strong></p>
<h5 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h5><ol>
<li><p>接口允许默认方法 / 扩展方法</p>
<p>default 关键字</p>
</li>
<li><p>方法与构造函数引用</p>
<p>允许使用 :: 关键字来传递方法或者构造函数引用</p>
</li>
<li><p>Lambda</p>
<ul>
<li><p>表达式：无需再使用传统匿名对象方式</p>
</li>
<li><p>函数式接口</p>
<p>每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 </p>
</li>
<li><p>访问局部变量：可以直接在lambda表达式中访问外层的局部变量</p>
</li>
<li><p>访问对象字段与静态变量</p>
<p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的。</p>
</li>
<li><p>访问接口的默认方法</p>
<p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h3><h4 id="集合总览"><a href="#集合总览" class="headerlink" title="集合总览"></a>集合总览</h4><p>arraylist数组实现，随机访问快；linklist链表实现，插入删除快</p>
<p>hashset使用hash散列,获取元素很快，Treeset使用红黑树，按照比较结果升序保存，linkedhashset用来链表按照被添加的顺序保存，用hash保留查找速度(set中元素不可重复)</p>
<p>hashmap没有顺序，查找快，Treemap按照比较结果升序保存key ,LinkedHashMap按照插入结果保存Key，保留查找速度</p>
<p>Vector ,Hashtable,Stack弃用</p>
<p>点框表示接口，实框表示具体类，空心箭头表示特定类实现接口，实心箭头表示某类可以生成箭头所指类的对象</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104812.png" alt="image-20200210163111068"></p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>使用场景：ArrayList的底层是一个数组，适合快速匹配，不适合频繁的增删</p>
<p><strong>允许</strong>add null 值，会自动扩容，其中size(),isEmpty(),get(),add()方法的复杂度为O(1)</p>
<p>使用Collentions.synchronizedList()，实现线程安全或者Vector也可（Vector在方法上加的synchronized锁）</p>
<p>调用无参构造函数的时候，在JDK1.8默认为空数组（<strong>DEFAULT_EMPTY_ELEMENTDATA</strong> = {}），数字大小为10是我们第一次调用add方法是进行扩容的数组大小<br>若我们在执行构造函数传入的数组大小为0时，它使用的不是DEFAULT_EMPTY_ELEMENTDATA，而是另一个空数组<strong>EMPTY_ELEMENTDATA</strong> = {}（这个知识点面试没说过）</p>
<p><strong>add方法的过程</strong><br>先确定数组大小是否足够，如果我们创建ArrayList的时候指定了大小，那么则以给定的大小创建一个数组，否则默认大小为10；容量够大的情况，直接赋值；如果容量不够大，则进行扩容方法grow()，扩容的大小为原来大小的1.5倍（newCapicity = oldCapicity + oldCapicity &gt;&gt; 1，其中&gt;&gt;1，右移一位除以2），如果扩容后的大小还不够的话，则会将数组大小直接设置为我们需要的大小，扩容的最大值为Integer.MAX_VALUE，之后会调用Arrays.copyOf()方法将原数组中的数组复制过来<br>其中Arrays.copyOf()底层调用的是System.arrayCopy()，大家可以去简单了解下</p>
<p><strong>remove方法</strong><br>该方将被删除位置后的元素<strong>向前复制</strong>，底层调用的也是System.arrayCopy()方法，复制完成后，将数组元素的最后一个设置为null（因为向前复制一个位置，所以最后位置的元素是重复的），这样就解决了复制重复元素的问题</p>
<p>迭代器和增强for是一样的（这是一个Java语法糖，我后边还会再写语法糖相关的），过程中会判断modCount的值是否符合循环过程中的期望，如果不符合的话则会抛出并发修改异常，比较常见的情况就是在增强for中进行删除操作</p>
<p><strong>随机访问</strong></p>
<p>实现了 RandomAccess 接口，因此<strong>支持随机访问</strong>，这是理所当然的，因为 ArrayList 是基于数组实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>基于数组实现，保存元素的<strong>数组使用 transient 修饰</strong>，该关键字声明数组默认不会被序列化。这是 ArrayList 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。ArrayList 重写了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那么部分内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>
<p>数组的<strong>默认大小为 10</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>删除元素时需要调用 System.arraycopy() 对元素进行复制，因此<strong>删除操作成本很高</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加元素时使用 ensureCapacity() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，使得新容量为<strong>旧容量的 1.5 倍</strong>（oldCapacity + (oldCapacity &gt;&gt; 1))。扩容操作需要把原数组整个复制到新数组中，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Iterator和ListIterator区别"><a href="#Iterator和ListIterator区别" class="headerlink" title="Iterator和ListIterator区别"></a>Iterator和ListIterator区别</h5><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h5 id="ArrayList、LinkedList、Vector"><a href="#ArrayList、LinkedList、Vector" class="headerlink" title="ArrayList、LinkedList、Vector"></a>ArrayList、LinkedList、Vector</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104813.png" alt="image-20210307201033444"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104814.png" alt="image-20210307201305145"></p>
<h5 id="快速失败-fail-fast-和安全失败-fail-safe"><a href="#快速失败-fail-fast-和安全失败-fail-safe" class="headerlink" title="快速失败(fail-fast) 和安全失败(fail-safe)"></a>快速失败(fail-fast) 和安全失败(fail-safe)</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104815.png" alt="image-20210307201414967"></p>
<h5 id="RandomAccess-接⼝"><a href="#RandomAccess-接⼝" class="headerlink" title="RandomAccess 接⼝"></a>RandomAccess 接⼝</h5><p>查看源码我们发现实际上  RandomAccess 接⼝中什么都没有定义。所以，在我看来RandomAccess 接⼝不过是⼀个标识罢了。标识什么？ 标识实现这个接⼝的类具有随机访问功能。<br>在  binarySearch?) ⽅法中，它要判断传⼊的 list 是否  RamdomAccess 的实例，如果是，调⽤ indexedBinarySearch() ⽅法，如果不是，那么调⽤ iteratorBinarySearch() ⽅法</p>
<h5 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h5><p>底层其实是调用了<code>Arrays.copyOf</code>方法来进行扩充数组容量的。</p>
<p><code>ArrayList</code>里面有两个概念，一个是<code>capacity</code>，它表示的就是“容量”，其实质是数组<code>elementData</code>的长度。而<code>size</code>则表示的“存放的元素的个数”。</p>
<p>在JDK1.8中，如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时（即添加第一个元素时），才真正分配容量，默认分配容量为10；当容量不足时（容量为size，添加第size+1个元素时），先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容。</p>
<p>ArrayList的最大容量为Integer.MAX_VALUE</p>
<p><strong>为什么需要手动扩容？</strong>试想一下，如果用户已经知道即将存入大量的元素，比如目前有20个元素，即将存入2000个。那这个时候使用自动扩容就会扩容多次。而手动扩容可以一次性扩容到2000，可以提高性能。</p>
<p><strong>ArrayList有缩容吗？</strong></p>
<p><code>ArrayList</code>没有缩容。无论是<code>remove</code>方法还是<code>clear</code>方法，它们都不会改变现有数组<code>elementData</code>的长度。但是它们都会把相应位置的元素设置为<code>null</code>，以便垃圾收集器回收掉不使用的元素，节省内存。</p>
<h5 id="Collections-sort-原理"><a href="#Collections-sort-原理" class="headerlink" title="Collections.sort  原理"></a>Collections.sort  原理</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104816.png" alt="image-20210307200607804"></p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><ul>
<li>线程安全的，通过锁 + 数组拷贝 + volatile 保证线程安全（底层数组被volatile修饰） </li>
<li>每次进行数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作之后再赋值回去 </li>
<li>对数组的操作，一般分为四步<br>1 加锁<br>2 从原数组中拷贝出新数组<br>3 在新数组上进行操作，并把新数组赋值给原引用<br>4 解锁 </li>
<li>已经加锁了，为什么还需要拷贝新数组？<br>因为在原数组上进行修改，没有办法触发volatile的可见性，需要修改内存地址，即将新拷贝的数组赋值给原引用 </li>
<li>在进行写操作的时候，是能读的，但是读的数据是老数组的，能保证数组最终的一致性，不能保证实时一致性； </li>
<li>存在内存占用问题，写时复制比较影响性能</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>在JDK1.8之前，哈希表底层采用<strong>数组+链表</strong>实现，而JDK1.8中，哈希表存储采用<strong>数组+链表+红黑树</strong>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104817.png" alt="image-20210305214229565"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104818.png" alt="哈希流程图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap的默认初始容量大小 16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap的最大容量 2的30次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负载因子，代表了table的填充度有多少，默认是0.75。当数组中的数据大于总长度的0.75倍时</span></span><br><span class="line"><span class="comment">     * HashMap会自动扩容，默认扩容到原长度的两倍。为什么是两倍，而不是1.5倍，或是3倍。length=2的n次方，h&amp;(length-1)==h%length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认阈值，当桶(bucket)上的链表长度大于这个值时会转成红黑树，put方法的代码里有用到</span></span><br><span class="line"><span class="comment">     * 在jdk1.7中链表就是普通的单向链表，很多数据出现哈希碰撞导致这些数据集中在某一个哈希桶上，</span></span><br><span class="line"><span class="comment">     * 因而导致链表很长，会出现效率问题，jdk1.8对此做了优化，默认当链表长度大于8时转化为红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和上一个的阈值相对的阈值，当桶(bucket)上的链表长度小于这个值时红黑树退化成链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap  * 的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="hashcode-的计算"><a href="#hashcode-的计算" class="headerlink" title="hashcode 的计算"></a>hashcode 的计算</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104819.png" alt="image-20210305214636891"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104820.png" alt="image-20210305214838703"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算hash，扰动函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算索引位置：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>
<h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104821.png" alt="image-20210305214934547"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104822.png" alt="image-20210305220438552"></p>
<p><strong>jdk1.8 扩容元素的位置要么是在原位置，要么是在原位置加原数组长度的位置</strong>。</p>
<h5 id="负载因子0-75"><a href="#负载因子0-75" class="headerlink" title="负载因子0.75"></a>负载因子0.75</h5><p>泊淞分布啊</p>
<p>简单翻译一下就是在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布，注释同时给出了桶中元素个数和概率的对照表。</p>
<p>从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。0.00000006，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p>
<h5 id="get方法（不加锁）"><a href="#get方法（不加锁）" class="headerlink" title="get方法（不加锁）"></a>get方法（不加锁）</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104823.png" alt="image-20210305215442825"></p>
<h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104818.png" alt="哈希流程图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用putVal()方法完成</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断table是否初始化，否则初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//计算存储的索引位置，如果没有元素，直接赋值</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//节点若已经存在，执行赋值操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断链表是否是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//红黑树对象操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//为链表，</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//链表长度8，将链表转化为红黑树存储</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//key存在，直接覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空操作</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对key为NULL的特别处理"><a href="#对key为NULL的特别处理" class="headerlink" title="对key为NULL的特别处理"></a>对key为NULL的特别处理</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104824.png" alt="image-20210305215635335"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104825.png" alt="image-20210305215617963"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若key==null，则将其放入table的第一个桶，即 table[0]</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;   </span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;   <span class="comment">// 若已经存在key为null的键，则替换其值，并返回旧值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;        <span class="comment">// 快速失败</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);       <span class="comment">// 否则，将其添加到 table[0] 的桶中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h5><p>添加删除和扩容时有问题</p>
<p>要想实现线程安全，那么需要调用 collections 类的静态方法 synchronizeMap（）实现</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104826.png" alt="image-20210305215705647"></p>
<h5 id="key-可以为任意对象或数据类型吗？"><a href="#key-可以为任意对象或数据类型吗？" class="headerlink" title="key 可以为任意对象或数据类型吗？"></a>key 可以为任意对象或数据类型吗？</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104827.png" alt="image-20210305220242863"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104828.png" alt="image-20210305220252516"></p>
<h5 id="树化操作的阈值是8和6？"><a href="#树化操作的阈值是8和6？" class="headerlink" title="树化操作的阈值是8和6？"></a>树化操作的阈值是8和6？</h5><p><a href>链表</a>的查询时间复杂度为O(n)，<a href>红黑树</a>的查询时间复杂度为O(logn)，在数据量不多的时候，使用<a href>链表</a>比较快，只有当数据量比较大的时候，才会转化为<a href>红黑树</a>，但是<a href>红黑树</a>占用的空间大小是<a href>链表</a>的2倍，考虑到时间和空间上的损耗，所以要设置边界值（其实<a href>链表</a>长度为8的概率很低，在HashMap注释中写了，出现的概率不择千万分之一，<a href>红黑树</a>只是为了在极端情况下来保证性能）</p>
<p>为什么还要有一个阈值是6？<br>避免频繁的进行树退化为<a href>链表</a>的操作，因为退化也是有开销的，当我们移除一个<a href>红黑树</a>上的值的时候，如果只有阈值8的话，那么它会直接退化，我们若再添加一个值，它有可能又需要变为<a href>红黑树</a>了，添加阈值6相当于添加了一个缓冲</p>
<h5 id="HashMap-JDK-1-8"><a href="#HashMap-JDK-1-8" class="headerlink" title="HashMap - JDK 1.8"></a>HashMap - JDK 1.8</h5><p><strong>链表转红黑树</strong></p>
<p>一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</p>
<p><strong>解决扩容时的死循环问题</strong></p>
<p>使用lo和hi分别指向两个新的链表。原来的链表中的元素扩容后位置不变，就放到lo中，位置改变，就放到hi中。采用尾插法进行移动，因此扩容之后元素顺序不改变，也不会发生死循环。而JDK1.7采用头插法则会改变元素顺序。最后分别将lo和hi放入新hashMap的桶中。</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>一个 ConcurrentHashMap 维护一个 <strong>Segment 数组,</strong>一个 Segment 维护一个 <strong>HashEntry 数组</strong>。Segment 继承了 <strong>ReentrantLock</strong>，表明每个 segment 都可以当做一个锁。这样对每个 segment 中的数据需要同步操作的话都是使用每个 segment 容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的 segment。 JDK1.8 的时候已经摒弃了  Segment 的概念，⽽是直接⽤  <strong>Node 数组+链表+红⿊树</strong>的数据结构来实现，并发控制使⽤  <strong>synchronized 和 CAS</strong> 来操作。（JDK1.6 以后 对  synchronized 锁做了很多优化） synchronized 只锁定当前<strong>链表或红⿊⼆叉树的⾸节点</strong>，这样只要 hash 不冲突，就不会产⽣并发，效率⼜提升 N 倍。整个看起来就像是优化过且线程安全的  HashMap ，虽然在 JDK1.8 中还能看到Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104829.png" alt="image-20210305222249650"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104830.png" alt="image-20210305222139377"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104831.png" alt="image-20210305222500466"></p>
<h5 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h5><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<h5 id="Get-原理"><a href="#Get-原理" class="headerlink" title="Get 原理"></a>Get 原理</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104832.png" alt="image-20210307195131476">先判断一下 count != 0；count 变量表示 segment 中存在 entry的个数。如果为 0 就不用找了。</p>
<p>假设这个时候恰好另一个线程 put 或者 remove了这个 segment 中的一个 entry，会不会导致两个线程看到的 count 值不一致呢？ <strong>依赖 volatile 关键字保证可见</strong>。看一下 count 变量的定义： transient volatile int count;</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104833.png" alt="image-20210307195102182"></p>
<h5 id="Put原理"><a href="#Put原理" class="headerlink" title="Put原理"></a>Put原理</h5><ul>
<li>如果没有初始化就先进行初始化过程</li>
<li>如果没有hash冲突就直接CAS插入</li>
<li>如果存在hash冲突，就加锁来保证线程安全，链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入</li>
</ul>
<p>下图大致描述了 put 一个新的 entry 的过程</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104834.png" alt="image-20210307195250159"></p>
<p>删除</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104835.png" alt="image-20210307195521157"></p>
<p>作者：方圆想当图灵<br>链接：<a href="https://www.nowcoder.com/discuss/634573?type=2&amp;channel=-1&amp;source_id=discuss_terminal_discuss_hot_nctrack" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/634573?type=2&amp;channel=-1&amp;source_id=discuss_terminal_discuss_hot_nctrack</a><br>来源：牛客网</p>
<h5 id="ConcurrentHashMap（JDK1-8）"><a href="#ConcurrentHashMap（JDK1-8）" class="headerlink" title="ConcurrentHashMap（JDK1.8）"></a>ConcurrentHashMap（JDK1.8）</h5><ul>
<li>底层基于CAS + synchronized实现，所有操作都是线程安全的，允许多个线程同时进行put、remove等操作 </li>
<li>底层数据结构：数组、<a href>链表</a>和<a href>红黑树</a>的基础上还添加了一个转移节点，在扩容时应用 </li>
<li>table数组被volatile修饰 </li>
<li>其中有一个比较重要的字段，sizeCtl= -1 时代表table正在初始化<br>table未初始化时，代表需要初始化的大小<br>table初始化完成，表示table的容量，默认为0.75table大小 </li>
<li>put过程<br>key和value都是不能为空的，否则会产生空指针异常，之后会进入自旋（for循环自旋），如果当前数组为空，那么进行初始化操作，初始化完成后，计算出数组的位置，如果该位置没有值，采用CAS操作进行添加；如果当前位置是转移节点，那么会调用helptransfer方法协助扩容；如果当前位置有值，那么用synchronized加锁，锁住该位置，如果是<a href>链表</a>的话，采用的是尾插发，如果是<a href>红黑树</a>，则采用<a href>红黑树</a>新增的方法，新增完成后需要判断是否需要扩容，大于sizeCtl的话，那么执行扩容操作 </li>
<li>初始化过程<br>在进行初始化操作的时候，会将sizeCtl利用CAS操作设置为-1，CAS成功之后，还会判断数组是否完成初始化，有一个双重检测的过程<br>过程：进入自旋，如果sizeCtl &lt; 0, 线程礼让（Thread.yield()）等待初始化；否则CAS操作将sizeCtl设置为-1，再次检测是否完成了初始化，若没有则执行初始化操作</li>
</ul>
<h5 id="HashMap与HashTable区别"><a href="#HashMap与HashTable区别" class="headerlink" title="HashMap与HashTable区别"></a>HashMap与HashTable区别</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104836.png" alt="image-20210307195855649"></p>
<h5 id="HashMap与ConcurrentHashMap区别"><a href="#HashMap与ConcurrentHashMap区别" class="headerlink" title="HashMap与ConcurrentHashMap区别"></a>HashMap与ConcurrentHashMap区别</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104837.png" alt="image-20210307195927117"></p>
<h5 id="ConcurrentHashMap与HashTable区别"><a href="#ConcurrentHashMap与HashTable区别" class="headerlink" title="ConcurrentHashMap与HashTable区别"></a>ConcurrentHashMap与HashTable区别</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104838.png" alt="image-20210307200123574"></p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104839.png" alt="image-20210307200236633"></p>
<p><strong>LinkedHashMap 实现LRU 缓存</strong></p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES  为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[3, 1, 4]</span></span><br></pre></td></tr></table></figure>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>对于 HashSet 而言，它是基于 HashMap 实现的,可以看出 hashset 底层是 hashmap 但是存储的是一个对象，hashset 实际将该元素 e 作为 key 放入 hashmap,当 key 值(该元素 e)相同时，只是进行更新 value，并不会新增<br>加，所以 set 中的元素不会进行改变。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104840.png" alt="image-20210307200433269"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104841.png" alt="image-20210307200449786"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104842.png" alt="image-20210307200457322"></p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>Java中PriorityQueue通过二叉小顶堆实现，可以用一棵完全二叉树表示。PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素<br>排序的比较器。PriorityQueue 不允许 null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104843.png" alt="image-20210305203257400"></p>
<p><strong>添加元素 add()和 offer()</strong><br>原理：添加元素位于末尾，同时队列长度加 1，然后这个元素与它的父节点进行比较，</p>
<p>如果比父节点小那么就与父节点进行交换，然后再与交换后的位置的父节点进行比较，<br>重复这个过程，直到该元素的值大于父节点结束这个过程。<br>区别: add(E e)和 offer(E e)的语义相同，都是向优先队列中插入元素，只是 Queue 接口规<br>定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回 false。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104844.png" alt="image-20210305203430221"></p>
<p><strong>寻找队列的头部元素 element()和 peek()头部元素</strong><br>element()和 peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回 null。 时间复杂度为 1，根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0 下标处的那个元素既是堆顶元素。所以直接返回数组 0 下标处的那个元素即可。</p>
<p><strong>最大堆 获取数组中最小的几个数 最小堆  获取数组中最大的几个数</strong></p>
<p><strong>删除元素 remove() 和 poll()</strong><br>区别:remove()和 poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回 null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。<br>原理：该方法的作用是从 k 指定的位置开始，将 x 逐层向下与当前点的左右孩子中较小的那个交换，直到 x 小于或等于左右孩子中的任何一个为止</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104845.png" alt="image-20210305203627842"></p>
<h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><p><strong>存储结构</strong></p>
<p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>ConcurrentCache</strong></p>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentCache</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.eden = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">this</span>.longterm = <span class="keyword">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            v = <span class="keyword">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">this</span>.longterm.putAll(<span class="keyword">this</span>.eden);</span><br><span class="line">            <span class="keyword">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105244.png" alt="image-20210308100929752"></p>
<!--more-->
<h4 id="JMM-内存模型"><a href="#JMM-内存模型" class="headerlink" title="JMM 内存模型"></a>JMM 内存模型</h4><p>JMM (Java Memory Model)是 Java 内存模型,JMM 定义了程序中各个<strong>共享变量的访问规则</strong>,即在虚拟机中将变量存储到内存和从内存读取变量这样的底层细节.并提供了内置解决方案（happen-before 原则）及其外部可使用的同步手段(synchronized/volatile 等)，确保了程序执行在多线程环境中的应有的 <strong>原子性，可视性及其有序性</strong>。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105245.png" alt="img"></p>
<p>JMM 规定了所有的变量都存储在主内存 规定了所有的变量都存储在主内存（ （Main Memory） ） 中 。 每个线程还有自己的工作内存（ 己的工作内存（Working Memory ）,线程的工作内存中保存了该线程使用到的变量的 线程的工作内存中保存了该线程使用到的变量的<strong>主内存的副本拷贝</strong>，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行 ， 而不能直接读写主内存中的变量（ （volatile 变量仍然有工作内存的拷贝 变量仍然有工作内存的拷贝 ， 但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，<strong>线程之间值的传递都需要通过主内存</strong>来完成.</p>
<h5 id="JMM-的-happens-before-原则"><a href="#JMM-的-happens-before-原则" class="headerlink" title="JMM 的 happens-before 原则"></a>JMM 的 happens-before 原则</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105246.png" alt="image-20210307211631353"></p>
<h5 id="为什么要实现内存模型"><a href="#为什么要实现内存模型" class="headerlink" title="为什么要实现内存模型"></a>为什么要实现内存模型</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105247.png" alt="image-20210307211402249"></p>
<h4 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105248.png" alt="image-20210307211804692"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105249.png" alt="image-20210307211854961"></p>
<h5 id="什么是堆中的永久代"><a href="#什么是堆中的永久代" class="headerlink" title="什么是堆中的永久代"></a>什么是堆中的永久代</h5><p>答： 永久代是用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类，永久代中一般包含：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类的方法(字节码...)</span><br><span class="line">类名(Sring 对象)</span><br><span class="line">.class 文件读到的常量信息</span><br><span class="line">class 对象相关的对象列表和类型列表 (e.g., 方法对象的 array).</span><br><span class="line">JVM 创建的内部对象</span><br><span class="line">JIT 编译器优化用的信息</span><br></pre></td></tr></table></figure>
<h5 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的"></a>程序计数器为什么是私有的</h5><p>程序计数器主要有下⾯两个作⽤：</p>
<ol>
<li><p>字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、选择、循环、异常处理。</p>
</li>
<li><p>在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时候能够知道该线程上次运⾏到哪⼉了。</p>
<p>需要注意的是，如果执⾏的是 native ⽅法，那么程序计数器记录的是 undefined 地址，只有执⾏的是 Java 代码时程序计数器记录的才是下⼀条指令的地址。<br>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执⾏位置</strong>。</p>
</li>
</ol>
<h5 id="对象初始化过程-newA"><a href="#对象初始化过程-newA" class="headerlink" title="对象初始化过程 newA()"></a>对象初始化过程 newA()</h5><p>Student s = new Student() 为例<br>1.首先查看类的符号引用，看是否已经在常量池中，在说明已经加载过了，不在的话需要进行类的加载，验证，准备，解析，初始化的过程。<br>2.上诉过程执行完毕以后，又将 Student 加载进内存，也就是存储 Student.class的字段信息和方法信息，存储到方法区中<br>字段信息：存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。<br>方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。<br>3。然后在自己的线程私有的虚拟机栈中，存储该引用，然后在每个线程的私有空间里面去分配空间存储 new Student()<br>4，对类中的成员变量进行默认初始化（设置0值，设置对象头）<br>5，对类中的成员变量进行显示初始化<br>6，有构造代码块就先执行构造代码块，如果没有，则省略<br>7，执行构造方法，通过构造方法对对对象数据进行初始化<br>8，堆内存中的数据初始化完毕，把内存值复制给 s 变量</p>
<h5 id="分配内存两种方式"><a href="#分配内存两种方式" class="headerlink" title="分配内存两种方式"></a>分配内存两种方式</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210417165517.png" alt="image-20210417165515649"></p>
<h5 id="并发下对象分配内存时线程安全"><a href="#并发下对象分配内存时线程安全" class="headerlink" title="并发下对象分配内存时线程安全"></a>并发下对象分配内存时线程安全</h5><p>例如同时创建对象A和B，在给A分配内存时，指针还未来得及移动的情况下，B又在原来的基础上分配内存,两种解决方案：</p>
<ol>
<li>虚拟机采取<strong>CAS操作</strong>配上<strong>失败重试</strong>来保证更新操作的原子性</li>
<li>每个线程在java堆eden区中分配一小块区域，称为<strong>本地线程分配缓冲</strong>(TLAB)，哪个线程要分配内存时，就在自己的TLAB上分配。</li>
</ol>
<h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><ul>
<li>在HotSpot虚拟机中，对象的内存布局可以分为：<strong>对象头</strong>，<strong>实例数据</strong>，<strong>对齐填充</strong></li>
<li><strong>对象头</strong>包括两部分的信息：<ol>
<li>存储对象自身运行时数据，如哈希码，<strong>GC分代年龄</strong>，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等</li>
<li><strong>类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例</li>
</ol>
</li>
<li><strong>实例数据</strong>是对象真正存储的有效信息，也是在程序段中所定义的各种类型字段(包括父类的)。</li>
</ul>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210513111121.png" alt="图片说明"></p>
<h5 id="对象的访问定位方式"><a href="#对象的访问定位方式" class="headerlink" title="对象的访问定位方式"></a>对象的访问定位方式</h5><p>通过栈上的reference数据来操作堆上的对象有两种访问方式：</p>
<ol>
<li><p><strong>句柄</strong>。java堆中专门划分出一个句柄池，reference存储的是句柄的地址，而句柄包含了对象实例数据和类型数据各自的具体地址信息。</p>
<p>优点：对象移动时，只需要修改句柄中的指针即可，reference不需要修改</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105250.png" alt="image-20200423105805390.png"></p>
</li>
<li><p><strong>直接指针</strong>。reference直接存储对象地址</p>
<p>优点：节省了一次地址定位的时间</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105251.png" alt="image-20200423105905341.png"></p>
</li>
</ol>
<h5 id="java堆内存溢出"><a href="#java堆内存溢出" class="headerlink" title="java堆内存溢出"></a>java堆内存溢出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM:-verbose:gc</span></span><br><span class="line"><span class="comment">     * -Xms20M</span></span><br><span class="line"><span class="comment">     * -Xmx20M</span></span><br><span class="line"><span class="comment">     * -Xmn10M</span></span><br><span class="line"><span class="comment">     * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">     * -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;OOMObject&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过设置参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code>可以在虚拟机出现内存溢出时Dump出当前的内存堆转储快照。</p>
<p>然后用内存映像分析工具(VisualVM)对Dump出的堆转储快照进行分析，重点是确认内存中的对象是否有必要存在，即判断是发生了<strong>内存泄漏</strong>还是<strong>内存溢出</strong>。</p>
<ul>
<li>如果是<strong>内存泄漏</strong>，可进一步查看泄漏对象到GC Roots的引用链，就可以找到泄漏对象是怎么和GC Roots相连的导致垃圾回收器无法自动回收它们。</li>
<li>如果<strong>内存溢出</strong>,那就应当检查虚拟机的堆参数，能不能调大一点。</li>
</ul>
<h5 id="对象的强、软、弱和虚引用"><a href="#对象的强、软、弱和虚引用" class="headerlink" title="对象的强、软、弱和虚引用"></a>对象的强、软、弱和虚引用</h5><p>强引用&gt;软引用&gt;弱引用&gt;虚引用</p>
<ul>
<li><p><strong>强引用</strong>。类似Object obj=new Object()这类的引用，只要强引用在，垃圾回收器就无法回收掉引用的对象。</p>
</li>
<li><p><strong>软引用</strong>。被软引用关联的对象只有在<strong>内存不够</strong>的情况下才会被回收，通常用在对内存敏感的程序中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; sf=new SoftReference&lt;&gt;(new Object());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>弱引用</strong>。被弱引用关联的对象只能活到<strong>下次垃圾收集发生之前</strong>。当垃圾收集器工作时，弱引用关联的对象总会被回收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; wf=new WeakReference&lt;&gt;(new Object());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚引用</strong>。虚引用对对象的生存时间不会构成影响，也无法通过虚引用来获取对象实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; rq=new ReferenceQueue&lt;&gt;();   //引用队列</span><br><span class="line">PhantomReference&lt;Object&gt; pr=new PhantomReference&lt;&gt;(new Object(),rq);</span><br><span class="line">System.out.println(pr.get());  //null</span><br><span class="line">System.out.println(rq.poll()); //null</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="如何减少-GC-的次数"><a href="#如何减少-GC-的次数" class="headerlink" title="如何减少 GC 的次数"></a>如何减少 GC 的次数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.对象不用时最好显示置为 NULL</span><br><span class="line">一般而言，为 NULL 的对象都会被作为垃圾处理，所以将不用的对象置为NULL，有利于 GC 收集器判定垃圾，从而提高了 GC 的效率。</span><br><span class="line">2.尽量少使用 System,gc()</span><br><span class="line">此函数建议 JVM 进行主 GC，会增加主 GC 的频率，增加了间接性停顿的次数。</span><br><span class="line">3.尽量少使用静态变量</span><br><span class="line">静态变量属于全局变量，不会被 GC 回收，他们会一直占用内存</span><br><span class="line">4.尽量使用 StringBuffer,而不使用 String 来累加字符串</span><br><span class="line">5.分散对象创建或删除的时间</span><br><span class="line">集中在短时间内大量创建新对象，特别是大对象，会导致突然需要大量内存，JVM 在这种情况下只能进行主 GC 以回收内存，从而增加主 GC 的频率。</span><br><span class="line">6.尽量少用 finaliza 函数,会加大 GC 的工作量。</span><br><span class="line">7.如果有需要使用经常用到的图片，可以使用软引用类型，将图片保存在内存中，而不引起 outofmemory</span><br><span class="line">8.能用基本类型入 INT 就不用对象 Integer</span><br><span class="line">9.增大-Xmx 的值</span><br></pre></td></tr></table></figure>
<h5 id="OutOfMemory和StackOverflow"><a href="#OutOfMemory和StackOverflow" class="headerlink" title="OutOfMemory和StackOverflow"></a>OutOfMemory和StackOverflow</h5><p><strong>如何产生OutOfMemory？</strong><br>堆内存不够用了，会抛出这个OutOfMemoryError </p>
<p><strong>你能用什么方法来抛出这个Error？</strong><br>可以通过把堆内存通过参数-Xmx调小一些，然后写一个while的死循环，不断的执行append操作 </p>
<p><strong>那如何产生Stack Overflow Error？</strong><br>这个是栈溢出，我们可以通过写两个方法，A方法调用B方法，B方法在调用A方法，这样可以产生这个Error</p>
<p><strong>你还知道其他的JVM参数嘛？</strong><br>知道，-Xms指定堆的初始大小，-Xss指定栈的大小，-XX:+HeapDumpOnOutOfMemoryError内存快照的Dump文件，可以分析Dump文件来查看OutOfMemoryError </p>
<p><strong>列举一些垃圾回收的参数</strong><br>指定期望的GC的停顿时间（在Parallel Scavenge、Parallel Old和G1回收器中指定）：-XX:MaxGCPauseMills<br>改变G2的Rigion容量：-XX:G1HeapRegionSize<br>年轻代大小:-Xmn<br>比例：-XX:Sur<a href>vivo</a>rRatio=8(8:1:1)<br>大对象直接进入老年代的阈值：-XX:PretenureSizeThreshold</p>
<h4 id="GC-算法（YGC-and-FGC）"><a href="#GC-算法（YGC-and-FGC）" class="headerlink" title="GC  算法（YGC and  FGC）"></a>GC  算法（YGC and  FGC）</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105252.png" alt="image-20210308101949605"></p>
<h5 id="判断一个对象是否存活-GC-对象判定方法"><a href="#判断一个对象是否存活-GC-对象判定方法" class="headerlink" title="判断一个对象是否存活?(GC 对象判定方法)"></a>判断一个对象是否存活?(GC 对象判定方法)</h5><p>引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）的情况<br>引用链法(可达性分析法）： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，如果有一条链能够到达 GC ROOT 就说明，不能到达 GC ROOT 就说明</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105253.png" alt="image-20210307212135054"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105254.png" alt="image-20210307213754774"></p>
<h5 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h5><ul>
<li>Minor GC：回收新生代，复制算法，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC / Major GC：回收老生代和新生代，标记清除整理算法，老生代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。出现了 Full GC，经常会伴随至少一次 Minor GC。</li>
</ul>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105252.png" alt="image-20210308101949605"></p>
<p>堆里面分为新生代和老生代（java8 取消了永久代 Perm Space，采用了 Metaspace,字符串常量存放到堆内存中），新生代包含 <strong>Eden+Survivor 区</strong>，1 部分 Eden 区较大，1 部分 Survivor 比较小,survivor 区里面分为 from 和 to 区，<strong>8:1:1</strong>,内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后(年龄阈值15，可以通过-XX:MaxTenuringThreshold 来设置)，存活下来的对象会被移动到老年区，当 <strong>JVM 内存不够</strong>用的时候，会触发 Full GC，清理 JVM 老年区。<br>当<strong>新生区满了</strong>之后会触发 YGC,先把存活的对象放到其中一个 Survice区，然后进行垃圾清理。一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。</p>
<p>FGC 就是标记整理或者是标记清除算法来清除老年代。</p>
<h5 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h5><p><strong>对象优先在Eden区分配</strong></p>
<ul>
<li>大多数情况下，对象在新生代的 Eden 区上分配，<strong>当 Eden 空间不够时，发起 Minor GC</strong></li>
<li>若启动了本地线程分配缓冲，则将按线程优先在 TLAB （本地线程分配缓冲）上分配</li>
</ul>
<p><strong>大对象直接进入老生代</strong></p>
<ul>
<li><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组</p>
</li>
<li><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象</p>
</li>
<li><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老生代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<p>该参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge收集器一般并不需要设置，若遇到必须使用该参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。</p>
</li>
</ul>
<p><strong>长期存活的对象进入老年代</strong></p>
<ul>
<li>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄（默认 15）则移动到老生代中。</li>
<li>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</li>
</ul>
<p><strong>动态对象年龄判定</strong></p>
<p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老生代，如果在 Survivor 中<strong>相同年龄所有对象大小的总和大于 Survivor 空间的一半</strong>，则年龄大于或等于该年龄的对象可以直接进入老生代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<p><strong>空间分配担保</strong></p>
<p>在进行 Minorgc前，虚拟机会查看 Handle Promotion Failure设置值是否为True，那么说明允许担保失败（会检查虚拟机老年代剩余空间的大小与平均晋升到老年代空间的大小，如果大于说明“可能”是安全的），为True那么进行一次 Minora，如果此时刻发现进入到老年代的新对象的大小是大于老年代的剩余空间，说明担保失败了，只能进行一次Fu|GC清除老年代的剩余空间。</p>
<p><strong>JDK 6 Update 24 之后不再使用 HandlePromotionFailure  参数</strong>，规则变为只要<strong>老生代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>就会进行Minor GC，否则将进行Full GC。</p>
<p><strong>实例：</strong></p>
<ol>
<li>内存大小设定</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制堆大小为 20M，不可扩展，10M 分配给新生代、10M 分配给老生代</span></span><br><span class="line">-Xms20M -Xmx20M -Xmn10M</span><br><span class="line"><span class="comment">// 决定新生代中 Eden：Survivor = 8：1</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>内存分配</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] allocation1，allocation2，allocation3，allocation4;</span><br><span class="line">allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]; <span class="comment">// 出现一次Minor GC</span></span><br></pre></td></tr></table></figure>
<p>​    分配 allocation4 对象的语句时会发生一次 Minor GC，这次 GC 的结果是新生代 6651KB 变为 148KB，而总内存占用量则几乎没有减少（因为 allocation1、allocation2、allocation3 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。</p>
<p>​    这次 GC 发生的原因是给 allocation4 分配内存的时候，发现 Eden 已经被占用了 6MB，剩余空间已不足以分配 allocation4 所需的 4MB 内存，因此发生 Minor GC。GC 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 Survivor 空间（ Survivor 空间只有 1MB 大小），所以<strong>只好通过分配担保机制提前转移到老生代去。</strong></p>
<ol start="3">
<li>结果</li>
</ol>
<p>​    Eden 占用 4 MB（被 allocation4 占用），Survivor 空闲，老生代被占用 6MB（被allocation1、 allocation2、allocation3 占用）。</p>
<h5 id="Full-GC-触发条件"><a href="#Full-GC-触发条件" class="headerlink" title="Full GC 触发条件"></a>Full GC 触发条件</h5><p>对于 Minor GC，其触发条件非常简单，<strong>当 Eden 空间满时，就将触发一次 Minor GC</strong>。而 Full GC 则相对复杂，有以下条件：</p>
<p><strong>调用 System.gc()</strong></p>
<p>只是<strong>建议虚拟机执行 Full GC</strong>，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<p><strong>老生代空间不足</strong></p>
<p>老生代空间不足的常见场景为前文所讲的大对象直接进入老生代、长期存活的对象进入老生代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老生代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老生代的年龄，让对象在新生代多存活一段时间。</p>
<p><strong>空间分配担保失败</strong></p>
<p>使用复制算法的 Minor GC 需要老生代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
<p><strong>JDK 1.7 及以前的永久代空间不足</strong></p>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 信息、Meta 信息、常量、静态变量等数据。GC 不会在主程序运行期对永久代区域进行清理。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<p><strong>Concurrent Mode Failure</strong></p>
<p>执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105255.png" alt="1553654058045.png"></p>
<p><strong>串行、并行与并发</strong></p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行：<strong>串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；</strong></li>
<li>并行：多条垃圾收集线程并行工作，但<strong>此时用户线程仍处于等待状态</strong>；</li>
<li>并发：<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上。</li>
<li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105256.png" alt="image-20210307212331377"></p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><ul>
<li>ParNew收集器是Serial收集器的多线程版本，使用多条线程进行垃圾收集，新生代使用<strong>复制</strong>算法。</li>
<li>默认开启线程数与 CPU 的数量相同</li>
<li>它是 <strong>Server</strong> 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</li>
</ul>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105257.png" alt="image-20200424094451166.png"></p>
<h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>与 ParNew 一样是并行多线程收集器，使用<strong>复制</strong>算法，新生代使用。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是<strong>达到一个可控制的吞吐量</strong>，因此它被称为 “<strong>吞吐量优先</strong>” 收集器。这里的<strong>吞吐量指 CPU 用于运行用户程序的时间占总时间的比值</strong>。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，<strong>适合在后台运算而不需要太多交互的任务</strong>。</p>
<p>提供了精确控制吞吐量的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMills		<span class="comment">// 控制最大垃圾收集停顿时间</span></span><br><span class="line">-XX:GCTimeRatio			<span class="comment">// 垃圾收集时间占总时间的比率，即吞吐量的倒数，例如19，则表示垃圾收集时间							   占比为1/(1+19)=5%</span></span><br></pre></td></tr></table></figure>
<ul>
<li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</li>
</ul>
<p>可以通过一个开关参数打开 <strong>GC 自适应的调节策略（GC Ergonomics）</strong>，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老生代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy  <span class="comment">// 开关参数</span></span><br></pre></td></tr></table></figure>
<h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105258.png" alt="1557456534404.png"></p>
<p>是 <strong>Serial 收集器的老生代版本</strong>，同样是一个<strong>单线程</strong>收集器（无法充分利用服务器多 CPU 的处理能力），使用 <strong>”标记 - 整理“</strong> 算法。该收集器主要是给 <strong>Client</strong> 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105259.png" alt="1557471744502.png"></p>
<p>JDK 1.6 中开始提供，是 Parallel Scavenge 收集器的老生代版本，使用<strong>多线程</strong>和 <strong>”标记 - 整理“</strong> 算法。</p>
<p>在JDK1.6之前，新生代使用 ParallelScavenge 收集器只能搭配老生代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了<strong>在老生代同样提供吞吐量优先</strong>的垃圾收集器，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105300.png" alt="1557471755660.png"></p>
<p>CMS（Concurrent Mark Sweep）是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，Mark Sweep 指的是<strong>标记 - 清除</strong>算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li><p><strong>初始标记：</strong>仅仅只是<strong>标记一下 GC Roots 能直接关联到的对象</strong>，速度很快，<strong>需要停顿</strong>。</p>
</li>
<li><p><strong>并发标记：</strong>进行 <strong>GC Roots Tracing</strong> 的过程，它在整个回收过程中耗时最长，<strong>不需要停顿</strong>。</p>
</li>
<li><p><strong>重新标记：</strong>为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<strong>需要停顿</strong>，时间长于初始标记、短于并发标记。</p>
</li>
<li><p><strong>并发清除：**</strong>不需要停顿**。</p>
</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p><strong>缺点：</strong></p>
<ul>
<li><p><strong>吞吐量低</strong>：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</p>
</li>
<li><p><strong>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。</strong>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老生代快满的时候再回收。<strong>如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure</strong>，这时虚拟机将临时启用 <strong>Serial Old</strong> 来替代 CMS。</p>
</li>
<li><p><strong>标记 - 清除</strong>算法导致的空间碎片，往往出现老生代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</p>
<p>可使用 <code>-XX：+UseCMSCompactAtFullCollection</code> 参数（默认开启）在需要进行 Full GC 时开启内存碎片合并整理过程，该过程无法并发，导致停顿时间变长。</p>
<p>可使用 <code>-XX：CMSFullGCsBeforeCompaction</code> 参数设置执行多少次不压缩的 Full GC 后进行带压缩的 Full GC（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</p>
</li>
</ul>
<h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<ul>
<li>适用于<strong>追求低停顿情况</strong>，不适用于追求吞吐量的情况</li>
</ul>
<ol>
<li><p>G1收集器的特点：</p>
<ol>
<li>并行与并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿</li>
</ol>
</li>
<li>G1收集器化整为零的思路，每个region都有一个Remembered Set区域</li>
<li><p>一共有四个步骤：</p>
<ol>
<li>初始标记（停止用户线程）</li>
<li>并发标记（时间较长，但是可以可用户并发进行）</li>
<li>最终标记（停止用户线程）</li>
<li>筛选回收（停止用户线程）</li>
</ol>
</li>
</ol>
<p>堆被分为新生代和老生代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和老生代一起回收。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105301.png" alt="4cf711a8-7ab2-4152-b85c-d5c226733807.png"></p>
<p><strong>G1 把堆划分成多个大小相等的独立区域</strong>（Region），区大小为 2 的幂，范围为 1M 到 32M，目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p>
<p>新生代和老生代不再物理隔离，仅保留逻辑上的分代概念，每个分区都可能随着 G1 的运行在不同代之间前后切换。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105302.png" alt="9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收，<strong>避免全内存扫描</strong>。这种划分方法带来了很大的灵活性，使得<strong>可预测的停顿时间模型</strong>（软目标）成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个<strong>优先列表</strong>，每次根据允许的收集时间，<strong>优先回收价值最大的 Region</strong>，有计划地避免在整个 Java 堆中进行全区域的垃圾收集，确保在有限时间内获得最高的垃圾收集效率。</p>
<p>每个 Region 都有一个 <strong>Remembered Set</strong>，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105303.png" alt="1557474325452.png"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li><p>初始标记：</p>
<p>标记 GC Roots 能直接关联到的对象并修改 TAMS（Next Top at Mark Set）的值，使下一阶段用户程序并发运行时能在正确可用的 Region 中创建新对象。需要停顿，但耗时很短。</p>
</li>
<li><p>并发标记：</p>
<p>从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象。耗时较长，但可以与用户程序并发执行。</p>
</li>
<li><p>最终标记：</p>
<p>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要<strong>停顿线程</strong>，但是可并行执行。</p>
</li>
<li><p>筛选回收：</p>
<p>首先，对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p>
</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>并行与并发</strong>：利用多个 CPU 缩短停顿时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作， G1 收集器仍然可以通过并发的方式使 Java 程序继续执行。</li>
<li><strong>分代收集</strong>：分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。</li>
<li><strong>空间整合</strong>：整体来看是基于 <strong>“标记 - 整理”</strong> 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 <strong>“复制”</strong> 算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li><strong>可预测的停顿</strong>：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h5 id="CMS-与-G1-整体区别"><a href="#CMS-与-G1-整体区别" class="headerlink" title="CMS 与 G1 整体区别"></a>CMS 与 G1 整体区别</h5><ul>
<li><p>两者都追求最短停顿时间，无法兼顾吞吐量</p>
</li>
<li><p><strong>CMS 使用标记清除算法</strong>实现，会导致空间碎片，提前触发 GC </p>
<p><strong>G1 使用标记整理算法</strong>，不会导致空间碎片</p>
</li>
<li><p>G1 中分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。</p>
<p><strong>CMS 针对理整个老年代进行处理。G1可以回收新生代和老年代</strong></p>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><table>
<thead>
<tr>
<th style="text-align:center">收集器</th>
<th style="text-align:center">定义</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">垃圾算法</th>
<th style="text-align:center">应用场景</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Serial</td>
<td style="text-align:center">最基本、发展历史最长的垃圾收集器</td>
<td style="text-align:center">并发、单线程、高效</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">客户端模式下，虚拟机的新生代区域</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Serial Old</td>
<td style="text-align:center">Serial 收集器应用在老年代区域的版本</td>
<td style="text-align:center">并发、单线程、高效</td>
<td style="text-align:center">标记 - 整理</td>
<td style="text-align:center">客户端模式下，虚拟机的老生代区域</td>
<td style="text-align:center">CMS 的后备预案，失败时使用</td>
</tr>
<tr>
<td style="text-align:center">ParNew</td>
<td style="text-align:center">Serial 收集器的多线程版本</td>
<td style="text-align:center">并发、多线程、性能低于 Serial</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">客户端模式下，虚拟机的新生代区域</td>
<td style="text-align:center">唯一可配合 CMS 工作的收集器</td>
</tr>
<tr>
<td style="text-align:center">Parallel Scavenge</td>
<td style="text-align:center">ParNew 收集器的升级版</td>
<td style="text-align:center">并发、多线程、自适应调节，以达到可控制吞吐量为目标</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">服务器模式下，虚拟机的新生代区域</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Parallel Old</td>
<td style="text-align:center">Parallel Scavenge 收集器应用在老年代区域的版本</td>
<td style="text-align:center">并发、多线程、自适应调节，以达到可控制吞吐量为目标</td>
<td style="text-align:center">标记 - 整理</td>
<td style="text-align:center">服务器模式下，虚拟机的老生代区域</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CMS</td>
<td style="text-align:center">基于<strong>标记 - 清除</strong>算法的收集器</td>
<td style="text-align:center">并行、单线程、垃圾收集停顿时间短，总吞吐量低，无法处理浮动垃圾，产生空间碎片</td>
<td style="text-align:center">标记 - 清除</td>
<td style="text-align:center">重视应用的响应速度、希望系统停顿时间最短的场景（如老年代）</td>
<td style="text-align:center">初始标记、并发标记、重新标记、并发清除、</td>
</tr>
<tr>
<td style="text-align:center">G1</td>
<td style="text-align:center">最新、技术最前沿的收集器</td>
<td style="text-align:center">并行、多线程、垃圾回收效率高（可预测的停顿时间模型），分代收集、无空间碎片</td>
<td style="text-align:center">新生代：复制、老生代：标记 - 整理</td>
<td style="text-align:center">服务器端虚拟机的内存区域（含新生代与老生代）</td>
<td style="text-align:center">初始标记、并发标记、最终标记、筛选回收、</td>
</tr>
</tbody>
</table>
<h5 id="组合选择"><a href="#组合选择" class="headerlink" title="组合选择"></a>组合选择</h5><ul>
<li><p><strong>单 CPU 或小内存，单机程序：</strong></p>
<p><strong>-XX:+UseSerialGC：</strong>新生代 Serial + 复制，老生代 SerialOld + 标记整理</p>
</li>
<li><p><strong>多 CPU，需要最大吞吐量，如后台计算型应用：</strong></p>
<p><strong>-XX:+UseParallelGC：</strong>新生代 Parallel + 复制，老生代 ParallelOld + 标记整理</p>
<p><strong>-XX:+UseParallelOldGC：</strong>同上</p>
</li>
<li><p><strong>多 CPU，追求低停顿时间，需要快速响应如互联网应用</strong></p>
<p><strong>-XX:+UseConcMarkSweepGC：</strong>新生代 ParNew + 复制，老生代 CMS +SerialOld 的收集器组合 + 标记清除</p>
<p><strong>-XX:+UseG1GC：</strong>整体采用标记整理，局部使用复制，不会产生碎片</p>
</li>
</ul>
<h4 id="Java-类加载机制"><a href="#Java-类加载机制" class="headerlink" title="Java 类加载机制"></a>Java 类加载机制</h4><h5 id="Class文件字节码结构组织示意图"><a href="#Class文件字节码结构组织示意图" class="headerlink" title="Class文件字节码结构组织示意图"></a>Class文件字节码结构组织示意图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; //Class 文件的标志</span><br><span class="line">    u2             minor_version;//Class 的小版本号</span><br><span class="line">    u2             major_version;//Class 的大版本号</span><br><span class="line">    u2             constant_pool_count;//常量池的数量</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];//常量池</span><br><span class="line">    u2             access_flags;//Class 的访问标记</span><br><span class="line">    u2             this_class;//当前类</span><br><span class="line">    u2             super_class;//父类</span><br><span class="line">    u2             interfaces_count;//接口</span><br><span class="line">    u2             interfaces[interfaces_count];//一个类可以实现多个接口</span><br><span class="line">    u2             fields_count;//Class 文件的字段属性</span><br><span class="line">    field_info     fields[fields_count];//一个类会可以有个字段</span><br><span class="line">    u2             methods_count;//Class 文件的方法数量</span><br><span class="line">    method_info    methods[methods_count];//一个类可以有个多个方法</span><br><span class="line">    u2             attributes_count;//此类的属性表中的属性数</span><br><span class="line">    attribute_info attributes[attributes_count];//属性表集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105304.png" alt="类文件字节码结构组织示意图"></p>
<h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105305.png" alt="image-20210307214358957"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">加载</span><br><span class="line">    1. 通过一个类的全限名来获取定义此类的二进制节流。（实现这个代码模块就是类加载器）</span><br><span class="line">    2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</span><br><span class="line">    3. 在内存中生成一个代表这个类的 java.lang.Class 对象,作为方法区这个类的各种数据的访问入口。</span><br><span class="line">验证</span><br><span class="line">    文件格式验证</span><br><span class="line">    – [x] 是否以魔数 0xCAFEBABE 开头</span><br><span class="line">    – [x] 主次版本号是否在当前虚拟机处理范围之内</span><br><span class="line">    – [x] 常量池中的常量是否有不被支持的常量类型</span><br><span class="line">    – [x] 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</span><br><span class="line">    – [x] CONSTANTUtf8info 型的常量中是否有不符合 UTF8 编码的数据</span><br><span class="line">    – [x] Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息</span><br><span class="line">    – [x] 等等</span><br><span class="line">    元数据验证</span><br><span class="line">    – [x] 这个类是否有父类</span><br><span class="line">    – [x] 这个类的父类是否继承了不准许被继承的类</span><br><span class="line">    – [x] 如果这个类不是抽象类,是否实现了其父类或者接口之中要求实现的所有方法</span><br><span class="line">    – [x] 类中的字段方法是否与父类产生矛盾</span><br><span class="line">    –</span><br><span class="line">    字节码验证</span><br><span class="line">    – [x] 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</span><br><span class="line">    – [x] 保证跳转指令不会跳转到方法体以外的字节码指令上</span><br><span class="line">    – [x] 保证方法体重的类型转换是有效的</span><br><span class="line">    符号引用验证</span><br><span class="line">    – [x] 符号引用中通过字符串描述的全限定名是否找到相应的类</span><br><span class="line">    – [x] 在指定的类中是否存在符合方法的字段描述符以及简单名称说描述的方法和字段</span><br><span class="line">    – [x] 符号引用中的类、字段、方法的访问性是否被当前类访问</span><br><span class="line">准备</span><br><span class="line">    准备阶段是正式为类变量分配内存并设置类变量初始值(被static修饰的变量)的阶段,这些变</span><br><span class="line">    量所使用的内存都将在方法区中进行分配</span><br><span class="line">解析</span><br><span class="line">	解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程</span><br><span class="line">初始化</span><br><span class="line">	初始化就是执行类构造器方法的过程</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">说说类加载的过程</span><br><span class="line">类加载分三个阶段，加载、连接和初始化，其中连接阶段分为验证、准备和解析。</span><br><span class="line">1 加载主要是加载二进制字节流，比如Class文件，在方法区中生成Class对象</span><br><span class="line">2 验证阶段是确保Class文件中的字节流包含的信息是否符合《Java虚拟机规范》的全部约束要求，保证这些信息不会危害虚拟机的安全</span><br><span class="line">（有文件格式验证、元数据验证、字节码验证、符号引用验证，我面试从没被问过具体的这几个阶段）</span><br><span class="line">3 准备阶段是为类中定义的变量（静态变量）分配内存并设置变量的初始值，但是有一种特殊情况，被final修饰的话，则会直接赋值为我们要指定的值（初始值！就是0，false，null那种，初始化阶段才是我们程序员写的值，谨记）</span><br><span class="line">4 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，有类和接口的解析，字段解析、方法解析和接口方法解析（符号引用是以一组符号来描述所引用的目标，它是编译原理方面的概念，有被模块到处或者开放的包，类和接口的全限定名，字段的名称和描述符，方法的名称和描述符，方法的句柄和方法类型，动态调用点和动态常量 《深入理解JVM 》 p218；直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄）</span><br><span class="line">5 初始化阶段是类加载的最后一个步骤，它会收集所有为类变量赋值和静态语句块中的语句，为这些静态变量赋值</span><br></pre></td></tr></table></figure>
<h5 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h5><p><strong>避免重复加载 + 避免核心类篡改</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105306.png" alt="image-20210307214738509"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105307.png" alt="image-20210307214648663"></p>
<h4 id="JVM对锁的优化"><a href="#JVM对锁的优化" class="headerlink" title="JVM对锁的优化"></a>JVM对锁的优化</h4><ul>
<li>自旋锁与自适应自旋：互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，如果我们可以通过上后面请求锁的线程自旋一会儿，那么将会避免线程切换的开销，但是它还是要占用处理器时间的，如果自旋时间很短的话，它的效果很好，否则长时间的自旋只会白白的浪费处理器时间，自旋的默认值是10次；自适应自旋意味着自旋次数不再是固定的了，而是由前一个在同一个锁上的自旋时间及锁的拥有者的状态来决定的，如果很可能获得到锁，那么将自旋等待的次数增多，否则直接省略掉自旋过程，进入阻塞状态，避免浪费处理器资源 </li>
<li>锁消除：对被检测到不可能存在共享数据竞争的锁进行消除</li>
<li>锁粗化：如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，虚拟机将会把同步锁的范围扩大到整个操作序列的外部，比如上例中，加锁到第一个append操作，解锁到最后一个append结束 </li>
<li>轻量级锁：是通过MarkWord来实现的，在进入同步块的时候，虚拟机会在当前线程的栈帧空开辟出锁记录的空间，用来存储锁对象的MarkWord的拷贝，加锁操作是使用一次CAS操作把对象的MarkWord更新为指向锁记录的指针，解锁操作也是通过一次CAS操作实现的，把复制到锁记录空间的MarkWord替换回来；但是轻量级锁不能发生竞争，如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效了，必须要膨胀为重量级锁 </li>
<li>偏向锁：在无竞争的情况下把整个同步都消除掉，连CAS操作都省去了，（偏就是偏袒的意思，会偏向第一个获取到它的线程，如果在接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不再需要进行同步），当锁对象第一次被线程获取的时候，通过CAS操作把获取到这个锁的线程ID记录到对象的MarkWord中，CAS成功的话，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都不会再进行任何同步操作，一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式立刻宣告结束。<br>当对象进入偏向状态的时候，MarkWord大部分空间都用于存储持有锁的线程ID了，若计算一次哈希值后，就需要在该位置存储哈希值，而不能再进入偏向锁模式了，而当一个对象处于偏向锁模式，又收到了需要计算其一致性哈希值的请求，它的偏向模式会理解被撤销，并且锁会膨胀为重量级锁</li>
</ul>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105308.png" alt="image-20210307214840464"></p>
<h5 id="jstat-jmap-jps-jinfo-jconsole查看内存"><a href="#jstat-jmap-jps-jinfo-jconsole查看内存" class="headerlink" title="jstat jmap jps jinfo jconsole查看内存"></a>jstat jmap jps jinfo jconsole查看内存</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105309.png" alt="image-20210308100816201"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105310.png" alt="image-20210307215245377"></p>
<h5 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-Xmx3550m：设置 JVM 最大堆内存为 3550M。</span><br><span class="line">-Xms3550m：设置 JVM 初始堆内存为 3550M。此值可以设置与-Xmx 相同，以避免每次垃</span><br><span class="line">圾回收完成后 JVM 重新分配内存。</span><br><span class="line">-Xss128k：设置每个线程的栈大小。JDK5.0 以后每个线程栈大小为 1M，之前每个线程栈</span><br><span class="line">大小为 256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个</span><br><span class="line">值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，</span><br><span class="line">经验值在 3000~5000 左右。需要注意的是：当这个值被设置的较大（例如&gt;2MB）时将会</span><br><span class="line">在很大程度上降低系统的性能。</span><br><span class="line">-Xmn2g：设置年轻代大小为 2G。在整个堆内存大小确定的情况下，增大年轻代将会减小</span><br><span class="line">年老代，反之亦然。此值关系到 JVM 垃圾回收，对系统性能影响较大，官方推荐配置为整</span><br><span class="line">个堆大小的 3/8。</span><br><span class="line">-XX:NewSize=1024m：设置年轻代初始值为 1024M。</span><br><span class="line">-XX:MaxNewSize=1024m：设置年轻代最大值为 1024M。</span><br><span class="line">-XX:PermSize=256m：设置持久代初始值为 256M。</span><br><span class="line">-XX:MaxPermSize=256m：设置持久代最大值为 256M。</span><br><span class="line">-XX:NewRatio=4：设置年轻代（包括 1 个 Eden 和 2 个 Survivor 区）与年老代的比值。表</span><br><span class="line">示年轻代比年老代为 1:4。</span><br><span class="line">-XX:SurvivorRatio=4：设置年轻代中 Eden 区与 Survivor 区的比值。表示 2 个 Survivor 区</span><br><span class="line">（JVM 堆内存年轻代中默认有 2 个大小相等的 Survivor 区）与 1 个 Eden 区的比值为 2:4，</span><br><span class="line">即 1 个 Survivor 区占整个年轻代大小的 1/6。</span><br><span class="line">-XX:MaxTenuringThreshold=7：表示一个对象如果在 Survivor 区（救助空间）移动了 7 次</span><br><span class="line">还没有被垃圾回收就进入年老代。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，</span><br><span class="line">直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为</span><br><span class="line">一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象在年轻代存</span><br><span class="line">活时间，增加对象在年轻代被垃圾回收的概率，减少 Full GC 的频率，这样做可以在某种程</span><br><span class="line">度上提高服务稳定性。</span><br><span class="line">-XX:PretenureSizeThreshold 直接晋升到老年代的对象大小，设置这个参数后，大于这个参</span><br><span class="line">数的对象将直接在老年代分配。</span><br><span class="line">-XX：MaxTenuringThreshold 每次 minorGC 就增加一次，超过这个值，在 from 中的对象直</span><br><span class="line">接进入到老年代</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105311.png" alt="image-20210307215333634"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105312.png" alt="image-20210307215341119"></p>
<h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h3><!--more-->
<h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105115.png" alt="image-20210307201619086"></p>
<p><strong>volatile保证内存可见性</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105116.png" alt="image-20210307201753855"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105117.png" alt="image-20210307201844818"></p>
<h4 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105118.png" alt="image-20210307203345273"></p>
<h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>乐观锁的实现中通常都会用版本戳version来对记录或对象标记，避免并发操作带来的问题，在Java中AtomicStampedReference<e>也实现了这个作用，它通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题</e></p>
<p>AtomicInteger实现原理：CAS操作volatile变量value</p>
<h5 id="循环时间长开销大。"><a href="#循环时间长开销大。" class="headerlink" title="循环时间长开销大。"></a>循环时间长开销大。</h5><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h5 id="只能保证一个共享变量的原子操作。"><a href="#只能保证一个共享变量的原子操作。" class="headerlink" title="只能保证一个共享变量的原子操作。"></a>只能保证一个共享变量的原子操作。</h5><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作</p>
<h4 id="Synchronized-原理"><a href="#Synchronized-原理" class="headerlink" title="Synchronized 原理"></a>Synchronized 原理</h4><p>synchronized 关键字解决的是多个线程之间访问资源的<strong>同步性</strong>， synchronized 关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有<strong>⼀个线程执⾏</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</span><br><span class="line">修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</span><br><span class="line">修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105119.png" alt="image-20210307202329448"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105120.png" alt="image-20210307202619317"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105121.png" alt="image-20210307202650741"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Contention List：所有请求锁的线程将被首先放置到该竞争队列</span><br><span class="line"> Entry List：Contention List 中那些有资格成为候选人的线程被移到 Entry List</span><br><span class="line"> Wait Set：那些调用 wait 方法被阻塞的线程被放置到 Wait Set</span><br><span class="line"> OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为 OnDeck</span><br><span class="line"> Owner：获得锁的线程称为 Owner</span><br><span class="line"> !Owner：释放锁的线程</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105122.png" alt="image-20210307202749923"></p>
<p>新请求锁的线程将首先被加入到ConetentionList中，当某个拥有锁的线程（Owner状态）调用unlock之后，如果发现EntryList为空则从ContentionList中移动线程到EntryList，下面说明下ContentionList和EntryList的实现方式：<br> <strong>ContentionList虚拟队列</strong><br>ContentionList并不是一个真正的Queue，而只是一个虚拟队列，原因在于ContentionList是由Node及其next指针逻辑构成，并不存在一个Queue的数据结构。ContentionList是一个后进先出（LIFO）的队列，每次新加入Node时都会在队头进行，通过CAS改变第一个节点的的指针为新增节点，同时设置新增节点的next指向后续节点，而取得操作则发生在队尾。显然，该结构其实是个Lock-Free的队列。</p>
<p>因为只有Owner线程才能从队尾取元素，也即线程出列操作无争用，当然也就避免了CAS的ABA问题。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105123.png" alt="image-20210307203933268"></p>
<p><strong>EntryList</strong><br>EntryList与ContentionList逻辑上同属等待队列，ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立EntryList。Owner线程在unlock时会从ContentionList中迁移线程到EntryList，并会指定EntryList中的某个线程（一般为Head）为Ready（OnDeck）线程。Owner线程并不是把锁传递给OnDeck线程，只是把竞争锁的权利交给OnDeck，OnDeck线程需要重新竞争锁。这样做虽然牺牲了一定的公平性，但极大的提高了整体吞吐量，在Hotspot中把OnDeck的选择行为称之为“竞争切换”。</p>
<p>OnDeck线程获得锁后即变为owner线程，无法获得锁则会依然留在EntryList中，考虑到公平性，在EntryList中的位置不发生变化（依然在队头）。如果Owner线程被wait方法阻塞，则转移到WaitSet队列；如果在某个时刻被notify/notifyAll唤醒，则再次转移到EntryList。</p>
<h5 id="双检锁实现单例（线程安全）"><a href="#双检锁实现单例（线程安全）" class="headerlink" title="双检锁实现单例（线程安全）"></a>双检锁实现单例（线程安全）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对synchronized的优化-偏向锁、轻量级锁、自旋锁和重量级锁"><a href="#对synchronized的优化-偏向锁、轻量级锁、自旋锁和重量级锁" class="headerlink" title="对synchronized的优化,偏向锁、轻量级锁、自旋锁和重量级锁"></a>对synchronized的优化,偏向锁、轻量级锁、自旋锁和重量级锁</h5><p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</p>
<p>synchronized锁膨胀过程：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105124" alt="img"></p>
<p><strong>偏向锁</strong><br>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了<strong>减少同一线程获取锁</strong>(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么<strong>锁就进入偏向模式</strong>，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p>
<p><strong>轻量级锁</strong><br>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p>
<p><strong>自旋锁</strong><br>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程<strong>做几个空循环</strong>(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p>
<p><strong>锁消除</strong><br>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，<strong>去除不可能存在共享资源竞争的锁</strong>，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p>
<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105125.png" alt="image-20210307205200297"></p>
<h5 id="Volatile-与-synchronized-区别"><a href="#Volatile-与-synchronized-区别" class="headerlink" title="Volatile 与 synchronized 区别"></a>Volatile 与 synchronized 区别</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105126.png" alt="image-20210307201608665"></p>
<h5 id="ReentrantLock-和-synchronized-区别"><a href="#ReentrantLock-和-synchronized-区别" class="headerlink" title="ReentrantLock 和 synchronized 区别"></a>ReentrantLock 和 synchronized 区别</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105127.png" alt="image-20210307205249993"></p>
<h4 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h4><p><strong>AQS原理</strong><br>AQS：AbstractQuenedSynchronizer抽象的队列式同步器。这个类在java.util.concurrent.locks包，AQS 是⼀个⽤来<strong>构建锁和同步器的框架</strong>，使⽤ AQS 能<strong>简单且⾼效地构造同步器</strong>。  ReentrantLock ， Semaphore ，其他的诸如 ReentrantReadWriteLock ， SynchronousQueue ， FutureTask 等等皆是基于 AQS 的。当然，我们⾃⼰也能利⽤ AQS ⾮常轻松容易地构造出符合我们⾃⼰需求的同步器。</p>
<p>使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p>
<p>同步器简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</p>
<p><strong>AQS的核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。<br>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p>
<p>AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS完成对status值的修改(0表示没有,1表示阻塞)，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>
<p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p>
<p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105128.png" alt="img"></p>
<p>AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：<br>getState();setState();compareAndSetState();</p>
<p>AQS 定义了两种资源共享方式：<br>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p>
<p>不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">- tryAcquire(<span class="keyword">int</span>)：独占方式。尝试获取资源，成功则返回<span class="keyword">true</span>，失败则返回<span class="keyword">false</span>。</span><br><span class="line">- tryRelease(<span class="keyword">int</span>)：独占方式。尝试释放资源，成功则返回<span class="keyword">true</span>，失败则返回<span class="keyword">false</span>。</span><br><span class="line">- tryAcquireShared(<span class="keyword">int</span>)：共享方式。尝试获取资源。负数表示失败；<span class="number">0</span>表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">- tryReleaseShared(<span class="keyword">int</span>)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回<span class="keyword">true</span>，否则返回<span class="keyword">false</span>。</span><br></pre></td></tr></table></figure>
<p>　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<p><strong>AQS 组件总结</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105129.png" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">7.1.1 CountDownLatch</span><br><span class="line">    这个类是一个同步计数器，主要用于线程间的控制，当 CountDownLatch 的 count 计数&gt;0 时，</span><br><span class="line">    await()会造成阻塞，直到 count 变为 0，await()结束阻塞，使用 countDown()会让 count 减 1。</span><br><span class="line">    CountDownLatch 的构造函数可以设置 count 值，当 count=1 时，它的作用类似于 wait()和 notify()</span><br><span class="line">    的作用。如果我想让其他线程执行完指定程序，其他所有程序都执行结束后我再执行，这时可以用</span><br><span class="line">    CountDownLatch，但计数无法被重置，如果需要重置计数，请考虑使用 CyclicBarrier 。</span><br><span class="line">7.1.2 CyclicBarrier</span><br><span class="line">    该类从字面理解为循环屏障，它可以协同多个线程，让多个线程在这个屏障前等到，直到所有</span><br><span class="line">    线程都到达了这个屏障时，再一起执行后面的操作。假如每个线程各有一个 await，任何一个线程运</span><br><span class="line">    行到 await 方法时就阻塞，直到最后一个线程运行到 await 时才同时返回。和之前的 CountDownLatch</span><br><span class="line">    相比，它只有 await 方法，而 CountDownLatch 是使用 countDown()方法将计数器减到 0，它创建的</span><br><span class="line">    参数就是 countDown 的数量；CyclicBarrier 创建时的 int 参数是 await 的数量。</span><br><span class="line">7.1.3 Semaphore</span><br><span class="line">    该类用于控制信号量的个数，构造时传入个数。总数就是控制并发的数量。假如是 5，程序执</span><br><span class="line">    行前用 acquire()方法获得信号，则可用信号变为 4，程序执行完通过 release()方法归还信号量，可用</span><br><span class="line">    信号又变为 5.如果可用信号为 0，acquire 就会造成阻塞，等待 release 释放信号。acquire 和 release</span><br><span class="line">    方法可以不在同一个线程使用。Semaphore 实现的功能就类似厕所有 5 个坑，假如有 10 个人要上厕</span><br><span class="line">    所，那么同时只能有多少个人去上厕所呢？同时只能有 5 个人能够占用，当 5 个人中 的任何一个人</span><br><span class="line">    让开后，其中等待的另外 5 个人中又有一个人可以占用了。另外等待的 5 个人中可以是随机获得优先</span><br><span class="line">    机会，也可以是按照先来后到的顺序获得机会，这取决于构造 Semaphore 对象时传入的参数选项。</span><br><span class="line">    单个信号量的 Semaphore 对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另</span><br><span class="line">    一个线程释放“锁”，这可应用于死锁恢复的一些场合。</span><br><span class="line">7.1.4 Exchanger</span><br><span class="line">    这个类用于交换数据，只能用于两个线程。当一个线程运行到 exchange()方法时会阻塞，另一</span><br><span class="line">    个线程运行到 exchange()时，二者交换数据，然后执行后面的程</span><br></pre></td></tr></table></figure>
<h4 id="重入锁实现"><a href="#重入锁实现" class="headerlink" title="重入锁实现"></a>重入锁实现</h4><p>三要素：</p>
<ul>
<li>原子状态。使用CAS操作获取和更改锁状态。</li>
<li>等待队列。</li>
<li>阻塞原语park()和unpark()。LockSupport</li>
</ul>
<p><strong>LockSupport的park()和unpark()</strong></p>
<p>线程挂起和恢复，类似于suspend()和resume()。</p>
<p>但是suspend()和resume()操作必须保证suspend()操作在resume()之前，否则会发生线程永久性挂起的情况。</p>
<p>LockSupport的park()和unpark()不会发生这种情况。</p>
<p>这是因为LockSupport类使用类似信号量的机制。它为每个线程准备一个许可，若许可可用，那么park()函数会立即返回，并且消费这个许可(将许可变为不可用)，如果许可不可用，则阻塞。unpark()使许可变为可用。</p>
<p>LockSupport的park()支持中断响应，但不是抛出InterruptedException异常，只是默默返回，但仍可以从Thread.interruptd()方法获得中断标记。</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock是基于AQS实现的，这在下面会讲到，AQS的基础又是CAS<br>ReentrantLock的静态内部类Sync实现了抽象类AQS（AbstractQueuedSynchronizer），其中有一个重要的字段是state，它在ReentrantLock中代表的是重入次数，为0是代表锁没有被任何线程持有，为1是被一个线程持有，每重入一次，state加一，每执行一次unlock方法，state减一；而ReentrantLock的公平锁和非公平锁机制是通过AQS中的队列来实现的，若是公平锁的话，每有一个线程想要获取这个锁，需要进入队列排队，而且不能插队，若是非公平锁的话，队列中的线程是可以插队的</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105130.png" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock()：获取锁，如果锁被暂用则一直等待</span><br><span class="line">unlock():释放锁</span><br><span class="line">tryLock(): 注意返回类型是 boolean，如果获取锁的时候锁被占用就返回 false，</span><br><span class="line">否则返回 true</span><br><span class="line">tryLock(long time, TimeUnit unit)：比起 tryLock()就是给了一个时间期限，保</span><br><span class="line">证等待参数时间</span><br><span class="line">lockInterruptibly()：用该锁的获得方式，如果线程在获取锁的阶段进入了等待，</span><br><span class="line">那么可以中断此线程，先去做别的事</span><br></pre></td></tr></table></figure>
<p>线程1独占了锁。然后线程2也要尝试获取同一个锁，在线程1没有释放锁的情况下必然是行不通的，所以线程2就要阻塞。那么，线程2如何被阻塞？看下线程2的方法调用链，这就比较复杂了：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105131.png" alt="img"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105132.png" alt="img"></p>
<h4 id="JUC包"><a href="#JUC包" class="headerlink" title="JUC包"></a>JUC包</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105133.png" alt="image-20210307220702101"></p>
<h4 id="Threadlocal"><a href="#Threadlocal" class="headerlink" title="Threadlocal"></a>Threadlocal</h4><p>每个Thread中都有一个ThreadLocalMap对象，而ThreadLocalMap中存储的是多个ThreadLocal对象，其中ThreadLocalMap中的<code>key</code>为ThreadLocal对象，<code>value</code>为ThreadLocal中是我们要存储的值</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105134.png" alt="image-20210305210233334"></p>
<p><strong>ThreadLocal 内存泄露问题</strong></p>
<p>ThreadLocalMap 中使⽤的 key 为  ThreadLocal 的<strong>弱引⽤</strong>,⽽ value 是强引⽤。所以，如果ThreadLocal 没有被外部强引⽤的情况下，在垃圾回收的时候，key 会被清理掉，⽽ value 不会被清理掉。这样⼀来， ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，<strong>value 永远⽆法被 GC 回收</strong>，这个时候就可能会产⽣内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调⽤  set() 、 get() 、 remove() ⽅法的时候，会<strong>清理掉 key 为 null</strong>的记录。使⽤完  ThreadLocal ⽅法后 最好⼿动调⽤ remove() ⽅法</p>
<h4 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h4><h5 id="创建线程方法"><a href="#创建线程方法" class="headerlink" title="创建线程方法"></a>创建线程方法</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105135.png" alt="image-20210307205718007"></p>
<h5 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105136.png" alt="这里写图片描述"></p>
<h5 id="线程、进程与程序的区别"><a href="#线程、进程与程序的区别" class="headerlink" title="线程、进程与程序的区别"></a>线程、进程与程序的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）</span><br><span class="line">一个程序运行后至少有一个进程，一个进程中可以包含多个线程 。</span><br><span class="line">2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。</span><br><span class="line"> 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</span><br><span class="line">3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC（Inter-Process Communication，进程间通信）)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</span><br><span class="line">4、但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</span><br><span class="line">5、同步方式不同：进程：无名管道、有名管道、信号、共享内存、消息队列、信号量</span><br><span class="line">线程：互斥量、读写锁、自旋锁、线程信号、条件变量</span><br><span class="line">6、进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换</span><br></pre></td></tr></table></figure>
<h5 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105137.png" alt="image-20210308095252651"></p>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105138.png" alt="image-20210307210611167"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210417163437.png" alt="image-20210417163430983"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</span><br><span class="line">当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行</span><br><span class="line">当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务</span><br><span class="line">当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理</span><br><span class="line">当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，释放空闲线程</span><br><span class="line">当设置allowCoreThreadTimeOut(true)时，该参数默认false，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">场景1：快速响应用户请求</span><br><span class="line">场景2：快速处理批量任务</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//CPU密集型,设置最大线程数为：CPU核数</span></span><br><span class="line">        Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="comment">//IO密集型，根据io任务的线程数来规定最大线程数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//核心线程数</span></span><br><span class="line">        <span class="comment">//最大线程数，线程池的伸缩性，达到开启条件后，才会不断开启</span></span><br><span class="line">        <span class="comment">//开启条件：当阻塞队列是ArrayBlockingQueue的时候，核心线程全部都处于工作状态，↓</span></span><br><span class="line">        <span class="comment">//且阻塞队列已经被任务塞满了，那么再来新的任务请求，便会开启新的线程</span></span><br><span class="line">        <span class="comment">//若是LinkedBlockingQueue的话，它会不断的存储任务，永远都不会向最大线程数进行线程的扩展！！！</span></span><br><span class="line">        <span class="comment">//活跃时间和活跃时间的单位，当线程的空闲时间超过活跃时间，线程就会被回收</span></span><br><span class="line">        <span class="comment">//阻塞队列：全部核心线程处于忙碌状态，新来的任务放在阻塞队列中</span></span><br><span class="line">        <span class="comment">// 最大承载：队列大小（如果是ArrayBlockingQueue的话）+最大的线程数</span></span><br><span class="line">        <span class="comment">//线程工厂，用于创建线程</span></span><br><span class="line">        <span class="comment">//拒绝策略:AbortPolicy:超过最大承载的话，会发生异常RejectedExecutionException</span></span><br><span class="line">        <span class="comment">//CallerRunsPolicy:哪来的去哪里执行，这里安排不了了</span></span><br><span class="line">        <span class="comment">//DiscardPolicy():多的任务都给我扔了，不执行！</span></span><br><span class="line">        <span class="comment">//DiscardOldestPolicy():将最早执行的任务停止掉，来执行新来的任务</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" ok "</span> + finalI);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池的作用：统一管理线程，实现线程的复用，更好的利用系统资源</span></span><br><span class="line">        <span class="comment">//四大方法，单个线程的池子；固定线程数的池子；自由伸缩的池子；执行定时任务的池子</span></span><br><span class="line">        <span class="comment">//前两个的阻塞队列为LinkedBlockingQueue</span></span><br><span class="line">        <span class="comment">//CachedThreadPool的阻塞队列为SynchronousQueue</span></span><br><span class="line">        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">            cachedThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭别忘了</span></span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 线程池的五种状态</span></span><br><span class="line">        <span class="comment">//RUNNING 接收新任务并处理排队中的任务</span></span><br><span class="line">        <span class="comment">//SHUTDOWN 不接受新任务，处理剩下的任务</span></span><br><span class="line">        <span class="comment">//STOP 不再接收新任务，不处理剩下的任务</span></span><br><span class="line">        <span class="comment">//TIDYING 所与线程都执行完了</span></span><br><span class="line">        <span class="comment">//TERMINATED 线程池终止了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 线程池的执行流程</span></span><br><span class="line">        <span class="comment">//1. 如果要执行的线程小于核心线程数的话，开启核心线程，直接执行</span></span><br><span class="line">        <span class="comment">//2. 如果大于核心线程数的话，将进程放入阻塞队列中进行排队</span></span><br><span class="line">        <span class="comment">//3. 如果队列中满了话，会开启临时线程执行线程任务</span></span><br><span class="line">        <span class="comment">//4. 如果线程任务超过最大的阈值，也就是大于最大线程数+阻塞队列的值的话，就会采用拒绝策略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否停止了</span></span><br><span class="line">        cachedThreadPool.isTerminated();</span><br><span class="line">        <span class="comment">//等待3秒后再进行判断</span></span><br><span class="line">        cachedThreadPool.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        cachedThreadPool.execute( () -&gt; System.out.println(<span class="string">"在shutDown之后，将不再能继续执行任务"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//强制的立即结束</span></span><br><span class="line">        fixedThreadPool.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4种类型的线程池"><a href="#4种类型的线程池" class="headerlink" title="4种类型的线程池"></a>4种类型的线程池</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506110557.webp" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new FixedThreadPool()</span><br><span class="line">说明：初始化一个指定线程数的线程池，其中 corePoolSize == maxiPoolSize，使用 LinkedBlockingQuene 作为阻塞队列</span><br><span class="line">特点：即使当线程池没有可执行任务时，也不会释放线程。</span><br><span class="line">new CachedThreadPool()</span><br><span class="line">说明：初始化一个可以缓存线程的线程池，默认缓存 60s，线程池的线程数可达到 Integer.MAX_VALUE，即 2147483647，内部使用 SynchronousQueue 作为阻塞队列；</span><br><span class="line">特点：在没有任务执行时，当线程的空闲时间超过 keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；</span><br><span class="line">因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。</span><br><span class="line">new SingleThreadExecutor()</span><br><span class="line">说明：初始化只有一个线程的线程池，内部使用 LinkedBlockingQueue 作为阻塞队列。</span><br><span class="line">特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行</span><br><span class="line">new ScheduledThreadPool()</span><br><span class="line">特定：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据</span><br></pre></td></tr></table></figure>
<h5 id="线程池基本参数"><a href="#线程池基本参数" class="headerlink" title="线程池基本参数"></a>线程池基本参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</span><br><span class="line"></span><br><span class="line">2、maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</span><br><span class="line"></span><br><span class="line">3、keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</span><br><span class="line"></span><br><span class="line">4、workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</span><br><span class="line"></span><br><span class="line">5、threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</span><br><span class="line"></span><br><span class="line">5、handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</span><br><span class="line">    AbortPolicy：直接抛出异常。</span><br><span class="line">    CallerRunsPolicy：只用调用者所在线程来运行任务。</span><br><span class="line">    DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</span><br><span class="line">    DiscardPolicy：不处理，丢弃掉。</span><br><span class="line">    可根据应用场景来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</span><br></pre></td></tr></table></figure>
<h5 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506105010.png" alt="img"></p>
<p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。</p>
<p>AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506105108.jpeg" alt="img"></p>
<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506111742.jpeg" alt="img"></p>
<h5 id="submit-和-execute"><a href="#submit-和-execute" class="headerlink" title="submit() 和 execute()"></a>submit() 和 execute()</h5><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>
<p><strong>线程池状态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUNNING 自然是运行状态，指可以接受任务执行队列里的任务</span><br><span class="line">SHUTDOWN 指调用了 shutdown() 方法，不再接受新任务了，但是队列里的任务得执行完毕。</span><br><span class="line">STOP 指调用了 <span class="function">s <span class="title">hutdownNow</span><span class="params">()</span> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</span></span><br><span class="line"><span class="function">TIDYING 所有任务都执行完毕，在调用 <span class="title">shutdown</span><span class="params">()</span>/<span class="title">shutdownNow</span><span class="params">()</span> 中都会尝试更新为这个状态。</span></span><br><span class="line"><span class="function">TERMINATED 终止状态，当执行 <span class="title">terminated</span><span class="params">()</span> 后会更新为这个状态</span></span><br></pre></td></tr></table></figure>
<h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105140.png" alt="image-20210308095421429"></p>
<h5 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105141.png" alt="image-20210307210152075"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105142.png" alt="image-20210308095513173"></p>
<h5 id="多线程共用一个数据变量"><a href="#多线程共用一个数据变量" class="headerlink" title="多线程共用一个数据变量"></a>多线程共用一个数据变量</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105143.png" alt="image-20210307210445922"></p>
<h5 id="一般线程和守护线程的区别"><a href="#一般线程和守护线程的区别" class="headerlink" title="一般线程和守护线程的区别"></a>一般线程和守护线程的区别</h5><p>所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如<strong>垃圾回收线程</strong>就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止</p>
<h5 id="Sleep与wait"><a href="#Sleep与wait" class="headerlink" title="Sleep与wait"></a>Sleep与wait</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105144.png" alt="image-20210307205958565"></p>
<h5 id="yield-join-notify-notifyAll"><a href="#yield-join-notify-notifyAll" class="headerlink" title="yield join notify notifyAll"></a>yield join notify notifyAll</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105145.png" alt="image-20210307210025423"></p>
<h5 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105146.png" alt="image-20210307210233243"></p>
<h5 id="多线程抛异常"><a href="#多线程抛异常" class="headerlink" title="多线程抛异常"></a>多线程抛异常</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105147.png" alt="image-20210307210810526"></p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h4><h5 id="常用操作数据库的命令"><a href="#常用操作数据库的命令" class="headerlink" title="常用操作数据库的命令"></a>常用操作数据库的命令</h5><!--more-->
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>; 查看所有的数据库</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>; 创建一个叫test的数据库</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">test</span>;删除一个叫test的数据库</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; 在选中的数据库之中查看所有的表</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;选中库 ,在建表之前必须要选择数据库</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名; 删除表</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名;清空表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (字段<span class="number">1</span> 类型, 字段<span class="number">2</span> 类型 <span class="keyword">not</span> <span class="literal">null</span>，primary <span class="keyword">key</span>(字段<span class="number">1</span>),<span class="keyword">foreign</span> <span class="keyword">key</span>(字段<span class="number">2</span>) <span class="keyword">references</span> 表<span class="number">2</span>[<span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>],<span class="keyword">check</span>(字段<span class="number">1</span>&gt;<span class="number">0</span>));创建表</span><br><span class="line">default 0;默认值</span><br><span class="line">desc 表名;查看所在的表的字段</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名; 查看创建表的详细信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">databases</span> 库名;查看创建库的详细信息</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105510.png" alt="image-20210414105457070"></p>
<h5 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105511.png" alt="image-20200223175524201"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date &apos;2001-04-25&apos;</span><br><span class="line">time &apos;09:30:00&apos;</span><br><span class="line">timestamp &apos;2001-04-25 10:29:01.45&apos;</span><br></pre></td></tr></table></figure>
<h5 id="改表-：DDL-数据定义语言"><a href="#改表-：DDL-数据定义语言" class="headerlink" title="改表 ：DDL 数据定义语言"></a>改表 ：DDL 数据定义语言</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改字段类型 <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 字段 字段类型;</span><br><span class="line">添加新的字段 <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 字段 字段类型</span><br><span class="line">添加字段并指定位置  <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 字段 字段类型   <span class="keyword">after</span> 字段;</span><br><span class="line">删除表字段  <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 字段名;</span><br><span class="line">修改指定的字段  <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> 原字段名字  新的字段名字 字段类型</span><br></pre></td></tr></table></figure>
<h5 id="完整select"><a href="#完整select" class="headerlink" title="完整select"></a>完整select</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> select_expr [,select_expr,...] [      </span><br><span class="line">      <span class="keyword">FROM</span> tb_name</span><br><span class="line">      [<span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...] </span><br><span class="line">      [<span class="keyword">HAVING</span> <span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name|expr|postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</span><br><span class="line">      [ <span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,]rowcount | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br><span class="line">]</span><br><span class="line">执行顺序为：</span><br><span class="line">    <span class="keyword">from</span> 表名</span><br><span class="line">    <span class="keyword">where</span> ....</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> ...</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> *</span><br><span class="line">    <span class="keyword">having</span> ...</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> ...</span><br><span class="line">    <span class="keyword">limit</span> <span class="keyword">start</span>,<span class="keyword">count</span></span><br></pre></td></tr></table></figure>
<h5 id="数据操作：DQL数据查询语言-amp-amp-DML数据操纵语言"><a href="#数据操作：DQL数据查询语言-amp-amp-DML数据操纵语言" class="headerlink" title="数据操作：DQL数据查询语言 &amp;&amp; DML数据操纵语言"></a>数据操作：DQL数据查询语言 &amp;&amp; DML数据操纵语言</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">1.增加数据(<span class="keyword">insert</span>)<span class="number">3</span>种方式 </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，...)(很少用)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段<span class="number">1</span>，字段<span class="number">2.</span>..) <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，....);（较常用）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段<span class="number">1</span>，字段<span class="number">2.</span>..) <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，....)，(值<span class="number">1</span>，值<span class="number">2</span>，....)，(值<span class="number">1</span>，值<span class="number">2</span>，....);</span><br><span class="line"></span><br><span class="line">2.删除数据(<span class="keyword">delete</span>) </span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件 注意：<span class="keyword">where</span> 条件必须加，否则数据会被全部删除</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>更新数据(<span class="keyword">update</span>) </span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段<span class="number">1</span> = 值<span class="number">1</span>, 字段<span class="number">2</span> = 值<span class="number">2</span> <span class="keyword">where</span> 条件</span><br><span class="line">注意：<span class="keyword">where</span> 必须加，否则数据全部修改</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>筛选重复值的字段    </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段 <span class="keyword">from</span> 表名</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>查询数据(<span class="keyword">select</span>)</span><br><span class="line"><span class="number">1.</span>查询表中的所有数据   <span class="keyword">select</span> * <span class="keyword">from</span> 表名</span><br><span class="line"><span class="number">2.</span>指定数据查询    <span class="keyword">select</span> [<span class="keyword">distinct</span>] 字段 <span class="keyword">from</span> 表名 </span><br><span class="line">字符串函数 串联（||）,<span class="keyword">upper</span>(s),<span class="keyword">trim</span>(s),<span class="keyword">lower</span>（s）,escape “\” 定义转义字符</span><br><span class="line">集合 <span class="keyword">id</span> [<span class="keyword">not</span>] <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>)  模糊查询  ：<span class="keyword">like</span> <span class="string">'%a%'</span>;%任意子串，_任意一个字符</span><br><span class="line"></span><br><span class="line">4.根据条件查询出来的数据  <span class="keyword">select</span> 字段 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件 (最常用的)</span><br><span class="line"><span class="keyword">where</span> 条件后面跟的条件</span><br><span class="line"> 关系：&gt;,&lt;,&gt;=,&lt;=,!=  </span><br><span class="line"> 逻辑：<span class="keyword">or</span>, <span class="keyword">and</span> </span><br><span class="line"> 区间：<span class="keyword">id</span> <span class="keyword">between</span> <span class="number">4</span> <span class="keyword">and</span> <span class="number">6</span> ;闭区间，包含边界</span><br><span class="line"> 集合运算 并集 union [all],  交集 intersect, 补集 except</span><br><span class="line"> &gt;some 集合 :至少比一个大；&gt;all 集合 比所有都大</span><br><span class="line"> </span><br><span class="line">5.结果集排序</span><br><span class="line">    1, 通过字段来排序</span><br><span class="line">    例如 ：<span class="keyword">select</span> * <span class="keyword">from</span> star orser <span class="keyword">by</span> money <span class="keyword">desc</span>, age <span class="keyword">asc</span>; </span><br><span class="line">    <span class="keyword">select</span> 字段 <span class="keyword">from</span> 表 <span class="keyword">order</span> <span class="keyword">by</span> 字段  排序关键词(<span class="keyword">desc</span> | <span class="keyword">asc</span>)</span><br><span class="line">    排序关键词 <span class="keyword">desc</span> 降序 <span class="keyword">asc</span> 升序(默认)</span><br><span class="line">    <span class="number">2</span>, 多字段排序</span><br><span class="line">    <span class="keyword">select</span> 字段 <span class="keyword">from</span> 表 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span>  <span class="keyword">desc</span> |<span class="keyword">asc</span>,...字段n <span class="keyword">desc</span>| <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line">6.限制结果集</span><br><span class="line"><span class="keyword">select</span>  字段 <span class="keyword">from</span> 表 <span class="keyword">limit</span> 数量;</span><br><span class="line">例如:<span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">id</span>) <span class="keyword">from</span> star                                                         </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名  <span class="keyword">limit</span> 偏移量,数量</span><br><span class="line">说明:</span><br><span class="line"><span class="number">1.</span>不写偏移量的话就是默认的为<span class="number">0</span></span><br><span class="line"><span class="number">2.</span>实现分页的时候必须写偏移量</span><br><span class="line">  偏移量怎么计算？:</span><br><span class="line">    <span class="keyword">limit</span> (n<span class="number">-1</span>)*数量 ,数量 </span><br><span class="line">    </span><br><span class="line"><span class="number">7.</span>常用的统计函数</span><br><span class="line"><span class="keyword">sum</span>，<span class="keyword">avg</span>，<span class="keyword">count</span>，<span class="keyword">max</span>,<span class="keyword">min</span></span><br><span class="line">只分组:<span class="keyword">select</span> * <span class="keyword">from</span> 表 <span class="keyword">group</span> <span class="keyword">by</span> 字段</span><br><span class="line">例子: <span class="keyword">select</span> <span class="keyword">count</span>(sex) <span class="keyword">as</span> re,sex <span class="keyword">from</span> star <span class="keyword">group</span> <span class="keyword">by</span> sex <span class="keyword">having</span> re &gt; <span class="number">3</span>;</span><br><span class="line">分组统计: <span class="keyword">select</span> <span class="keyword">count</span>(sex) <span class="keyword">from</span> star <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure>
<h5 id="多表联合查询"><a href="#多表联合查询" class="headerlink" title="多表联合查询"></a>多表联合查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1，内连接</span><br><span class="line">隐式内连接 <span class="keyword">select</span> username,<span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span>,goods <span class="keyword">where</span> user.gid=gods.gid;</span><br><span class="line">显示内连接</span><br><span class="line"><span class="keyword">select</span> username,<span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> goods <span class="keyword">on</span> user.gid=goods.gid;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">left</span> <span class="keyword">join</span> goods <span class="keyword">on</span> user.gid=goods.gid;</span><br><span class="line">2.外链接</span><br><span class="line">左连接 包含所有的左边表中的记录以及右边表中没有和他匹配的记录</span><br><span class="line">右连接 </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gid <span class="keyword">in</span>(<span class="keyword">select</span> gid <span class="keyword">from</span> goods);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">right</span> <span class="keyword">join</span> goods <span class="keyword">on</span> user.gid=goods.gid;</span><br><span class="line">子嵌套查询</span><br><span class="line">数据联合查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">left</span> <span class="keyword">join</span> goods <span class="keyword">on</span> user.gid=goods.gid <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">right</span> <span class="keyword">join</span> goods <span class="keyword">on</span> user.gid=goods.gid;</span><br><span class="line">两个表同时更新</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> u, goods g <span class="keyword">set</span> u.gid=<span class="number">12</span>,g.price=<span class="number">1</span> <span class="keyword">where</span> u.id=<span class="number">2</span> <span class="keyword">and</span> u.gid=g.gid;</span><br></pre></td></tr></table></figure>
<h5 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL 数据控制语言"></a>DCL 数据控制语言</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建用户:<span class="keyword">create</span> <span class="keyword">user</span><span class="string">'xiaoming'</span>@<span class="string">'localhost'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'666666'</span>;</span><br><span class="line">授权用户:<span class="keyword">grant</span> all <span class="keyword">on</span> test.* <span class="keyword">to</span> <span class="string">'xiaoming'</span>@<span class="string">'localhost'</span>;</span><br><span class="line">刷新权限:<span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line">取消授权:<span class="keyword">revoke</span> all <span class="keyword">on</span> test.* <span class="keyword">from</span> <span class="string">'xiaoming'</span>@<span class="string">'localhost'</span>;</span><br><span class="line">删除用户: <span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">'xiaoming'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure>
<h5 id="DTL-数据事务语言"><a href="#DTL-数据事务语言" class="headerlink" title="DTL 数据事务语言"></a>DTL 数据事务语言</h5><p>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启事务：<span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line">操作回滚：<span class="keyword">rollback</span>;</span><br><span class="line">提交事务：<span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>通俗的讲，视图就是一条SELECT语句执行后返回的结果集。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；视图一般不能插入。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义视图 建议以v_开头</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> <span class="keyword">select</span>语句;</span><br><span class="line">查看表会将所有的视图也列出来</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">视图的用途就是查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v_stu_score;</span><br><span class="line">删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名称; eg：<span class="keyword">drop</span> <span class="keyword">view</span> v_stu_sco;</span><br></pre></td></tr></table></figure>
<h5 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入驱动jar包</span></span><br><span class="line"><span class="comment">//2.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//3.获取数据库连接对象</span></span><br><span class="line">Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db3"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line"><span class="comment">//4.定义sql语句</span></span><br><span class="line">String sql = <span class="string">"update account set balance = 500 where id = 1"</span>;</span><br><span class="line"><span class="comment">//5.获取执行sql的对象 Statement</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">//6.执行sql</span></span><br><span class="line"><span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line">String sql2 = <span class="string">"update account set balance = balance + ? where id = ?"</span>;</span><br><span class="line">pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line"><span class="comment">//4. 设置参数</span></span><br><span class="line">pstmt2.setDouble(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">pstmt2.setInt(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">pstmt2.executeUpdate();</span><br><span class="line"><span class="comment">//7.处理结果</span></span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="comment">//8.释放资源</span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>
<h5 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。</span><br><span class="line">	    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</span><br><span class="line"></span><br><span class="line">2. 好处：</span><br><span class="line">	1. 节约资源</span><br><span class="line">	2. 用户访问高效</span><br><span class="line"></span><br><span class="line">3. 实现：</span><br><span class="line">	1. 标准接口：DataSource   javax.sql包下的</span><br><span class="line">		1. 方法：</span><br><span class="line">			* 获取连接：getConnection()</span><br><span class="line">			* 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</span><br><span class="line"></span><br><span class="line">	2. 一般我们不去实现它，有数据库厂商来实现</span><br><span class="line">		1. C3P0：数据库连接池技术</span><br><span class="line">		2. Druid：数据库连接池实现技术，由阿里巴巴提供的</span><br></pre></td></tr></table></figure>
<h5 id="C3P0和Druid"><a href="#C3P0和Druid" class="headerlink" title="C3P0和Druid"></a>C3P0和Druid</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>. C3P0：数据库连接池技术</span><br><span class="line">	* 步骤：</span><br><span class="line">		<span class="number">1</span>. 导入jar包 (两个) c3p0-<span class="number">0.9</span>.5.2.jar mchange-commons-java-<span class="number">0.2</span>.12.jar ，</span><br><span class="line">			* 不要忘记导入数据库驱动jar包</span><br><span class="line">		<span class="number">2</span>. 定义配置文件：</span><br><span class="line">			* 名称： c3p0.properties 或者 c3p0-config.xml</span><br><span class="line">			* 路径：直接将文件放在src目录下即可。</span><br><span class="line">			  	&lt;!--  连接参数 --&gt;</span><br><span class="line">                &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">                &lt;property name=<span class="string">"jdbcUrl"</span>&gt;jdbc:mysql:<span class="comment">//localhost:3306/day25&lt;/property&gt;</span></span><br><span class="line">                &lt;property name="user"&gt;root&lt;/property&gt;</span><br><span class="line">                &lt;property name="password"&gt;root&lt;/property&gt;   </span><br><span class="line">                &lt;!-- 连接池参数 --&gt;</span><br><span class="line">                &lt;property name="initialPoolSize"&gt;5&lt;/property&gt;</span><br><span class="line">                &lt;property name="maxPoolSize"&gt;10&lt;/property&gt;</span><br><span class="line">                &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt;</span><br><span class="line">		<span class="number">3</span>. 创建核心对象 数据库连接池对象 ComboPooledDataSource</span><br><span class="line">		<span class="number">4</span>. 获取连接： getConnection</span><br><span class="line">	* 代码：</span><br><span class="line">		 <span class="comment">//1.创建数据库连接池对象</span></span><br><span class="line">        DataSource ds  = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        <span class="comment">//2. 获取连接对象</span></span><br><span class="line">        Connection conn = ds.getConnection();</span><br><span class="line"><span class="number">5</span>. Druid：数据库连接池实现技术，由阿里巴巴提供的</span><br><span class="line">	<span class="number">1</span>. 步骤：</span><br><span class="line">		<span class="number">1</span>. 导入jar包 druid-<span class="number">1.0</span>.9.jar</span><br><span class="line">		<span class="number">2</span>. 定义配置文件：</span><br><span class="line">			* 是properties形式的</span><br><span class="line">			* 可以叫任意名称，可以放在任意目录下</span><br><span class="line">			driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">            url=jdbc:mysql:<span class="comment">///db3</span></span><br><span class="line">            username=root</span><br><span class="line">            password=root</span><br><span class="line">            initialSize=<span class="number">5</span></span><br><span class="line">            maxActive=<span class="number">10</span></span><br><span class="line">            maxWait=<span class="number">3000</span></span><br><span class="line">		<span class="number">3</span>. 加载配置文件。Properties</span><br><span class="line">		<span class="number">4</span>. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</span><br><span class="line">		<span class="number">5</span>. 获取连接：getConnection</span><br><span class="line">	* 代码：</span><br><span class="line">		 <span class="comment">//3.加载配置文件</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        <span class="comment">//4.获取连接池对象</span></span><br><span class="line">        DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        <span class="comment">//5.获取连接</span></span><br><span class="line">        Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>
<h5 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</span><br><span class="line">* 步骤：</span><br><span class="line">	<span class="number">1</span>. 导入jar包</span><br><span class="line">	<span class="number">2</span>. 创建JdbcTemplate对象。依赖于数据源DataSource</span><br><span class="line">		* JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(ds);</span><br><span class="line"></span><br><span class="line">	<span class="number">3</span>. 调用JdbcTemplate的方法来完成CRUD的操作</span><br><span class="line">		* update():执行DML语句。增、删、改语句</span><br><span class="line">		* queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</span><br><span class="line">			* 注意：这个方法查询的结果集长度只能是<span class="number">1</span></span><br><span class="line">		* queryForList():查询结果将结果集封装为list集合</span><br><span class="line">			* 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</span><br><span class="line">		* query():查询结果，将结果封装为JavaBean对象</span><br><span class="line">			* query的参数：RowMapper</span><br><span class="line">				* 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</span><br><span class="line">				* <span class="keyword">new</span> BeanPropertyRowMapper&lt;类型&gt;(类型.class)</span><br><span class="line">		* queryForObject：查询结果，将结果封装为对象</span><br><span class="line">			* 一般用于聚合函数的查询</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取JDBCTemplate对象</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 修改1号数据的 salary 为 10000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//2. 定义sql</span></span><br><span class="line">        String sql = <span class="string">"update emp set salary = 10000 where id = 1001"</span>;</span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 添加一条记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into emp(id,ename,dept_id) values(?,?,?)"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>, <span class="string">"郭靖"</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.删除刚才添加的记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"delete from emp where id = ?"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.查询id为1001的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment">     * 注意：这个方法查询的结果集长度只能是1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp where id = ? or id = ?"</span>;</span><br><span class="line">        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="number">1001</span>,<span class="number">1002</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5. 查询所有记录，将其封装为List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;</span><br><span class="line">            System.out.println(stringObjectMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> RowMapper&lt;Emp&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Emp <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                Emp emp = <span class="keyword">new</span> Emp();</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String ename = rs.getString(<span class="string">"ename"</span>);</span><br><span class="line">                <span class="keyword">int</span> job_id = rs.getInt(<span class="string">"job_id"</span>);</span><br><span class="line">                <span class="keyword">int</span> mgr = rs.getInt(<span class="string">"mgr"</span>);</span><br><span class="line">                Date joindate = rs.getDate(<span class="string">"joindate"</span>);</span><br><span class="line">                <span class="keyword">double</span> salary = rs.getDouble(<span class="string">"salary"</span>);</span><br><span class="line">                <span class="keyword">double</span> bonus = rs.getDouble(<span class="string">"bonus"</span>);</span><br><span class="line">                <span class="keyword">int</span> dept_id = rs.getInt(<span class="string">"dept_id"</span>);</span><br><span class="line"></span><br><span class="line">                emp.setId(id);</span><br><span class="line">                emp.setEname(ename);</span><br><span class="line">                emp.setJob_id(job_id);</span><br><span class="line">                emp.setMgr(mgr);</span><br><span class="line">                emp.setJoindate(joindate);</span><br><span class="line">                emp.setSalary(salary);</span><br><span class="line">                emp.setBonus(bonus);</span><br><span class="line">                emp.setDept_id(dept_id);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 7. 查询总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select count(id) from emp"</span>;</span><br><span class="line">        Long total = template.queryForObject(sql, Long.class);</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h5><p>1、码：能唯一确定一条记录的一个/多个属性。码包括主码和候选码。任意一个候选码也能作为主键。其中主码/候选码的任意一个真子集都不能确定一条记录。</p>
<p>2、主属性：构成<strong>主码</strong>或<strong>候选码</strong>的属性都叫主属性！千万不要误认为候选码的属性不是主属性！</p>
<p>3、非主属性：除了主属性以外的属性都为非主属性。</p>
<p>4、传递依赖：如果存在A → B → C的决定关系，则C传递函数依赖于A。(学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)有如下传递依赖(学号) → (所在学院) → (学院地点, 学院电话)</p>
<p>5、部分依赖：（学号和身份证）-&gt;姓名，姓名部分函数依赖于(学号和身份证)</p>
<p>第一范式：数据库的字段是单一属性，不可再分</p>
<p>第二范式：每个非主属性都完全函数依赖于主键，目的是去除<strong>非主属性</strong>对<strong>码</strong>的部分依赖。（学号和身份证）-&gt;姓名</p>
<p>第三范式：非关键字字段必须直接依赖任一侯选关键字，目的是去除<strong>非主属性</strong>对<strong>码</strong>的传递依赖。(学号) → (所在学院) → (学院地点)</p>
<p>BC范式：消除主属性对码的传递和函数依赖，消除（仓库名，管理员，物品名）-&gt;数量中仓库名 → 管理员主属性部分依赖</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看索引</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> 表名;</span><br><span class="line">创建索引</span><br><span class="line">如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致</span><br><span class="line">字段类型如果不是字符串，可以不填写长度部分</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名称 <span class="keyword">on</span> 表名(字段名称(长度))</span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> 索引名称 <span class="keyword">on</span> 表名;</span><br></pre></td></tr></table></figure>
<h5 id="索引特点和优缺点"><a href="#索引特点和优缺点" class="headerlink" title="索引特点和优缺点"></a>索引特点和优缺点</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105512.png" alt="image-20210307222031035"></p>
<h5 id="在哪里建索引"><a href="#在哪里建索引" class="headerlink" title="在哪里建索引"></a>在哪里建索引</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105513.png" alt="image-20210308105225087"></p>
<h5 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h5><p>（id，name) where id=1 and name=’xxx’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.最左前缀匹配原则，mysql 会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，范围查询会导致组合索引半生效。比如 a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，c 可以用到索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。where范围查询要放在最后 （这不绝对，但可以利用一部分索引）。</span><br><span class="line">2. 特别注意：and 之间的部分可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。where 字句有 or 出现还是会遍历全表。</span><br><span class="line">3. 尽量选择区分度高的字段作为索引,某字段的区分度的公式是 count(distinctcol)/count(*)，表示字段不重复的比例，比例越大，我们扫描的记录数越少，查找匹配的时候可以过滤更多的行， 唯一索引的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0。</span><br><span class="line">4. 不在索引列做运算或者使用函数。</span><br><span class="line">5. 尽量扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</span><br><span class="line">6. Where 子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。</span><br><span class="line">7. like 模糊查询中，右模糊查询（321%）会使用索引，而%321 和%321%会放弃索引而使用全局扫描。</span><br></pre></td></tr></table></figure>
<h5 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105514.png" alt="image-20210308141645229"></p>
<h5 id="EXPLAIN-SQL"><a href="#EXPLAIN-SQL" class="headerlink" title="EXPLAIN SQL"></a>EXPLAIN SQL</h5><p>在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。</p>
<p>expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra,下面对这些字段出现的可能进行解释：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type表示MySQL在表中找到所需行的方式，又称“访问类型”。</span><br><span class="line">常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</span><br><span class="line">Select_type 说明查询中使用到的索引类型，如果没有用有用到索引则为all</span><br><span class="line">ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</span><br><span class="line">index: Full Index Scan，index与ALL区别为index类型只遍历索引树</span><br><span class="line">range:只检索给定范围的行，使用一个索引来选择行</span><br><span class="line">ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</span><br><span class="line">eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</span><br><span class="line">const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system</span><br><span class="line">NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</span><br></pre></td></tr></table></figure>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>innoDB 的数据保存在表空间中，表空间又包含各种段，其中有数据段，索引段，回滚段。InnoDB中数据以B+Tree的数据结构存储的，非叶子节点既是索引，叶子节点既是数据行，回滚段用于存储undoLog，undoLog中记录的就是多版本数据，用于快照读和事务失败后的数据回滚,MySQL在合适的时机会清理undoLog。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105515.webp" alt="img"></p>
<h4 id="InnoDB与MyISAM"><a href="#InnoDB与MyISAM" class="headerlink" title="InnoDB与MyISAM"></a>InnoDB与MyISAM</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105516.png" alt="image-20210308105617479"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105517.png" alt="image-20210308141746008"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105518.png" alt="image-20210308105654476"></p>
<p><strong>自增主键删除</strong></p>
<p>一张表,里面有 ID 自增主键,当 insert 了 17 条记录之后,删除了第 15,16,17 条记录,再把 Mysql 重启,再 insert 一<br>条记录,这条记录的 ID 是 18 还是 15 ？<br>如果表的类型是 MyISAM， 那么是 18。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里， 重启MySQL自增主键的最大 ID 也不会丢失。<br>如果表的类型是 InnoDB， 那么是 15。InnoDB 表只是把自增主键的最大 ID 记录到内存中， 所以重启数据库会导<br>致最大 ID 丢失。</p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。</p>
<p>如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读者，<strong>在某个瞬间看到的是数据库的一个快照</strong>，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于<strong>其他的读者来说是不可见</strong>的。</p>
<p>一句话讲，MVCC就是用 <strong>同一份数据临时保留多版本的方式</strong> 的方式，实现并发控制。</p>
<p>什么是多版本并发控制呢 ？其实就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，而每一个事务在启动的时候，都有一个唯一的递增的版本号。<br>1、在插入操作时 ： 记录的创建版本号就是事务版本号。<br>比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105519.png" alt="image-20210408163551921"></p>
<p>2、在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新<br>的记录的方式。<br>比如，针对上面那行记录，事务Id为2 要把name字段更新<br>update table set name= ‘new_value’ where id=1;</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105520.png" alt="image-20210408163628472"></p>
<p>3、删除操作的时候，就把事务版本号作为删除版本号。比如<br>delete from table where id=1;</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105521.png" alt="image-20210408163653776"></p>
<p>4、查询操作：<br>从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：<br>1）InnoDB只查找<strong>版本早于当前事务版本</strong>的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，只么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。<br>2）行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删<br>除。<br>这样就保证了各个事务互不影响。从这里也可以体会到一种提高系统性能的思路，就是：<br><strong>通过版本号来减少锁的争用</strong>。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="事务的四大特征"><a href="#事务的四大特征" class="headerlink" title="事务的四大特征"></a>事务的四大特征</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</span><br><span class="line">2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。</span><br><span class="line">3. 隔离性：并发的事务之间不会互相影响，相互独立。</span><br><span class="line">4. 一致性：事务操作前后，数据总量不变</span><br></pre></td></tr></table></figure>
<h5 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h5><p><strong>丢失更新</strong><br>如果两个事务都要更新数据库一个字段X，x=100</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105522.png" alt="image-20210408162727975"></p>
<p>两个不同事物同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务更新会被后提交事务的<br>更新给覆盖掉，这种情况事务A的更新就被覆盖掉了、丢失了。<br><strong>脏读（未提交读）</strong><br>防止一个事务读到另一个事务还没有提交的记录。 如：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105523.png" alt="image-20210408162746429"></p>
<p>事务读取了未提交的数据，事务B的回滚，导致了事务A的数据不一致，导致了事务A的脏读 ！<br><strong>不可重复读</strong><br>一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的；如果不一致，<br>就说明为不可重复读。 还是用上面的例子</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105524.png" alt="image-20210408162804468"></p>
<p>这种情况事务A多次读取x的结果出现了不一致，即为不可重复读 。<br><strong>幻读（Phantom Read）</strong><br>事务A读的时候读出了15条记录，事务B在事务A执行的过程中 增加 了1条，事务A再读的时候就变成了 16 条，这<br>种情况就叫做幻影读。 不可重复读说明了做数据库读操作的时候可能会出现的问题。</p>
<h5 id="事务隔离级别（恶果：脏读、-不可重复读、幻读-）"><a href="#事务隔离级别（恶果：脏读、-不可重复读、幻读-）" class="headerlink" title="事务隔离级别（恶果：脏读、 不可重复读、幻读 ）"></a>事务隔离级别（恶果：脏读、 不可重复读、幻读 ）</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105525.png" alt="image-20210307222230326"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105526.png" alt="image-20210308105723199"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read uncommited ：读到未提交数据 A线程读到B未submit的数据</span><br><span class="line">read committed：脏读，不可重复读  A线程读到B submit的数据，两次查询不同</span><br><span class="line">repeatable read：可重读  A线程读到B insert的数据，第一次没有，第二次有了</span><br><span class="line">serializable ：串行事物</span><br></pre></td></tr></table></figure>
<h5 id="GAP-锁（间隙锁解决幻读）"><a href="#GAP-锁（间隙锁解决幻读）" class="headerlink" title="GAP 锁（间隙锁解决幻读）"></a>GAP 锁（间隙锁解决幻读）</h5><p>在索引记录的间隙上加锁，禁止插入，这样就避免了幻读</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105527.png" alt="image-20210308154325058"></p>
<h5 id="next-key-锁"><a href="#next-key-锁" class="headerlink" title="next-key 锁"></a>next-key 锁</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105528.png" alt="image-20210308154445909"></p>
<h5 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h5><p>指事务的资源分别位于不同的分布式系统的不同节点上的事务，需要保证事务的 ACID 特性。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105529.png" alt="image-20210408121957422"></p>
<p><strong>产生原因</strong></p>
<ul>
<li><p>数据库分库分表</p>
</li>
<li><p>业务服务化</p>
<p>业务按照面向服务（SOA）的架构拆分整个网站系统：如金融网站拆分为交易系统、账务系统等。</p>
</li>
</ul>
<p>分布式事务用于在分布式系统中保证不同节点之间的数据一致性。分布式事务的实现有很多种，最具有代表性的是<br>由Oracle Tuxedo系统提出的XA分布式事务协议。<br>XA协议包含<strong>两阶段提交（2PC）和三阶段提交（3PC）</strong>两种实现</p>
<h5 id="事务两阶段提交（2PC）"><a href="#事务两阶段提交（2PC）" class="headerlink" title="事务两阶段提交（2PC）"></a>事务两阶段提交（2PC）</h5><p>在XA协议中包含着两个角色：事务协调者和事务参与者。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105530.png" alt="image-20210408122202911"></p>
<p>在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。<br>在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。<br>当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105531.png" alt="image-20210408122223925"></p>
<p>在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。<br>接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。<br>当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。<br>以上所描述的是XA两阶段提交的正向流程，接下来我们看一看失败情况的处理流程：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105532.png" alt="image-20210408122438925"></p>
<p>在XA的第一阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。<br>于是在第二阶段，事务协调节点向所有的事务参与者发送Abort请求。接收到Abort请求之后，各个事务参与者节点需要在本地进行事务的回滚操作，回滚操作依照Undo Log来进行。<br>以上就是XA两阶段提交协议的详细过程。</p>
<h5 id="XA两阶段提交的不足"><a href="#XA两阶段提交的不足" class="headerlink" title="XA两阶段提交的不足"></a>XA两阶段提交的不足</h5><p>XA两阶段提交究竟有哪些不足呢？<br><strong>1.性能问题 同步阻塞</strong><br>XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。<br><strong>2.协调者单点故障问题</strong><br>事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。<br><strong>3.丢失消息导致的不一致问题。</strong><br>在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</p>
<p><strong>4 太过保守</strong></p>
<p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p>
<h5 id="XA三阶段提交（3PC）"><a href="#XA三阶段提交（3PC）" class="headerlink" title="XA三阶段提交（3PC）"></a>XA三阶段提交（3PC）</h5><p>XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。</p>
<h5 id="MQ事务"><a href="#MQ事务" class="headerlink" title="MQ事务"></a>MQ事务</h5><p>利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。</p>
<h5 id="TCC事务"><a href="#TCC事务" class="headerlink" title="TCC事务"></a>TCC事务</h5><p>TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于XA两阶段提交，但是实现方式是在代码层面来人为实现。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105533.png" alt="image-20210408123158032"></p>
<h5 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h5><p>单数据库事务完全遵循 ACID 规范，属于刚性事务，分布式事务要完全遵循 ACID 规范比较困难，属于柔性事务，满足 <strong>BASE</strong> 理论。</p>
<ul>
<li><p><strong>BA：Basic Availability</strong> 基本业务可用性</p>
</li>
<li><p><strong>S：Soft state</strong> 柔性状态</p>
</li>
<li><p><strong>E：Eventual consistency</strong> 最终一致性</p>
</li>
</ul>
<p>柔性事务对 ACID 的支持：</p>
<ol>
<li>原子性：严格遵循</li>
<li>一致性：事务完成后的一致性严格遵循，事务中的一致性可适当放宽</li>
<li>隔离性：并行事务间不可影响，事务中间结果可见性允许安全放宽</li>
<li>持久性：严格遵循</li>
</ol>
<p><strong>分类</strong></p>
<ol>
<li><p><strong>两阶段型</strong></p>
<p>XA、JTA/JTS 属于该类型，为分布式环境下事务处理的典型模式。</p>
</li>
<li><p><strong>补偿型</strong></p>
<p>TCC 可以归为该类型，其思路为：尽早释放锁，在 Try 成功的情况下如果事务要回滚，则 Cancel 将作为补偿机制回滚 Try 操作。</p>
</li>
<li><p><strong>异步确保型</strong></p>
<p>将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用；比如消息事务机制。</p>
</li>
<li><p><strong>最大努力通知型</strong></p>
<p>通过通知服务器（消息通知）进行，允许失败，有补充机制；</p>
</li>
</ol>
<h4 id="Sql-优化"><a href="#Sql-优化" class="headerlink" title="Sql 优化"></a>Sql 优化</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105534.png" alt="image-20210308142154220"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105535.png" alt="image-20210308142212180"></p>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105536.png" alt="image-20210308142549375"></p>
<h4 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105537.png" alt="image-20210308142652289"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105538.png" alt="image-20210308142707570"></p>
<h5 id="封锁协议（解决脏读不可重复读）"><a href="#封锁协议（解决脏读不可重复读）" class="headerlink" title="封锁协议（解决脏读不可重复读）"></a>封锁协议（解决脏读不可重复读）</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105539.png" alt="image-20210308142817068"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105540.png" alt="image-20210308142833910"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105541.png" alt="image-20210308142845141"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105542.png" alt="image-20210308143011980"></p>
<h5 id="死锁活锁"><a href="#死锁活锁" class="headerlink" title="死锁活锁"></a>死锁活锁</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105543.png" alt="image-20210308145752680"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105544.png" alt="image-20210308145808709"></p>
<h5 id="两阶段协议"><a href="#两阶段协议" class="headerlink" title="两阶段协议"></a>两阶段协议</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414105545.png" alt="image-20210308145850964"></p>
<h3 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h3><h4 id="分层协议"><a href="#分层协议" class="headerlink" title="分层协议"></a>分层协议</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111343.png" alt="image-20210414111154114"></p>
<!--more-->
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111344.png" alt="image-20210307223025471"></p>
<h4 id="一次网页访问"><a href="#一次网页访问" class="headerlink" title="一次网页访问"></a>一次网页访问</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111345.png" alt="image-20210307153953158"></p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="http请求和响应报文"><a href="#http请求和响应报文" class="headerlink" title="http请求和响应报文"></a>http请求和响应报文</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111346.png" alt="image-20210307223219011"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111347.png" alt="image-20210307223241867"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111348.png" alt="image-20210307223249141"></p>
<h5 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111349.png" alt="image-20210307223624541"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111350.png" alt="image-20210307223613666"></p>
<h5 id="http-请求过程"><a href="#http-请求过程" class="headerlink" title="http 请求过程"></a>http 请求过程</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111351.png" alt="image-20210307224005898"></p>
<h5 id="get与post"><a href="#get与post" class="headerlink" title="get与post"></a>get与post</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111352.png" alt="image-20210307224203352"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111353.png" alt="image-20210307224141797"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111354.png" alt="image-20210307224235985"></p>
<h5 id="http长连接"><a href="#http长连接" class="headerlink" title="http长连接"></a>http长连接</h5><p>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</p>
<p>无状态：HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111355.png" alt="image-20210307223744070"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111356.png" alt="image-20210307224611197"></p>
<p><strong>原理</strong></p>
<p>再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。</p>
<p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li>
</ol>
<h5 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111357.png" alt="image-20210307224335187"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111358.png" alt="image-20210307224402115"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111359.png" alt="image-20210307224420773"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111400.png" alt="image-20210307224436398"></p>
<h5 id="转发与重定向"><a href="#转发与重定向" class="headerlink" title="转发与重定向"></a>转发与重定向</h5><p>转发是服务器行为，重定向是客户端行为。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111401.png" alt="image-20210329203213395"></p>
<h5 id="http1-0-1-1-2-X"><a href="#http1-0-1-1-2-X" class="headerlink" title="http1.0,1.1,2.X"></a>http1.0,1.1,2.X</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111402.png" alt="image-20210307224656500"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111403.png" alt="image-20210307224713263"></p>
<h4 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS=HTTP+ 加密 + 认证 + 完整性保护"></a>HTTPS=HTTP+ 加密 + 认证 + 完整性保护</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111404.png" alt="image-20210307231641138"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. A 与 B 通过 TCP 建立链接，初始化 SSL 层。</span><br><span class="line">2. 进行 SSL 握手，A 发送 https 请求，传送客户端 SSL 协议版本号、支持的加密算法、随机数等。</span><br><span class="line">3. 服务器 B 把 CA 证书（包含 B 的公钥），把自己支持的加密算法、随机数等回传给A。</span><br><span class="line">4. A 接收到 CA 证书，验证证书有效性。</span><br><span class="line">5. 校验通过，客户端随机产生一个字符串作为与 B 通信的对称密钥，通过 CA 证书解出服务器 B 的公钥，对其加密，发送给服务器。</span><br><span class="line">6. B 用私钥解开信息，得到随机的字符串（对称密钥），利用这个密钥作为之后的通信密钥。</span><br><span class="line">7. 客户端向服务器发出信息，指明后面的数据使用该对称密钥进行加密，同时通知服务器 SSL 握手结束。</span><br><span class="line">8. 服务器接收到信息，使用对称密钥通信，通知握手接收。</span><br><span class="line">9. SSL 握手结束，使用对称密钥加密数据。</span><br></pre></td></tr></table></figure>
<h5 id="https与http区别"><a href="#https与http区别" class="headerlink" title="https与http区别"></a>https与http区别</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111405.png" alt="image-20210307231552528"></p>
<h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111406.png" alt="image-20210307231408268"></p>
<h5 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111407.png" alt="image-20210307231433548"></p>
<h4 id="TCP、UDP"><a href="#TCP、UDP" class="headerlink" title="TCP、UDP"></a>TCP、UDP</h4><h5 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111408.png" alt="image-20210307224826315"></p>
<h5 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACK ： TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的ACK 必须为 1。</span><br><span class="line">SYN(SYNchronization) ： 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则在响应报文中使 SYN=1 和 ACK=1.因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。</span><br><span class="line">FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111409.png" alt="image-20210307224740805"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111410.png" alt="image-20210307232127447"></p>
<h5 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111411.png" alt="image-20210307224945140"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111412.png" alt="image-20210307225054471"></p>
<h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111413.png" alt="image-20210307225333703"></p>
<h5 id="tcp-粘包问题-nagle-算法"><a href="#tcp-粘包问题-nagle-算法" class="headerlink" title="tcp 粘包问题 nagle 算法"></a>tcp 粘包问题 nagle 算法</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111414.png" alt="image-20210307225439361"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111415.png" alt="image-20210307225456168"></p>
<h5 id="tcp-如何保证可靠性传输"><a href="#tcp-如何保证可靠性传输" class="headerlink" title="tcp 如何保证可靠性传输"></a>tcp 如何保证可靠性传输</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111416.png" alt="image-20210307225655607"></p>
<h5 id="TCP-流量控制-拥塞控制"><a href="#TCP-流量控制-拥塞控制" class="headerlink" title="TCP 流量控制 拥塞控制"></a>TCP 流量控制 拥塞控制</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111417.png" alt="image-20210307225751924"></p>
<h5 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111421.png" alt="image-20210307230532476"></p>
<h5 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h5><p>发送方维持一个叫做口 拥塞窗口 cwnd （congestion window） ）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。</p>
<p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111418.png" alt="image-20210307230036650"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111419.png" alt="image-20210307230134036"></p>
<h5 id="快速重传快速恢复"><a href="#快速重传快速恢复" class="headerlink" title="快速重传快速恢复"></a>快速重传快速恢复</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111420.png" alt="image-20210307230435445"></p>
<h5 id="TCP状态转移"><a href="#TCP状态转移" class="headerlink" title="TCP状态转移"></a>TCP状态转移</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111422.png" alt="image-20210307230601261"></p>
<h5 id="TIME-WAIT-和-CLOSE-WAIT"><a href="#TIME-WAIT-和-CLOSE-WAIT" class="headerlink" title="TIME_WAIT 和 CLOSE_WAIT"></a>TIME_WAIT 和 CLOSE_WAIT</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111423.png" alt="image-20210307230830662"></p>
<p><strong>当一个 tcp 监听了 80 端口后，Udp 还能否监听 80 端口</strong><br>答：由于 TCP/IP 传输层的两个协议 TCP 和 UDP 是完全独立的两个软件模块，因此各自的端口号也相互独立，如 TCP 有一个 255 号端口，UDP 也可以有一个 255 号端口，二者并不冲突。</p>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111424.png" alt="image-20210307231023027"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111425.png" alt="image-20210307231036546"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414111426.png" alt="image-20210307231047743"></p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><!--more-->
<h5 id="大端和小端序"><a href="#大端和小端序" class="headerlink" title="大端和小端序"></a>大端和小端序</h5><p>如果数据都是单字节，怎么存储无所谓，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。</p>
<p>Big-endian（大端序）：数据的高位字节存放在地址的低端 低位字节存放在地址高端</p>
<p>Little-endian（小端序）：数据的高位字节存放在地址的高端 低位字节存放在地址低端</p>
<p>if(((char*)&amp;a)[3] ==1) 则为大端序，由于a是int，所以占四个字节，其值是00000001，存储方式如下。所以a[3]是0，不是大端序。一个更标准的写法是将a[3]替换为a[sizeof(int) - 1]。</p>
<h5 id="程序的内存模型"><a href="#程序的内存模型" class="headerlink" title="程序的内存模型"></a>程序的内存模型</h5><p>32 位操作系统进程地址空间有 4G，0~3G 为用户空间，3~4G 为内核空间。用户空间从低地址到高地址分别为：代码段、初始化数据段、未初始化数据段、堆段、栈段。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506103242.png" alt="image-20210506103236816"></p>
<h5 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select、poll、epoll 的区别</span><br><span class="line">Select 底层采用数组存储文件描述符，存在以下四个问题：</span><br><span class="line">1. 单进程监听的文件描述符最大数量存在限制，32 位操作系统上是 1024</span><br><span class="line">2. 内核/用户态空间内存拷贝问题，select 复制大量的句柄数据结构，产生巨大开销</span><br><span class="line">3. select 仅支持水平触发模式，存在重复触发风险</span><br><span class="line">4. select 返回后应用程序需要遍历整个数组，效率低。</span><br><span class="line">Poll 底层采用队列存储文件描述符，因此没有文件描述符数量限制，select 其它三个缺点它也有。</span><br><span class="line">Epoll 解决 select 和 poll 的缺点，底层采用队列加红黑树方式实现，除了不受文件描述符数量限制之外，还支持边缘触发模式。</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210506104724.png" alt="在这里插入图片描述"></p>
<h5 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">14. 介绍僵尸进程和孤儿进程</span><br><span class="line">僵尸进程指的是子进程退出后，父进程没有回收子进程的资源。僵尸进程过多导致系统资源不足。</span><br><span class="line">孤儿进程指的是父进程退出，子进程变成孤儿进程，孤儿进程由 init 进程进行资源回收。</span><br><span class="line">15. 如何解决僵尸进程过多问题</span><br><span class="line">1. 可以在父进程的 SIG_CHLD 信号处理函数中回收子进程资源。</span><br><span class="line">2. 设置父进程的 SIG_CHLD 信号处理函数位 SIG_IGN，子进程会自动回收</span><br></pre></td></tr></table></figure>
<h5 id="常见Linux命令"><a href="#常见Linux命令" class="headerlink" title="常见Linux命令"></a>常见Linux命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ls列出目录；cd切换目录；pwd显示当前目录；mkdir创建目录；rmdir删除目录</span><br><span class="line">cp复制目录或文件；rm移除文件或目录；mv移动文件或目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩文件</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改文件|目录的拥有者</span></span><br><span class="line">chown 用户名 文件名|目录名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归修改文件|目录的组</span></span><br><span class="line">chgrp -R 组名 文件名|目录名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归修改文件权限 r:4 w:2 x:1 拥有者／组/其他</span></span><br><span class="line">chmod -R 755 文件名|目录名</span><br><span class="line">cat从第一行正序显示内容；tac从最后一行开始显示内容；head -n20 显示前20行；tail看尾几行</span><br><span class="line">开启端口 firewall-cmd --zone=public --add-port=80/tcp --permanent；</span><br><span class="line">firewall-cmd --state 查看状态；</span><br><span class="line">service firewall start/restar/stop 开启/重启/停止</span><br><span class="line">ps -ef|grep redis 查看redis的进程信息 ps -aux 查看进程</span><br><span class="line">kill [-9] 进程代号	终止指定代号的进程，-9 表示强行终止	</span><br><span class="line">top 查看各个进程的资源占用状况 Cache 主要是文件缓存，buffer 主要是磁盘缓存。</span><br><span class="line">df -h	disk free 显示磁盘剩余空间</span><br><span class="line">service iptables status 查看防火墙状态</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡对应的 IP 地址</span></span><br><span class="line">ifconfig | grep inet</span><br><span class="line">Iostat 查看磁盘。</span><br><span class="line">netstat -apn 查看所有端口</span><br><span class="line">Vmstat 查看虚拟内存</span><br><span class="line">Awk 主要用于列处理，sed 用于行处理。开发常用命令包括 grep 搜索，wc 统计，tcpdump 抓包等等。</span><br></pre></td></tr></table></figure>
<h4 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414114329.png" alt="image-20210308095803977"></p>
<p><strong>多级反馈队列调度算法</strong> ：前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</p>
<h4 id="内存管理方式（页式、段式、段页式）"><a href="#内存管理方式（页式、段式、段页式）" class="headerlink" title="内存管理方式（页式、段式、段页式）"></a>内存管理方式（页式、段式、段页式）</h4><h5 id="页式"><a href="#页式" class="headerlink" title="页式"></a><strong>页式</strong></h5><p>为了便于在内存中找到进程的每个页面所对应的物理块，系统为<strong>每个进程建立一张页表</strong>，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见页表作用是实现从页号到物理块号的地址映射，这种是 页存储管理方式。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414114330.png" alt="image-20210308100029250"></p>
<h5 id="段式"><a href="#段式" class="headerlink" title="段式"></a>段式</h5><p>将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配，这种是 段存储管理方式。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414114331.png" alt="image-20210308100112242"></p>
<h5 id="段页存储"><a href="#段页存储" class="headerlink" title="段页存储"></a>段页存储</h5><p>作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位，这种是 段页存储管理方式。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414114332.png" alt="image-20210308100147792"></p>
<h5 id="快表和多级⻚表"><a href="#快表和多级⻚表" class="headerlink" title="快表和多级⻚表"></a>快表和多级⻚表</h5><p><strong>我 ：在分⻚内存管理中，很重要的两点是：</strong></p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间⼤，⻚表也会很⼤的问题。</li>
</ol>
<p><strong>快表</strong></p>
<p>为了解决虚拟地址到物理地址的转换速度，操作系统在 ⻚表⽅案 基础之上引⼊了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为⼀种特殊的⾼速缓冲存储器（Cache），其中的内容是⻚表的⼀部分或者全部内容。作为⻚表的 Cache，它的作⽤与⻚表相似，但是提⾼了访问速率。由于采⽤⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。使⽤快表之后的地址转换流程是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 根据虚拟地址中的⻚号查快表；</span><br><span class="line">2. 如果该⻚在快表中，直接从快表中读取相应的物理地址；</span><br><span class="line">3. 如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；</span><br><span class="line">4. 当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。</span><br></pre></td></tr></table></figure>
<p> <strong>多级⻚表</strong>引⼊多级⻚表的主要⽬的是为了避免把全部⻚表⼀直放在内存中占⽤过多空间，特别是那些根本就不需要的⻚表就不需要保留在内存中。</p>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>缺页中断：缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。<br>页面置换算法：在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用<strong>来选择淘汰哪一页</strong>的规则叫做页面置换算法。</p>
<h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为<strong>孤儿进程</strong>。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h4 id="僵尸进程-1"><a href="#僵尸进程-1" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait () 或 waitpid () 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait () 或 waitpid ()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为<strong>僵尸进程</strong>。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p> 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
<h4 id="原码，反码和补码"><a href="#原码，反码和补码" class="headerlink" title="原码，反码和补码"></a>原码，反码和补码</h4><h5 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h5><ul>
<li><p>原码就是符号位加上所要表达值得绝对值，即用第一位表示符号，其他位表示值，比如在8位二进制中：</p>
<p>[+1]~原~=0000 0001</p>
<p>[-1]~原~=1000 0001</p>
</li>
<li><p>所以可以得到8位二进制得取值范围是[1111 1111] - [0111 1111]即-127到127</p>
</li>
</ul>
<h5 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h5><ul>
<li><p>正数的反码是自己，负数的反码是在其原码基础上，符号位不变，其他位取反，例如：</p>
<p>[0000 0001]=[+1]~原~=[+1]~反~</p>
<p>[-1]~原~=1000 0001 ，[-1]~反~=1111 1110</p>
</li>
</ul>
<h5 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h5><ul>
<li><p>正数的补码就是自己，负数的补码是反码加1</p>
<p>[0000 0001]=[+1]~原~=[+1]~反~=[+1]~补~</p>
<p>[-1]~原~=1000 0001 ，[-1]~反~=1111 1110 ，[-1]~补~= 1111 1111</p>
</li>
</ul>
<h5 id="为什么使用原码，反码和补码"><a href="#为什么使用原码，反码和补码" class="headerlink" title="为什么使用原码，反码和补码"></a>为什么使用原码，反码和补码</h5><ul>
<li><p>以原码为例，当涉及到减法时，计算机会将其转换为加法，以1-1为例</p>
<p>1 - 1 = 1 + (-1) = [00000001]~原~ + [10000001]~原~ = [10000010]~原~ = -2</p>
</li>
<li><p>补码可以解决这个问题，统一加法和减法</p>
<p>1-1 = 1 + (-1) =[0000 0001]~补~ + [1111 1111]~补~ = [0000 0000]~补~=[0000 0000]~原~</p>
</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h5 id="Java中的设计模式"><a href="#Java中的设计模式" class="headerlink" title="Java中的设计模式"></a>Java中的设计模式</h5><p>装饰器设计模式（Decorator design pattern）被用于多个 Java IO 类中。</p>
<p>⼯⼚设计模式 : Spring使⽤⼯⼚模式通过  BeanFactory 、 ApplicationContext 创建 bean 对象。<br>代理设计模式 : Spring AOP 功能的实现。<br>单例设计模式 : Spring 中的 Bean 默认都是单例的。 Runtime，Calendar<br>包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。<br>观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。  Swing<br>适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</p>
<h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h3><h4 id="大型网站架构演化发展历程"><a href="#大型网站架构演化发展历程" class="headerlink" title="大型网站架构演化发展历程"></a>大型网站架构演化发展历程</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110734.png" alt="image-20210407163257554"></p>
<!--more-->
<ol>
<li>拆分：不同的多台服务器上面部署不同的服务模块，模块之间通过RPC通信和调用，用于拆分业务功能，独立部署，多个服务器共同组成一个整体对外提供服务。</li>
<li>集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，用于分流容灾，降低单个服务器的访问压力。</li>
</ol>
<h5 id="初始阶段的网站架构"><a href="#初始阶段的网站架构" class="headerlink" title="初始阶段的网站架构"></a>初始阶段的网站架构</h5><p>小型网站最开始没有太多人访问，只需要一台服务器就绰绰有余，应用程序、数据库、文件等所有资源都在一台服务器上。这时的网站架构如下图所示：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110735.png" alt="image-20210407162234274"></p>
<h5 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">应用服务器需要处理大量的业务逻辑，因此需要更快更强大的CPU；</span><br><span class="line">数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的磁盘和更大的内存；</span><br><span class="line">文件服务器需要存储大量用户上传的文件，因此需要更大的硬盘。</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110736.png" alt="image-20210407162339201"></p>
<h5 id="使用缓存改善网站性能"><a href="#使用缓存改善网站性能" class="headerlink" title="使用缓存改善网站性能"></a>使用缓存改善网站性能</h5><p>如果把这一小部分数据缓存在内存中，就可以减少数据库的访问压力，提高整个网站的数据访问速度，改善数据库的写入性能了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本地缓存的访问速度更快一些，但是受应用服务器内存限制，其缓存数据量有限，而且会出现和应用程序争用内存的情况。</span><br><span class="line">远程分布式缓存可以使用集群的方式，部署大内存的服务器作为专门的缓存服务器，可以在理论上做到不受内存容量限制的缓存服务。</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110737.png" alt="image-20210407162524730"></p>
<h5 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h5><p>通过负载均衡调度服务器，可以将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多用户，就在集群中加入更多的应用服务器，使应用服务器的压力不再成为整个网站的瓶颈。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110738.png" alt="image-20210407162559564"></p>
<h5 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h5><p>目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110739.png" alt="image-20210407162717596"></p>
<h5 id="使用反向代理和-CDN-加速网站响应"><a href="#使用反向代理和-CDN-加速网站响应" class="headerlink" title="使用反向代理和 CDN 加速网站响应"></a>使用反向代理和 CDN 加速网站响应</h5><p>CDN 和反向代理的基本原理都是缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据</span><br><span class="line">反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户</span><br></pre></td></tr></table></figure>
<p>使用 CDN 和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110740.png" alt="image-20210407162753331"></p>
<h5 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h5><p>分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数据部署在不同的物理服务器上。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110741.png" alt="image-20210407162911704"></p>
<h5 id="使用-NoSQL-和搜索引擎"><a href="#使用-NoSQL-和搜索引擎" class="headerlink" title="使用 NoSQL 和搜索引擎"></a>使用 NoSQL 和搜索引擎</h5><p>NoSQL 和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110742.png" alt="image-20210407163015722"></p>
<h5 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h5><p>大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将整个网站业务分成不同的产品线。如大型购物交易网站都会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。<br>具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署。应用之间可以通过一个超链接建立关系（在首页上的导航链接每个都指向不同的应用地址），也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统，如下图所示：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110743.png" alt="image-20210407163152524"></p>
<h5 id="分布式微服务"><a href="#分布式微服务" class="headerlink" title="分布式微服务"></a>分布式微服务</h5><p>随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。<br>既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些<strong>共用的业务提取出来，独立部署</strong>。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。如下图所示：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110744.png" alt="image-20210407163251463"></p>
<h4 id="数据库架构发展历程"><a href="#数据库架构发展历程" class="headerlink" title="数据库架构发展历程"></a>数据库架构发展历程</h4><h5 id="单机MySQL的美好年代"><a href="#单机MySQL的美好年代" class="headerlink" title="单机MySQL的美好年代"></a>单机MySQL的美好年代</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110745.png" alt="image-20210408103732149"></p>
<h5 id="Memcached-缓存-MySQL-垂直拆分"><a href="#Memcached-缓存-MySQL-垂直拆分" class="headerlink" title="Memcached(缓存)+MySQL+垂直拆分"></a>Memcached(缓存)+MySQL+垂直拆分</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110746.png" alt="image-20210408103912789"></p>
<p>Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在<br>Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性<br>hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端</p>
<h5 id="Mysql主从复制读写分离"><a href="#Mysql主从复制读写分离" class="headerlink" title="Mysql主从复制读写分离"></a>Mysql主从复制读写分离</h5><p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110747.png" alt="image-20210408104213351"></p>
<h5 id="分表分库-水平拆分-mysql集群"><a href="#分表分库-水平拆分-mysql集群" class="headerlink" title="分表分库+水平拆分+mysql集群"></a>分表分库+水平拆分+mysql集群</h5><p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。</p>
<p>同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110748.png" alt="image-20210408104334954"></p>
<h5 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110749.png" alt="image-20210408104521288"></p>
<h5 id="数据的水平拆分和垂直拆分"><a href="#数据的水平拆分和垂直拆分" class="headerlink" title="数据的水平拆分和垂直拆分"></a>数据的水平拆分和垂直拆分</h5><p>当我们使用读写分离、缓存后，数据库的压力还是很大的时候，这就需要使用到数据库拆分了。<br>数据库拆分简单来说，就是指通过某种特定的条件，按照某个维度，将我们存放在同一个数据库中的数据分散存放<br>到多个数据库（主机）上面以达到分散单库（主机）负载的效果。<br>切分模式： 垂直（纵向）拆分、水平拆分。</p>
<p>垂直拆分<br>一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据<br>库上面，这样也就将数据或者说压力分担到不同的库上面，如下图：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110750.png" alt="image-20210408121335272"></p>
<p>优点：</p>
<ol>
<li>拆分后业务清晰，拆分规则明确。</li>
<li>系统之间整合或扩展容易。</li>
<li>数据维护简单</li>
</ol>
<p>缺点：</p>
<ol>
<li>部分业务表无法join，只能通过接口方式解决，提高了系统复杂度。</li>
<li>受每种业务不同的限制存在单库性能瓶颈，不易数据扩展跟性能提高。</li>
<li>事务处理复杂。</li>
</ol>
<p>水平拆分<br>垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆到不同的数据库中。<br>相对于垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中<br>包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中 的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，主要有分表，分库两种模式，如图：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110751.png" alt="image-20210408121426591"></p>
<p>优点：</p>
<ol>
<li>不存在单库大数据，高并发的性能瓶颈。</li>
<li>对应用透明，应用端改造较少。</li>
<li>按照合理拆分规则拆分，join操作基本避免跨库。</li>
<li>提高了系统的稳定性跟负载能力。</li>
</ol>
<p>缺点：</p>
<ol>
<li>拆分规则难以抽象。</li>
<li>分片事务一致性难以解决。</li>
<li>数据多次扩展难度跟维护量极大。</li>
<li>跨库join性能较差。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">拆分原则</span><br><span class="line">1. 尽量不拆分，架构是进化而来，不是一蹴而就。(SOA)</span><br><span class="line">2. 最大可能的找到最合适的切分维度。</span><br><span class="line">3. 由于数据库中间件对数据Join 实现的优劣难以把握，而且实现高性能难度极大，业务读取 尽量少使用多表Join -</span><br><span class="line">尽量通过数据冗余，分组避免数据垮库多表join。</span><br><span class="line">4. 尽量避免分布式事务。</span><br><span class="line">5. 单表拆分到数据1000万以内。</span><br><span class="line">切分方</span><br><span class="line">范围、枚举、时间、取模、哈希、指定等</span><br><span class="line"></span><br><span class="line">场景3:上海公积金，养老金，社保系统</span><br><span class="line">分析：</span><br><span class="line">    社保系统</span><br><span class="line">    实时性要求不高</span><br><span class="line">    不存在瞬时压力</span><br><span class="line">    大规模分析？</span><br><span class="line">    数据规模大</span><br><span class="line">    数据重要不可丢失</span><br><span class="line">    偏于查询？</span><br><span class="line">方案1：按照用户取模，</span><br><span class="line">带来的问题：后续扩容困难</span><br><span class="line">方案2：按用户ID范围分片（1-1000万=分片1，xxx）</span><br><span class="line">带来的问题：用户活跃度无法掌握，可能存在热点问题</span><br><span class="line">方案3：按省份区县地区枚举</span><br><span class="line">数据分配不一定均匀</span><br></pre></td></tr></table></figure>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h5><p>（一）性能 如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110752.png" alt="image-20210407164425598"></p>
<p>（二）并发 如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110753.png" alt="image-20210407164450638"></p>
<h5 id="Redis与mencached"><a href="#Redis与mencached" class="headerlink" title="Redis与mencached"></a>Redis与mencached</h5><p><img src="C:\Users\zsy\AppData\Roaming\Typora\typora-user-images\image-20210417223000949.png" alt="image-20210417223000949"></p>
<h5 id="优秀的缓存系统Redis"><a href="#优秀的缓存系统Redis" class="headerlink" title="优秀的缓存系统Redis"></a>优秀的缓存系统Redis</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">	Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。</span><br><span class="line">	官方提供测试数据，<span class="number">50</span>个并发执行<span class="number">100000</span>个请求,读的速度是<span class="number">110000</span>次/s,写的速度是<span class="number">81000</span>次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求。目前为止Redis支持的键值数据类型如下：</span><br><span class="line"><span class="number">1</span>) 字符串类型 string：一些复杂的计数功能的缓存。</span><br><span class="line">	<span class="number">1</span>. 存储： set key value</span><br><span class="line">	<span class="number">2</span>. 获取： get key</span><br><span class="line">	<span class="number">3</span>. 删除： del key</span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>) 哈希类型 hash ： map格式，单点登录，cookieId为key，<span class="number">30</span>分钟过期，模拟session</span><br><span class="line">	<span class="number">1</span>. 存储： hset key field value</span><br><span class="line">	<span class="number">2</span>. 获取： hget key field: 获取指定的field对应的值 </span><br><span class="line">			 hgetall key：获取所有的field和value</span><br><span class="line">	<span class="number">3</span>. 删除： hdel key field</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span>) 列表类型 list ： linkedlist格式。支持重复元素,消息队列,分页功能</span><br><span class="line">	<span class="number">1</span>. 添加：</span><br><span class="line">		<span class="number">1</span>. lpush key value: 将元素加入列表左表	</span><br><span class="line">		<span class="number">2</span>. rpush key value：将元素加入列表右边</span><br><span class="line">	<span class="number">2</span>. 获取：lrange key start end ：范围获取</span><br><span class="line">	<span class="number">3</span>. 删除：</span><br><span class="line">		lpop key： 删除列表最左边的元素，并将元素返回</span><br><span class="line">		rpop key： 删除列表最右边的元素，并将元素返回</span><br><span class="line">		</span><br><span class="line"><span class="number">4</span>) 集合类型 set  ： 不允许重复元素,全局去重,交集、并集、差集</span><br><span class="line">	<span class="number">1</span>. 存储：sadd key value</span><br><span class="line">	<span class="number">2</span>. 获取：smembers key:获取set集合中所有元素</span><br><span class="line">	<span class="number">3</span>. 删除：srem key value:删除set集合中的某个元素	</span><br><span class="line">	</span><br><span class="line"><span class="number">5</span>) 有序集合类型 sortedset：不允许重复元素，且元素有顺序,排行榜应用，范围查找，延时应用</span><br><span class="line">	<span class="number">1</span>. 存储：zadd key score value</span><br><span class="line">	<span class="number">2</span>. 获取：zrange key start end [withscores]</span><br><span class="line">	<span class="number">3</span>. 删除：zrem key value</span><br><span class="line">	</span><br><span class="line">通用命令</span><br><span class="line">    <span class="number">1</span>. keys * : 查询所有的键</span><br><span class="line">    <span class="number">2</span>. type key ： 获取键对应的value的类型</span><br><span class="line">    <span class="number">3</span>. del key：删除指定的key value</span><br></pre></td></tr></table></figure>
<p>具有如下优点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</span><br><span class="line">Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</span><br><span class="line">Redis支持数据的备份，即master-slave模式的数据备份</span><br></pre></td></tr></table></figure>
<p> redis的应用场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">•	缓存（数据查询、短连接、新闻内容、商品内容等等）</span><br><span class="line">•	聊天室的在线好友列表</span><br><span class="line">•	任务队列。（秒杀、抢购、12306等等）</span><br><span class="line">•	应用排行榜</span><br><span class="line">•	网站访问统计</span><br><span class="line">•	数据过期处理（可以精确到毫秒</span><br><span class="line">•	分布式集群架构中的session分离</span><br></pre></td></tr></table></figure>
<h5 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">纯内存操作</span><br><span class="line">单线程操作，避免了频繁的上下文切换</span><br><span class="line">采用了非阻塞I/O多路复用机制</span><br></pre></td></tr></table></figure>
<p>我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。 需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110754.png" alt="image-20210407165146422"></p>
<h5 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</span><br><span class="line">2. redis持久化机制：</span><br><span class="line">    1. RDB：默认方式，不需要进行配置，默认就使用这种机制</span><br><span class="line">    * 在一定的间隔时间中，检测key的变化情况，然后持久化数据</span><br><span class="line">    1. 编辑redis.windwos.conf文件</span><br><span class="line">    #   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">    save 900 1</span><br><span class="line">    #   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">    save 300 10</span><br><span class="line">    #   after 60 sec if at least 10000 keys changed</span><br><span class="line">        save 60 10000</span><br><span class="line"></span><br><span class="line">        2. 重新启动redis服务器，并指定配置文件名称</span><br><span class="line">        D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf	</span><br><span class="line"></span><br><span class="line">            2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</span><br><span class="line">            1. 编辑redis.windwos.conf文件</span><br><span class="line">            appendonly no（关闭aof） --&gt; appendonly yes （开启aof）</span><br><span class="line"></span><br><span class="line">            # appendfsync always ： 每一次操作都进行持久化</span><br><span class="line">            appendfsync everysec ： 每隔一秒进行一次持久化</span><br><span class="line">            # appendfsync no	 ： 不进行持久化</span><br></pre></td></tr></table></figure>
<h5 id="redis的过期策略及内存淘汰机制"><a href="#redis的过期策略及内存淘汰机制" class="headerlink" title="redis的过期策略及内存淘汰机制"></a>redis的过期策略及内存淘汰机制</h5><p>redis采用的是定期删除+惰性删除策略。</p>
<p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 </p>
<p><strong>采用定期删除+惰性删除就没其他问题了么?</strong> </p>
<p>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。</p>
<h5 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h5><p>在redis.conf中有一行配置该配置就是配内存淘汰策略的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>
<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。</p>
<p> 2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。 </p>
<p>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。 </p>
<p>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐 </p>
<p>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐</p>
<p>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键<br>空间中，有更早过期时间的key优先移除。不推荐 ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>
<p>4.0 版本后增加以下两种：</p>
<ol start="7">
<li>volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使⽤的数据淘汰</li>
<li>allkeys-lfu（least frequently used）：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最不经常使⽤的 key</li>
</ol>
<p><strong>为什么不用定时删除策略?</strong> </p>
<p>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略. </p>
<h5 id="渐进式ReHash"><a href="#渐进式ReHash" class="headerlink" title="渐进式ReHash"></a>渐进式ReHash</h5><p>扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 rehash 到 <code>ht[1]</code> 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 <code>ht[1]</code> 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。渐进式rehash的好处在于它采取分为而治的方式，将rehash键值对的计算均摊到每个字典增删改查操作，避<br>免了集中式rehash的庞大计算量。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110755.png" alt="img"></p>
<p>在进行渐进式 rehash 的过程中， 字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 <code>ht[0]</code> 里面进行查找， 如果没找到的话， 就会继续到 <code>ht[1]</code> 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面， 而 <code>ht[0]</code> 则不再进行任何添加操作： 这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>概念访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。<br>解决方案：<br>采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；<br>访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。</p>
<h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。<br>解决方案<br>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效；<br>采用限流算法，限制流量；<br>采用分布式锁，加锁访问。</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题<br>实现高性能，高可用，可伸缩和最终一致性架构<br>使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110756.png" alt="image-20210307191714942"></p>
<p>缺点：系统可用性降低、系统复杂性提高：怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性、一致性问题</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110757.png" alt="img"></p>
<h5 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110758.png" alt="img"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110759.png" alt="img"></p>
<h5 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h5><p>场景说明：用户下单后，订单系统需要通知库存系统。传统做法是，订单系统调用库存系统的接口。如下图</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110800.png" alt="image-20210407225046264"></p>
<p>传统模式的缺点：<br>假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，同时，订单系统与库存系统耦合</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110801.png" alt="image-20210407225145007"></p>
<p>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功<br>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作<br>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</p>
<h5 id="流量削锋"><a href="#流量削锋" class="headerlink" title="流量削锋"></a>流量削锋</h5><p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛<br>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。<br>可以控制活动的人数<br>可以缓解短时间内高流量压垮应用</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110802.png" alt="image-20210407225344907"></p>
<p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面<br>秒杀业务根据消息队列中的请求信息，再做后续处理</p>
<h5 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h5><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110803.png" alt="image-20210407225433351"></p>
<p>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列<br>Kafka消息队列，负责日志数据的接收，存储和转发<br>日志处理应用：订阅并消费kafka队列中的日志数据</p>
<h5 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h5><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等<br>点对点通讯：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110804.png" alt="image-20210407225557334"></p>
<p>聊天室通讯：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110805.png" alt="image-20210407225619737"></p>
<h5 id="电商系统"><a href="#电商系统" class="headerlink" title="电商系统"></a>电商系统</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110806.png" alt="image-20210407225743294"></p>
<p>消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。<br>（1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）<br>（2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。<br>（3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。</p>
<h5 id="日志收集系统"><a href="#日志收集系统" class="headerlink" title="日志收集系统"></a>日志收集系统</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110807.png" alt="image-20210407225849548"></p>
<p>为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。<br>Zookeeper注册中心，提出负载均衡和地址查找服务<br>日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列<br>Kafka集群：接收，路由，存储，转发等消息处理<br>Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据</p>
<h5 id="JMS消息服务"><a href="#JMS消息服务" class="headerlink" title="JMS消息服务"></a>JMS消息服务</h5><p>讲消息队列就不得不提JMS 。JMS（JAVA Message Service,java消息服务）API是一个消息服务的标准/规范，允许<br>应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<br>在EJB架构中，有消息bean可以无缝的与JM消息服务集成。在J2EE架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。</p>
<h5 id="两种消息模型P2P（Point-to-Point）-Publish-Subscribe-Pub-Sub"><a href="#两种消息模型P2P（Point-to-Point）-Publish-Subscribe-Pub-Sub" class="headerlink" title="两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)"></a>两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)</h5><p>如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式。</p>
<p>P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。<br>P2P的特点<br>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)，发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列<br>接收者在成功接收消息之后需向队列应答成功</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110808.png" alt="image-20210407230426794"></p>
<p>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</p>
<p>Pub/sub模式包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。<br>Pub/Sub的特点<br>每个消息可以有多个消费者<br>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息<br>为了消费消息，订阅者必须保持运行的状态<br>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运<br>行），它也能接收到发布者的消息。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110809.png" alt="image-20210407230510471"></p>
<p>在JMS中，消息的产生和消费都是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。<br>（1）同步<br>订阅者或接收者通过receive方法来接收消息，receive方法在接收到消息之前（或超时之前）将一直阻塞；<br>（2）异步<br>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</p>
<h5 id="防止消息丢失"><a href="#防止消息丢失" class="headerlink" title="防止消息丢失"></a>防止消息丢失</h5><p>由于网络问题，我们很难保证生产者发送的消息能100%到达消息队列服务器，也就是说有消息丢失的可能性，因此，生产者就必须具有消息丢失检测和重发机制，也就是我们常说的消息队列的事物机制</p>
<p>不能把可靠性的保证全部交给TCP，TCP只保证了传输层的可靠传输，但是无法保证与应用层的交互是否出错<br>TCP无法给应用层任何反馈，因此必须在应用层处理差错<br><strong>同步的事务——停止等待</strong><br>所谓停止等待协议就是没发送完一组数据后，等待对方确认并且收到确认后，再发送下一组数据。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110810.png" alt="image-20210407230625065"></p>
<p><strong>同步的事务——连续ARQ</strong><br>类似于TCP的滑动窗口模型</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110811.png" alt="image-20210407230654497"></p>
<p><strong>异步的事务——回调机制</strong><br>生产者在发送消息的时候，注册一个回调函数，这样生产者便不用停下来等待确认了，而是可以一直持续发送消<br>息，当消息到达消息队列服务器的时候，服务器便会调用生产者注册的回调函数，告知生产者消息发送成功了还是<br>失败了，进而做进一步的处理，从而提高了并发量。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110812.png" alt="image-20210407230718032"></p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><h5 id="dns域名解析负载均衡"><a href="#dns域名解析负载均衡" class="headerlink" title="dns域名解析负载均衡"></a>dns域名解析负载均衡</h5><p>原理：在DNS服务器上配置多个域名对应IP的记录。例如一个域名<a href="http://www.baidu.com对应一组web服务器IP地址，域名解析时经过DNS服务器的算法将一个域名请求分配到合适的真实服务器上。" target="_blank" rel="noopener">www.baidu.com对应一组web服务器IP地址，域名解析时经过DNS服务器的算法将一个域名请求分配到合适的真实服务器上。</a></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110813.png" alt="image-20210408160022369"></p>
<p>优点：将负载均衡的工作交给了DNS，省却了网站管理维护负载均衡服务器的麻烦，许多DNS还支持基于地<br>理位置的域名解析，将域名解析成距离用户地理最近的一个服务器地址，加快访问速度，改善性能。<br>缺点：目前的DNS解析是多级解析，每一级DNS都可能缓存记录A，当某一服务器下线后，该服务器对应的DNS<br>记录A可能仍然存在，导致分配到该服务器的用户访问失败。<br>DNS负载均衡的控制权在域名服务商手里，网站可能无法做出过多的改善和管理。<br>不能够按服务器的处理能力来分配负载。DNS负载均衡采用的是<strong>简单的轮询算法</strong>，不能区分服务器之间的差异，<br>不能反映服务器当前运行状态，所以其的负载均衡效果并不是太好。<br>可能会造成额外的网络问题。为了使本DNS服务器和其他DNS服务器及时交互，保证DNS数据及时更新，使地址<br>能随机分配，一般都要将DNS的刷新时间设置的较小，但太小将会使DNS流量大增造成额外的网络问题。</p>
<h5 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h5><p>原理：反向代理处于web服务器这边，反向代理服务器提供负载均衡的功能，同时管理一组web服务器，它根据负载均衡算法将请求的浏览器访问转发到不同的web服务器处理，处理结果经过反向服务器返回给浏览器。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110814.png" alt="image-20210408160246561"></p>
<p>例如：浏览器访问请求的地址是反向代理服务器的地址114.100.80.10，反向代理服务器收到请求，经过负载均衡算法后得到一个真实物理地址10.0.03，并将请求结果发给真实无服务，真实服务器处理完后通过反向代理服务器返回给请求用户。<br>优点：部署简单，处于http协议层面。<br>缺点：使用了反向代理服务器后，web 服务器地址不能直接暴露在外，因此web服务器不需要使用外部IP地址，<br>而反向代理服务作为沟通桥梁就需要配置双网卡、外部内部两套IP地址。</p>
<h5 id="http重定向协议实现负载均衡"><a href="#http重定向协议实现负载均衡" class="headerlink" title="http重定向协议实现负载均衡"></a>http重定向协议实现负载均衡</h5><p>原理：根据用户的http请求计算出一个真实的web服务器地址，并将该web服务器地址写入http重定向响应中返回给浏览器，由浏览器重新进行访问。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110815.png" alt="image-20210408160410793"></p>
<p>优点：比较简单<br>缺点：浏览器需要两次次请求服务器才能完成一次访问，性能较差。<br>http重定向服务器自身的处理能力可能成为瓶颈。<br>使用http302响应重定向，有可能使搜索引擎判断为SEO作弊，降低搜索排名。</p>
<h5 id="一致性hash-虚拟节点"><a href="#一致性hash-虚拟节点" class="headerlink" title="一致性hash+虚拟节点"></a>一致性hash+虚拟节点</h5><p><strong>一致性hash</strong>——改进的分布式方法</p>
<p>1）求出服务器节点的哈希值， 将其配置到0～232的圆上；</p>
<p>2）用同样的方法求出存储数据的键的哈希值并映射到圆上；</p>
<p>3）从数据映射到的位置开始顺时针查找，将数据保存到找到的第一台服务器上；</p>
<p>4）如果超过232仍然找不到服务器，就保存到第一台服务器上。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110816.png" alt="image-20210408161138645"></p>
<p><strong>虚拟节点：</strong> </p>
<p>使用一般的hash函数，服务器的映射地点的分布可能出现不均匀的情况。</p>
<p>  为每个物理节点（服务器）在圆环上分配100～200个点，从而抑制分布不均匀，最大限度地减小服务器增减时的缓存重新分布。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110817.jpg" alt="img"></p>
<h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><h5 id="ZK简述"><a href="#ZK简述" class="headerlink" title="ZK简述"></a>ZK简述</h5><p>Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架， 它负责存储和管理大家都关心的数据， 然后接受观察者的注册， 一旦这些数据的状态发生变化， Zookeeper就将负责通知已经在<br>Zookeeper上注册的那些观察者做出 相应 的反 应 ， 从而 实现集群中类似Master/Slave管理模式</p>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110818.png" alt="image-20210408164737111"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110819.png" alt="image-20210408164850759"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">此外，znode还有操作权限。如果我们把以上几类属性细化，又可以得到以下属性的细节：</span><br><span class="line">czxid：创建节点的事务的zxid</span><br><span class="line">mzxid：对znode最近修改的zxid</span><br><span class="line">ctime：以距离时间原点(epoch)的毫秒数表示的znode创建时间</span><br><span class="line">mtime：以距离时间原点(epoch)的毫秒数表示的znode最近修改时间</span><br><span class="line">version：znode数据的修改次数</span><br><span class="line">cversion：znode子节点修改次数</span><br><span class="line">aversion：znode的ACL修改次数</span><br><span class="line">ephemeralOwner：如果znode是临时节点，则指示节点所有者的会话ID；如果不是临时节点，则为零。</span><br><span class="line">dataLength：znode数据长度。</span><br><span class="line">numChildren：znode子节点个数。</span><br></pre></td></tr></table></figure>
<p>znode中的存在类型<br>我们知道了zookeeper内部维护了一套数据结构：由znode构成的集合，znode的集合又是一个树形结构。每一个znode又有很多属性进行描述。并且znode的存在性还分为四类，如下如所示：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110820.png" alt="image-20210408165138724"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">znode是由客户端创建的，它和创建它的客户端的内在联系，决定了它的存在性：</span><br><span class="line">PERSISTENT-持久化节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点也不会被删除（除非您使用API强制删除）。</span><br><span class="line">PERSISTENT_SEQUENTIAL-持久化顺序编号节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当客户端与zookeeper服务的连接断开后，这个节点也不会被删除。</span><br><span class="line">EPHEMERAL-临时目录节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点（还有涉及</span><br><span class="line">到的子节点）就会被删除。</span><br><span class="line">EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当创建这个节点的客户端与zookeeper服务的连接断开后，这个节点被删除。</span><br><span class="line">另外，无论是EPHEMERAL还是EPHEMERAL_SEQUENTIAL节点类型，在zookeeper的client异常终止后，节</span><br><span class="line">点也会被删除。</span><br></pre></td></tr></table></figure>
<h5 id="统一命名服务"><a href="#统一命名服务" class="headerlink" title="统一命名服务"></a>统一命名服务</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110821.png" alt="image-20210408165643277"></p>
<h5 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110822.png" alt="image-20210408165657899"></p>
<h5 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110823.png" alt="image-20210408165714977"></p>
<h5 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110824.png" alt="image-20210408165736904"></p>
<h5 id="服务器动态上下线"><a href="#服务器动态上下线" class="headerlink" title="服务器动态上下线"></a>服务器动态上下线</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110825.png" alt="image-20210408165752431"></p>
<h5 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h5><p>Zookeeper提供的是 弱一致性，CAP限制，读的的数据可能不是最新的，如果想读到最新的数据，应该手动调用sync方法从Leader同步数据</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110826.png" alt="image-20210408165826077"></p>
<h5 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h5><p>ZK的Leader负责同步数据，发起选举<br>1）半数机制：集群中半数以上机器存活，集群可用。所以zookeeper适合装在奇数台机器上。<br>2）Zookeeper虽然在配置文件中并没有指定master和slave。但是，zookeeper工作时，是有一个节点为leader，<br>其他则为follower，Leader是通过内部的选举机制临时产生的<br>3）以一个简单的例子来说明整个选举的过程。<br>假设有五台服务器组成的zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110827.png" alt="image-20210408165856735"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）服务器1启动，此时只有它一台服务器启动了，它发出去的报没有任何响应，所以它的选举状态一直是</span><br><span class="line">LOOKING状态。</span><br><span class="line">（2）服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，</span><br><span class="line">所以id值较大的服务器2胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是</span><br><span class="line">3)，所以服务器1、2还是继续保持LOOKING状态。</span><br><span class="line">（3）服务器3启动，根据前面的理论分析，服务器3成为服务器1、2、3中的老大，而与上面不同的是，此时有三</span><br><span class="line">台服务器选举了它，所以它成为了这次选举的leader。</span><br><span class="line">（4）服务器4启动，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是由于前面已经有半</span><br><span class="line">数以上的服务器选举了服务器3，所以它只能接收当小弟的命了。</span><br><span class="line">（5）服务器5启动，同4一样当小弟</span><br></pre></td></tr></table></figure>
<h4 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h4><h5 id="业务特点"><a href="#业务特点" class="headerlink" title="业务特点"></a>业务特点</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110828.png" alt="image-20210408095317899"></p>
<h5 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h5><p><strong>现有业务的冲击</strong><br>秒杀是营销活动中的一种，如果和其他营销活动应用部署在同一服务器上，肯定会对现有其他活动造成冲击，极端情况下可能导致整个电商系统服务宕机。<br><strong>直接下订单</strong><br>下单页面是一个正常的 URL 地址，需要控制在秒杀开始前，不能下订单，只能浏览对应活动商品的信息。简单来说，需要 Disable 订单按钮。<br><strong>页面流量突增</strong><br>秒杀活动开始前后，会有很多用户请求对应商品页面，会造成后台服务器的流量突增，同时对应的网络带宽增加，需要控制商品页面的流量不会对后台服务器、DB、Redis 等组件的造成过大的压力</p>
<h5 id="架构设计思想"><a href="#架构设计思想" class="headerlink" title="架构设计思想"></a>架构设计思想</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110829.png" alt="image-20210408095639159"></p>
<h5 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h5><p>客户端优化主要有两个问题：<br><strong>秒杀页面</strong><br>秒杀活动开始前，其实就有很多用户访问该页面了。如果这个页面的一些资源，比如 CSS、JS、图片、商品详情<br>等，都访问后端服务器，甚至 DB 的话，服务肯定会出现不可用的情况。所以一般我们会把这个页面整体进行静态化，并将页面静态化之后的页面分发到 CDN 边缘节点上，起到压力分散的作用。<br><strong>防止提前下单</strong><br>防止提前下单主要是在静态化页面中加入一个 JS 文件引用，该 JS 文件包含活动是否开始的标记以及开始时的动态下单页面的 URL 参数。同时，这个 JS 文件是不会被 CDN 系统缓存的，会一直请求后端服务的，所以这个 JS 文件一定要很小。当活动快开始的时候（比如提前），通过后台接口修改这个 JS 文件使之生效。</p>
<h5 id="API-接入层优化"><a href="#API-接入层优化" class="headerlink" title="API 接入层优化"></a>API 接入层优化</h5><p>客户端优化，对于不是搞计算机方面的用户还是可以防止住的。但是稍有一定网络基础的用户就起不到作用了，他会自己写post,因此服务端也需要加些对应控制，不能信任客户端的任何操作。一般控制分为 2 大类：<br><strong>限制用户维度访问频率</strong><br>针对同一个用户（ Userid 维度），做页面级别缓存，单元时间内的请求，统一走缓存，返回同一个页面。<br><strong>限制商品维度访问频率</strong><br>大量请求同时间段查询同一个商品时，可以做页面级别缓存，不管下回是谁来访问，只要是这个页面就直接返回。</p>
<h5 id="秒杀整体流程图"><a href="#秒杀整体流程图" class="headerlink" title="秒杀整体流程图"></a>秒杀整体流程图</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414110830.png" alt="image-20210408102940798"></p>
<p>通过上面流程图就会发现压力最大的地方在哪里？<br>MQ 排队服务，只要 MQ 排队服务顶住，后面下订单与扣减库存的压力都是自己能控制的，根据数据库的压力，可以定制化创建订单消费者的数量，避免出现消费者数据量过多，导致数据库压力过大或者直接宕机。<br>库存服务专门为秒杀的商品提供库存管理，实现提前锁定库存，避免超卖的现象。同时，通过超时处理任务发现已抢到商品，但未付款的订单，并在规定付款时间后，处理这些订单，将恢复订单商品对应的库存量。</p>
<p>总结核心思想：<strong>层层过滤</strong><br>尽量将请求拦截在上游，降低下游的压力<br>充分利用缓存与消息队列，提高请求处理速度以及削峰填谷的作用</p>
<h4 id="素质测评"><a href="#素质测评" class="headerlink" title="素质测评"></a>素质测评</h4><h5 id="文字理解能力考查"><a href="#文字理解能力考查" class="headerlink" title="文字理解能力考查"></a>文字理解能力考查</h5><p>这个主要是看语言的理解能力，紧跟材料就可以，往往是考察大家的分析能力和阅读能力，一般不会有那种刻意饶的陷阱，就是注意不要主观的臆测，一切以所给的材料为主就可以。</p>
<p>做这种题目很忌讳同学们不认真读材料，仅靠判断选项就得出答案，其实选项往往都是正确，而题目考察的是选项与材料的关联度，不仅仅是选项本身观点的正确与否；还有一种是同学们容易犯的错误，容易过度解读，属于“想的太多”，也容易曲解出题人的本意、</p>
<p><strong>还有一种是要求你从所给的四个选项中选出一个填空，使句子的意思表达得最准确：</strong></p>
<h5 id="数字推理能力考查"><a href="#数字推理能力考查" class="headerlink" title="数字推理能力考查"></a>数字推理能力考查</h5><p>这个考察比较多的，一般就是小学奥数或者公务员行测中的那种数字推理填空题，总体上不难，但是要求考生对数字比较敏感，或者是掌握了一定答题套路，知道从哪几种常见规律入手。</p>
<p><strong>技巧总结：这就要求我们对于常见的等差或等比的数量关系比较熟悉，因为数字与数字之间的差值往往就是这几种关系的组合。</strong></p>
<p>如</p>
<p>1、差值是<strong>固定递增的关系</strong>：1，3，5，7，9或者2，4，6，8，10等等</p>
<p>2、<strong>平方递增的关系</strong>，就要对于平方关系比较熟悉：4（2的平方），9（3），16（4），25（5），36，49，64，81，100，121，144，169，196，225，256，289，324，361，400…最好是1~20的平方自己都能背出来</p>
<p>3、<strong>立方关系</strong>：8（2的立方），27（3），64（4），125，216，343，512，729，1000…最好1`10的立方能够自己背下来</p>
<p>4、<strong>质数关系</strong>：2，3，5，7，11，13，17，19，23，29….</p>
<p>5、<strong>开方关系</strong>：2（4的开方），3（9），4（16）….</p>
<p>如<strong>例题2</strong>：1，3，5，7，（）…这里是9，差值是2</p>
<p>1，2，6，15，31，（）…这里是56，差值是平方</p>
<p>1，2，10，37，（）…这里是101，差值是立方</p>
<p><strong>例题3</strong>：0，9，26，65，124，（）</p>
<p>A．165 B．193 C．217 D．239</p>
<p><strong>解答：</strong>数列中除了0、9是多次方数，其他的三个附件有多次方数，如26有25、27，65有64，124有125、121，分析差值情况，显然只能选项差为1的，所以将他们转化为多次方的形式就很清楚，1的三次方-1，2的三次方+1，3的三次方-1，4的三次方+1，5的三次方-1，6的三次方+1，所以答案很清楚选C。当然这里面也加入了奇偶列的考察。</p>
<p><strong>技巧在总结：上面的这些规律都可以跟奇偶列数结合来考察同学，所以考察的方式是多样的</strong>，一般而言如果数列的数都较小，且比较分散，我们就要采用做和或者做积的方法来尝试，可以是两两做和，也可以是三三做和。当数列的最后一项或者是给出的选项变化较大的时候，我们基本可以判定数列为递推数列，且为倍数、乘积或者是方递推数列。</p>
<p><strong>例题4：</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104632.jpg" alt="img"></p>
<p><strong>解析：</strong>像这种分数的也是一样，要学会去找两个数字之间的关系，我们发现前一个分数的分子加分母的值，等于后面一个分数分母的值，所以很快可以判断出答案选A。</p>
<p><strong>技巧总结：</strong>一般我们判断，在同一个数列中，分数的个数多于整数个数时，定义此为分数数列，在解答时用到的技巧主要有：约分、通分、反约分、做差、做积或者考虑前后项的关系。</p>
<p>而在同一个数列中，当分数的个数少于整数个数时，如果：</p>
<p>1、数列看起来好像两头小，中间大，此时应考虑多次方数列；</p>
<p>2、数列具有单调性，且只有一项或者两项分数，此时考虑等比数列或者递推数列，递推的规律是前两项的和或者乘积除以某个数值。</p>
<h5 id="图像推理能力考查"><a href="#图像推理能力考查" class="headerlink" title="图像推理能力考查"></a>图像推理能力考查</h5><p><strong>技巧总结：</strong></p>
<p>\1. 图形相同看位置——平移，旋转，翻转（注意位置移动的方向和距离；时针法判断旋转和翻转）。</p>
<p>2、图形相似看样式 ——遍历，运算。遍历指的是每行或列有相同个数的组成元素，但排列不同，</p>
<p>3、图形杂乱看属性和数量——对称，曲直，封闭和点线面角素：属性： 封闭，曲直，对称——注意对称轴的方位和数量；点——线线接触时数点：交点，顶点，割点，切点；线——线多，数线条，优先数直线；面——所给图形有明显的区域划分（封闭区间）；角——（180度以内的内角）题中有扇形出现时——数角；棱角分明且多的图形——数角；素（部分）——图形的组成元，或者有几个独立的部分组成</p>
<p>4、折叠图形先看特征面，再看双面关系，旋转确定三面关系；</p>
<p><strong>例题1</strong>：</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104633.jpg" alt="img"></p>
<p>因为在第一套图形中多边形均有一条边双线，在第二套图形中均有二条相邻的边双线。所以选C，当然，这是最简单的一种考题。</p>
<p><strong>例题2：</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104634.jpg" alt="img"></p>
<p><strong>【解答】</strong>D。本题属于数量类。按照“直线居多数直线”的原则，发现每一列的第一个图形的直线数减去第二个等于第三个。</p>
<p><strong>例题3：</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104635.jpg" alt="img"></p>
<p><strong>【解答】</strong>B。本题属于数量类。数面，都有1个封闭区间，选B。</p>
<p><strong>例题4：</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104636.jpg" alt="img"></p>
<p><strong>【解答】B，</strong>本题属于样式类。求同，每一行三个图形都有一个相同元素，第三行都有一平行四边形。</p>
<p><strong>例题5：</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104637.jpg" alt="img"></p>
<p><strong>【解答】</strong>D。本题属于样式类。分别是横轴对称、竖轴对称、横竖轴对称、横竖轴对称、竖轴对称，所以选D。</p>
<p><strong>例题6：</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104638.jpg" alt="img"></p>
<p><strong>【解答】</strong>B。平面组成型，元素相同看时针方向，四个扇形组成相同，从黑点向白点画一个箭头，发现四个扇形都是顺时针方向，选B。</p>
<p><strong>例题7：</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210414104639.jpg" alt="img"></p>
<p><strong>【解答】</strong>A。本题属于位置类。在图形外面的曲线上添上箭头，会发现，每一行的第一个图形与第三个图形方向一样，第二个方向相反，所以选A。</p>
<h3 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h3><h4 id="JavaSTL"><a href="#JavaSTL" class="headerlink" title="JavaSTL"></a>JavaSTL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(Object anObject)</span> ：将此字符串与指定对象进行比较。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span> <span class="params">(String anotherString)</span> ：将此字符串与指定对象比较，忽略大小写。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span> <span class="params">()</span> ：返回此字符串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span> <span class="params">(String str)</span> ：将指定的字符串连接到该字符串的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span> <span class="params">(<span class="keyword">int</span> index)</span> ：返回指定索引处的 <span class="keyword">char</span>值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span> <span class="params">(String str)</span> ：返回指定子字符串第一次出现的索引。如果没有返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex)</span> ：返回一个子字符串，从beginIndex开始截取到结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ：含beginIndex，不含endIndex</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span>[] <span class="title">toCharArray</span> <span class="params">()</span> ：将此字符串转换为新的字符数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">getBytes</span> <span class="params">()</span> ：使用平台的默认字符集将该 String编码转换为新的字节数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span> <span class="params">(CharSequence target, CharSequence replacement)</span> ：、后者替换前者。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">split</span><span class="params">(String regex)</span> ：regex（规则）拆分为字符串数组。“,|</span>=”表示分割符分为“，”和“=”</span><br><span class="line">trim()方法返回字符串的副本，忽略前导空格和尾部空格。</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">()</span>方法与<span class="title">endsWith</span><span class="params">()</span>方法分别用于判断字符串是否以指定的内容开始或结束。</span></span><br><span class="line"><span class="function"><span class="title">toLowerCase</span><span class="params">()</span>大写字母改写为小写字母，而<span class="title">tuUpperCase</span><span class="params">()</span>方法将小写字母改写为大写字母。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印list</span></span><br><span class="line">System.out.println(Arrays.toString(list.toArray()));</span><br><span class="line"><span class="comment">//拷贝数组src从0开始拷贝到dest,包含0，不包含3</span></span><br><span class="line">System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">STLUse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================arraylist================"</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.contains(<span class="keyword">new</span> Integer(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.print(list.get(i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.print(it.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ACID</span></span><br><span class="line">        list.add(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">        System.out.println(list.indexOf(<span class="number">3</span>));</span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="number">3</span>));</span><br><span class="line">        list.remove(<span class="number">2</span>);</span><br><span class="line">        list.remove(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">        list.set(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Collections 交换</span></span><br><span class="line">        Collections.swap(list, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//最大max 最小min</span></span><br><span class="line">        <span class="comment">//static int binaryScarch ( List list,Object key)</span></span><br><span class="line">		<span class="comment">//使用二分法搜索指定对象在List集合中的索引，查找的 List集合中的元素必须是有序的</span></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// o1排在o2后面,返回值大于0 ，来查看升序还是降序</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">        System.out.println(<span class="string">"================linklist================"</span>);</span><br><span class="line">        list.addFirst(<span class="number">1</span>);</span><br><span class="line">        list.addLast(<span class="number">9</span>);</span><br><span class="line">        list.getFirst();</span><br><span class="line">        list.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================queue================"</span>);</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        q.offer(<span class="number">1</span>);</span><br><span class="line">        q.offer(<span class="number">2</span>);</span><br><span class="line">        q.offer(<span class="number">3</span>);</span><br><span class="line">        q.offer(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// q.element();//返回队头</span></span><br><span class="line">        System.out.println(q.peek());</span><br><span class="line">        <span class="comment">// q.remove();//移除并返回队头</span></span><br><span class="line">        System.out.println(q.poll());</span><br><span class="line">        System.out.println(q.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================stack================"</span>);</span><br><span class="line">        LinkedList&lt;Integer&gt; s = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.peek());</span><br><span class="line">        System.out.println(s.pop());</span><br><span class="line">        System.out.println(s.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无序不可重复,非线程安全的</span></span><br><span class="line">    <span class="comment">// 首先，hashCode()方法返回的是一个哈希值，这个哈希值是由对象在内存中的地址所形成的，</span></span><br><span class="line">    <span class="comment">// 如果两个对象的哈希值不一样，那么这两个对象肯定是不相同的，如果哈希值一样，那么这还不能肯定这两个对象是否一样，</span></span><br><span class="line">    <span class="comment">// 还需要通过equlas()方法比较一下两个对象是否一样，equals()返回true才能说明这两个对象是相同的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hashset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================hashset================"</span>);</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        set.add(<span class="string">"123"</span>);</span><br><span class="line">        set.add(<span class="string">"456"</span>);</span><br><span class="line">        set.add(<span class="string">"zsy"</span>);</span><br><span class="line">        set.add(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        set.remove(<span class="string">"zsy"</span>);</span><br><span class="line">        set.remove(<span class="keyword">new</span> String(<span class="string">"456"</span>));</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非线程安全的，排序规则是默认使用元素的自然排序,重不重复也是通过compareTo()方法来完成的，当compareTo()方法返回值为0时，两个对象是相同的。</span></span><br><span class="line">    <span class="comment">// LinkedHashSet将会以元素的放入顺序来依次访问</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">treeset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================treeset================"</span>);</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        set.add(<span class="string">"123"</span>);</span><br><span class="line">        set.add(<span class="string">"963"</span>);</span><br><span class="line">        set.add(<span class="string">"125"</span>);</span><br><span class="line">        set.add(<span class="string">"456"</span>);</span><br><span class="line">        set.add(<span class="string">"zsy"</span>);</span><br><span class="line">        set.add(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        set.remove(<span class="string">"zsy"</span>);</span><br><span class="line">        set.remove(<span class="keyword">new</span> String(<span class="string">"456"</span>));</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hashmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================hashmap================"</span>);</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        map.put(<span class="string">"zsy"</span>, <span class="number">93</span>);</span><br><span class="line">        map.put(<span class="string">"syz"</span>, <span class="number">86</span>);</span><br><span class="line">        map.put(<span class="string">"ysz"</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.通过遍历键的Set集合来遍历整个Map集合</span></span><br><span class="line">        System.out.println(<span class="string">"foreach遍历"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : map.keySet()) &#123;</span><br><span class="line">            System.out.println(str + <span class="string">":"</span> + map.get(str));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"迭代器遍历"</span>);</span><br><span class="line">        Iterator&lt;String&gt; intertor = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (intertor.hasNext()) &#123;</span><br><span class="line">            String key = intertor.next();</span><br><span class="line">            System.out.println(key + <span class="string">":"</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.使用Map集合的关系遍历</span></span><br><span class="line">        System.out.println(<span class="string">"Map关系遍历"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以key排序用treemap</span></span><br><span class="line">        TreeMap treemap = <span class="keyword">new</span> TreeMap(map); </span><br><span class="line">		<span class="comment">//以value排序，先转为list</span></span><br><span class="line">        ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">        Collections.sort(entries, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());<span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        map.remove(<span class="string">"zsy"</span>);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">treemap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"================treemap================"</span>);</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;String, Integer&gt;();</span><br><span class="line">        map.put(<span class="string">"zsy"</span>, <span class="number">93</span>);</span><br><span class="line">        map.put(<span class="string">"syz"</span>, <span class="number">86</span>);</span><br><span class="line">        map.put(<span class="string">"ysz"</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.通过遍历键的Set集合来遍历整个Map集合</span></span><br><span class="line">        System.out.println(<span class="string">"foreach遍历"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : map.keySet()) &#123;</span><br><span class="line">            System.out.println(str + <span class="string">":"</span> + map.get(str));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"迭代器遍历"</span>);</span><br><span class="line">        Iterator&lt;String&gt; intertor = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (intertor.hasNext()) &#123;</span><br><span class="line">            String key = intertor.next();</span><br><span class="line">            System.out.println(key + <span class="string">":"</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.使用Map集合的关系遍历</span></span><br><span class="line">        System.out.println(<span class="string">"Map关系遍历"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.remove(<span class="string">"zsy"</span>);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        arrayList();</span><br><span class="line">        linklist();</span><br><span class="line">        queue();</span><br><span class="line">        stack();</span><br><span class="line">        hashset();</span><br><span class="line">        treeset();</span><br><span class="line">        hashmap();</span><br><span class="line">        treemap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><h5 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];<span class="comment">//中间数最好</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//while (q[++i] &lt; x);</span></span><br><span class="line">		<span class="comment">//while (q[--j] &gt; x);</span></span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, j), quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--more-->
<h5 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="comment">//多出来的合并</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h5><p>整数二分算法模板 —— 模板题 AcWing 789. 数的范围</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161114.png" alt="image-20210325214301736"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：//有减要加1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Java语法糖，秒杀高精度</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader cin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String[] s = cin.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        BigInteger n = <span class="keyword">new</span> BigInteger(s[<span class="number">0</span>]);</span><br><span class="line">        s = cin.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        BigInteger m = <span class="keyword">new</span> BigInteger(s[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(m.add(n));</span><br><span class="line">        System.out.println(n.subtract(m));</span><br><span class="line">        System.out.println(n.multiply(m));</span><br><span class="line">        System.out.println(n.divide(m));</span><br><span class="line">        System.out.println(n.remainder(m));<span class="comment">//取余</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">高精度加法 —— 模板题 AcWing <span class="number">791</span>. 高精度加法</span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size()) <span class="keyword">return</span> add(B, A);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line">高精度减法 —— 模板题 AcWing <span class="number">792</span>. 高精度减法</span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i];</span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//去除前面的0</span></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line">高精度乘低精度 —— 模板题 AcWing <span class="number">793</span>. 高精度乘法</span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line">高精度除以低精度 —— 模板题 AcWing <span class="number">794</span>. 高精度除法</span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(), C.end());</span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h5><p>一维前缀和 —— 模板题 AcWing 795. 前缀和</p>
<p>输入一个长度为 n 的整数序列。输出原序列中从第 l 个数到第 r 个数的和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>二维前缀和 —— 模板题 AcWing 796. 子矩阵的和</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161111.png" alt="image-20210104161136636"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第i行j列格子左上部分所有元素的和</span><br><span class="line">S[i, j] = S[i-1,j]+S[i,j-1]-S[i-1,j-1]+a[i,j]</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</span><br></pre></td></tr></table></figure>
<h5 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h5><p>一维差分 —— 模板题 AcWing 797. 差分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure>
<p>二维差分 —— 模板题 AcWing 798. 差分矩阵</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">B[x1, y1] += c, B[x2 + <span class="number">1</span>, y1] -= c, B[x1, y2 + <span class="number">1</span>] -= c, B[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br></pre></td></tr></table></figure>
<h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：lowbit(n) = n&amp;-n=n&amp;(~n+<span class="number">1</span>)  x=<span class="number">1010</span> lowbit(x)=<span class="number">10</span></span><br><span class="line">整数的二进制表示中的最右边一个<span class="number">1</span>变成<span class="number">0</span>：n = (n - <span class="number">1</span>) &amp; n;</span><br></pre></td></tr></table></figure>
<h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">(<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">(<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure>
<h5 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line">sort(alls.begin(), alls.end()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.erase(unique(alls.begin(), alls.end()), alls.end());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    sort(segs.begin(), segs.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = max(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h5><p>回溯算法其实就是不断尝试的过程，一旦尝试成功了，就算成功了，如果尝试失败了还会回到上一步，注意回到上一步的时候还要把状态还原到上一步的状态。回溯算法这里就不在过多介绍，关于回溯算法的 可以看下450，什么叫回溯算法，一看就会，一写就废。</p>
<p>回溯算法其实有一个经典的模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void backtrack(&quot;原始参数&quot;) &#123;</span><br><span class="line">    //终止条件(递归必须要有终止条件)</span><br><span class="line">    if (&quot;终止条件&quot;) &#123;</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = &quot;for循环开始的参数&quot;; i &lt; &quot;for循环结束的参数&quot;; i++) &#123;</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line"></span><br><span class="line">        //做出选择</span><br><span class="line"></span><br><span class="line">        //递归</span><br><span class="line">        backtrack(&quot;新的参数&quot;);</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line"></span><br><span class="line">        //撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h3><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161113.png" alt="image-20210325214000189"></p>
<h5 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161112.png" alt="image-20210104145246880"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 读入数据的代码</span></span><br><span class="line">        Scanner reader = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 物品的数量为N</span></span><br><span class="line">        <span class="keyword">int</span> N = reader.nextInt();</span><br><span class="line">        <span class="comment">// 背包的容量为V</span></span><br><span class="line">        <span class="keyword">int</span> V = reader.nextInt();</span><br><span class="line">        <span class="comment">// 一个长度为N的数组，第i个元素表示第i个物品的体积；</span></span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>] ;</span><br><span class="line">        <span class="comment">// 一个长度为N的数组，第i个元素表示第i个物品的价值；</span></span><br><span class="line">        <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">            <span class="comment">// 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值</span></span><br><span class="line">            v[i] = reader.nextInt();</span><br><span class="line">            w[i] = reader.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正式工作的代码</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个二阶矩阵dp[N+1][V+1],</span></span><br><span class="line"><span class="comment">        这里之所以要N+1和V+1，是因为第0行表示只能选择第0个物品的时候，即没有物品的时候</span></span><br><span class="line"><span class="comment">        第0列表示背包的体积为0的时候，即不能装任何东西的时候</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        dp[i][j]表示在 只能选择前i个物品，背包容量为j的情况下，背包中物品的最大价值</span></span><br><span class="line"><span class="comment">        对于dp[i][j]有两种情况：</span></span><br><span class="line"><span class="comment">        1. 不选择当前的第i件物品/第i件物品比背包容量要大，则dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="comment">        2. 选择当前的第i件物品（潜在要求第i件物品体积小于等于背包总容量），则能装入的物品最大价值为：</span></span><br><span class="line"><span class="comment">            当前物品的价值 加上 背包剩余容量在只能选前i-1件物品的情况下的最大价值</span></span><br><span class="line"><span class="comment">            dp[i][j] = dp[i-1][j-v[i]] + w[i]</span></span><br><span class="line"><span class="comment">        dp[i][j]在两种情况中选择比较大的情况作为当前的最优解；</span></span><br><span class="line"><span class="comment">        即：</span></span><br><span class="line"><span class="comment">        if(j &gt;= v[i]):</span></span><br><span class="line"><span class="comment">            dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])</span></span><br><span class="line"><span class="comment">        else:</span></span><br><span class="line"><span class="comment">            dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i])&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-v[i]] + w[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[N][V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有优化版</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. f[i] 仅用到了f[i-1]层, </span></span><br><span class="line"><span class="comment">2. j与j-v[i] 均小于j</span></span><br><span class="line"><span class="comment">3.若用到上一层的状态时,从大到小枚举, 反之从小到大哦</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意，这里第二层循环的时候，还是小到大循环的话，那么</span></span><br><span class="line"><span class="comment"> dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])</span></span><br><span class="line"><span class="comment">实际上变成了</span></span><br><span class="line"><span class="comment">dp[i][j] = Math.max(dp[i][j], dp[i][j-v[i]] + w[i]);</span></span><br><span class="line"><span class="comment">因为i-1的值已经在前面被更新过了，覆盖了</span></span><br><span class="line"><span class="comment">为了避免这个问题，所以要逆序更新，即先更新第i个，然后更新第i-1个，从而保证第i-1个不被覆盖</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> V=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] v=<span class="keyword">new</span> <span class="keyword">int</span> [N+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>[] w=<span class="keyword">new</span> <span class="keyword">int</span> [N+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        v[i]=sc.nextInt();</span><br><span class="line">        w[i]=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];<span class="comment">//多开</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v[i];j--)&#123;</span><br><span class="line">            f[j]=Math.max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(f[V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161115.png" alt="image-20210325211930272"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会爆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> V=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] v=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] w=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        v[i]=sc.nextInt();</span><br><span class="line">        w[i]=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[][]=<span class="keyword">new</span> <span class="keyword">int</span> [N+<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=V;j++)&#123;<span class="comment">//体积</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*v[i]&lt;=j;k++)&#123;<span class="comment">//枚举k ,找最大</span></span><br><span class="line">                dp[i][j]=Math.max(dp[i][j],dp[i-<span class="number">1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[N][V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161116.png" alt="image-20210325215256820"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> V=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] v=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] w=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        v[i]=sc.nextInt();</span><br><span class="line">        w[i]=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[][]=<span class="keyword">new</span> <span class="keyword">int</span> [N+<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=V;j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i])dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[N][V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在优化为一维</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> V=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] v=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] w=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        v[i]=sc.nextInt();</span><br><span class="line">        w[i]=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[]=<span class="keyword">new</span> <span class="keyword">int</span> [V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=V;j++)&#123;</span><br><span class="line">            dp[j]=Math.max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161117.png" alt="image-20210325230403204"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f[i][j]=Math.max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); k=0,1,2,3,...s[i]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> V=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] v=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] w=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] s=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        v[i]=sc.nextInt();</span><br><span class="line">        w[i]=sc.nextInt();</span><br><span class="line">        s[i]=sc.nextInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> [][]f=<span class="keyword">new</span> <span class="keyword">int</span> [N+<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++)&#123;<span class="comment">//枚举k,不超过s[i]</span></span><br><span class="line">                f[i][j]=Math.max(f[i][j],f[i-<span class="number">1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(f[N][V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> V=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> [] s=<span class="keyword">new</span> <span class="keyword">int</span> [N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[][] v=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">int</span>[][] w=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][<span class="number">1013</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        s[i]=sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)&#123;</span><br><span class="line">            v[i][j]=sc.nextInt();</span><br><span class="line">            w[i][j]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[][]=<span class="keyword">new</span> <span class="keyword">int</span> [N+<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=V;j++)&#123;<span class="comment">//体积</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])dp[i][j]=Math.max(dp[i][j],dp[i-<span class="number">1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[N][V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。</p>
<h5 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210519111500.png" alt="数组表示单链表.png"></p>
<p>为什么使用数组来模拟链表<br>如果数据规模很大, 一个一个的new操作太慢了, 会超时, 使用数组会大大加快速度</p>
<p>单链表<br>数组模拟单链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>;  <span class="comment">// 数据规模为 10w</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> head;                <span class="comment">// 表示头结点的下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[N];    <span class="comment">// 表示结点 i的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ne = <span class="keyword">new</span> <span class="keyword">int</span>[N];   <span class="comment">// 表示结点 i的 next指针是多少</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> idx;                 <span class="comment">// 表示存储当前结点已经使用结点的下一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = -<span class="number">1</span>;  <span class="comment">// 没有头结点</span></span><br><span class="line">    idx = <span class="number">0</span>;    <span class="comment">// 没有存入数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 val插到头结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    e[idx] = val;   <span class="comment">// 赋值</span></span><br><span class="line">    ne[idx] = head; <span class="comment">// 插入之前头结点的前面</span></span><br><span class="line">    head = idx;     <span class="comment">// 更新头结点信息</span></span><br><span class="line">    idx++;          <span class="comment">// idx向右移动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是 k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];  <span class="comment">// 让下标为 k的结点指向 下个结点的下个结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 val插入下标为 k的点的后面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    e[idx] = val;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双指针判断环"><a href="#双指针判断环" class="headerlink" title="双指针判断环"></a>双指针判断环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快慢指针 从同一起点走</span></span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        fast =fast.next.next; <span class="comment">//快指针走两步</span></span><br><span class="line">        slow = slow.next; <span class="comment">//慢指针走一步</span></span><br><span class="line">        <span class="keyword">if</span>(slow==fast)&#123; <span class="comment">//快慢指针相遇,证明有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则 无环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>求环节点</strong></p>
<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; seen = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!seen.add(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210508141930.png" alt="fig1"></p>
<p><em>a</em>+(<em>n</em>+1)<em>b</em>+<em>n**c</em>=2(<em>a</em>+<em>b</em>)⟹<em>a</em>=<em>c</em>+(<em>n</em>−1)(<em>b</em>+<em>c</em>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果满足下面的条件，说明无环</span></span><br><span class="line">    <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//下面开始找环的入口节点  </span></span><br><span class="line">    <span class="comment">//刚才的循环 慢指针走了a + b (a是从开始到入口节点) 假设等于cnt</span></span><br><span class="line">    <span class="comment">//快指针走了 a + b + c + b (b + c = 环)，应该等于2 * cnt</span></span><br><span class="line">    <span class="comment">//推导出 a = c，所以把慢指针再放到头节点，下一次快慢指针相遇的节点即环的入口节点</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双指针找交点"><a href="#双指针找交点" class="headerlink" title="双指针找交点"></a>双指针找交点</h5><h5 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur=head,pre=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next=cur.next;</span><br><span class="line">        cur.next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p=reverseList(head.next);</span><br><span class="line">    ListNode tmp=head.next;</span><br><span class="line">    tmp.next=head;</span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">stack1主要存放数据，stack2是为了实现各方法而起到了临时中转站的作用（具体的实现往下看），设置不对等地位一方面也是为了编写易理解的代码。</span></span><br><span class="line"><span class="comment">push(int x)方法的实现</span></span><br><span class="line"><span class="comment">    队列元素入队，就是为了存放数据，我在这里直接使元素x入栈stack1。</span></span><br><span class="line"><span class="comment">pop()</span></span><br><span class="line"><span class="comment">    队列的pop是取队头元素，即最先push进来的元素，但该元素存储在栈stack1的栈底，因此若想取出栈底元素，就要想办法把它变为栈顶元素。OK，这个时候stack2就该上场了。把stack1的栈顶元素入栈进入到stack2，即语句stack2.push(stack1.pop());重复此操作直至全部元素进入到stack2。现在让stack2栈顶元素出栈即为队列的队头元素出队。完成出队操作后，还要把stack2剩下的元素放回stack1内，因为stack1是存放数据的，而且下文empty()方法也是依据stack1完成的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1 =<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; stack2 =<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=stack2.pop();</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=stack2.peek();</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="先序遍历（LeetCode144）"><a href="#先序遍历（LeetCode144）" class="headerlink" title="先序遍历（LeetCode144）"></a>先序遍历（LeetCode144）</h5><p>1、申请一个栈stack，然后将头节点压入stack中。</p>
<p>2、从stack中弹出栈顶节点，打印，再将其右孩子节点（不为空的话）先压入stack中，最后将其左孩子节点（不为空的话）压入stack中。</p>
<p>3、不断重复步骤2，直到stack为空，全部过程结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty()) &#123;</span><br><span class="line">                TreeNode tr=stack.pop();</span><br><span class="line">                list.add(tr.val);</span><br><span class="line">                <span class="keyword">if</span>(tr.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(tr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tr.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                     stack.push(tr.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历（LeetCode94）"><a href="#中序遍历（LeetCode94）" class="headerlink" title="中序遍历（LeetCode94）"></a>中序遍历（LeetCode94）</h5><p>1、申请一个栈stack，初始时令cur=head</p>
<p>2、先把cur压入栈中，依次把左边界压入栈中，即不停的令cur=cur.left，重复步骤2</p>
<p>3、不断重复2，直到为null，从stack中弹出一个节点，记为node，打印node的值，并令cur=node.right,重复步骤2</p>
<p>4、当stack为空且cur为空时，整个过程停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode head) &#123;</span><br><span class="line">        List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();</span><br><span class="line">        if (head!=null) &#123;</span><br><span class="line">            while(head!=null||!stack.empty()) &#123;</span><br><span class="line">                if(head!=null) &#123;</span><br><span class="line">                    stack.push(head);</span><br><span class="line">                    head=head.left;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    head=stack.pop();</span><br><span class="line">                    list.add(head.val);</span><br><span class="line">                    head=head.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历（LeetCode145）"><a href="#后序遍历（LeetCode145）" class="headerlink" title="后序遍历（LeetCode145）"></a>后序遍历（LeetCode145）</h5><p>用非递归的方式实现后序遍历有点麻烦。</p>
<p>1、申请一个栈s1，然后将头节点压入栈s1中。</p>
<p>2、从s1中弹出的节点记为cur，然后依次将cur的左孩子节点和右孩子节点压入s1中。</p>
<p>3、在整个过程中，每一个从s1中弹出的节点都放进s2中。</p>
<p>4、不断重复步骤2和步骤3，直到s1为空，过程停止。</p>
<p>5、从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack2=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(head);</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty()) &#123;</span><br><span class="line">                head=stack1.pop();</span><br><span class="line">                stack2.push(head);</span><br><span class="line">                <span class="keyword">if</span> (head.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack1.push(head.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (head.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack1.push(head.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack2.empty()) &#123;</span><br><span class="line">                list.add(stack2.pop().val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210517112628.png" alt="image-20210517112626536"></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210518215900.png" alt="image-20210518215858611"></p>
<h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><h5 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h5><p>给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。 <strong>双指针算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] A=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] num=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];<span class="comment">//记录i，j之前出现的数的次数，超过2表示有重复</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        A[i]=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        num[A[j]]++;</span><br><span class="line">        <span class="comment">//有重复 i向右移</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;num[A[j]]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            num[A[i]]--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=Math.max(ans,j-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="数字三角形的最大路径和"><a href="#数字三角形的最大路径和" class="headerlink" title="数字三角形的最大路径和"></a>数字三角形的最大路径和</h5><p>给定一个如下图所示的，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        7</span><br><span class="line">      3   8</span><br><span class="line">    8   1   0</span><br><span class="line">  2   7   4   4</span><br><span class="line">4   5   2   6   5</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161120.png" alt="8021.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[][] f=<span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            f[i][j]=sc.nextInt();   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f[i][j]表示从下到上的最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            f[i][j]+=Math.max(f[i+<span class="number">1</span>][j],f[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(f[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210411111534.png" alt="image-20210411111508252"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">1001</span>;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> a[]=<span class="keyword">new</span> <span class="keyword">int</span> [N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f[]=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                f[i]=Math.max(f[j]+<span class="number">1</span>,f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=Math.max(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h5><p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210411160039.png" alt="image-20210411160037389"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">    <span class="keyword">int</span> m = scan.nextInt();</span><br><span class="line">    <span class="comment">//i=0情况</span></span><br><span class="line">    String A = <span class="string">" "</span> + scan.next();</span><br><span class="line">    String B = <span class="string">" "</span> + scan.next();</span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = Math.max(f[i-<span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//包含A[i] = B[j]情况的集合</span></span><br><span class="line">            <span class="keyword">if</span>(A.charAt(i) == B.charAt(j)) </span><br><span class="line">                f[i][j] = Math.max(f[i][j],f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(f[n][m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="石头合并-区间dp"><a href="#石头合并-区间dp" class="headerlink" title="石头合并-区间dp"></a>石头合并-区间dp</h5><p>合并 N 堆石子，每次只能合并相邻的两堆石子，求最小代价</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210412103924.png" alt="image-20210412103922273"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> []a =<span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            a[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> []s=<span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            s[i]+=s[i-<span class="number">1</span>]+a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> f[][]=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len-<span class="number">1</span>&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> l=i,r=l+len-<span class="number">1</span>;</span><br><span class="line">                f[l][r]=Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;r;j++)&#123;</span><br><span class="line">                    f[l][r]=Math.min(f[l][r],f[l][j]+f[j+<span class="number">1</span>][r]+s[r]-s[l-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(f[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="大顶推求最小的K个元素"><a href="#大顶推求最小的K个元素" class="headerlink" title="大顶推求最小的K个元素"></a>大顶推求最小的K个元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">int</span> length = input.length;</span><br><span class="line">       <span class="keyword">if</span>(k &gt; length || k == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//大顶推</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//降序</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.size() != k) &#123;</span><br><span class="line">                maxHeap.offer(input[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.peek() &gt; input[i]) &#123;</span><br><span class="line">                Integer temp = maxHeap.poll();</span><br><span class="line">                temp = <span class="keyword">null</span>;</span><br><span class="line">                maxHeap.offer(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : maxHeap) &#123;</span><br><span class="line">            result.add(integer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="货仓选址求最小"><a href="#货仓选址求最小" class="headerlink" title="货仓选址求最小"></a>货仓选址求最小</h5><p>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p>
<p><strong>中位数就是答案</strong></p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161118.png" alt="image-20210314132800964"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] A=<span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        A[i]=sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans+=Math.abs(A[i]-A[n/<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h5><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是0。</p>
<p>现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。</p>
<p>接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。</p>
<p><img src="https://pic-1253537137.cos.ap-guangzhou.myqcloud.com/pic/img/20210327161119.png" alt="image-20210314142819114"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    Pair(<span class="keyword">int</span> first,<span class="keyword">int</span> second)&#123;</span><br><span class="line">        <span class="keyword">this</span>.first=first;</span><br><span class="line">        <span class="keyword">this</span>.second=second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m=sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">300010</span>; <span class="comment">//因为需要将所有x，l，r存在数组中，这样就是n + 2m &lt;= 300000</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//从1开始，需要通过x找到离散量，然后+1，</span></span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//前缀和来做，所以需要从1开始记录a</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; alls = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//将所有的使用到的数存在alls中，比如x，l，r</span></span><br><span class="line">        <span class="comment">//但其中会有先后顺序的差别，以及重复，所以需要排序和去重</span></span><br><span class="line">        List&lt;Pair&gt; add = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//用来存n次操作</span></span><br><span class="line">        List&lt;Pair&gt; query = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//用来存m次询问</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> c = sc.nextInt();</span><br><span class="line">            add.add(<span class="keyword">new</span> Pair(x, c));</span><br><span class="line">            alls.add(x); <span class="comment">//存入alls中，为后续操作做准备</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> r = sc.nextInt();</span><br><span class="line">            query.add(<span class="keyword">new</span> Pair(l, r));</span><br><span class="line">            alls.add(l);</span><br><span class="line">            alls.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//到此为止，alls中存好了所有会被用到的数轴上的点，可以进行离散化操作</span></span><br><span class="line">        <span class="comment">// 1. 排序 2. 去重</span></span><br><span class="line">        Collections.sort(alls);</span><br><span class="line">        <span class="keyword">int</span> unique = unique(alls);</span><br><span class="line">        alls = alls.subList(<span class="number">0</span>, unique); <span class="comment">//将去重后的List保存下来，或者此处也可以将unique作为最后一个数，用r作为二分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Pair item:add) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = find(item.first, alls);</span><br><span class="line">            a[index] += item.second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= alls.size(); i++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Pair item:query) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = find(item.first, alls);</span><br><span class="line">            <span class="keyword">int</span> r = find(item.second, alls);</span><br><span class="line">            System.out.println(s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排序list去重</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unique</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || list.get(i) != list.get(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                list.set(j, list.get(i));</span><br><span class="line">                j++;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到x所在的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(mid) &gt;= x) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>; <span class="comment">//因为要考虑到前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="区间合并-1"><a href="#区间合并-1" class="headerlink" title="区间合并"></a>区间合并</h5><p>给定 n 个区间，要求合并所有有交集的区间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    Pair(<span class="keyword">int</span> first,<span class="keyword">int</span> second) &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pair&#123;"</span> +</span><br><span class="line">                <span class="string">"first="</span> + first +</span><br><span class="line">                <span class="string">", second="</span> + second +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">        List&lt;Pair&gt; list=<span class="keyword">new</span> ArrayList&lt;Pair&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Pair(sc.nextInt(),sc.nextInt()));</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Pair&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Pair o1, Pair o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.first-o2.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//System.out.println(list.toString());</span></span><br><span class="line">        List&lt;Pair&gt; ans=<span class="keyword">new</span> ArrayList&lt;Pair&gt;();</span><br><span class="line">        <span class="keyword">int</span> st=list.get(<span class="number">0</span>).first,ed=list.get(<span class="number">0</span>).second;</span><br><span class="line">        <span class="keyword">for</span>(Pair p:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ed&lt;p.first)&#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> Pair(st,ed));</span><br><span class="line">                st=p.first;</span><br><span class="line">                ed=p.second;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ed=Math.max(ed,p.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="keyword">new</span> Pair(st,ed));</span><br><span class="line">        System.out.println(ans.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h4><h5 id="变量命名约定"><a href="#变量命名约定" class="headerlink" title="变量命名约定"></a>变量命名约定</h5><ul>
<li>nums 表示数字数组，array 表示通用数组，matrix 表示矩阵；</li>
<li>n 表示数组长度、字符串长度、树节点个数，以及其它具有一维性质的数据结构的元素个数；</li>
<li>m, n 表示矩阵的行数和列数；</li>
<li>first, last 表示闭区间，在需要作为函数参数时使用：[first, last]；</li>
<li>l, h 也表示闭区间，在只作为局部变量时使用：[l, h]；</li>
<li>begin, end 表示左闭右开区间：[begin, end)；</li>
<li>ret 表示结果相关的变量；</li>
<li>dp 表示动态规划保存子问题的数组；</li>
</ul>
<h5 id="复杂度简写说明"><a href="#复杂度简写说明" class="headerlink" title="复杂度简写说明"></a>复杂度简写说明</h5><p>O(nlog<sub>n</sub>) + O(n<sup>2</sup>)，第一个指时间复杂度，第二个指空间复杂度。</p>
<h5 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h5><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 {2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。</p>
<p>这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素放到第 i 个位置上。</p>
<p>以 (2, 3, 1, 0, 2, 5) 为例，以下代码的运行过程为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">position-0 : (2,3,1,0,2,5) // 2 <span class="tag">&lt;<span class="name">-</span>&gt;</span> 1</span><br><span class="line">             (1,3,2,0,2,5) // 1 <span class="tag">&lt;<span class="name">-</span>&gt;</span> 3</span><br><span class="line">             (3,1,1,0,2,5) // 3 <span class="tag">&lt;<span class="name">-</span>&gt;</span> 0</span><br><span class="line">             (0,1,1,3,2,5) // already in position</span><br><span class="line">position-1 : (0,1,1,3,2,5) // already in position</span><br><span class="line">position-2 : (0,1,1,3,2,5) // nums[i] == nums[nums[i]], exit</span><br></pre></td></tr></table></figure>
<p>遍历到位置 2 时，该位置上的数为 1，但是第 1 个位置上已经有一个 1 的值了，因此可以知道 1 重复。</p>
<p>复杂度：O(n) + O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i &amp;&amp; nums[i] != nums[nums[i]]) &#123;</span><br><span class="line">            swap(nums, i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i &amp;&amp; nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">            duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nums[i]; nums[i] = nums[j]; nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h5><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure>
<p>从右上角开始查找。因为矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。</p>
<p>复杂度：O(m + n) + O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = n - <span class="number">1</span>; <span class="comment">// 从右上角开始</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt;= m - <span class="number">1</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[r][c]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[r][c]) r++;</span><br><span class="line">        <span class="keyword">else</span> c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5. 替换空格"></a>5. 替换空格</h5><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy. 则经过替换之后的字符串为 We%20Are%20Happy。</p>
<p>在字符串尾部填充任意字符，使得字符串的长度等于字符串替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。</p>
<p>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。</p>
<p>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p>
<p>复杂度：O(n) + O(1)</p>
<p><div align="center"> <img src="../pics//35b0caf8-6f34-49db-93ed-d505e9eb3d99.png"> </div><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldLen = str.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">            str.append(<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idxOfOld = oldLen - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> idxOfNew = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (idxOfOld &gt;= <span class="number">0</span> &amp;&amp; idxOfNew &gt; idxOfOld) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(idxOfOld--);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            str.setCharAt(idxOfNew--, <span class="string">'0'</span>);</span><br><span class="line">            str.setCharAt(idxOfNew--, <span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(idxOfNew--, <span class="string">'%'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str.setCharAt(idxOfNew--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6. 从尾到头打印链表"></a>6. 从尾到头打印链表</h5><p>输入链表的第一个节点，从尾到头反过来打印出每个结点的值。</p>
<p>使用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        ret.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">        ret.add(listNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Collections.reverse()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用头插法</strong></p>
<p>利用链表头插法为逆序的特点。</p>
<p>头结点和第一个节点的区别：头结点是在头插法中使用的一个额外节点，这个节点不存储值；第一个节点就是链表的第一个真正存储值的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头插法构建逆序链表</span></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode memo = listNode.next;</span><br><span class="line">        listNode.next = head.next;</span><br><span class="line">        head.next = listNode;</span><br><span class="line">        listNode = memo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 ArrayList</span></span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.add(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="++7. 重建二叉树++"></a>++7. 重建二叉树++</h5><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">For example, given</span><br><span class="line"></span><br><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder =  [9,3,15,20,7]</span><br><span class="line"></span><br><span class="line">Return the following binary tree:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; inOrderNumsIdx = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 缓存中序遍历数组的每个值对应的索引</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">        inOrderNumsIdx.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span>[] in, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preL == preR) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">    <span class="keyword">if</span> (preL &gt; preR || inL &gt; inR) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">    <span class="keyword">int</span> inIdx = inOrderNumsIdx.get(root.val);</span><br><span class="line">    <span class="keyword">int</span> leftTreeSize = inIdx - inL;</span><br><span class="line">    root.left = reConstructBinaryTree(pre, preL + <span class="number">1</span>, preL + leftTreeSize, in, inL, inL + leftTreeSize - <span class="number">1</span>);</span><br><span class="line">    root.right = reConstructBinaryTree(pre, preL + leftTreeSize + <span class="number">1</span>, preR, in, inL + leftTreeSize + <span class="number">1</span>, inR);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-二叉树的下一个结点"><a href="#8-二叉树的下一个结点" class="headerlink" title="++8. 二叉树的下一个结点++"></a>++8. 二叉树的下一个结点++</h5><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p>① 如果一个节点有右子树不为空，那么该节点的下一个节点是右子树的最左节点；</p>
<p><div align="center"> <img src="../pics//931e112e-97d3-4a47-ac64-a86d70844e58.png" width="200"> </div><br></p>
<p>② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。</p>
<p><div align="center"> <img src="../pics//350048d6-20f5-4ca9-8452-3957a09ef3af.png" width="200"> </div><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeLinkNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode right = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeLinkNode node = pNode.right;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeLinkNode parent = pNode.next;</span><br><span class="line">            <span class="keyword">if</span> (parent.left == pNode) <span class="keyword">return</span> parent;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a>9. 用两个栈实现队列</h5><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，此时先进入的元素先退出，这就是队列的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">            out.push(in.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10.1 斐波那契数列"></a>10.1 斐波那契数列</h5><p>以 O(1) 的时间复杂度求菲波那切数列。</p>
<p><div align="center"><img src="https://latex.codecogs.com/gif.latex?f(n)=\left\{\begin{array}{rcl}0&&{n=0}\\1&&{n=1}\\f(n-1)+f(n-2)&&{n>1}\end{array}\right."></div> <br></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><p>如果使用递归求解，那么会重复计算一些子问题。例如，求 f(10) 需要计算 f(9) 和 f(8)，计算 f(9) 需要计算 f(8) 和 f(7)，可以看到 f(8) 被重复计算了。</p>
<p><div align="center"> <img src="../pics//080f488c-75ef-49a8-a49d-78fa372ad422.png"> </div><br></p>
<p>递归方法是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，避免重复求解子问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        fib[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; fib.length; i++) &#123;</span><br><span class="line">            fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fib[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-2-跳台阶"><a href="#10-2-跳台阶" class="headerlink" title="10.2 跳台阶"></a>10.2 跳台阶</h5><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-3-变态跳台阶"><a href="#10-3-变态跳台阶" class="headerlink" title="10.3 变态跳台阶"></a>10.3 变态跳台阶</h5><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            dp[i] += dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-4-矩形覆盖"><a href="#10-4-矩形覆盖" class="headerlink" title="10.4 矩形覆盖"></a>10.4 矩形覆盖</h5><p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="==11. 旋转数组的最小数字=="></a>==11. 旋转数组的最小数字==</h5><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增数组(不存在重复元素)的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。</p>
<p><strong>二分查找</strong></p>
<p>当 nums[m] &lt;= nums[h] 的情况下，说明解在 [l, m] 之间，此时令 h = m；<br>否则解在 [m + 1, h] 之间，令 l = m + 1。</p>
<p>循环：</p>
<p>复杂度：O(log<sub>n</sub>) + O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;= nums[h])</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归:</strong></p>
<p>复杂度：O(log<sub>n</sub>) + O(log<sub>n</sub>) （java 无法对尾递归做优化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> findMin(nums, <span class="number">0</span>, nums.length -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> nums[left];</span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(nums[right] &gt; nums[left])&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= nums[left])&#123;</span><br><span class="line">        <span class="keyword">return</span> findMin(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findMin(nums, left, mid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情况2：非递减数组(存在重复元素)。leetcode 154</p>
<p>如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，那么此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == nums[m] &amp;&amp; nums[m] == nums[h])</span><br><span class="line">            <span class="keyword">return</span> minNumber(nums, l, h);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt;= nums[h])</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; h; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分治</strong></p>
<p>是否存在重复元素都可以使用分治方法。</p>
<p>复杂度：O(log<sub>n</sub>) + O(n)，因为分治使用了递归栈，用到了额外的空间，如果对空间有要求就不能用这种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minNumberInRotateArray(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[first] &lt; nums[last]) <span class="keyword">return</span> nums[first];</span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span> nums[first];</span><br><span class="line">    <span class="keyword">int</span> mid = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(minNumberInRotateArray(nums, first, mid), minNumberInRotateArray(nums, mid + <span class="number">1</span>, last));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a>12. 矩阵中的路径</h5><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如 a b c e s f c s a d e e 矩阵中包含一条字符串 “bcced” 的路径，但是矩阵中不包含 “abcb” 路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rows == <span class="number">0</span> || cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="keyword">boolean</span>[][] hasUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">char</span>[][] matrix = buildMatrix(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (backtracking(matrix, str, hasUsed, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">char</span>[] str, <span class="keyword">boolean</span>[][] hasUsed, <span class="keyword">int</span> pathLen, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pathLen == str.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= rows || col &lt; <span class="number">0</span> || col &gt;= cols) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (matrix[row][col] != str[pathLen]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasUsed[row][col]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    hasUsed[row][col] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; next.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtracking(matrix, str, hasUsed, pathLen + <span class="number">1</span>, row + next[i][<span class="number">0</span>], col + next[i][<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hasUsed[row][col] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] buildMatrix(<span class="keyword">char</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">char</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, idx = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            matrix[i][j] = array[idx++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a>13. 机器人的运动范围</h5><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格（35, 37），因为 3+5+3+7=18。但是，它不能进入方格（35, 38），因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] digitSum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">    initDigitSum();</span><br><span class="line">    <span class="keyword">boolean</span>[][] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    dfs(hasVisited, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[][] hasVisited, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= <span class="keyword">this</span>.rows || c &lt; <span class="number">0</span> || c &gt;= <span class="keyword">this</span>.cols) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasVisited[r][c]) <span class="keyword">return</span>;</span><br><span class="line">    hasVisited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.digitSum[r][c] &gt; <span class="keyword">this</span>.threshold) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.next.length; i++) &#123;</span><br><span class="line">        dfs(hasVisited, r + next[i][<span class="number">0</span>], c + next[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDigitSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] digitSumOne = <span class="keyword">new</span> <span class="keyword">int</span>[Math.max(rows, cols)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digitSumOne.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = i;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digitSumOne[i] += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.digitSum = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.cols; j++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.digitSum[i][j] = digitSumOne[i] + digitSumOne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="++14. 剪绳子++"></a>++14. 剪绳子++</h5><p>把一根绳子剪成多段，并且使得每段的长度乘积最大。</p>
<p><strong>动态规划解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>贪心解法</strong></p>
<p>尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现，如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。</p>
<p>证明：当 n &gt;= 5 时，3(n - 3) - 2(n - 2) = n - 5 &gt;= 0。因此把长度大于 5 的绳子切成两段，令其中一段长度为 3 可以使得两段的乘积最大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf3 = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n - timesOf3 * <span class="number">3</span> == <span class="number">1</span>) timesOf3--;</span><br><span class="line">    <span class="keyword">int</span> timesOf2 = (n - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(<span class="number">3</span>, timesOf3)) * (<span class="keyword">int</span>) (Math.pow(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="15-二进制中-1-的个数"><a href="#15-二进制中-1-的个数" class="headerlink" title="++15. 二进制中 1 的个数++"></a>++15. 二进制中 1 的个数++</h5><p>输入一个整数，输出该数二进制表示中 1 的个数。</p>
<p><strong>Integer.bitCount()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>n&amp;(n-1)</strong></p>
<p>O(logM) 时间复杂度解法，其中 M 表示 1 的个数。</p>
<p>该位运算是去除 n 的位级表示中最低的那一位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n       : 10110100</span><br><span class="line">n-1     : 10110011</span><br><span class="line">n&amp;(n-1) : 10110000</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a>16. 数值的整数次方</h5><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</p>
<p>下面的讨论中 x 代表 base，n 代表 exponent。</p>
<p><div align="center"><img src="https://latex.codecogs.com/gif.latex?x^n=\left\{\begin{array}{rcl}(x*x)^{n/2}&&{n\%2=0}\\x*(x*x)^{n/2}&&{n\%2=1}\end{array}\right."></div> <br></p>
<p>因为 (x*x)<sup>n/2</sup> 可以通过递归求解，并且每递归一次，n 都减小一半，因此整个算法的时间复杂度为 O(logn)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指数为int最小值时不太对？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">1</span>) <span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">        isNegative = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pow = Power(base * base, exponent / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (exponent % <span class="number">2</span> != <span class="number">0</span>) pow = pow * base;</span><br><span class="line">    <span class="keyword">return</span> isNegative ? (<span class="number">1</span> / pow) : pow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速幂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.全面考察指数的正负、底数是否为零等情况。</span></span><br><span class="line"><span class="comment"> * 2.写出指数的二进制表达，例如13表达为二进制1101。</span></span><br><span class="line"><span class="comment"> * 3.举例:10^1101 = 10^0001*10^0100*10^1000。</span></span><br><span class="line"><span class="comment"> * 4.通过&amp;1和&gt;&gt;1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 指数为int最小值时不太对？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>,curr = base;</span><br><span class="line">    <span class="keyword">int</span> exponent;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        exponent = n;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"分母不能为0"</span>); </span><br><span class="line">        exponent = -n;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// n==0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">// 0的0次方</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((exponent&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">            res*=curr;</span><br><span class="line">        curr*=curr;<span class="comment">// 翻倍</span></span><br><span class="line">        exponent&gt;&gt;=<span class="number">1</span>;<span class="comment">// 右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n&gt;=<span class="number">0</span>?res:(<span class="number">1</span>/res);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="17-打印从-1-到最大的-n-位数"><a href="#17-打印从-1-到最大的-n-位数" class="headerlink" title="17. 打印从 1 到最大的 n 位数"></a>17. 打印从 1 到最大的 n 位数</h5><p>输入数字 n，按顺序打印出从 1 最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。</p>
<p>由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。</p>
<p>使用回溯法得到所有的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>[] number = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    print1ToMaxOfNDigits(number, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">char</span>[] number, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digit == number.length - <span class="number">1</span>) &#123;</span><br><span class="line">        printNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        number[digit + <span class="number">1</span>] = (<span class="keyword">char</span>) (i + <span class="string">'0'</span>);</span><br><span class="line">        print1ToMaxOfNDigits(number, digit + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">char</span>[] number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; number.length &amp;&amp; number[index] == <span class="string">'0'</span>) index++;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; number.length) System.out.print(number[index++]);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="18-1-在-O-1-时间内删除链表节点"><a href="#18-1-在-O-1-时间内删除链表节点" class="headerlink" title="18.1 在 O(1) 时间内删除链表节点"></a>18.1 在 O(1) 时间内删除链表节点</h5><p>① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，令该节点指向下下个节点，然后删除下一个节点，时间复杂度为 O(1)。</p>
<p><div align="center"> <img src="../pics//72f9bc11-06a9-40b4-8939-14f72e5cb4c3.png"> </div><br></p>
<p>② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。</p>
<p><div align="center"> <img src="../pics//2a398239-ee47-4ea1-b2d8-0ced638839ef.png"> </div><br></p>
<p>综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个为节点以 O(n) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2，因此该算法的平均时间复杂度为 O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode tobeDelete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || tobeDelete == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (tobeDelete.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点不是尾节点</span></span><br><span class="line">        ListNode next = tobeDelete.next;</span><br><span class="line">        tobeDelete.val = next.val;</span><br><span class="line">        tobeDelete.next = next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != tobeDelete) cur = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="18-2-删除链表中重复的结点"><a href="#18-2-删除链表中重复的结点" class="headerlink" title="++18.2 删除链表中重复的结点++"></a>++18.2 删除链表中重复的结点++</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input : 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output : 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = pHead.next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">    <span class="keyword">if</span> (pHead.val == next.val) &#123;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="keyword">null</span> &amp;&amp; pHead.val == next.val) next = next.next;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplication(next);</span><br><span class="line">    &#125;</span><br><span class="line">    pHead.next = deleteDuplication(pHead.next);</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="++19. 正则表达式匹配++"></a>++19. 正则表达式匹配++</h5><p>请实现一个函数用来匹配包括 ‘.’ 和 ‘*‘ 的正则表达式。模式中的字符 ‘.’ 表示任意一个字符，而 ‘*‘ 表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 “aaa” 与模式 “a.a” 和 “ab*ac*a” 匹配，但是与 “aa.a” 和 “ab*a” 均不匹配。</p>
<p>应该注意到，’.’ 是用来代替一个任意字符，而 ‘*‘ 是用来重复前面的字符。这两个的作用不同，不能把 ‘.’ 的作用和 ‘*‘ 进行类比，从而把它当成重复前面字符一次。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.charAt(j) == s.charAt(i)  :  dp[i][j] = dp[i-1][j-1];</span><br><span class="line">p.charAt(j) == '.'          :  dp[i][j] = dp[i-1][j-1];</span><br><span class="line">p.charAt(j) == '*'          :</span><br><span class="line">   p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  // in this case, a* only counts as empty</span><br><span class="line">   p.charAt(j-1) == s.charAt(i) or p.charAt(i-1) == '.':</span><br><span class="line">            dp[i][j] = dp[i-1][j]   // in this case, a* counts as multiple a</span><br><span class="line">         or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a</span><br><span class="line">         or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = str.length, n = pattern.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i - <span class="number">1</span>] == pattern[j - <span class="number">1</span>] || pattern[j - <span class="number">1</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern[j - <span class="number">2</span>] == str[i - <span class="number">1</span>] || pattern[j - <span class="number">2</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串"></a>20. 表示数值的字符串</h5><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 “+100”,”5e2”,”-123”,”3.1416” 和 “-1E-16” 都表示数值。 但是 “12e”,”1a3.14”,”1.2.3”,”+-5” 和 “12e+4.3” 都不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(str).matches(<span class="string">"[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h5><p>保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。</p>
<p>复杂度：O(n<sup>2</sup>) + O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextOddIdx = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nextOddIdx &lt; n &amp;&amp; nums[nextOddIdx] % <span class="number">2</span> == <span class="number">0</span>) nextOddIdx++;</span><br><span class="line">            <span class="keyword">if</span> (nextOddIdx == n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> nextOddVal = nums[nextOddIdx];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nextOddIdx; j &gt; i; j--) &#123;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = nextOddVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O(n) + O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oddCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) <span class="keyword">if</span> (val % <span class="number">2</span> == <span class="number">1</span>) oddCnt++;</span><br><span class="line">    <span class="keyword">int</span>[] copy = nums.clone();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = oddCnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : copy) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) nums[i++] = num;</span><br><span class="line">        <span class="keyword">else</span> nums[j++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="22-链表中倒数第-K-个结点"><a href="#22-链表中倒数第-K-个结点" class="headerlink" title="22. 链表中倒数第 K 个结点"></a>22. 链表中倒数第 K 个结点</h5><p>设链表的长度为 N。设两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到 N - K 个节点处，该位置就是倒数第 K 个节点。</p>
<p><div align="center"> <img src="../pics//40d96c0d-156f-4eee-a183-2d597344f1cd.png"> </div><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode P1 = head;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(P1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        P1 = P1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode P2 = head;</span><br><span class="line">    <span class="keyword">while</span> (P1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        P1 = P1.next;</span><br><span class="line">        P2 = P2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="23-链表中环的入口结点"><a href="#23-链表中环的入口结点" class="headerlink" title="23. 链表中环的入口结点"></a>23. 链表中环的入口结点</h5><p>使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。</p>
<p>在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。</p>
<p><div align="center"> <img src="../pics//e7d7dc0d-fc22-4f95-8768-b8a216168792.jpg"> </div><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode slow = pHead, fast = pHead;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            fast = pHead;</span><br><span class="line">            <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. 反转链表</h5><p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode newHead = ReverseList(next);</span><br><span class="line">    next.next = head;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newList = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = newList.next;</span><br><span class="line">        newList.next = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a>25. 合并两个排序的链表</h5><p><div align="center"> <img src="../pics//79f28233-f5cb-492a-9dc4-696cb714d434.png"> </div><br></p>
<p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">    <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">        list1.next = Merge(list1.next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2.next = Merge(list1, list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            cur.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1 != <span class="keyword">null</span>) cur.next = list1;</span><br><span class="line">    <span class="keyword">if</span> (list2 != <span class="keyword">null</span>) cur.next = list2;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h5><p><div align="center"> <img src="../pics//26223561-eea4-463c-8ddb-3bb456c76267.png"> </div><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h5><p><div align="center"> <img src="../pics//7cfcfdf7-63a7-4111-a677-2eca29fbcf24.png"> </div><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    swap(root);</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode t = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28 对称的二叉树"></a>28 对称的二叉树</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(pRoot.left, pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(t1.left, t2.right) &amp;&amp; isSymmetrical(t1.right, t2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h5><p>下图的矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10</p>
<p><div align="center"> <img src="../pics//8615d9f7-bd1d-4240-8bb4-02b941d54a6f.png"> </div><br></p>
<p><div align="center"> <img src="../pics//6afa9796-af1a-4495-9f02-63349ab68a19.png"> </div><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">0</span>, r2 = matrix.length - <span class="number">1</span>, c1 = <span class="number">0</span>, c2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c1; i &lt;= c2; i++) ret.add(matrix[r1][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r1 + <span class="number">1</span>; i &lt;= r2; i++) ret.add(matrix[i][c2]);</span><br><span class="line">        <span class="keyword">if</span> (r1 != r2) <span class="keyword">for</span> (<span class="keyword">int</span> i = c2 - <span class="number">1</span>; i &gt;= c1; i--) ret.add(matrix[r2][i]);</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) <span class="keyword">for</span> (<span class="keyword">int</span> i = r2 - <span class="number">1</span>; i &gt; r1; i--) ret.add(matrix[i][c1]);</span><br><span class="line">        r1++; r2--; c1++; c2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="30-包含-min-函数的栈"><a href="#30-包含-min-函数的栈" class="headerlink" title="30. 包含 min 函数的栈"></a>30. 包含 min 函数的栈</h5><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    stack.push(node);</span><br><span class="line">    <span class="keyword">if</span> (min &gt; node) min = node;</span><br><span class="line">    minStack.push(min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack.pop();</span><br><span class="line">    minStack.pop();</span><br><span class="line">    min = minStack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minStack.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a>31. 栈的压入、弹出序列</h5><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA, <span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = pushA.length;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pushIndex = <span class="number">0</span>, popIndex = <span class="number">0</span>; pushIndex &lt; n; pushIndex++) &#123;</span><br><span class="line">        stack.push(pushA[pushIndex]);</span><br><span class="line">        <span class="keyword">while</span> (popIndex &lt; n &amp;&amp; stack.peek() == popA[popIndex]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="32-1-从上往下打印二叉树"><a href="#32-1-从上往下打印二叉树" class="headerlink" title="32.1 从上往下打印二叉树"></a>32.1 从上往下打印二叉树</h5><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>例如，以下二叉树层次遍历的结果为 8, 6, 10, 5, 7, 9, 11</p>
<p><div align="center"> <img src="../pics//c8cdfa3d-d610-4731-9d89-564252378e7d.png"> </div><br></p>
<p>使用队列来进行层次遍历。</p>
<p>不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            TreeNode t = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (t.left != <span class="keyword">null</span>) queue.add(t.left);</span><br><span class="line">            <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) queue.add(t.right);</span><br><span class="line">            ret.add(t.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="32-2-把二叉树打印成多行"><a href="#32-2-把二叉树打印成多行" class="headerlink" title="32.2 把二叉树打印成多行"></a>32.2 把二叉树打印成多行</h5><p>和上题几乎一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="32-3-按之字形顺序打印二叉树"><a href="#32-3-按之字形顺序打印二叉树" class="headerlink" title="32.3 按之字形顺序打印二叉树"></a>32.3 按之字形顺序打印二叉树</h5><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(pRoot);</span><br><span class="line">    <span class="keyword">boolean</span> reverse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (reverse) Collections.reverse(list);</span><br><span class="line">        reverse = !reverse;</span><br><span class="line">        ret.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33. 二叉搜索树的后序遍历序列"></a>33. 二叉搜索树的后序遍历序列</h5><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。</p>
<p>例如，下图中后序遍历序列 5, 7, 6, 9, 11, 10, 8 所对应的二叉搜索树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> verify(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> rootVal = sequence[last];</span><br><span class="line">    <span class="keyword">int</span> cutIndex = first;</span><br><span class="line">    <span class="keyword">while</span> (cutIndex &lt; last &amp;&amp; sequence[cutIndex] &lt;= rootVal) cutIndex++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cutIndex + <span class="number">1</span>; i &lt; last; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[i] &lt; rootVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> verify(sequence, first, cutIndex - <span class="number">1</span>) &amp;&amp; verify(sequence, cutIndex, last - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34. 二叉树中和为某一值的路径"></a>34. 二叉树中和为某一值的路径</h5><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    dfs(root, target, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> target, ArrayList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    path.add(node.val);</span><br><span class="line">    target -= node.val;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs(node.left, target, path);</span><br><span class="line">        dfs(node.right, target, path);</span><br><span class="line">    &#125;</span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a>35. 复杂链表的复制</h5><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p>
<p>第一步，在每个节点的后面插入复制的节点。</p>
<p>第二步，对复制节点的 random 链接进行赋值。</p>
<p>第三步，拆分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    RandomListNode cur = pHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode clone = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">        clone.next = cur.next;</span><br><span class="line">        cur.next = clone;</span><br><span class="line">        cur = clone.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立 random 链接</span></span><br><span class="line">    cur = pHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode clone = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clone.random = cur.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = clone.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拆分</span></span><br><span class="line">    cur = pHead;</span><br><span class="line">    RandomListNode pCloneHead = pHead.next;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pCloneHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="==36. 二叉搜索树与双向链表=="></a>==36. 二叉搜索树与双向链表==</h5><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;<span class="comment">//记录尾节点</span></span><br><span class="line"><span class="keyword">private</span> TreeNode head = <span class="keyword">null</span>;<span class="comment">//记录头结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    node.left = pre;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>) pre.right = node;</span><br><span class="line">    pre = node;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) head = node;</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="==37. 序列化二叉树=="></a>==37. 序列化二叉树==</h5><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>需要分隔符的原因：一个节点序列化成字符串后可能不止一个字符，比如10</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String deserializeStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">return</span> root.val + <span class="string">" "</span> + Serialize(root.left) + <span class="string">" "</span> + Serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        deserializeStr = str;</span><br><span class="line">        <span class="keyword">return</span> Deserialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">Deserialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (deserializeStr.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> index = deserializeStr.indexOf(<span class="string">" "</span>);</span><br><span class="line">        String node = index == -<span class="number">1</span> ? deserializeStr : deserializeStr.substring(<span class="number">0</span>, index);</span><br><span class="line">        deserializeStr = index == -<span class="number">1</span> ? <span class="string">""</span> : deserializeStr.substring(index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.equals(<span class="string">"#"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> val = Integer.valueOf(node);</span><br><span class="line">        TreeNode t = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        t.left = Deserialize();</span><br><span class="line">        t.right = Deserialize();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a>38. 字符串的排列</h5><p>输入一个包含重复字符的字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abb，则打印出由字符 a, b, b 所能排列出来的所有字符串 abb, bab, 和 bba。</p>
<p>==重复条件==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    Arrays.sort(chars);</span><br><span class="line">    backtracking(chars, <span class="keyword">new</span> <span class="keyword">boolean</span>[chars.length], <span class="keyword">new</span> StringBuffer());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">boolean</span>[] hasUsed, StringBuffer s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == chars.length) &#123;</span><br><span class="line">        ret.add(s.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasUsed[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; chars[i] == chars[i - <span class="number">1</span>] &amp;&amp; !hasUsed[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 保证不重复</span></span><br><span class="line">        hasUsed[i] = <span class="keyword">true</span>;</span><br><span class="line">        s.append(chars[i]);</span><br><span class="line">        backtracking(chars, hasUsed, s);</span><br><span class="line">        s.deleteCharAt(s.length() - <span class="number">1</span>);</span><br><span class="line">        hasUsed[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="++39. 数组中出现次数超过一半的数字++"></a>++39. 数组中出现次数超过一半的数字++</h5><p>partition 找中位数。平均时间复杂度为 O(n)。但 partition 的限制很多，例如修改了数组，且最坏情况下复杂度高，若数组分布均匀且采取三数取中的算法可达到平均复杂度。</p>
<p>这个数字出现的次数比其他所有数字出现的总和还多。因此可以保存两个值：一个是数字，一个是次数。遍历到一个字符时，如果和保存的数相等，次数加一，如果不相等，次数减一。如果次数为0，要保存新的数字，次数为1。时间复杂度为 O(n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cnt = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        cnt = nums[i] == majority ? cnt + <span class="number">1</span> : cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            majority = nums[i];</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) <span class="keyword">if</span> (val == majority) cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt &gt; nums.length / <span class="number">2</span> ? majority : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="40-最小的-K-个数"><a href="#40-最小的-K-个数" class="headerlink" title="40. 最小的 K 个数"></a>40. 最小的 K 个数</h5><p><strong>快速选择</strong></p>
<ul>
<li>复杂度：O(N) + O(1)</li>
<li>只有当允许修改数组元素时才可以使用</li>
</ul>
<p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。</p>
<p>找到第 K 个元素之后，就可以再遍历一次数组，所有小于等于该元素的数组元素都是最小的 K 个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nums.length || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> kthSmallest = findKthSmallest(nums, k - <span class="number">1</span>);</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= kthSmallest &amp;&amp; ret.size() &lt; k) ret.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthSmallest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            l = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) &#123;</span><br><span class="line">            h = j - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">int</span> j = h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; h &amp;&amp; nums[++i] &lt; nums[l]) ;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; l &amp;&amp; nums[l] &lt; nums[--j]) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>大小为 K 的最小堆</strong></p>
<ul>
<li>复杂度：O(NlogK) + O(K)</li>
<li>特别适合处理海量数据</li>
</ul>
<p>应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p>
<p>维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nums.length || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        maxHeap.add(num);</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &gt; k) &#123;</span><br><span class="line">            maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;(maxHeap);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="41-1-数据流中的中位数"><a href="#41-1-数据流中的中位数" class="headerlink" title="41.1 数据流中的中位数"></a>41.1 数据流中的中位数</h5><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 大顶堆，存储左半边元素</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="comment">// 小顶堆，存储右半边元素，并且右半边元素都大于左半边</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前数据流读入的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入要保证两个堆存于平衡状态</span></span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// N 为偶数的情况下插入到右半边。</span></span><br><span class="line">            <span class="comment">// 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，</span></span><br><span class="line">            <span class="comment">// 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边</span></span><br><span class="line">            left.add(val);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.add(val);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) right.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="41-2-字符流中第一个不重复的字符"><a href="#41-2-字符流中第一个不重复的字符" class="headerlink" title="41.2 字符流中第一个不重复的字符"></a>41.2 字符流中第一个不重复的字符</h5><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g”。当从该字符流中读出前六个字符“google” 时，第一个只出现一次的字符是 “l”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        cnts[ch]++;</span><br><span class="line">        queue.add(ch);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; cnts[queue.peek()] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a>42. 连续子数组的最大和</h5><p>{6,-3,-2,7,-15,1,2,2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) sum = val;</span><br><span class="line">        <span class="keyword">else</span> sum += val;</span><br><span class="line">        ret = Math.max(ret, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="43-从-1-到-n-整数中-1-出现的次数"><a href="#43-从-1-到-n-整数中-1-出现的次数" class="headerlink" title="==43. 从 1 到 n 整数中 1 出现的次数=="></a>==43. 从 1 到 n 整数中 1 出现的次数==</h5><p>依次计算1出现在个位、十位、百位…的次数，求和即为总次数。</p>
<p>计算个位1出现的次数时，每10个数有一个个位为1，分三种情况：<br><br>个位为0：n/10取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br><br>个位为1：n/10取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br><br>个位大于等于2：n/10取整+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br></p>
<p>计算十位1出现的次数时，每100个数有10个十位为1，分三种情况：<br><br>十位为0：n/10取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br><br>十位为1：n/10取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;个位+1<br><br>十位大于等于2：n/10取整+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = n / m, b = n % m;</span><br><span class="line">        cnt += (a + <span class="number">8</span>) / <span class="number">10</span> * m + (a % <span class="number">10</span> == <span class="number">1</span> ? b + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="44-数字序列中的某一位数字"><a href="#44-数字序列中的某一位数字" class="headerlink" title="44. 数字序列中的某一位数字"></a>44. 数字序列中的某一位数字</h5><p>数字以 0123456789101112131415… 的格式序列化到一个字符串中，求这个字符串的第 index 位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> amount = getAmountOfDigit(digit);</span><br><span class="line">        <span class="keyword">int</span> totalAmount = amount * digit;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; totalAmount) &#123;</span><br><span class="line">            <span class="keyword">return</span> digitAtIndex(index, digit);</span><br><span class="line">        &#125;</span><br><span class="line">        index -= totalAmount;</span><br><span class="line">        digit++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * digit 位数的数字组成的字符串长度</span></span><br><span class="line"><span class="comment"> * 例如 digit = 2，return 90</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAmountOfDigit</span><span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digit == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, digit - <span class="number">1</span>) * <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 digit 位数组成的字符串中，第 index 为的数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = beginNumber(digit) + index / digit;</span><br><span class="line">    <span class="keyword">int</span> remain = index % digit;</span><br><span class="line">    <span class="keyword">return</span> (number + <span class="string">""</span>).charAt(remain) - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * digit 位数的起始数字</span></span><br><span class="line"><span class="comment"> * 例如 digit = 2 return 10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">beginNumber</span><span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digit == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, digit - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45. 把数组排成最小的数"></a>45. 把数组排成最小的数</h5><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p>
<p>可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">    String[] nums = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) nums[i] = numbers[i] + <span class="string">""</span>;</span><br><span class="line">    Arrays.sort(nums, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1));</span><br><span class="line">    String ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (String str : nums) ret += str;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a>46. 把数字翻译成字符串</h5><p>给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”… 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTranslationCount</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = s.charAt(n-<span class="number">1</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> two;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(n-i) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            two = Integer.parseInt(s.substring(n-i, n-i+<span class="number">2</span>));</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + (two &lt;= <span class="number">26</span> &amp;&amp; two &gt; <span class="number">0</span>? dp[i-<span class="number">2</span>] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a>47. 礼物的最大价值</h5><p>在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1    10   3    8</span><br><span class="line">12   2    9    6</span><br><span class="line">5    7    4    11</span><br><span class="line">3    7    16   5</span><br></pre></td></tr></table></figure>
<p>礼物的最大价值为 1+12+5+7+7+16+5=53。</p>
<p>应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[][] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.length;</span><br><span class="line">    <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + board[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度还可以优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[][] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span> || values[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = values[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] value : values) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] += value[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            dp[i] = Math.max(dp[i], dp[i - <span class="number">1</span>]) + value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48. 最长不含重复字符的子字符串"></a>48. 最长不含重复字符的子字符串</h5><p>输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubStringWithoutDuplication</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] indexs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = str.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> preIndex = indexs[c];</span><br><span class="line">        <span class="keyword">if</span> (preIndex == -<span class="number">1</span> || i - preIndex &gt; curLen) curLen++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            maxLen = Math.max(maxLen, curLen);</span><br><span class="line">            curLen = i - preIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        indexs[c] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen = Math.max(maxLen, curLen);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a>49. 丑数</h5><p>把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。 习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">6</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; N) &#123;</span><br><span class="line">        <span class="keyword">int</span> n2 = dp[i2] * <span class="number">2</span>, n3 = dp[i3] * <span class="number">3</span>, n5 = dp[i5] * <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(n2, Math.min(n3, n5));</span><br><span class="line">        dp[cnt++] = min;</span><br><span class="line">        <span class="keyword">if</span> (min == n2) i2++;</span><br><span class="line">        <span class="keyword">if</span> (min == n3) i3++;</span><br><span class="line">        <span class="keyword">if</span> (min == n5) i5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="50-第一个只出现一次的字符位置"><a href="#50-第一个只出现一次的字符位置" class="headerlink" title="50. 第一个只出现一次的字符位置"></a>50. 第一个只出现一次的字符位置</h5><p>在一个字符串 (1&lt;=字符串长度 &lt;=10000，全部由字母组成) 中找到第一个只出现一次的字符，并返回它的位置。</p>
<p>最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) cnts[str.charAt(i)]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) <span class="keyword">if</span> (cnts[str.charAt(i)] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么我们只需要统计的次数信息只有 0,1,更大，那么使用两个比特位就能存储这些信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    BitSet bs1 = <span class="keyword">new</span> BitSet(<span class="number">256</span>);</span><br><span class="line">    BitSet bs2 = <span class="keyword">new</span> BitSet(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bs1.get(c) &amp;&amp; !bs2.get(c)) bs1.set(c);     <span class="comment">// 0 0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bs1.get(c) &amp;&amp; !bs2.get(c)) bs2.set(c); <span class="comment">// 0 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (bs1.get(c) &amp;&amp; !bs2.get(c)) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a>51. 数组中的逆序对</h5><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数 P。题目保证输入的数组中没有的相同的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] tmp;  <span class="comment">// 在这里声明辅助数组，而不是在 merge() 递归函数中声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    tmp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (cnt % <span class="number">1000000007</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h - l &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, l, m);</span><br><span class="line">    mergeSort(nums, m + <span class="number">1</span>, h);</span><br><span class="line">    merge(nums, l, m, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>, k = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m || j &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; m)</span><br><span class="line">            tmp[k] = nums[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; h)</span><br><span class="line">            tmp[k] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[j])</span><br><span class="line">            tmp[k] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[j])&#123;</span><br><span class="line">            tmp[k] = nums[j++];</span><br><span class="line">            <span class="keyword">this</span>.cnt += m - i; <span class="comment">// nums[i] = nums[j]，说明 nums[i+1...mid] 都大于 nums[j]</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k] = nums[j++];</span><br><span class="line">            <span class="keyword">this</span>.cnt += m - i + <span class="number">1</span>;  <span class="comment">// nums[i] &gt; nums[j]，说明 nums[i...mid] 都大于 nums[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = l; k &lt;= h; k++)</span><br><span class="line">        nums[k] = tmp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="52-两个链表的第一个公共结点"><a href="#52-两个链表的第一个公共结点" class="headerlink" title="52. 两个链表的第一个公共结点"></a>52. 两个链表的第一个公共结点</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                  ↘</span><br><span class="line">                    c1 → c2 → c3</span><br><span class="line">                  ↗</span><br><span class="line">B:    b1 → b2 → b3</span><br></pre></td></tr></table></figure>
<p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    ListNode l1 = pHead1, l2 = pHead2;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? pHead2 : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? pHead1 : l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="53-数字在排序数组中出现的次数"><a href="#53-数字在排序数组中出现的次数" class="headerlink" title="==53 数字在排序数组中出现的次数=="></a>==53 数字在排序数组中出现的次数==</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">1, 2, 3, 3, 3, 3, 4, 6</span><br><span class="line">3</span><br><span class="line">Output:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>可以用二分查找找出大于等于某数的第一个索引。若数组中所有数都小于该数，则返回数组的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = binarySearch(nums, K);</span><br><span class="line">    <span class="keyword">int</span> last = binarySearch(nums, K + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> first == nums.length ? <span class="number">0</span> : last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &gt;= K)</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="54-二叉搜索树的第-K-个结点"><a href="#54-二叉搜索树的第-K-个结点" class="headerlink" title="++54. 二叉搜索树的第 K 个结点++"></a>++54. 二叉搜索树的第 K 个结点++</h5><p>利用二叉搜索数中序遍历有序的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode ret;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    inOrder(pRoot, k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; k) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left, k);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt == k) ret = root;</span><br><span class="line">    inOrder(root.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55.1 二叉树的深度"></a>55.1 二叉树的深度</h5><p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(TreeDepth(root.left), TreeDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55.2 平衡二叉树"></a>55.2 平衡二叉树</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>平衡二叉树左右子树高度差不超过 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    height(root);</span><br><span class="line">    <span class="keyword">return</span> isBalanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = height(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = height(root.right);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>) isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="56-数组中只出现一次的数字"><a href="#56-数组中只出现一次的数字" class="headerlink" title="56. 数组中只出现一次的数字"></a>56. 数组中只出现一次的数字</h5><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。</p>
<p>两个不相等的元素在位级表示上必定会有一位存在不同。</p>
<p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : array) diff ^= num;</span><br><span class="line">    <span class="comment">// 得到最右一位</span></span><br><span class="line">    diff &amp;= -diff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>) num1[<span class="number">0</span>] ^= num;</span><br><span class="line">        <span class="keyword">else</span> num2[<span class="number">0</span>] ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="57-1-和为-S-的两个数字"><a href="#57-1-和为-S-的两个数字" class="headerlink" title="57.1 和为 S 的两个数字"></a>57.1 和为 S 的两个数字</h5><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。</p>
<p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<p>如果两个指针指向元素的和 sum == target，那么得到要求的结果；如果 sum &gt; target，移动较大的元素，使 sum 变小一些；如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = array[i] + array[j];</span><br><span class="line">        <span class="keyword">if</span> (cur == sum) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(array[i], array[j]));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur &lt; sum) i++;</span><br><span class="line">        <span class="keyword">else</span> j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="57-2-和为-S-的连续正数序列"><a href="#57-2-和为-S-的连续正数序列" class="headerlink" title="57.2 和为 S 的连续正数序列"></a>57.2 和为 S 的连续正数序列</h5><p>和为 100 的连续序列有 18, 19, 20, 21, 22。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>, last = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (first &lt;= sum / <span class="number">2</span> &amp;&amp; last &lt; sum) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; sum) &#123;</span><br><span class="line">            curSum -= first;</span><br><span class="line">            first++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum &lt; sum) &#123;</span><br><span class="line">            last++;</span><br><span class="line">            curSum += last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(list);</span><br><span class="line">            curSum -= first;</span><br><span class="line">            first++;</span><br><span class="line">            last++;</span><br><span class="line">            curSum += last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="58-1-翻转单词顺序列"><a href="#58-1-翻转单词顺序列" class="headerlink" title="58.1 翻转单词顺序列"></a>58.1 翻转单词顺序列</h5><p>输入：”I am a student.”</p>
<p>输出：”student. a am I”</p>
<p>题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(n)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">int</span> n = str.length();</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == n || chars[j] == <span class="string">' '</span>) &#123;</span><br><span class="line">            reverse(chars, i, j - <span class="number">1</span>);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">char</span> t = c[i]; c[i] = c[j]; c[j] = t;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58.2 左旋转字符串"></a>58.2 左旋转字符串</h5><p>对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”, 要求输出循环左移 3 位后的结果，即“XYZdefabc”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line">    reverse(c, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    reverse(c, n, c.length - <span class="number">1</span>);</span><br><span class="line">    reverse(c, <span class="number">0</span>, c.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">char</span> t = c[i]; c[i] = c[j]; c[j] = t;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="59-滑动窗口的最大值"><a href="#59-滑动窗口的最大值" class="headerlink" title="59. 滑动窗口的最大值"></a>59. 滑动窗口的最大值</h5><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; num.length || size &lt; <span class="number">1</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// 构建最大堆，即堆顶元素是堆的最大值。</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) heap.add(num[i]);</span><br><span class="line">    ret.add(heap.peek());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + size - <span class="number">1</span> &lt; num.length; i++) &#123;</span><br><span class="line">        heap.remove(num[i - <span class="number">1</span>]);</span><br><span class="line">        heap.add(num[i + size - <span class="number">1</span>]);</span><br><span class="line">        ret.add(heap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书上思路：队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || size &lt;= <span class="number">0</span> || num.length &lt; size) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size() != <span class="number">0</span> &amp;&amp; queue.get(<span class="number">0</span>) &lt;= i-size)&#123;</span><br><span class="line">                queue.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i] &gt;= num[queue.get(<span class="number">0</span>)])&#123;</span><br><span class="line">                    queue.clear();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span> </span><br><span class="line">                         &amp;&amp; num[queue.get(queue.size()-<span class="number">1</span>)] &lt; num[i])&#123;</span><br><span class="line">                        queue.remove(queue.size()-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= size - <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(num[queue.get(<span class="number">0</span>)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="60-n-个骰子的点数"><a href="#60-n-个骰子的点数" class="headerlink" title="60. n 个骰子的点数"></a>60. n 个骰子的点数</h5><p>把 n 个骰子仍在地上，求点数和为 s 的概率。</p>
<p><strong>动态规划解法</strong></p>
<p>空间复杂度：O(n<sup>2</sup>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> face = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">countProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || s &lt; n) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> pointNum = face * n;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][pointNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; face; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; pointNum; j++) &#123; <span class="comment">// 使用 i 个骰子最小点数为 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= face; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> totalNum = (<span class="keyword">int</span>) Math.pow(<span class="number">6</span>, n);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) dp[n - <span class="number">1</span>][s - <span class="number">1</span>] / totalNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>动态规划解法 + 旋转数组</strong></p>
<p>空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> face = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">countProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || s &lt; n) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> pointNum = face * n;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][pointNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; face; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; pointNum; j++) &#123; <span class="comment">// 使用 i 个骰子最小点数为 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= face; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[flag][j] += dp[<span class="number">1</span> - flag][j - k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span> - flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> totalNum = (<span class="keyword">int</span>) Math.pow(<span class="number">6</span>, n);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) dp[flag][s - <span class="number">1</span>] / totalNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="61-扑克牌顺子"><a href="#61-扑克牌顺子" class="headerlink" title="61. 扑克牌顺子"></a>61. 扑克牌顺子</h5><p>五张牌，其中大小鬼为癞子，牌面大小为 0。判断是否能组成顺子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) <span class="keyword">if</span> (num == <span class="number">0</span>) cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i + <span class="number">1</span>] == nums[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> interval = nums[i + <span class="number">1</span>] - nums[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (interval &gt; cnt) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        cnt -= interval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="62-圆圈中最后剩下的数"><a href="#62-圆圈中最后剩下的数" class="headerlink" title="==62. 圆圈中最后剩下的数=="></a>==62. 圆圈中最后剩下的数==</h5><p>让小朋友们围成一个大圈。然后 , 他随机指定一个数 m, 让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌 , 然后可以在礼品箱中任意的挑选礼物 , 并且不再回到圈中 , 从他的下一个小朋友开始 , 继续 0…m-1 报数 …. 这样下去 …. 直到剩下最后一个小朋友 , 可以不用表演。</p>
<p>约瑟夫环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LastRemaining_Solution(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a>63. 股票的最大利润</h5><p>可以有一次买入和一次卖出，买入必须在前。求最大收益。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> soFarMin = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(soFarMin &gt; prices[i]) soFarMin = prices[i];</span><br><span class="line">        <span class="keyword">else</span> max = Math.max(max, prices[i] - soFarMin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="64-求-1-2-3-…-n"><a href="#64-求-1-2-3-…-n" class="headerlink" title="++64. 求 1+2+3+…+n++"></a>++64. 求 1+2+3+…+n++</h5><p>求 1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="keyword">boolean</span> b = (n &gt; <span class="number">0</span>) &amp;&amp; ((sum += Sum_Solution(n - <span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65. 不用加减乘除做加法"></a>65. 不用加减乘除做加法</h5><p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num2 == <span class="number">0</span>) <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="keyword">return</span> Add(num1 ^ num2, (num1 &amp; num2) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66. 构建乘积数组"></a>66. 构建乘积数组</h5><p>给定一个数组 A[0, 1,…, n-1], 请构建一个数组 B[0, 1,…, n-1], 其中 B 中的元素 B[i]=A[0]*A[1]*…*A[i-1]*A[i+1]*…*A[n-1]。不能使用除法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, product = <span class="number">1</span>; i &lt; n; product *= A[i], i++) &#123;</span><br><span class="line">        B[i] = product;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, product = <span class="number">1</span>; i &gt;= <span class="number">0</span>; product *= A[i], i--) &#123;</span><br><span class="line">        B[i] *= product;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67. 把字符串转换成整数"></a>67. 把字符串转换成整数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2147483647+1 = -2147483648</span></span><br><span class="line"><span class="comment">//-(-2147483648) = -2147483648</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">boolean</span> isNegative = chars[<span class="number">0</span>] == <span class="string">'-'</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; (chars[i] == <span class="string">'+'</span> || chars[i] == <span class="string">'-'</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] &lt; <span class="string">'0'</span> || chars[i] &gt; <span class="string">'9'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ret = ret * <span class="number">10</span> + (chars[i] - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isNegative ? -ret : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="68-树中两个节点的最低公共祖先"><a href="#68-树中两个节点的最低公共祖先" class="headerlink" title="==68. 树中两个节点的最低公共祖先=="></a>==68. 树中两个节点的最低公共祖先==</h5><p>二叉查找树</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        _______6______</span><br><span class="line">       /              \</span><br><span class="line">   ___2__           ___8__</span><br><span class="line">  /      \         /      \</span><br><span class="line"> 0        4       7        9</span><br><span class="line">         / \</span><br><span class="line">        3   5</span><br><span class="line">For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通二叉树</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       _______3______</span><br><span class="line">      /              \</span><br><span class="line">  ___5__           ___1__</span><br><span class="line"> /      \         /      \</span><br><span class="line"> 6       2       0        8</span><br><span class="line">        / \</span><br><span class="line">       7   4</span><br><span class="line">For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="开发一个实时热搜的榜单。"><a href="#开发一个实时热搜的榜单。" class="headerlink" title="开发一个实时热搜的榜单。"></a>开发一个实时热搜的榜单。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">第一行一个正整数n，表示接下来有n条操作。（1&lt;= n &lt;= 100000）</span><br><span class="line">接下来n行，每行是两种操作中的一种：</span><br><span class="line">append x y ：其中x和y是两个正整数，表示接收到新闻x的热度提升了y。（新闻编号x的范围是[1,1000]，单次热度提升y的范围是[1,1000]）</span><br><span class="line">query : 用户向你发来查询。</span><br><span class="line">输出</span><br><span class="line">对于每条用户查询，输出最高的十条新闻，以空格分隔。不足十条时，有几条输出几条。没有新闻时，输出null。每条查询的输出占一行。</span><br><span class="line">样例输入</span><br><span class="line">9</span><br><span class="line">query</span><br><span class="line">append 1 10</span><br><span class="line">query</span><br><span class="line">append 2 20</span><br><span class="line">query</span><br><span class="line">append 3 15</span><br><span class="line">query</span><br><span class="line">append 1 10</span><br><span class="line">query</span><br><span class="line">样例输出</span><br><span class="line">null</span><br><span class="line">1 </span><br><span class="line">2 1 </span><br><span class="line">2 3 1 </span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            String s = sc.nextLine();</span><br><span class="line">            String[] sa = s.split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span> (sa.length != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = Integer.parseInt(sa[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span> y = Integer.parseInt(sa[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(x))&#123;</span><br><span class="line">                    map.put(x,map.get(x)+y);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(x,y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"query"</span>)) &#123;</span><br><span class="line">                ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">                Collections.sort(entries, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//System.out.println(Arrays.toString(entries.toArray()));</span></span><br><span class="line">                <span class="keyword">if</span>(entries.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"null"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(entries.size()&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; o1:entries)&#123;</span><br><span class="line">                            System.out.print(o1.getKey()+<span class="string">" "</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(entries.get(j)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                                System.out.print(entries.get(j).getKey()+<span class="string">" "</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
		<!-- 在这里添加版权内容-->
		
				<! -- 添加版权信息 -->
<! -- 设置版权信息格式 -->
<style type="text/css">
div.article-footer-copyright{
   border-top:1px solid #d3d3d3;
   margin: 20px auto;     
   padding-left:2em;
   width: 100%;
}
div.article-footer-copyright span,.copyright abbr{
  color:#3d3d3d;
}
div.article-footer-copyright{
	margin-top:2em;
	padding:1.5em;
	border:1px solid #d3d3d3;
	background-color:#eaeaea;
}
div.article-footer-copyright {
	line-height: 160%;
	margin: 10px;
	font-size: 90%;
    color: #A3A3A3
}
</style>
<br>
<!-- 版权信息内容在这里 -->
<div class="article-footer-copyright">
本文作者：<b><a href="/index.html" target="_blank" title="方既白">方既白</a></b>，采用署名-非商业性使用-相同方式共享<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a>许可协议</br>
本文标题：<b><a href="/2021/20211001面试汇总/" target="_blank" title="面试问题汇总">面试问题汇总</a></b>
</br>
本文链接：<b><a href="https://blog.syzhou.site/2021/20211001面试汇总/" target="_blank" title="面试问题汇总">https://blog.syzhou.site/2021/20211001面试汇总/</a></b>
</div>
<! -- 添加版权信息 -->
		
		<!--添加版权内容结束-->
      
        <div class="page-reward">
          <a href="javascript:;" class="page-reward-btn tooltip-top">
            <div class="tooltip tooltip-east">
            <span class="tooltip-item">
              赏
            </span>
            <span class="tooltip-content">
              <span class="tooltip-text">
                <span class="tooltip-inner">
                  <p class="reward-p"><i class="icon icon-quo-left"></i>谢谢你请我吃糖果<i class="icon icon-quo-right"></i></p>
                  <div class="reward-box">
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/assets/img/alipay.png">
                      <span class="reward-type">支付宝</span>
                    </div>
                    
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/assets/img/weixin.png">
                      <span class="reward-type">微信</span>
                    </div>
                    
                  </div>
                </span>
              </span>
            </span>
          </div>
          </a>
        </div>
      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">基础</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">复习</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/learning//" class="article-tag-list-link color5">技术学习</a>
        		</li>
      		
		</ul>
	</div>


      

      
        
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="http://bshare.optimix.asia/barCode?site=weixin&url=http:/2021/20211001面试汇总/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2021/20210310MySQL复习/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          MySQL复习
        
      </div>
    </a>
  
  
    <a href="/2020/20201210各种代码题汇总/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">刷题问题汇总</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category"></i>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content">
                    <div class="toc-article">
                    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#项目"><span class="toc-number">1.</span> <span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#自我介绍"><span class="toc-number">1.0.1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#错题集"><span class="toc-number">1.0.2.</span> <span class="toc-text">错题集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#反问："><span class="toc-number">1.0.3.</span> <span class="toc-text">反问：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#大数据项目"><span class="toc-number">1.0.4.</span> <span class="toc-text">大数据项目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#电影推荐"><span class="toc-number">1.0.5.</span> <span class="toc-text">电影推荐</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#论文格式检测系统"><span class="toc-number">1.0.6.</span> <span class="toc-text">论文格式检测系统</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常考题"><span class="toc-number">1.1.</span> <span class="toc-text">常考题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景题"><span class="toc-number">2.</span> <span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#O-1-时间内删除链表节点"><span class="toc-number">2.1.</span> <span class="toc-text">O(1)时间内删除链表节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#海量数据处理"><span class="toc-number">2.2.</span> <span class="toc-text">海量数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#怎样对10亿个数字（字符串）快速去重？"><span class="toc-number">2.2.1.</span> <span class="toc-text">怎样对10亿个数字（字符串）快速去重？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#100亿个数取出最大的10000个"><span class="toc-number">2.2.2.</span> <span class="toc-text">100亿个数取出最大的10000个</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如何在海量数据中找出重复最多⼀个。（提取出某⽇访问百度次数最多的那个IP）"><span class="toc-number">2.2.3.</span> <span class="toc-text">如何在海量数据中找出重复最多⼀个。（提取出某⽇访问百度次数最多的那个IP）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#有10个1G⽂件，每⾏都是⼀个可重复⽤户query，按query频度排序。"><span class="toc-number">2.2.4.</span> <span class="toc-text">有10个1G⽂件，每⾏都是⼀个可重复⽤户query，按query频度排序。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#A-B两个⽂件各存放50亿url，每个为64Byte，限制内存4G找出公共url。"><span class="toc-number">2.2.5.</span> <span class="toc-text">A,B两个⽂件各存放50亿url，每个为64Byte，限制内存4G找出公共url。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BitMap"><span class="toc-number">2.3.</span> <span class="toc-text">BitMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见的限流算法"><span class="toc-number">2.4.</span> <span class="toc-text">常见的限流算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#计数器法"><span class="toc-number">2.4.1.</span> <span class="toc-text">计数器法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#滑动窗口"><span class="toc-number">2.4.2.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#漏桶算法"><span class="toc-number">2.4.3.</span> <span class="toc-text">漏桶算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#令牌桶算法"><span class="toc-number">2.4.4.</span> <span class="toc-text">令牌桶算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式环境下全局唯一的发号器"><span class="toc-number">2.5.</span> <span class="toc-text">分布式环境下全局唯一的发号器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、UUID"><span class="toc-number">2.5.1.</span> <span class="toc-text">1、UUID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、数据库自增长序列或字段"><span class="toc-number">2.5.2.</span> <span class="toc-text">2、数据库自增长序列或字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、数据库sequence表以及乐观锁"><span class="toc-number">2.5.3.</span> <span class="toc-text">3、数据库sequence表以及乐观锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、Redis生成ID"><span class="toc-number">2.5.4.</span> <span class="toc-text">4、Redis生成ID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、Twitter的snowflake算法"><span class="toc-number">2.5.5.</span> <span class="toc-text">5、Twitter的snowflake算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java实现线程安全的List"><span class="toc-number">2.6.</span> <span class="toc-text">Java实现线程安全的List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java实现阻塞队列"><span class="toc-number">2.7.</span> <span class="toc-text">Java实现阻塞队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaSE"><span class="toc-number">3.</span> <span class="toc-text">JavaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基础"><span class="toc-number">3.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK、JRE、JVM"><span class="toc-number">3.1.1.</span> <span class="toc-text">JDK、JRE、JVM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java程序执行"><span class="toc-number">3.1.2.</span> <span class="toc-text">java程序执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#与equals"><span class="toc-number">3.1.3.</span> <span class="toc-text">==与equals()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法参数传值"><span class="toc-number">3.1.4.</span> <span class="toc-text">方法参数传值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#final和static"><span class="toc-number">3.1.5.</span> <span class="toc-text">final和static</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据类型"><span class="toc-number">3.1.6.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#包装类缓存机制"><span class="toc-number">3.1.7.</span> <span class="toc-text">包装类缓存机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ASCII"><span class="toc-number">3.1.8.</span> <span class="toc-text">ASCII</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java内存计算"><span class="toc-number">3.1.9.</span> <span class="toc-text">Java内存计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String，StringBuffer，StringBuider"><span class="toc-number">3.1.10.</span> <span class="toc-text">String，StringBuffer，StringBuider</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String-不可变的原因"><span class="toc-number">3.1.11.</span> <span class="toc-text">String 不可变的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重写equals还要重写hashcode？"><span class="toc-number">3.1.12.</span> <span class="toc-text">重写equals还要重写hashcode？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String-intern"><span class="toc-number">3.1.13.</span> <span class="toc-text">String#intern()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#new-String-“abc”"><span class="toc-number">3.1.14.</span> <span class="toc-text">new String(“abc”)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object类"><span class="toc-number">3.1.15.</span> <span class="toc-text">Object类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Runtime-类"><span class="toc-number">3.1.16.</span> <span class="toc-text">Runtime 类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Enum类"><span class="toc-number">3.1.17.</span> <span class="toc-text">Enum类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#finally-代码块和-finalize-方法有什么区别？"><span class="toc-number">3.1.18.</span> <span class="toc-text">finally  代码块和 finalize()方法有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#comparable和-comparator-接口区别"><span class="toc-number">3.1.19.</span> <span class="toc-text">comparable和 comparator 接口区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#接口和抽象类的区别"><span class="toc-number">3.1.20.</span> <span class="toc-text">接口和抽象类的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#session与cookie"><span class="toc-number">3.1.21.</span> <span class="toc-text">session与cookie</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hash算法"><span class="toc-number">3.1.22.</span> <span class="toc-text">hash算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java动态代理"><span class="toc-number">3.1.23.</span> <span class="toc-text">Java动态代理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象"><span class="toc-number">3.2.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java创建对象四种方法"><span class="toc-number">3.2.1.</span> <span class="toc-text">Java创建对象四种方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#强、软、弱和虚引用"><span class="toc-number">3.2.2.</span> <span class="toc-text">强、软、弱和虚引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#封装"><span class="toc-number">3.2.3.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#继承"><span class="toc-number">3.2.4.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多态"><span class="toc-number">3.2.5.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重载与重写"><span class="toc-number">3.2.6.</span> <span class="toc-text">重载与重写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内部类"><span class="toc-number">3.2.7.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#类加载器初始化"><span class="toc-number">3.2.8.</span> <span class="toc-text">类加载器初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型"><span class="toc-number">3.3.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么使用泛型"><span class="toc-number">3.3.1.</span> <span class="toc-text">为什么使用泛型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#泛型的实现"><span class="toc-number">3.3.2.</span> <span class="toc-text">泛型的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通配符"><span class="toc-number">3.3.3.</span> <span class="toc-text">通配符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件与IO"><span class="toc-number">3.4.</span> <span class="toc-text">文件与IO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IO-NIO-BIO-AIO"><span class="toc-number">3.4.1.</span> <span class="toc-text">IO  NIO BIO  AIO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NIO原理"><span class="toc-number">3.4.2.</span> <span class="toc-text">NIO原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#select-epoll"><span class="toc-number">3.4.3.</span> <span class="toc-text">select/epoll</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常"><span class="toc-number">3.5.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#序列化"><span class="toc-number">3.6.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射"><span class="toc-number">3.7.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java各版本的特性"><span class="toc-number">3.8.</span> <span class="toc-text">java各版本的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK1-5"><span class="toc-number">3.8.1.</span> <span class="toc-text">JDK1.5</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK1-6"><span class="toc-number">3.8.2.</span> <span class="toc-text">JDK1.6</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK1-7"><span class="toc-number">3.8.3.</span> <span class="toc-text">JDK1.7</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK1-8"><span class="toc-number">3.8.4.</span> <span class="toc-text">JDK1.8</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java集合"><span class="toc-number">4.</span> <span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#集合总览"><span class="toc-number">4.1.</span> <span class="toc-text">集合总览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">4.2.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Iterator和ListIterator区别"><span class="toc-number">4.2.1.</span> <span class="toc-text">Iterator和ListIterator区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList、LinkedList、Vector"><span class="toc-number">4.2.2.</span> <span class="toc-text">ArrayList、LinkedList、Vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#快速失败-fail-fast-和安全失败-fail-safe"><span class="toc-number">4.2.3.</span> <span class="toc-text">快速失败(fail-fast) 和安全失败(fail-safe)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RandomAccess-接⼝"><span class="toc-number">4.2.4.</span> <span class="toc-text">RandomAccess 接⼝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList扩容"><span class="toc-number">4.2.5.</span> <span class="toc-text">ArrayList扩容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Collections-sort-原理"><span class="toc-number">4.2.6.</span> <span class="toc-text">Collections.sort  原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">4.3.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-number">4.4.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hashcode-的计算"><span class="toc-number">4.4.1.</span> <span class="toc-text">hashcode 的计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#扩容机制"><span class="toc-number">4.4.2.</span> <span class="toc-text">扩容机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#负载因子0-75"><span class="toc-number">4.4.3.</span> <span class="toc-text">负载因子0.75</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get方法（不加锁）"><span class="toc-number">4.4.4.</span> <span class="toc-text">get方法（不加锁）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#put方法"><span class="toc-number">4.4.5.</span> <span class="toc-text">put方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对key为NULL的特别处理"><span class="toc-number">4.4.6.</span> <span class="toc-text">对key为NULL的特别处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程不安全"><span class="toc-number">4.4.7.</span> <span class="toc-text">线程不安全</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#key-可以为任意对象或数据类型吗？"><span class="toc-number">4.4.8.</span> <span class="toc-text">key 可以为任意对象或数据类型吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#树化操作的阈值是8和6？"><span class="toc-number">4.4.9.</span> <span class="toc-text">树化操作的阈值是8和6？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap-JDK-1-8"><span class="toc-number">4.4.10.</span> <span class="toc-text">HashMap - JDK 1.8</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">4.5.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#size-操作"><span class="toc-number">4.5.1.</span> <span class="toc-text">size 操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-原理"><span class="toc-number">4.5.2.</span> <span class="toc-text">Get 原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Put原理"><span class="toc-number">4.5.3.</span> <span class="toc-text">Put原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap（JDK1-8）"><span class="toc-number">4.5.4.</span> <span class="toc-text">ConcurrentHashMap（JDK1.8）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap与HashTable区别"><span class="toc-number">4.5.5.</span> <span class="toc-text">HashMap与HashTable区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap与ConcurrentHashMap区别"><span class="toc-number">4.5.6.</span> <span class="toc-text">HashMap与ConcurrentHashMap区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap与HashTable区别"><span class="toc-number">4.5.7.</span> <span class="toc-text">ConcurrentHashMap与HashTable区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">4.6.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet"><span class="toc-number">4.7.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityQueue"><span class="toc-number">4.8.</span> <span class="toc-text">PriorityQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakHashMap"><span class="toc-number">4.9.</span> <span class="toc-text">WeakHashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-number">5.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM-内存模型"><span class="toc-number">5.1.</span> <span class="toc-text">JMM 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JMM-的-happens-before-原则"><span class="toc-number">5.1.1.</span> <span class="toc-text">JMM 的 happens-before 原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么要实现内存模型"><span class="toc-number">5.1.2.</span> <span class="toc-text">为什么要实现内存模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存分区"><span class="toc-number">5.2.</span> <span class="toc-text">内存分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#什么是堆中的永久代"><span class="toc-number">5.2.1.</span> <span class="toc-text">什么是堆中的永久代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#程序计数器为什么是私有的"><span class="toc-number">5.2.2.</span> <span class="toc-text">程序计数器为什么是私有的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对象初始化过程-newA"><span class="toc-number">5.2.3.</span> <span class="toc-text">对象初始化过程 newA()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分配内存两种方式"><span class="toc-number">5.2.4.</span> <span class="toc-text">分配内存两种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发下对象分配内存时线程安全"><span class="toc-number">5.2.5.</span> <span class="toc-text">并发下对象分配内存时线程安全</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对象的内存布局"><span class="toc-number">5.2.6.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对象的访问定位方式"><span class="toc-number">5.2.7.</span> <span class="toc-text">对象的访问定位方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java堆内存溢出"><span class="toc-number">5.2.8.</span> <span class="toc-text">java堆内存溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对象的强、软、弱和虚引用"><span class="toc-number">5.2.9.</span> <span class="toc-text">对象的强、软、弱和虚引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如何减少-GC-的次数"><span class="toc-number">5.2.10.</span> <span class="toc-text">如何减少 GC 的次数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OutOfMemory和StackOverflow"><span class="toc-number">5.2.11.</span> <span class="toc-text">OutOfMemory和StackOverflow</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC-算法（YGC-and-FGC）"><span class="toc-number">5.3.</span> <span class="toc-text">GC  算法（YGC and  FGC）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#判断一个对象是否存活-GC-对象判定方法"><span class="toc-number">5.3.1.</span> <span class="toc-text">判断一个对象是否存活?(GC 对象判定方法)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Minor-GC-和-Full-GC"><span class="toc-number">5.3.2.</span> <span class="toc-text">Minor GC 和 Full GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内存分配与回收策略"><span class="toc-number">5.3.3.</span> <span class="toc-text">内存分配与回收策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Full-GC-触发条件"><span class="toc-number">5.3.4.</span> <span class="toc-text">Full GC 触发条件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#垃圾收集器"><span class="toc-number">5.4.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial收集器"><span class="toc-number">5.4.1.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ParNew收集器"><span class="toc-number">5.4.2.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Scavenge收集器"><span class="toc-number">5.4.3.</span> <span class="toc-text">Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-Old-收集器"><span class="toc-number">5.4.4.</span> <span class="toc-text">Serial Old 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Old收集器"><span class="toc-number">5.4.5.</span> <span class="toc-text">Parallel Old收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS收集器"><span class="toc-number">5.4.6.</span> <span class="toc-text">CMS收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1收集器"><span class="toc-number">5.4.7.</span> <span class="toc-text">G1收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS-与-G1-整体区别"><span class="toc-number">5.4.8.</span> <span class="toc-text">CMS 与 G1 整体区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#总结"><span class="toc-number">5.4.9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#组合选择"><span class="toc-number">5.4.10.</span> <span class="toc-text">组合选择</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-类加载机制"><span class="toc-number">5.5.</span> <span class="toc-text">Java 类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Class文件字节码结构组织示意图"><span class="toc-number">5.5.1.</span> <span class="toc-text">Class文件字节码结构组织示意图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#类加载过程"><span class="toc-number">5.5.2.</span> <span class="toc-text">类加载过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">5.5.3.</span> <span class="toc-text">双亲委派机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM对锁的优化"><span class="toc-number">5.6.</span> <span class="toc-text">JVM对锁的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存泄漏"><span class="toc-number">5.7.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jstat-jmap-jps-jinfo-jconsole查看内存"><span class="toc-number">5.7.1.</span> <span class="toc-text">jstat jmap jps jinfo jconsole查看内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#参数设置"><span class="toc-number">5.7.2.</span> <span class="toc-text">参数设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java并发"><span class="toc-number">6.</span> <span class="toc-text">Java并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile原理"><span class="toc-number">6.1.</span> <span class="toc-text">volatile原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS原理"><span class="toc-number">6.2.</span> <span class="toc-text">CAS原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ABA问题"><span class="toc-number">6.2.1.</span> <span class="toc-text">ABA问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#循环时间长开销大。"><span class="toc-number">6.2.2.</span> <span class="toc-text">循环时间长开销大。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#只能保证一个共享变量的原子操作。"><span class="toc-number">6.2.3.</span> <span class="toc-text">只能保证一个共享变量的原子操作。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized-原理"><span class="toc-number">6.3.</span> <span class="toc-text">Synchronized 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#双检锁实现单例（线程安全）"><span class="toc-number">6.3.1.</span> <span class="toc-text">双检锁实现单例（线程安全）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对synchronized的优化-偏向锁、轻量级锁、自旋锁和重量级锁"><span class="toc-number">6.3.2.</span> <span class="toc-text">对synchronized的优化,偏向锁、轻量级锁、自旋锁和重量级锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#公平锁与非公平锁"><span class="toc-number">6.3.3.</span> <span class="toc-text">公平锁与非公平锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Volatile-与-synchronized-区别"><span class="toc-number">6.3.4.</span> <span class="toc-text">Volatile 与 synchronized 区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReentrantLock-和-synchronized-区别"><span class="toc-number">6.3.5.</span> <span class="toc-text">ReentrantLock 和 synchronized 区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS-AbstractQueuedSynchronizer"><span class="toc-number">6.4.</span> <span class="toc-text">AQS(AbstractQueuedSynchronizer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重入锁实现"><span class="toc-number">6.5.</span> <span class="toc-text">重入锁实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">6.6.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JUC包"><span class="toc-number">6.7.</span> <span class="toc-text">JUC包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Threadlocal"><span class="toc-number">6.8.</span> <span class="toc-text">Threadlocal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程与进程"><span class="toc-number">6.9.</span> <span class="toc-text">线程与进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建线程方法"><span class="toc-number">6.9.1.</span> <span class="toc-text">创建线程方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程状态"><span class="toc-number">6.9.2.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程、进程与程序的区别"><span class="toc-number">6.9.3.</span> <span class="toc-text">线程、进程与程序的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程通信方式"><span class="toc-number">6.9.4.</span> <span class="toc-text">进程通信方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程池"><span class="toc-number">6.9.5.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4种类型的线程池"><span class="toc-number">6.9.6.</span> <span class="toc-text">4种类型的线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程池基本参数"><span class="toc-number">6.9.7.</span> <span class="toc-text">线程池基本参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程池实现原理"><span class="toc-number">6.9.8.</span> <span class="toc-text">线程池实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#submit-和-execute"><span class="toc-number">6.9.9.</span> <span class="toc-text">submit() 和 execute()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#僵尸进程"><span class="toc-number">6.9.10.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程死锁"><span class="toc-number">6.9.11.</span> <span class="toc-text">进程死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多线程共用一个数据变量"><span class="toc-number">6.9.12.</span> <span class="toc-text">多线程共用一个数据变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#一般线程和守护线程的区别"><span class="toc-number">6.9.13.</span> <span class="toc-text">一般线程和守护线程的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sleep与wait"><span class="toc-number">6.9.14.</span> <span class="toc-text">Sleep与wait</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield-join-notify-notifyAll"><span class="toc-number">6.9.15.</span> <span class="toc-text">yield join notify notifyAll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#中断线程"><span class="toc-number">6.9.16.</span> <span class="toc-text">中断线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多线程抛异常"><span class="toc-number">6.9.17.</span> <span class="toc-text">多线程抛异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL"><span class="toc-number">7.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL基础"><span class="toc-number">7.1.</span> <span class="toc-text">MySQL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#常用操作数据库的命令"><span class="toc-number">7.1.1.</span> <span class="toc-text">常用操作数据库的命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL数据类型"><span class="toc-number">7.1.2.</span> <span class="toc-text">MySQL数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#改表-：DDL-数据定义语言"><span class="toc-number">7.1.3.</span> <span class="toc-text">改表 ：DDL 数据定义语言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#完整select"><span class="toc-number">7.1.4.</span> <span class="toc-text">完整select</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据操作：DQL数据查询语言-amp-amp-DML数据操纵语言"><span class="toc-number">7.1.5.</span> <span class="toc-text">数据操作：DQL数据查询语言 &amp;&amp; DML数据操纵语言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多表联合查询"><span class="toc-number">7.1.6.</span> <span class="toc-text">多表联合查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DCL-数据控制语言"><span class="toc-number">7.1.7.</span> <span class="toc-text">DCL 数据控制语言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DTL-数据事务语言"><span class="toc-number">7.1.8.</span> <span class="toc-text">DTL 数据事务语言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#视图"><span class="toc-number">7.1.9.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDBC"><span class="toc-number">7.1.10.</span> <span class="toc-text">JDBC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据库连接池"><span class="toc-number">7.1.11.</span> <span class="toc-text">数据库连接池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C3P0和Druid"><span class="toc-number">7.1.12.</span> <span class="toc-text">C3P0和Druid</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDBCTemplate"><span class="toc-number">7.1.13.</span> <span class="toc-text">JDBCTemplate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据库三大范式"><span class="toc-number">7.1.14.</span> <span class="toc-text">数据库三大范式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引"><span class="toc-number">7.2.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#索引特点和优缺点"><span class="toc-number">7.2.1.</span> <span class="toc-text">索引特点和优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#在哪里建索引"><span class="toc-number">7.2.2.</span> <span class="toc-text">在哪里建索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#索引建立原则"><span class="toc-number">7.2.3.</span> <span class="toc-text">索引建立原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#索引分类"><span class="toc-number">7.2.4.</span> <span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EXPLAIN-SQL"><span class="toc-number">7.2.5.</span> <span class="toc-text">EXPLAIN SQL</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB"><span class="toc-number">7.3.</span> <span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB与MyISAM"><span class="toc-number">7.4.</span> <span class="toc-text">InnoDB与MyISAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC"><span class="toc-number">7.5.</span> <span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务"><span class="toc-number">7.6.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#事务的四大特征"><span class="toc-number">7.6.1.</span> <span class="toc-text">事务的四大特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#并发事务带来的问题"><span class="toc-number">7.6.2.</span> <span class="toc-text">并发事务带来的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事务隔离级别（恶果：脏读、-不可重复读、幻读-）"><span class="toc-number">7.6.3.</span> <span class="toc-text">事务隔离级别（恶果：脏读、 不可重复读、幻读 ）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GAP-锁（间隙锁解决幻读）"><span class="toc-number">7.6.4.</span> <span class="toc-text">GAP 锁（间隙锁解决幻读）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#next-key-锁"><span class="toc-number">7.6.5.</span> <span class="toc-text">next-key 锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分布式事务"><span class="toc-number">7.6.6.</span> <span class="toc-text">分布式事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事务两阶段提交（2PC）"><span class="toc-number">7.6.7.</span> <span class="toc-text">事务两阶段提交（2PC）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#XA两阶段提交的不足"><span class="toc-number">7.6.8.</span> <span class="toc-text">XA两阶段提交的不足</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#XA三阶段提交（3PC）"><span class="toc-number">7.6.9.</span> <span class="toc-text">XA三阶段提交（3PC）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MQ事务"><span class="toc-number">7.6.10.</span> <span class="toc-text">MQ事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCC事务"><span class="toc-number">7.6.11.</span> <span class="toc-text">TCC事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#柔性事务"><span class="toc-number">7.6.12.</span> <span class="toc-text">柔性事务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sql-优化"><span class="toc-number">7.7.</span> <span class="toc-text">Sql 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分库分表"><span class="toc-number">7.8.</span> <span class="toc-text">分库分表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库锁"><span class="toc-number">7.9.</span> <span class="toc-text">数据库锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#封锁协议（解决脏读不可重复读）"><span class="toc-number">7.9.1.</span> <span class="toc-text">封锁协议（解决脏读不可重复读）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#死锁活锁"><span class="toc-number">7.9.2.</span> <span class="toc-text">死锁活锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#两阶段协议"><span class="toc-number">7.9.3.</span> <span class="toc-text">两阶段协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计网"><span class="toc-number">8.</span> <span class="toc-text">计网</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分层协议"><span class="toc-number">8.1.</span> <span class="toc-text">分层协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一次网页访问"><span class="toc-number">8.2.</span> <span class="toc-text">一次网页访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP"><span class="toc-number">8.3.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#http请求和响应报文"><span class="toc-number">8.3.1.</span> <span class="toc-text">http请求和响应报文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#http请求方法"><span class="toc-number">8.3.2.</span> <span class="toc-text">http请求方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#http-请求过程"><span class="toc-number">8.3.3.</span> <span class="toc-text">http 请求过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get与post"><span class="toc-number">8.3.4.</span> <span class="toc-text">get与post</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#http长连接"><span class="toc-number">8.3.5.</span> <span class="toc-text">http长连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#http状态码"><span class="toc-number">8.3.6.</span> <span class="toc-text">http状态码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#转发与重定向"><span class="toc-number">8.3.7.</span> <span class="toc-text">转发与重定向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#http1-0-1-1-2-X"><span class="toc-number">8.3.8.</span> <span class="toc-text">http1.0,1.1,2.X</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS-HTTP-加密-认证-完整性保护"><span class="toc-number">8.4.</span> <span class="toc-text">HTTPS=HTTP+ 加密 + 认证 + 完整性保护</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#https与http区别"><span class="toc-number">8.4.1.</span> <span class="toc-text">https与http区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#加密"><span class="toc-number">8.4.2.</span> <span class="toc-text">加密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#认证"><span class="toc-number">8.4.3.</span> <span class="toc-text">认证</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP、UDP"><span class="toc-number">8.5.</span> <span class="toc-text">TCP、UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP与UDP区别"><span class="toc-number">8.5.1.</span> <span class="toc-text">TCP与UDP区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP头部"><span class="toc-number">8.5.2.</span> <span class="toc-text">TCP头部</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP-三次握手"><span class="toc-number">8.5.3.</span> <span class="toc-text">TCP 三次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP四次挥手"><span class="toc-number">8.5.4.</span> <span class="toc-text">TCP四次挥手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tcp-粘包问题-nagle-算法"><span class="toc-number">8.5.5.</span> <span class="toc-text">tcp 粘包问题 nagle 算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tcp-如何保证可靠性传输"><span class="toc-number">8.5.6.</span> <span class="toc-text">tcp 如何保证可靠性传输</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP-流量控制-拥塞控制"><span class="toc-number">8.5.7.</span> <span class="toc-text">TCP 流量控制 拥塞控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#滑动窗口机制"><span class="toc-number">8.5.8.</span> <span class="toc-text">滑动窗口机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#慢开始与拥塞避免"><span class="toc-number">8.5.9.</span> <span class="toc-text">慢开始与拥塞避免</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#快速重传快速恢复"><span class="toc-number">8.5.10.</span> <span class="toc-text">快速重传快速恢复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP状态转移"><span class="toc-number">8.5.11.</span> <span class="toc-text">TCP状态转移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TIME-WAIT-和-CLOSE-WAIT"><span class="toc-number">8.5.12.</span> <span class="toc-text">TIME_WAIT 和 CLOSE_WAIT</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP"><span class="toc-number">8.6.</span> <span class="toc-text">IP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作系统"><span class="toc-number">9.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#大端和小端序"><span class="toc-number">9.0.1.</span> <span class="toc-text">大端和小端序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#程序的内存模型"><span class="toc-number">9.0.2.</span> <span class="toc-text">程序的内存模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IO多路复用"><span class="toc-number">9.0.3.</span> <span class="toc-text">IO多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#僵尸进程和孤儿进程"><span class="toc-number">9.0.4.</span> <span class="toc-text">僵尸进程和孤儿进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#常见Linux命令"><span class="toc-number">9.0.5.</span> <span class="toc-text">常见Linux命令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU调度"><span class="toc-number">9.1.</span> <span class="toc-text">CPU调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存管理方式（页式、段式、段页式）"><span class="toc-number">9.2.</span> <span class="toc-text">内存管理方式（页式、段式、段页式）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#页式"><span class="toc-number">9.2.1.</span> <span class="toc-text">页式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#段式"><span class="toc-number">9.2.2.</span> <span class="toc-text">段式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#段页存储"><span class="toc-number">9.2.3.</span> <span class="toc-text">段页存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#快表和多级⻚表"><span class="toc-number">9.2.4.</span> <span class="toc-text">快表和多级⻚表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#页面置换算法"><span class="toc-number">9.3.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#孤儿进程"><span class="toc-number">9.4.</span> <span class="toc-text">孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#僵尸进程-1"><span class="toc-number">9.5.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原码，反码和补码"><span class="toc-number">9.6.</span> <span class="toc-text">原码，反码和补码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#原码"><span class="toc-number">9.6.1.</span> <span class="toc-text">原码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#反码"><span class="toc-number">9.6.2.</span> <span class="toc-text">反码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#补码"><span class="toc-number">9.6.3.</span> <span class="toc-text">补码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么使用原码，反码和补码"><span class="toc-number">9.6.4.</span> <span class="toc-text">为什么使用原码，反码和补码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式"><span class="toc-number">10.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java中的设计模式"><span class="toc-number">10.0.1.</span> <span class="toc-text">Java中的设计模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网站架构"><span class="toc-number">11.</span> <span class="toc-text">网站架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#大型网站架构演化发展历程"><span class="toc-number">11.1.</span> <span class="toc-text">大型网站架构演化发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#初始阶段的网站架构"><span class="toc-number">11.1.1.</span> <span class="toc-text">初始阶段的网站架构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#应用服务和数据服务分离"><span class="toc-number">11.1.2.</span> <span class="toc-text">应用服务和数据服务分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用缓存改善网站性能"><span class="toc-number">11.1.3.</span> <span class="toc-text">使用缓存改善网站性能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用应用服务器集群改善网站的并发处理能力"><span class="toc-number">11.1.4.</span> <span class="toc-text">使用应用服务器集群改善网站的并发处理能力</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据库读写分离"><span class="toc-number">11.1.5.</span> <span class="toc-text">数据库读写分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用反向代理和-CDN-加速网站响应"><span class="toc-number">11.1.6.</span> <span class="toc-text">使用反向代理和 CDN 加速网站响应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用分布式文件系统和分布式数据库系统"><span class="toc-number">11.1.7.</span> <span class="toc-text">使用分布式文件系统和分布式数据库系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用-NoSQL-和搜索引擎"><span class="toc-number">11.1.8.</span> <span class="toc-text">使用 NoSQL 和搜索引擎</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#业务拆分"><span class="toc-number">11.1.9.</span> <span class="toc-text">业务拆分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分布式微服务"><span class="toc-number">11.1.10.</span> <span class="toc-text">分布式微服务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库架构发展历程"><span class="toc-number">11.2.</span> <span class="toc-text">数据库架构发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#单机MySQL的美好年代"><span class="toc-number">11.2.1.</span> <span class="toc-text">单机MySQL的美好年代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Memcached-缓存-MySQL-垂直拆分"><span class="toc-number">11.2.2.</span> <span class="toc-text">Memcached(缓存)+MySQL+垂直拆分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mysql主从复制读写分离"><span class="toc-number">11.2.3.</span> <span class="toc-text">Mysql主从复制读写分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分表分库-水平拆分-mysql集群"><span class="toc-number">11.2.4.</span> <span class="toc-text">分表分库+水平拆分+mysql集群</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NoSQL"><span class="toc-number">11.2.5.</span> <span class="toc-text">NoSQL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据的水平拆分和垂直拆分"><span class="toc-number">11.2.6.</span> <span class="toc-text">数据的水平拆分和垂直拆分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中间件"><span class="toc-number">12.</span> <span class="toc-text">中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存"><span class="toc-number">12.1.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么要使用缓存"><span class="toc-number">12.1.1.</span> <span class="toc-text">为什么要使用缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis与mencached"><span class="toc-number">12.1.2.</span> <span class="toc-text">Redis与mencached</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#优秀的缓存系统Redis"><span class="toc-number">12.1.3.</span> <span class="toc-text">优秀的缓存系统Redis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redis为什么这么快"><span class="toc-number">12.1.4.</span> <span class="toc-text">redis为什么这么快</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis持久化"><span class="toc-number">12.1.5.</span> <span class="toc-text">Redis持久化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redis的过期策略及内存淘汰机制"><span class="toc-number">12.1.6.</span> <span class="toc-text">redis的过期策略及内存淘汰机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis内存淘汰机制"><span class="toc-number">12.1.7.</span> <span class="toc-text">Redis内存淘汰机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#渐进式ReHash"><span class="toc-number">12.1.8.</span> <span class="toc-text">渐进式ReHash</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缓存穿透"><span class="toc-number">12.1.9.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缓存雪崩"><span class="toc-number">12.1.10.</span> <span class="toc-text">缓存雪崩</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息队列"><span class="toc-number">12.2.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#异步处理"><span class="toc-number">12.2.1.</span> <span class="toc-text">异步处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#应用解耦"><span class="toc-number">12.2.2.</span> <span class="toc-text">应用解耦</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#流量削锋"><span class="toc-number">12.2.3.</span> <span class="toc-text">流量削锋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#日志处理"><span class="toc-number">12.2.4.</span> <span class="toc-text">日志处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#消息通讯"><span class="toc-number">12.2.5.</span> <span class="toc-text">消息通讯</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#电商系统"><span class="toc-number">12.2.6.</span> <span class="toc-text">电商系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#日志收集系统"><span class="toc-number">12.2.7.</span> <span class="toc-text">日志收集系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JMS消息服务"><span class="toc-number">12.2.8.</span> <span class="toc-text">JMS消息服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#两种消息模型P2P（Point-to-Point）-Publish-Subscribe-Pub-Sub"><span class="toc-number">12.2.9.</span> <span class="toc-text">两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#防止消息丢失"><span class="toc-number">12.2.10.</span> <span class="toc-text">防止消息丢失</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#负载均衡"><span class="toc-number">12.3.</span> <span class="toc-text">负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dns域名解析负载均衡"><span class="toc-number">12.3.1.</span> <span class="toc-text">dns域名解析负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#反向代理负载均衡"><span class="toc-number">12.3.2.</span> <span class="toc-text">反向代理负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#http重定向协议实现负载均衡"><span class="toc-number">12.3.3.</span> <span class="toc-text">http重定向协议实现负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#一致性hash-虚拟节点"><span class="toc-number">12.3.4.</span> <span class="toc-text">一致性hash+虚拟节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Zookeeper"><span class="toc-number">12.4.</span> <span class="toc-text">Zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ZK简述"><span class="toc-number">12.4.1.</span> <span class="toc-text">ZK简述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据结构"><span class="toc-number">12.4.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#统一命名服务"><span class="toc-number">12.4.3.</span> <span class="toc-text">统一命名服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#负载均衡-1"><span class="toc-number">12.4.4.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#统一配置管理"><span class="toc-number">12.4.5.</span> <span class="toc-text">统一配置管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#集群管理"><span class="toc-number">12.4.6.</span> <span class="toc-text">集群管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#服务器动态上下线"><span class="toc-number">12.4.7.</span> <span class="toc-text">服务器动态上下线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#写数据流程"><span class="toc-number">12.4.8.</span> <span class="toc-text">写数据流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Leader选举"><span class="toc-number">12.4.9.</span> <span class="toc-text">Leader选举</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#秒杀"><span class="toc-number">12.5.</span> <span class="toc-text">秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#业务特点"><span class="toc-number">12.5.1.</span> <span class="toc-text">业务特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#技术难点"><span class="toc-number">12.5.2.</span> <span class="toc-text">技术难点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#架构设计思想"><span class="toc-number">12.5.3.</span> <span class="toc-text">架构设计思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#客户端优化"><span class="toc-number">12.5.4.</span> <span class="toc-text">客户端优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API-接入层优化"><span class="toc-number">12.5.5.</span> <span class="toc-text">API 接入层优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#秒杀整体流程图"><span class="toc-number">12.5.6.</span> <span class="toc-text">秒杀整体流程图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#素质测评"><span class="toc-number">12.6.</span> <span class="toc-text">素质测评</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#文字理解能力考查"><span class="toc-number">12.6.1.</span> <span class="toc-text">文字理解能力考查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数字推理能力考查"><span class="toc-number">12.6.2.</span> <span class="toc-text">数字推理能力考查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#图像推理能力考查"><span class="toc-number">12.6.3.</span> <span class="toc-text">图像推理能力考查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码题"><span class="toc-number">13.</span> <span class="toc-text">代码题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaSTL"><span class="toc-number">13.1.</span> <span class="toc-text">JavaSTL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码模板"><span class="toc-number">13.2.</span> <span class="toc-text">代码模板</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#快排"><span class="toc-number">13.2.1.</span> <span class="toc-text">快排</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#归并"><span class="toc-number">13.2.2.</span> <span class="toc-text">归并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二分"><span class="toc-number">13.2.3.</span> <span class="toc-text">二分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#高精度"><span class="toc-number">13.2.4.</span> <span class="toc-text">高精度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#前缀和"><span class="toc-number">13.2.5.</span> <span class="toc-text">前缀和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#差分"><span class="toc-number">13.2.6.</span> <span class="toc-text">差分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#位运算"><span class="toc-number">13.2.7.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双指针"><span class="toc-number">13.2.8.</span> <span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#离散化"><span class="toc-number">13.2.9.</span> <span class="toc-text">离散化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#区间合并"><span class="toc-number">13.2.10.</span> <span class="toc-text">区间合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#回溯"><span class="toc-number">13.2.11.</span> <span class="toc-text">回溯</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#经典题目"><span class="toc-number">14.</span> <span class="toc-text">经典题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#背包问题"><span class="toc-number">14.1.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#01背包"><span class="toc-number">14.1.1.</span> <span class="toc-text">01背包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#完全背包"><span class="toc-number">14.1.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多重背包"><span class="toc-number">14.1.3.</span> <span class="toc-text">多重背包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分组背包"><span class="toc-number">14.1.4.</span> <span class="toc-text">分组背包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链表"><span class="toc-number">14.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数组模拟链表"><span class="toc-number">14.2.1.</span> <span class="toc-text">数组模拟链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双指针判断环"><span class="toc-number">14.2.2.</span> <span class="toc-text">双指针判断环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双指针找交点"><span class="toc-number">14.2.3.</span> <span class="toc-text">双指针找交点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#翻转链表"><span class="toc-number">14.2.4.</span> <span class="toc-text">翻转链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#两个栈实现队列"><span class="toc-number">14.2.5.</span> <span class="toc-text">两个栈实现队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树"><span class="toc-number">14.3.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#先序遍历（LeetCode144）"><span class="toc-number">14.3.1.</span> <span class="toc-text">先序遍历（LeetCode144）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#中序遍历（LeetCode94）"><span class="toc-number">14.3.2.</span> <span class="toc-text">中序遍历（LeetCode94）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#后序遍历（LeetCode145）"><span class="toc-number">14.3.3.</span> <span class="toc-text">后序遍历（LeetCode145）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双指针-1"><span class="toc-number">14.4.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#最长连续不重复子序列"><span class="toc-number">14.4.1.</span> <span class="toc-text">最长连续不重复子序列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态规划"><span class="toc-number">14.5.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数字三角形的最大路径和"><span class="toc-number">14.5.1.</span> <span class="toc-text">数字三角形的最大路径和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#最长上升子序列"><span class="toc-number">14.5.2.</span> <span class="toc-text">最长上升子序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#最长公共子序列"><span class="toc-number">14.5.3.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#石头合并-区间dp"><span class="toc-number">14.5.4.</span> <span class="toc-text">石头合并-区间dp</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他"><span class="toc-number">14.6.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#大顶推求最小的K个元素"><span class="toc-number">14.6.1.</span> <span class="toc-text">大顶推求最小的K个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#货仓选址求最小"><span class="toc-number">14.6.2.</span> <span class="toc-text">货仓选址求最小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#区间和"><span class="toc-number">14.6.3.</span> <span class="toc-text">区间和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#区间合并-1"><span class="toc-number">14.6.4.</span> <span class="toc-text">区间合并</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#剑指offer"><span class="toc-number">14.7.</span> <span class="toc-text">剑指offer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#变量命名约定"><span class="toc-number">14.7.1.</span> <span class="toc-text">变量命名约定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#复杂度简写说明"><span class="toc-number">14.7.2.</span> <span class="toc-text">复杂度简写说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-数组中重复的数字"><span class="toc-number">14.7.3.</span> <span class="toc-text">3. 数组中重复的数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-二维数组中的查找"><span class="toc-number">14.7.4.</span> <span class="toc-text">4. 二维数组中的查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-替换空格"><span class="toc-number">14.7.5.</span> <span class="toc-text">5. 替换空格</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-从尾到头打印链表"><span class="toc-number">14.7.6.</span> <span class="toc-text">6. 从尾到头打印链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-重建二叉树"><span class="toc-number">14.7.7.</span> <span class="toc-text">++7. 重建二叉树++</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number"></span> <span class="toc-text"> </span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-二叉树的下一个结点"><span class="toc-number">0.0.1.</span> <span class="toc-text">++8. 二叉树的下一个结点++</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-用两个栈实现队列"><span class="toc-number">0.0.2.</span> <span class="toc-text">9. 用两个栈实现队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-斐波那契数列"><span class="toc-number">0.0.3.</span> <span class="toc-text">10.1 斐波那契数列</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number"></span> <span class="toc-text"> </span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-2-跳台阶"><span class="toc-number">0.0.1.</span> <span class="toc-text">10.2 跳台阶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-变态跳台阶"><span class="toc-number">0.0.2.</span> <span class="toc-text">10.3 变态跳台阶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-4-矩形覆盖"><span class="toc-number">0.0.3.</span> <span class="toc-text">10.4 矩形覆盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-旋转数组的最小数字"><span class="toc-number">0.0.4.</span> <span class="toc-text">==11. 旋转数组的最小数字==</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-矩阵中的路径"><span class="toc-number">0.0.5.</span> <span class="toc-text">12. 矩阵中的路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-机器人的运动范围"><span class="toc-number">0.0.6.</span> <span class="toc-text">13. 机器人的运动范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-剪绳子"><span class="toc-number">0.0.7.</span> <span class="toc-text">++14. 剪绳子++</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-二进制中-1-的个数"><span class="toc-number">0.0.8.</span> <span class="toc-text">++15. 二进制中 1 的个数++</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-数值的整数次方"><span class="toc-number">0.0.9.</span> <span class="toc-text">16. 数值的整数次方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-打印从-1-到最大的-n-位数"><span class="toc-number">0.0.10.</span> <span class="toc-text">17. 打印从 1 到最大的 n 位数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-1-在-O-1-时间内删除链表节点"><span class="toc-number">0.0.11.</span> <span class="toc-text">18.1 在 O(1) 时间内删除链表节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-2-删除链表中重复的结点"><span class="toc-number">0.0.12.</span> <span class="toc-text">++18.2 删除链表中重复的结点++</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-正则表达式匹配"><span class="toc-number">0.0.13.</span> <span class="toc-text">++19. 正则表达式匹配++</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-表示数值的字符串"><span class="toc-number">0.0.14.</span> <span class="toc-text">20. 表示数值的字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-调整数组顺序使奇数位于偶数前面"><span class="toc-number">0.0.15.</span> <span class="toc-text">21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-链表中倒数第-K-个结点"><span class="toc-number">0.0.16.</span> <span class="toc-text">22. 链表中倒数第 K 个结点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-链表中环的入口结点"><span class="toc-number">0.0.17.</span> <span class="toc-text">23. 链表中环的入口结点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-反转链表"><span class="toc-number">0.0.18.</span> <span class="toc-text">24. 反转链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-合并两个排序的链表"><span class="toc-number">0.0.19.</span> <span class="toc-text">25. 合并两个排序的链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-树的子结构"><span class="toc-number">0.0.20.</span> <span class="toc-text">26. 树的子结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27-二叉树的镜像"><span class="toc-number">0.0.21.</span> <span class="toc-text">27. 二叉树的镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28-对称的二叉树"><span class="toc-number">0.0.22.</span> <span class="toc-text">28 对称的二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29-顺时针打印矩阵"><span class="toc-number">0.0.23.</span> <span class="toc-text">29. 顺时针打印矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30-包含-min-函数的栈"><span class="toc-number">0.0.24.</span> <span class="toc-text">30. 包含 min 函数的栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31-栈的压入、弹出序列"><span class="toc-number">0.0.25.</span> <span class="toc-text">31. 栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32-1-从上往下打印二叉树"><span class="toc-number">0.0.26.</span> <span class="toc-text">32.1 从上往下打印二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32-2-把二叉树打印成多行"><span class="toc-number">0.0.27.</span> <span class="toc-text">32.2 把二叉树打印成多行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32-3-按之字形顺序打印二叉树"><span class="toc-number">0.0.28.</span> <span class="toc-text">32.3 按之字形顺序打印二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33-二叉搜索树的后序遍历序列"><span class="toc-number">0.0.29.</span> <span class="toc-text">33. 二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34-二叉树中和为某一值的路径"><span class="toc-number">0.0.30.</span> <span class="toc-text">34. 二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#35-复杂链表的复制"><span class="toc-number">0.0.31.</span> <span class="toc-text">35. 复杂链表的复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#36-二叉搜索树与双向链表"><span class="toc-number">0.0.32.</span> <span class="toc-text">==36. 二叉搜索树与双向链表==</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#37-序列化二叉树"><span class="toc-number">0.0.33.</span> <span class="toc-text">==37. 序列化二叉树==</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#38-字符串的排列"><span class="toc-number">0.0.34.</span> <span class="toc-text">38. 字符串的排列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#39-数组中出现次数超过一半的数字"><span class="toc-number">0.0.35.</span> <span class="toc-text">++39. 数组中出现次数超过一半的数字++</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#40-最小的-K-个数"><span class="toc-number">0.0.36.</span> <span class="toc-text">40. 最小的 K 个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#41-1-数据流中的中位数"><span class="toc-number">0.0.37.</span> <span class="toc-text">41.1 数据流中的中位数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#41-2-字符流中第一个不重复的字符"><span class="toc-number">0.0.38.</span> <span class="toc-text">41.2 字符流中第一个不重复的字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#42-连续子数组的最大和"><span class="toc-number">0.0.39.</span> <span class="toc-text">42. 连续子数组的最大和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#43-从-1-到-n-整数中-1-出现的次数"><span class="toc-number">0.0.40.</span> <span class="toc-text">==43. 从 1 到 n 整数中 1 出现的次数==</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#44-数字序列中的某一位数字"><span class="toc-number">0.0.41.</span> <span class="toc-text">44. 数字序列中的某一位数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#45-把数组排成最小的数"><span class="toc-number">0.0.42.</span> <span class="toc-text">45. 把数组排成最小的数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#46-把数字翻译成字符串"><span class="toc-number">0.0.43.</span> <span class="toc-text">46. 把数字翻译成字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#47-礼物的最大价值"><span class="toc-number">0.0.44.</span> <span class="toc-text">47. 礼物的最大价值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#48-最长不含重复字符的子字符串"><span class="toc-number">0.0.45.</span> <span class="toc-text">48. 最长不含重复字符的子字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#49-丑数"><span class="toc-number">0.0.46.</span> <span class="toc-text">49. 丑数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#50-第一个只出现一次的字符位置"><span class="toc-number">0.0.47.</span> <span class="toc-text">50. 第一个只出现一次的字符位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#51-数组中的逆序对"><span class="toc-number">0.0.48.</span> <span class="toc-text">51. 数组中的逆序对</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#52-两个链表的第一个公共结点"><span class="toc-number">0.0.49.</span> <span class="toc-text">52. 两个链表的第一个公共结点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#53-数字在排序数组中出现的次数"><span class="toc-number">0.0.50.</span> <span class="toc-text">==53 数字在排序数组中出现的次数==</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#54-二叉搜索树的第-K-个结点"><span class="toc-number">0.0.51.</span> <span class="toc-text">++54. 二叉搜索树的第 K 个结点++</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55-1-二叉树的深度"><span class="toc-number">0.0.52.</span> <span class="toc-text">55.1 二叉树的深度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55-2-平衡二叉树"><span class="toc-number">0.0.53.</span> <span class="toc-text">55.2 平衡二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#56-数组中只出现一次的数字"><span class="toc-number">0.0.54.</span> <span class="toc-text">56. 数组中只出现一次的数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#57-1-和为-S-的两个数字"><span class="toc-number">0.0.55.</span> <span class="toc-text">57.1 和为 S 的两个数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#57-2-和为-S-的连续正数序列"><span class="toc-number">0.0.56.</span> <span class="toc-text">57.2 和为 S 的连续正数序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#58-1-翻转单词顺序列"><span class="toc-number">0.0.57.</span> <span class="toc-text">58.1 翻转单词顺序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#58-2-左旋转字符串"><span class="toc-number">0.0.58.</span> <span class="toc-text">58.2 左旋转字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#59-滑动窗口的最大值"><span class="toc-number">0.0.59.</span> <span class="toc-text">59. 滑动窗口的最大值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#60-n-个骰子的点数"><span class="toc-number">0.0.60.</span> <span class="toc-text">60. n 个骰子的点数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#61-扑克牌顺子"><span class="toc-number">0.0.61.</span> <span class="toc-text">61. 扑克牌顺子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#62-圆圈中最后剩下的数"><span class="toc-number">0.0.62.</span> <span class="toc-text">==62. 圆圈中最后剩下的数==</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#63-股票的最大利润"><span class="toc-number">0.0.63.</span> <span class="toc-text">63. 股票的最大利润</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#64-求-1-2-3-…-n"><span class="toc-number">0.0.64.</span> <span class="toc-text">++64. 求 1+2+3+…+n++</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#65-不用加减乘除做加法"><span class="toc-number">0.0.65.</span> <span class="toc-text">65. 不用加减乘除做加法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#66-构建乘积数组"><span class="toc-number">0.0.66.</span> <span class="toc-text">66. 构建乘积数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#67-把字符串转换成整数"><span class="toc-number">0.0.67.</span> <span class="toc-text">67. 把字符串转换成整数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#68-树中两个节点的最低公共祖先"><span class="toc-number">0.0.68.</span> <span class="toc-text">==68. 树中两个节点的最低公共祖先==</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#开发一个实时热搜的榜单。"><span class="toc-number">0.0.69.</span> <span class="toc-text">开发一个实时热搜的榜单。</span></a></li></ol></li></ol></li></ol>
                    </div>
                </span>
            </div>
        </div>
        
    </div>
</aside>



  
  
  

  

  

  
    
	
	  <section id="comments" class="comments">
		<style>
		  .comments{margin:30px;padding:10px;background:#fff}
		  @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}
		</style>
		<div id="vcomment" class="comment"></div>
<script src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>
<script src='//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>
<script>
   var notify = 'false' == true ? true : false;
   var verify = 'false' == true ? true : false;
   new Valine({
            av: AV,
            el: '#vcomment',
            notify: notify,
            verify: verify,
            app_id: "8Krq24SNwAuetFahF7XbCDY0-gzGzoHsz",
            app_key: "waqSnwyci4BiQnlGr4qOXGPG",
            placeholder: "瞎白话",
            avatar: "",
            avatar_cdn: "https://sdn.geekzu.org/avatar/",
            pageSize: 15
    });
    if(window.location.hash){
          var checkExist = setInterval(function() {
            if (document.getElementById(window.location.hash.replace("#",""))) {
              location.href = window.location.hash;
              clearInterval(checkExist);
            }
          }, 250);
        }
</script>
	  </section>
	
	


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2023 方既白
    	</div>
		<span id="busuanzi_container_site_pv">
			本站总访问量<span id="busuanzi_value_site_pv"></span>次
		</span>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有</a></li>
      
        
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">基础</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">复习</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">项目</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">C</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">面试</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">web</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">python</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">安装</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">机器学习</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">分布式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Code</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">摄影</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">金融</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">观点</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">游戏</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">周思远&lt;br/&gt;
大工软院19届&lt;br/&gt;
毕业于华科&lt;br/&gt;
就职于鹅厂&lt;br/&gt;
编程新手一枚&lt;br/&gt;
热爱动漫与大海&lt;br/&gt;
会的不深，项目不强&lt;br/&gt;
写写博客，记录生活
</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>