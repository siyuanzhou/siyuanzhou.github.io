---
layout: post
title: "python基础复习"
date: 2019-07-18 10:36
toc: true
comments: true
categories: 技术学习                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
tags: 
  - python
  - 复习
---

#### python基础

##### 相关概念

**开源许可证选择**

<!--more-->

![image-20200226142717986](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194903.png)

**编译型语言执行速度快,解释型语言跨平台性好**

![001_编译型和解释型语言工作对比-w360](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194904.png)

**Pyc 文件**

> `C` 是 `compiled` **编译过** 的意思

```
浏览程序目录会发现一个 `__pycache__` 的目录
目录下会有一个 `hm_10_分隔线模块.cpython-35.pyc` 文件，`cpython-35` 表示 `Python` 解释器的版本

字节码
* Python 在解释源程序时是分成两个步骤的
  1. 首先处理源代码，编译 生成一个二进制 字节码
  2. 再对 字节码 进行处理，才会生成 CPU 能够识别的 机器码
* 有了模块字节码文件后，下一次运行程序时，如果在 上次保存字节码之后 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤
* 当Python重编译时，它会自动检查源文件和字节码文件的时间戳
* 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建
```

##### 数值

```python
• 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；
• 数字包括int、float、bool、complex（复数）
• 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。
• 给 Python 文件起名时，不能以数字开头,无法在PyCharm中通过导入这个模块
• 除法/返回浮点型
• 整数除法用//
• 幂运算用 ** #print(2**3) 8
• 混用整数浮点数类型提升 print(type(2.0+3)) # <class 'float'>
• 无穷大 float("inf") 与 无穷小 float("-inf")
• 类型转换 a='123' b=int(a)
• 输入输出：
a = input("提示信息：")
print("苹果单价 %.02f 元／斤，购买 %.02f 斤，需要支付 %.02f 元" % (price, weight, money))
print('Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125))
print("\r%.2f...(%s)" % (copy_rate, file_name) + " "*50, end="") #类似上传文件进度的显示形式
print()会依次打印每个字符串，遇到逗号“,”会输出一个空格

• 交互模式下 _ 是特殊变量，上一次计算的结果，类似 bash 的 $? 或 cmd 的%errorlevel%,非交互模式不能用
• 默认交互环境（非ipython）下赋值会覆盖
• id()函数可查看变量的内存地址 print("%d 内存地址是 %x" % (num, id(num)))
• os.system("终端命令")
• eval() 函数十分强大 —— 将字符串 当成 有效的表达式 来求值 并 返回计算结果
• is 用于判断 两个变量 引用对象是否为同一个
• == 用于判断 引用变量的值 是否相等
```

| 转义字符 | 描述                                  |
| -------- | ------------------------------------- |
| \\\      | 反斜杠符号                            |
| \\'      | 单引号                                |
| \\"      | 双引号                                |
| \n       | 换行                                  |
| \t       | 横向制表符: **垂直方向** 按列对齐文本 |
| \r       | 回车                                  |

##### 注释

```python
# 这是第一个单行注释
"""
这是一个多行注释
在多行注释之间，可以写很多很多的内容……
""" 

#文档注释 一个函数必须要有文档字符串, 除非它满足以下条件:外部不可见 非常短小 简单明了
def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):
    """Fetches rows from a Bigtable.

    Retrieves rows pertaining to the given keys from the Table instance
    represented by big_table. 

    Args:
        big_table: An open Bigtable Table instance.
        keys: A sequence of strings representing the key of each table row
            to fetch.
        other_silly_variable: Another optional variable, that has a much
            longer name than the other args, and which does nothing.

    Returns:
        A dict mapping keys to the corresponding table row data
        fetched. Each row is represented as a tuple of strings. For
        example:

        {'Serak': ('Rigel VII', 'Preparer'),
         'Zim': ('Irk', 'Invader'),
         'Lrrr': ('Omicron Persei 8', 'Emperor')}

        If a key from the keys argument is missing from the dictionary,
        then that row was not found in the table.

    Raises:
        IOError: An error occurred accessing the bigtable.Table object.
    """
    pass
```

##### 流程控制

```python
• None/False/0/”/()/[]/{} 会判定为假
• 可以有任意多个 elif 分支
• range 左闭右开
• range 在 Python3 中不返回列表，可用 list(range()) 习语
```

##### 函数

```python
def sum_2_num(num1, num2):
    result = num1 + num2    
    print("%d + %d = %d" % (num1, num2, result))

sum_2_num(50, 20)
• 在函数调用位置，使用快捷键 CTRL + Q 可以查看函数的说明信息
• 默认参数：在需要默认参数的地方用 = 号给定即可, 但要注意所有的默认参数都不能出现在非默认参数前。
• 如果在函数中需要修改全局变量，需要使用 `global` 进行声明
• 函数的 实参/返回值 都是是靠 引用 来传递来的
• 只要针对参数使用赋值语句，会在 函数内部修改局部变量的引用，不会影响到 外部变量的引用
• 如果传递的参数是可变类型，在函数内部，使用方法修改了数据的内容，同样会影响到外部的数据
num=100
b=100
a=[1,2,3,4]
d=[1,2,3,4]
def test():
    global num
    num+=100
    b=100
    b+=2
    a.append(23)
    d[1]=3
num： 100
a: [1, 2, 3, 4]
b: 100
d: [1, 2, 3, 4]
调用test函数后
num： 200
a: [1, 2, 3, 4, 23]
b: 100
d: [1, 3, 3, 4]
    
函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！
>>> abs
<built-in function abs>
>>> f = abs
>>> f(-10)
10

既然变量可以指向函数，函数的参数能接收变量，函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
def add(x, y, f):
    return f(x) + f(y)

函数作为返回值,高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
lazy_sum不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f
<function lazy_sum.<locals>.sum at 0x101c6ed90>
调用函数f时，才真正计算求和的结果：
>>> f() #25
当我们调用lazy_sum()时，每次调用都会返回一个新函数，即使传入相同参数：f1()和f2()调用结果互不影响。
>>> f1 = lazy_sum(1, 3, 5, 7, 9);f2 = lazy_sum(1, 3, 5, 7, 9)
>>> f1==f2#False

偏函数
假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：
简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
def int2(x, base=2):
    return int(x, base)
functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000') # 64
```

**函数可变参数**

```python
*args是可变参数，args接收的是一个tuple；
**kw是关键字参数，kw接收的是一个dict。
可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
关键字参数既可直接传入：func(a=1, b=2)，又可先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。
参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
def report(name, *grades):#参数名前增加一个 `*`可以接收元组
    total_grade = 0
    for grade in grades:
        total_grade += grade
    print(name, 'total grade is ', total_grade)
def portrait(name, **kw):#参数名前增加两个 `*` 可以接收 字典
    print('name is', name)
    for k,v in kw.items():
        print(k, v)
```

```python
def demo(*args, **kwargs):
    print(args)
    print(kwargs)
# 需要将一个元组变量/字典变量传递给函数对应的参数
gl_nums = (1, 2, 3)
gl_xiaoming = {"name": "小明", "age": 18}

# 下面code会把 num_tuple 和 xiaoming 作为元组传递给 args，kwargs无法传值
# demo(gl_nums, gl_xiaoming)
# 可以使用 拆包，简化参数的传递，**拆包** 的方式是
# 在 元组变量前，增加 一个 `*`
# 在 字典变量前，增加 两个 `*`
demo(*gl_nums, **gl_xiaoming)
```

```python
如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：
def person(name, age, *, city, job):
    print(name, age, city, job)
```

##### 面向对象

```python
>>> class Complex(object):
        def __init__(self, realpart, imagpart):
            self.r = realpart
            self.i = imagpart
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i #(3.0, -4.5)
• 在__init__函数中用 self 初始化的是属性,self类似java中的this
• 属性和方法可以动态添加和删除
>>> s = Student()
>>> s.name = 'Michael' # 动态给实例绑定一个属性
>>> def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
>>> from types import MethodType
>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
>>> s.set_age(25) # 调用实例方法
• 特殊的__slots__变量，来限制该class实例能添加的属性
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
    
• 必要时用 hasattr 判断是否包含某属性， setattr 添加属性
• 在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线__，定义的就是 私有 属性或方法
• 私有实际是对 名称 做了一些特殊处理，使得外界无法访问到,_类名__名称可访问
• @property广泛应用在类的定义中，可以用类似属性这样简单方式来访问类变量，同时保证对参数进行必要的检查
class Student(object):
    @property
    def birth(self):
        return self._birth
    @birth.setter
    def birth(self, value):
        self._birth = value
    @property
    def age(self):
        return 2015 - self._birth
    
• isinstance(b, A) 判断a是否是A或A的子类
• 要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list
• is 与 == 区别：
    is 用于判断 两个变量 引用对象是否为同一个
    == 用于判断 引用变量的值 是否相等

当调用不存在的属性时，Python解释器会试图调用__getattr__()来尝试获得属性，这样就会返回score值：
class Student(object):
    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
```

| 序号 |    方法名    | 类型 | 作用                                                         |
| :--: | :----------: | :--: | :----------------------------------------------------------- |
|  01  |  `__new__`   | 方法 | **创建对象**时，会被 **自动** 调用                           |
|  02  |  `__init__`  | 方法 | **对象被初始化**时，会被 **自动** 调用                       |
|  03  |  `__del__`   | 方法 | **对象被从内存中销毁**前，会被 **自动** 调用                 |
|  04  |  `__str__`   | 方法 | 返回**对象的描述信息**，`print` 函数输出使用                 |
|  05  |  `__iter__`  | 方法 | 返回一个迭代对象，该类被用于`for ... in`循环                 |
|  06  | `__call__()` | 方法 | `instance.method()`来调用实例方法，call方法可直接对实例进行调用 |

![022_对象分配空间和初始化](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194905.png)

封装

```python
外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。
xx: 公有变量
_x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问
__xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)
__xx__:双前后下划线,用户名字空间的魔法对象或属性。例如:__init__ , __ 不要自己发明这样的名字
xx_:单后置下划线,用于避免与Python关键词的冲突
```

继承

```python
super() 就是使用 super 类创建出来的对象
Python 中针对 类 提供了一个 内置属性 __mro__ 可以查看 方法 搜索顺序
MRO 是 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径
class A:
def foo(self):
	print("in A::foo")
class B(A):
	pass
b = B()
b.foo()
多继承
class Dog(Mammal, Runnable):
    pass
```

多态：在程序执行时，传入不同的 **狗对象** 实参，就会产生不同的执行效果

![016_多态](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194906.png)

单例——让 类 创建的对象，在系统中 只有 唯一的一个实例

```python
class MusicPlayer(object):
    # 记录第一个被创建对象的引用
    instance = None
    # 记录是否执行过初始化动作
    init_flag = False
    def __new__(cls, *args, **kwargs):
        # 1. 判断类属性是否是空对象
        if cls.instance is None:
            # 2. 调用父类的方法，为第一个对象分配空间
            cls.instance = super().__new__(cls)
        # 3. 返回类属性保存的对象引用
        return cls.instance
    def __init__(self):
        if not MusicPlayer.init_flag:
            print("初始化音乐播放器")
            MusicPlayer.init_flag = True
```

![023_单例流程](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194907.png)

##### 类对象/类属性/类方法

```
在程序运行时，类 同样 会被加载到内存
在 Python 中，类 是一个特殊的对象 —— 类对象
在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例
除了封装 实例 的 属性 和 方法外，类对象 还可以拥有自己的 属性 和 方法
```

![017_类的结构示意图II](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194908.png)

属性的获取机制

![019_通过对象访问类属性](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194909.png)

```python
实例属性属于各个实例所有，互不干扰；
类属性属于类所有，所有实例共享一个属性；
类属性 就是针对 类对象 定义的属性
    类属性 用于记录 与这个类相关 的特征
类方法 就是针对 类对象 定义的方法
	在 类方法 内部可以直接访问 类属性 或者调用其他的 类方法
class Tool(object):
    # 使用赋值语句，定义类属性，记录创建工具对象的总数
    count = 0
    def __init__(self, name):
        self.name = name
        # 针对类属性做一个计数+1
        Tool.count += 1        
    @classmethod
    def show_tool_count(cls):
        """显示工具对象的总数"""
        print("工具对象的总数 %d" % cls.count)	

静态方法 需要用 修饰器 @staticmethod 来标识，告诉解释器这是一个静态方法
    @staticmethod
    def run():        
        # 不需要访问实例属性也不需要访问类属性的方法
        print("狗在跑...")
```

##### 字符串

```python
• 加号拼接字符串
• 乘号重复字符串
• 字符串常量直接拼接
• 字符串可下标
• 0 起始，-1 最后
• : 用于切片，左闭右开
• Python 字符串是不可变的，与 Java 类似
• len 返回长度，类比 strlen
• str.strip([chars]);方法用于移除字符串头尾指定的字符（默认为空格）
• string.find(str, start=0, end=len(string))检查str是否包含在指定范围内，如果是返回开始的索引值，否则返回-1
• string.index(str, start=0, end=len(string)) 也是，但是不存在会报错
• string.replace(old_str, new_str, num=string.count(old))把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次
• string.split(str="", num)以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\r', '\t', '\n' 和空格
• re.split(r'[或,，]', str)  多个分隔符
• string.title()把字符串的每个单词首字母大写
```

```python
>>> 3*’un’ + ’ium’
’unununium’
>>> word[2:5] # python from position 2 (included) to 5 (excluded)
’tho’
print('aabbccabc'.find('ab', 3, len('aabbccabc')))  # 从下标3开始查找
>> 6
print('aabbccabc'.find('abd'))
>> -1
print('aabbccabc'.index('abd'))
>> ValueError: substring not found
# 9. 字符串的逆序（面试题）
print(num_str[::-1])
```

**字符串格式化**

```python
arg="123"
str2="789{}798".format(arg)
print("123%d456"%(789))
# 3.6+
str=f"789{arg}798"
```

**str<-->bytes**

```python
str 使用encode方法转化为 bytes
bytes通过decode转化为str
str1='人生苦短，我用Python!'
b=str1.encode()
b'\xe4\xba\xba\xe7\x94\x9f\xe8\x8b\xa6\xe7\x9f\xa\xe7\x94\xa8Python!'
b.decode()
'人生苦短，我用Python!'
    
bytearray和bytes不一样的地方在于，bytearray是可变的。
b1=bytearray(str1.encode())
b1[:6]=bytearray('生命'.encode())
b1.decode()
'生命苦短，我用Python!'
```

**str<-->list**

```python
mystring = "The quick brown fox"
mylist = mystring.split(' ')
print(mylist)
# ['The', 'quick', 'brown', 'fox']

mylist = ['The', 'quick', 'brown', 'fox']
mystring = " ".join(mylist)
print(mystring)
# 'The quick brown fox'
```

##### 正则表达式

[正则表达式测试网址](http://tool.oschina.net/regex/)

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194910.png)

```python
• [a-zA-Z] 匹配某个字符
• ˆ和 $ 匹配首尾
• \ˆ和\$ 字面值
• . 匹配任意字符，点号默认情况匹配不到`\n` ,\. 匹配点号
• \b 匹配单词边界
• \w 匹配非空字符
• \s 匹配空格 不仅仅包含空格，还有`\t|\r\n`
• 中文的 unicode 编码范围 主要在 [u4e00-u9fa5]
• 原始字符串前加上r，待匹配字符串中有反斜杠的时候，使用r能够忽视反斜杠带来的转义的效果

• * 表示任意次数，\* 表示字面值
• + 表示 1 次或多次，\+ 表示字面值
• {3} 和 {4,6} 表示重复 3 次和 4–6 次

Python里数量词默认是贪婪的。
abbb使用贪婪的数量词的正则表达式 ab* ，匹配结果： abbb。
	* 决定了尽可能多匹配 b，所以a后面所有的 b 都出现了。
abbb使用非贪婪的数量词的正则表达式ab*?，匹配结果： a。
	即使前面有 *，但是 ? 决定了尽可能少匹配 b，所以没有 b。

常用正则表达式的方法：
	re.compile（编译，生成一个 Pattern 对象）
	pattern.match（从头找一个，只要找到了一个匹配的结果就返回）
	pattern.search（找一个，查找字符串的任何位置）
	pattern.findall（找所有子串，返回全部能匹配的子串）
    pattern.finditer(跟 findall 的行为类似,返回一个顺序访问每一个匹配结果（Match 对象）的迭代器)
	pattern.sub（替换）
        p = re.compile(r'(\w+) (\w+)') # \w = [A-Za-z0-9]
        print (p.sub(r'hello world', 'hello 123, hello 456')) #hello world替换后面
        print (p.sub(r'\2 \1', 'hello 123, hello 456')) # 引用分组 \2表示匹配到的第二个
        # hello world, hello world
        # 123 hello, 456 hello
    pattern.split 按照能够匹配的子串将字符串分割后返回列表
        >>> re.split(r'[\s\,\;]+', 'a,b;; c  d')#['a', 'b', 'c', 'd']
    
Grouping 分组捕获，不分组时匹配的是全部，分组后匹配的是组内的内容
• () 表示分组
• \数字进行引用 要几个
>>> re.match(r’(abc)|(def)’, ’abc’).group() # 使用|表示 或，\|表 示 字 面 值
’abc’

re.findall("a(.*?)b","str"),能够返回括号中的内容,括号前后的内容起到定位和过滤的效果
re.findall(r“a.*bc”,”a\nbc”,re.DOTALL)  #a\nbc
re.findall(r“a(.*)bc”,”a\nbc”,re.DOTALL) #\n
无（）时匹配的是全部，分组后(有括号)匹配的是组内的内容
    >>> re.findall(r’\bf[a-z] * ’, ’which foot or hand fell fastest’)
    [’foot’, ’fell’, ’fastest’]
    >>> re.findall("href=’(. * ?)’", html) #查找所有HTML链接
    [’a.html’, ’b.html’]
    >>> re.findall(r’(.)\1’, ’明 明 亮 亮 蛋 蛋’)
    [’明’, ’亮’, ’蛋’]
```

```python
>>> pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)  # re.I 表示忽略大小写
>>> m = pattern.match('Hello World Wide Web')
>>> print (m)     # 匹配成功，返回一个 Match 对象
<_sre.SRE_Match object at 0x10bea83e8>
#group([group1, ...]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；
>>> m.group(0)  # 返回匹配成功的整个子串
'Hello World'
>>> m.span(0)   # 返回匹配成功的整个子串的索引
(0, 11)
>>> m.group(2)  # 返回第二个分组匹配成功的子串
'World'
>>> m.span(2)   # 返回第二个分组匹配成功的子串
(6, 11)
>>> m.groups()  # 等价于 (m.group(1), m.group(2), ...)
('Hello', 'World')

#pattern.finditer | m1.group(), m1.span()
pattern = re.compile(r'\d+')
result_iter1 = pattern.finditer('hello 123456 789')
for m1 in result_iter1:   # m1 是 Match 对象
    print ('matching string: {}, position: {}'.format(m1.group(), m1.span()))
# matching string: 123456, position: (6, 12)
# matching string: 789, position: (13, 16)
```

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194911.png)

##### 列表 [’a’, ’b’, ’c']

```python
• Python数据类型最常见的是列表,与数组类似
• 允许元素类型不同
• 和字符串类似，可下标可切片
• 加法和乘法也和字符串类似
• len 返回长度
• 与字符串不同的，列表是可变的
• append 方法用于追加
• 多维数组用嵌套列表实现
• 列表转str print(' '.join(['das','da','dsa']))
• 列表变量调用 `+=` 本质上是在执行列表变量的 `extend` 方法，不会修改变量的引用
• 列表list合并
	方法1: 直接使用"+"号合并列表 cList = aList + bList 
    方法2: 使用extend方法 aList.extend(bList)
```

![001_列表示意图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194912.png)

```python
前10个数，每两个取一个：
>>> L[:10:2]
[0, 2, 4, 6, 8]
所有数，每5个取一个：
>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
>>> squares = [1, 4, 9, 16, 25]
>>> squares[-3:] # slicing returns a new list
[9, 16, 25]
>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
>>> a = [’a’, ’b’, ’c’]
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[[’a’, ’b’, ’c’], [1, 2, 3]]
>>> x[0][1]
’b’
```

##### lambda表达式

```python
# 注意 ：Python的lambda表达 式 不 能 换 行
# 关键字lambda表示匿名函数，冒号前面的x表示函数参数。
inc = lambda x: x + 1
add = lambda x, y: x + y
inc(5)
add(10, 20)
```

##### 列表推导

```python
[i*2 for i in range(10)]
[i*2 for i in range(10) if i % 2 == 0]
colours = ["red", "green", "yellow", "blue"]
things = ["house", "car", "tree"]
combined = [(x,y) for x in colours for y in things]
```

##### Map/Filter/Reduce/Sorted

```python
#map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
map(lambda x: x**2, range(10))
#filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
filter(lambda x: x % 2 == 0,map(lambda x: x**2, range(10)))
#reduce把结果继续和序列的下一个元素做累积计算，其效果就是：reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
reduce(lambda x, y: x + y,filter(lambda x: x % 2 == 0,map(lambda x: x**2,range(10))))

# sorted()函数就可以对list进行排序：
>>> sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]
def by_score(t):
    return t[1]
L2 = sorted(L, key=by_score)
print(L2)
```

##### 字典{’jack’: 4098, ’sape’: 4139}

```python
• 字典类似其他语言中散列表、关联数组，按键值方式组织
• 不像列表元组可以用下标随机访问
• 任何不可变对象均可作为键（元组亦可，但不能包含可变元素）
• 空字典用 {} 构造；非空字典在 {} 内逗号分割的键: 值对表示
• list(d.keys()) 返回所有键。如需有序，使用 sorted(d.keys())
```

![002_字典示意图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194913.png)

```python
>>> tel = {’jack’: 4098, ’sape’: 4139}
>>> tel[’guido’] = 4127
>>> tel
{’sape’: 4139, ’guido’: 4127, ’jack’: 4098}
>>> tel[’jack’]
4098
>>> del tel[’sape’]
>>> tel[’irv’] = 4127
>>> tel
{’guido’: 4127, ’irv’: 4127, ’jack’: 4098}
>>> list(tel.keys())
[’irv’, ’guido’, ’jack’]
>>> sorted(tel.keys())
[’guido’, ’irv’, ’jack’]
>>> ’guido’ in tel
True
>>> ’jack’ not in tel
False

>>> x[(1, 2, 3, [4, 5])] = 6
TypeError: unhashable type: ’list’
```

```python
• 字典还可以由二元组列表初始化
• 字典推导与列表推导类似
• 字典键为字符串时，可以用关键字参数设定
```

```python
>>> dict([(’sape’, 4139),(’guido’, 4127),(’jack’, 4098)])
{’sape’: 4139, ’jack’: 4098, ’guido’: 4127}
>>> {x: x ** 2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
>>> dict(sape=4139, guido=4127, jack=4098)
{’sape’: 4139, ’jack’: 4098, ’guido’: 4127}
```

**多字典去重py3.5+**

```python
dict1 = { 'a': 1, 'b': 2 }
dict2 = { 'b': 3, 'c': 4 }
merged = { **dict1, **dict2 }
print (merged)
# {'a': 1, 'b': 3, 'c': 4}
```

##### 集合{’apple’, ’orange’, ’apple’}

```python
• 集合是无序无重复的数据结构
• 支持成员测试、添加、删除等操作 s.add( x ) s.remove( x )
• 支持交集、并集、差等集合操作
• 初始化用 {} 括住的逗号分割元素序列
• 空集合用 set()，而不是 {}
• 集合推导同样支持
• set中添加list 使用 set.update() or |=
• set去重list和str
    mylist = [1, 1, 2, 3, 4, 5, 5, 5, 6, 6]
    print (set(mylist))
    # {1, 2, 3, 4, 5, 6}
    print (set("aaabbbcccdddeeefff"))
    # {'a', 'b', 'c', 'd', 'e', 'f'}
```

```python
>>> basket = {’apple’, ’orange’, ’apple’, ’pear’, ’orange’, ’banana’}
>>> print(basket) # show that duplicates have been removed
{’orange’, ’banana’, ’pear’, ’apple’}
>>> ’orange’ in basket # fast membership testing
True
>>> ’crabgrass’ in basket
False
>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set(’abracadabra’)
>>> b = set(’alacazam’)
>>> a # unique letters in a
{’a’, ’r’, ’b’, ’c’, ’d’}
>>> a - b # letters in a but not in b
{’r’, ’d’, ’b’}
>>> a | b # letters in a or b or both
{’a’, ’c’, ’r’, ’d’, ’b’, ’m’, ’z’, ’l’}
>>> a & b # letters in both a and b
{’a’, ’c’}
>>> a ^ b # letters in a or b but not both
{’r’, ’d’, ’b’, ’m’, ’z’, ’l’}
>>> a = {x for x in ’abracadabra’ if x not in ’abc’}
>>> a
{’r’, ’d’}

>>> a = set('abc')
>>> l = ['d', 'e']
>>> a.update(l)
>>> a
{'e', 'b', 'c', 'd', 'a'}

>>> l = ['f', 'g']
>>> a |= set(l)
>>> a
{'e', 'b', 'f', 'c', 'd', 'g', 'a'}
```

##### 元组(12345, 54321, ’hello!’)

```python
• 元组与列表类似，都是线性数据结构
• 元组内容不可变
• 元组可以嵌套
• 构造空元组使用 ()
• 构造单元素元组用 (a,)
• 如果元组元素是可变的，则可以修改（有坑）
• 元组也可出现在赋值左部（lhs）
```

```python
>>> t = 12345, 54321, ’hello!’
>>> t[0]
12345
>>> t
(12345, 54321, ’hello!’)
>>> # Tuples may be nested嵌套:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, ’hello!’), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:
... t[0] = 88888
TypeError: ’tuple’ object does not support item assignment
>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
>>> empty = ()
>>> singleton = ’hello’, # <-- note trailing comma
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
(’hello’,)
>>> x, y, z = t
>>> x, y = y, x
>>> x = (1, 2, 3, [4, 5])
>>> x[3] += [6]
TypeError: ’tuple’ object does not support item assignment，但加入成功了
>>> x
(1, 2, 3, [4, 5, 6])
```

**元组和列表之间的转换**

* 使用 `list` 函数可以把元组转换成列表

```python
list(元组) 
```

* 使用 `tuple` 函数可以把列表转换成元组

```python
tuple(列表)
```

##### 异常

```python
try:
    # 尝试执行的代码
    pass
except 错误类型1:
    # 针对错误类型1，对应的代码处理
    pass
except 错误类型2:
    # 针对错误类型2，对应的代码处理
    pass
except (错误类型3, 错误类型4):
    # 针对错误类型3 和 4，对应的代码处理
    pass
except Exception as result:
    # 打印错误信息
    print(result)
else:
    # 没有异常才会执行的代码
    pass
finally:
    # 无论是否有异常，都会执行的代码
    print("无论是否有异常，都会执行的代码")
  
#抛出异常
def input_password():
    pwd = input("请输入密码：")
    # 2. 判断密码长度，如果长度 >= 8，返回用户输入的密码
    if len(pwd) >= 8:
        return pwd
    # 3. 密码长度不够，需要抛出异常
    # 1> 创建异常对象 - 使用异常的错误信息字符串作为参数
    ex = Exception("密码长度不够")
    # 2> 抛出异常对象
    raise ex
try:
    user_pwd = input_password()
    print(user_pwd)
except Exception as result:
    print("发现错误：%s" % result)
    
Python内置的logging模块可以非常容易地记录错误信息：程序打印完错误信息后会继续执行，并正常退出
logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别
当我们指定level=INFO时，logging.debug就不起作用了。
这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。：
import logging
logging.basicConfig(level=logging.INFO)
def foo(s):
    return 10 / int(s)
def bar(s):
    return foo(s) * 2
def main():
    try:
        bar('0')
    except Exception as e:
        logging.exception(e)
main()
print('END')

凡是用print()来辅助查看的地方，都可以用断言（assert）来替代：
assert n != 0, 'n is zero!'
```

##### 路径与模块导入

每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**

导入之后不需要通过 `模块名.`可以直接使用 **模块提供的工具** —— **全局变量**、**函数**、**类**

如果 **两个模块**，存在**同名的函数**，那么 **后导入模块的函数**，会 **覆盖掉先导入的函数**

`__name__ `属性可以做到，测试模块的代码 只在测试情况下被运行，而在 被导入时不会被执行！

```python 
if __name__=='__main__':如果在其他地方导入该模块时，if判断将失败,后面代码不执行
```

`Python` 的解释器在 **导入模块** 时，会：

1. 搜索 **当前目录** 指定模块名的文件，**如果有就直接导入**

2. 如果没有，再按顺序搜索路径,它在Python编译或安装时确定，存储在sys模块中的path变量中

   ![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194914.png)

   ```python
   sys.path.append('/home/itcast/xxx') #os.getcwd()，不用相对路径
   sys.path.insert(0, '/home/itcast/xxx')  # 可以确保先搜索这个路径
   ```

​    3.模块被导入后，`import module`不能重新导入模块，重新导入需用`reload`![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194915.png)

> 在开发时，给文件起名，不要和 **系统的模块文件** **重名**

- **包** 是一个 **包含多个模块** 的 **特殊目录**
- 包目录下有一个 **特殊的文件** `__init__.py`
- 使用 `import 包名` 可以一次性导入 **包** 中 **所有的模块**
- 要在外界使用 **包** 中的模块，需要在 `__init__.py` 中指定 **对外界提供的模块列表**
- 如果`__init__.py` 存在一个叫做` __all__ `的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有模块作为包内容导入。 
- from...import...会在内存中创建并加载该模块工具的副本，当有另外一个程序导入时，会在内存中创建另一个副本进行加载，不会共用一个副本。所以程序进行的修改不会影响到被导入的原模块，且不同程序之间不会互相影响。
- import...方法导入模块会在内存中直接加载该模块的全部属性。当出现多个程序导入该模块时,会共用一个模块，程序之间会互相影响，包括原模块。

```python
#在包内 从 当前目录 导入 模块列表 
from . import send_message
from . import receive_message
或者
__all__ = ["send_message", "receive_message"]
```

一、**同级目录下的调用**

```bsh
-- src
    |-- mod1.py
    |-- test1.py
若在程序test1.py中导入模块mod1, 则直接使用
import mod1 或 from mod1 import *;
```

二、**调用子目录下的模块** 

```bsh
-- src
    |-- mod1.py
    |-- lib
    |    |-- mod2.py
    |-- test1.py
如果想在程序test1.py中导入模块mod2.py ，可以在lib件夹中建立空文件__init__.py文件
from lib.mod2 import *或 import lib.mod2.
```

三、**调用上级目录下的文件** 

```bsh
-- src
    |-- mod1.py
    |-- lib
    |    |-- mod2.py
    |-- sub
    |    |-- test2.py
想要实现test2.py调用mod1.py和mod2.py ，先跳到src目录下面，直接可以调用mod1，然后在lib上当下建一个空文件__init__.py ，就可以像第二步调用子目录下的模块一样，通过import  lib.mod2进行调用了。
```

```python
import sys
sys.path.append("..")
import mod1
import lib.mod2
```

python项目在IDE中能直接执行，在命令行下提示no module named xxxx 解决办法

原因：

PyCharm会自动添加项目路径到sys.path,但ß 在命令行模式下项目路径并没有加入到当前 python运行环境中，所以会提示异常。其实我们只需要将自定义的 module 加入到当前环境中

##### 文件IO

![image-20200417181044706](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194916.png)

```python
Python 2.x 默认使用 ASCII 编码格式
在 Python 2.x 文件的 第一行 增加以下代码，解释器会以 utf-8 编码来处理 python 文件
    # *-* coding:utf8 *-*
    # 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串
    hello_str = u"你好世界"
Python 3.x 默认使用 UTF-8 编码格式
import os
path=''.decode('utf-8')

把两个路径合成一个时，不要直接拼字符串，而要os.path.join()，这样可以正确处理不同操作系统路径分隔符。
要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：
>>> os.path.split('/Users/michael/testdir/file.txt')
('/Users/michael/testdir', 'file.txt')

#创建多级目录
if not os.path.exists(path):
	os.makedirs(path)
    
# 列出当前目录所有的.py文件：
>>> [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']
['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py']
# 列出当前目录及其子目录下所有的.anns文件：
[x for file in imutils.paths.list_files(src, validExts=('.anns',))]

#重命名 删除
os.rename( "test1.txt", "test2.txt" )
os.remove(file_name)

#显示当前工作目录
os.getcwd()
#改变当前目录
os.chdir("newdir")

返回指定目录下的所有文件和目录名
os.listdir(path)

判断是否是文件夹
os.path.isdir(path)

判断是否存在
os.path.exists('d:/assist')

删除目录
os.rmdir(“dir”) 只能删除空目录
shutil.rmtree(“dir”) 空目录、有内容的目录都可以删

复制文件：
shutil.copyfile(“oldfile”,”newfile”) oldfile和newfile都只能是文件
shutil.copy(“oldfile”,”newfile”) oldfile只能是文件夹，newfile可以是文件，也可以是目标目录
复制文件夹：
shutil.copytree(“olddir”,”newdir”) olddir和newdir都只能是目录，且newdir必须不存在

文件操作
f.seek(0):回到文件的开头,  f.seek(1):返回文件的当前位置,  f.seek(2):到文件的末尾
fp.read([size]) #size为读取的长度，以byte为单位
fp.readline([size])  #读一行，如果定义了size，有可能返回的只是一行的一部分,会从文件中读取单独的一行。换行符为 '\n'。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。
fp.readlines([size])  #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。
fp.write(str)    #把str写到文件中，write()并不会在str后加上一个换行符
fp.writelines(seq)  #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。
fp.close()    #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError
fp.flush()   #把缓冲区的内容写入硬盘

文件名和后缀
获取路径名：os.path.dirname()
获取文件名：os.path.basename()
file_path = "D:/test/test.py"
(filepath,tempfilename) = os.path.split(file_path)
(filename,extension) = os.path.splitext(tempfilename)
filepath为文件的目录,即D:/test
filename为文件的名字,即test
extension为文件的扩展名,即.py

运行shell命令: os.system(cmd)
修改文件权限与时间戳：os.chmod（file）
```

打开文件，不存在则创建

```python
open(file, mode=’rb’, buffering=-1, encoding=None,errors='ignore', newline=None,closefd=True, opener=None) as f
errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：
’r’ 读（默认）
’w’ 写（覆盖）
’x’ 排他性创建
’a’ 写（追加） (从 EOF 开始, 必要时创建新文件)
’b’ 二进制模式
’t’ 文本模式（默认）
’+’ 更新（读写）
’U’ 统一 newlines 模式（过时）
```

**StringIO/BytesIO**

要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可

StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。

```python
>>> from io import StringIO
>>> f = StringIO()
>>> f.write('hello')
5
>>> f.write(' ')
1
>>> f.write('world!')
6
>>> print(f.getvalue())#getvalue()方法用于获得写入后的str。
hello world!
>>> from io import BytesIO
>>> f = BytesIO()
>>> f.write('中文'.encode('utf-8'))
6
>>> print(f.getvalue())
b'\xe4\xb8\xad\xe6\x96\x87'
```

##### 序列化

```python
把变量从内存中变成可存储或传输的过程称之为序列化
在Python中叫pickling，其他语言中也被称为serialization，marshalling，flattening等等
把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。
>>> import pickle
>>> d = dict(name='Bob', age=20, score=88)
#pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。
>>> pickle.dumps(d)
b'\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'
#另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object：
>>> f = open('dump.txt', 'wb')
>>> pickle.dump(d, f)
>>> f.close()
#用pickle.loads()方法反序列化出对象，也可用pickle.load()方法从一个file-like Object中直接反序列化
>>> f = open('dump.txt', 'rb')
>>> d = pickle.load(f)
>>> f.close()
>>> d
{'age': 20, 'score': 88, 'name': 'Bob'}
```

##### json

```python
具有read()或者write()方法的对象就是类文件对象
	f = open(“a.txt”,”r”) f就是类文件对象

str = "你好"
print (json.dumps(str,ensure_ascii=False))

json使用注意点
    - json中的字符串都是双引号引起来的
      - 如果不是双引号
        - eval：能实现简单的字符串和python类型的转化
        - replace：把单引号替换为双引号
    - 往一个文件中写入多个json串，不再是一个json串，不能直接读取
      - 一行写一个json串，按照行来读取
```

![image-20200404175034357](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194917.png)

##### Socket

```python
import socket
socket.socket(AddressFamily, Type)
Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET
Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）

UDP
import socket
import threading
def send_msg(udp_socket):
    """获取键盘数据，并将其发送给对方"""
    while True:
        # 1. 从键盘输入数据
        msg = input("\n请输入要发送的数据:")
        # 2. 输入对方的ip地址
        dest_ip = input("\n请输入对方的ip地址:")
        # 3. 输入对方的port
        dest_port = int(input("\n请输入对方的port:"))
        # 4. 发送数据
        udp_socket.sendto(msg.encode("utf-8"), (dest_ip, dest_port))
def recv_msg(udp_socket):
    """接收数据并显示"""
    while True:
        # 1. 接收数据
        recv_msg = udp_socket.recvfrom(1024)
        # 2. 解码
        recv_ip = recv_msg[1]
        recv_msg = recv_msg[0].decode("utf-8")
        # 3. 显示接收到的数据
        print(">>>%s:%s" % (str(recv_ip), recv_msg))
def main():
    # 1. 创建套接字
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # 2. 绑定本地信息
    udp_socket.bind(("", 7890))
    # 3. 创建一个子线程用来接收数据
    t = threading.Thread(target=recv_msg, args=(udp_socket,))
    t.start()
    # 4. 让主线程用来检测键盘数据并且发送
    send_msg(udp_socket)
if __name__ == "__main__":
    main()
    
TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）
TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议
TCP客户端
from socket import *
# 创建socket
tcp_client_socket = socket(AF_INET, SOCK_STREAM)
server_ip = input("请输入服务器ip:")
server_port = int(input("请输入服务器port:"))
# 链接服务器
tcp_client_socket.connect((server_ip, server_port))
# 提示用户输入数据
send_data = input("请输入要发送的数据：")
tcp_client_socket.send(send_data.encode("gbk"))
# 接收对方发送过来的数据，最大接收1024个字节
recvData = tcp_client_socket.recv(1024)
print('接收到的数据为:', recvData.decode('gbk'))
# 关闭套接字
tcp_client_socket.close()

TCP服务器
from socket import *
# 创建socket
tcp_server_socket = socket(AF_INET, SOCK_STREAM)
# 本地信息
address = ('', 7788)
# 绑定
tcp_server_socket.bind(address)
# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收128个的链接了
tcp_server_socket.listen(128)
# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务
# client_socket用来为这个客户端服务
# tcp_server_socket就可以省下来专门等待其他新客户端的链接
client_socket, clientAddr = tcp_server_socket.accept()
# 接收对方发送过来的数据
recv_data = client_socket.recv(1024)  # 接收1024个字节
print('接收到的数据为:', recv_data.decode('gbk'))
# 发送一些数据到客户端
client_socket.send("thank you !".encode('gbk'))
# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了
client_socket.close()
```

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194918.png)

##### 邮件发送

一封电子邮件的旅程就是：

```
发件人 -> MUA -> MTA -> MTA -> 若干个MTA -> MDA <- MUA <- 收件人
MUA：Mail User Agent——邮件用户代理
MTA：Mail Transfer Agent——邮件传输代理，就是那些Email服务提供商，比如网易、新浪
MTA会把Email投递到邮件的最终目的地MDA：Mail Delivery Agent——邮件投递代理。
发邮件时，MUA和MTA使用的协议就是SMTP：Simple Mail Transfer Protocol，后面的MTA到另一个MTA也是用SMTP协议。
收邮件时，MUA和MDA使用的协议有两种：POP：Post Office Protocol，目前版本是3，俗称POP3；IMAP：Internet Message Access Protocol，目前版本是4，优点是不但能取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移到垃圾箱，等等。
邮件客户端软件在发邮件时，会让你先配置SMTP服务器，也就是你要发到哪个MTA上。假设你正在使用163的邮箱，你就不能直接发到新浪的MTA上，因为它只服务新浪的用户，所以，你得填163提供的SMTP服务器地址：smtp.163.com，为了证明你是163的用户，SMTP服务器还要求你填写邮箱地址和邮箱口令，这样，MUA才能正常地把Email通过SMTP协议发送到MTA。
从MDA收邮件时，MDA服务器也要求验证你的邮箱口令，确保不会有人冒充你收取你的邮件，所以，Outlook之类的邮件客户端会要求你填写POP3或IMAP服务器地址、邮箱地址和口令，这样，MUA才能顺利地通过POP或IMAP协议从MDA取到邮件。
```

```python
from email import encoders
from email.header import Header
from email.mime.text import MIMEText
from email.utils import parseaddr, formataddr
import smtplib    
def _format_addr(s):
    name, addr = parseaddr(s)
    return formataddr((Header(name, 'utf-8').encode(), addr))

from_addr = input('From: ')
password = input('Password: ')
to_addr = input('To: ')
smtp_server = input('SMTP server: ')

# 邮件对象:
msg = MIMEMultipart()
msg['From'] = _format_addr('Python爱好者 <%s>' % from_addr)
msg['To'] = _format_addr('管理员 <%s>' % to_addr)
msg['Subject'] = Header('来自SMTP的问候……', 'utf-8').encode()

# 邮件正文是MIMEText:
#第一个参数就是邮件正文，第二个参数是MIME的subtype，传入'plain'表示纯文本
msg.attach(MIMEText('send with file...', 'plain', 'utf-8'))
# 添加附件就是加上一个MIMEBase，从本地读取一个图片:
with open('/Users/michael/Downloads/test.png', 'rb') as f:
    # 设置附件的MIME和文件名，这里是png类型:
    mime = MIMEBase('image', 'png', filename='test.png')
    # 加上必要的头信息:
    mime.add_header('Content-Disposition', 'attachment', filename='test.png')
    mime.add_header('Content-ID', '<0>')
    mime.add_header('X-Attachment-Id', '0')
    # 把附件的内容读进来:
    mime.set_payload(f.read())
    # 用Base64编码:
    encoders.encode_base64(mime)
    # 添加到MIMEMultipart:
    msg.attach(mime)
    
server = smtplib.SMTP(smtp_server, 25)
server.set_debuglevel(1)
server.login(from_addr, password)
server.sendmail(from_addr, [to_addr], msg.as_string())
server.quit()
```

```
构造一个邮件对象就是一个Messag对象，如果构造一个MIMEText对象，就表示一个文本邮件对象，如果构造一个MIMEImage对象，就表示一个作为附件的图片，要把多个对象组合起来，就用MIMEMultipart对象，而MIMEBase可以表示任何对象。它们的继承关系如下：
Message
+- MIMEBase
   +- MIMEMultipart
   +- MIMENonMultipart
      +- MIMEMessage
      +- MIMEText
      +- MIMEImage
```

POP3收取邮件

```python
import poplib
# 输入邮件地址, 口令和POP3服务器地址:
email = input('Email: ')
password = input('Password: ')
pop3_server = input('POP3 server: ')

# 连接到POP3服务器:
server = poplib.POP3(pop3_server)
# 可以打开或关闭调试信息:
server.set_debuglevel(1)
# 可选:打印POP3服务器的欢迎文字:
print(server.getwelcome().decode('utf-8'))

# 身份认证:
server.user(email)
server.pass_(password)

# stat()返回邮件数量和占用空间:
print('Messages: %s. Size: %s' % server.stat())
# list()返回所有邮件的编号:
resp, mails, octets = server.list()
# 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]
print(mails)

# 获取最新一封邮件, 注意索引号从1开始:
index = len(mails)
resp, lines, octets = server.retr(index)

# lines存储了邮件的原始文本的每一行,
# 可以获得整个邮件的原始文本:
msg_content = b'\r\n'.join(lines).decode('utf-8')
# 稍后解析出邮件:
msg = Parser().parsestr(msg_content)

# 可以根据邮件索引号直接从服务器删除邮件:
# server.dele(index)
# 关闭连接:
server.quit()
```

##### 多线程

```python
当调用start()时，才会真正的创建线程，并且开始执行
#coding=utf-8
import threading
from time import sleep,ctime
def sing():
    for i in range(3):
        print("正在唱歌...%d"%i)
        sleep(1)
def dance():
    for i in range(3):
        print("正在跳舞...%d"%i)
        sleep(1)
if __name__ == '__main__':
    print('---开始---:%s'%ctime())
    t1 = threading.Thread(target=sing)#没有括号
    t2 = threading.Thread(target=dance)
    t1.start()
    t2.start()
    while True:
        length = len(threading.enumerate())
        print('当前运行的线程数为：%d'%length)
        if length<=1:
            break
        sleep(0.5)

#另外一种多线程实现方式
#coding=utf-8
import threading
import time
class MyThread(threading.Thread):
    def run(self):
        for i in range(3):
            time.sleep(1)
            msg = "I'm "+self.name+' @ '+str(i)
            print(msg)
def test():
    for i in range(5):
        t = MyThread()
        t.start()
if __name__ == '__main__':
    test()

线程共享全局变量，下面code线程间共享变量
from threading import Thread
import time
def work1(nums):
    nums.append(44)
    print("----in work1---",nums)
def work2(nums):
    #延时一会，保证t1线程中的事情做完
    time.sleep(1)
    print("----in work2---",nums)
g_nums = [11,22,33]
t1 = Thread(target=work1, args=(g_nums,))
t1.start()
t2 = Thread(target=work2, args=(g_nums,))
t2.start()

一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。
可以理解为全局变量local_school是一个dict，以thread自身作为key获得线程对应的Student对象
全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。
import threading    
# 创建全局ThreadLocal对象:
local_school = threading.local()
def process_student():
    # 获取当前线程关联的student:
    std = local_school.student
    print('Hello, %s (in %s)' % (std, threading.current_thread().name))
def process_thread(name):
    # 绑定ThreadLocal的student:
    local_school.student = name
    process_student()
t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')
t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')#name线程名
t1.start()
t2.start()
t1.join()
t2.join()
Hello, Alice (in Thread-A)
Hello, Bob (in Thread-B)
```

**互斥锁**

当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制

同步就是协同步调，按预定的先后次序进行运行。如:你说完，我再说。

某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。

互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。

```python
import threading
import time
g_num = 0
def test1(num):
    global g_num
    for i in range(num):
        mutex.acquire()  # 上锁
        g_num += 1
        mutex.release()  # 解锁
    print("---test1---g_num=%d"%g_num)
def test2(num):
    global g_num
    for i in range(num):
        mutex.acquire()  # 上锁
        g_num += 1
        mutex.release()  # 解锁
    print("---test2---g_num=%d"%g_num)
# 创建一个互斥锁
# 默认是未上锁的状态
mutex = threading.Lock()
# 创建2个线程，让他们各自对g_num加1000000次
p1 = threading.Thread(target=test1, args=(1000000,))
p1.start()
p2 = threading.Thread(target=test2, args=(1000000,))
p2.start()
# 等待计算完成
while len(threading.enumerate()) != 1:
    time.sleep(1)
print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)
```

##### 多进程

```python
Process([group [, target [, name [, args [, kwargs]]]]])
    target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码
    args：给target指定的函数传递的参数，以元组的方式传递
    kwargs：给target指定的函数传递命名参数
    name：给进程设定一个名字，可以不设定
    group：指定进程组，大多数情况下用不到
    
Process创建的实例对象的常用方法：
    start()：启动子进程实例（创建子进程）
    is_alive()：判断进程子进程是否还在活着
    join([timeout])：是否等待子进程执行结束，或等待多少秒
    terminate()：不管任务是否完成，立即终止子进程
    
Process创建的实例对象的常用属性：
    name：当前进程的别名，默认为Process-N，N为从1开始递增的整数
    pid：当前进程的pid（进程号）
```

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194919.png)

**Queue**

```python
#coding=utf-8
from multiprocessing import Queue
q=Queue(3) #初始化一个Queue对象，最多可收三条put消息,若无值或为负值，可收消息量无上限（到内存尽头）
q.put("消息1") 
q.put("消息2")
print(q.full())  #False
q.put("消息3")
print(q.full()) #True

#因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常
try:
    q.put("消息4",True,2)
except:
    print("消息列队已满，现有消息数量:%s"%q.qsize()) #消息列队已满，现有消息数量:3

try:
    q.put_nowait("消息4")
except:
    print("消息列队已满，现有消息数量:%s"%q.qsize()) #消息列队已满，现有消息数量:3

#推荐的方式，先判断消息列队是否已满，再写入
if not q.full():
    q.put_nowait("消息4")

#读取消息时，先判断消息列队是否为空，再读取
if not q.empty():
    for i in range(q.qsize()):
        print(q.get_nowait())
```

**进程间通信**

```python
import multiprocessing as mp
def job(q):
    res=0
    for i in range(1000):
        res+=i+i**2+i**3
    q.put(res)    #queue

if __name__=='__main__':
	#Queue的功能是将每个核或线程的运算结果放在队里中， 等到每个线程或核运行完毕后再从队列中取出结果， 继续加载运算。原因很简单, 多线程调用的函数不能有返回值, 所以使用Queue存储多个线程运算的结果
    q = mp.Queue()
	#定义两个线程函数，用来处理同一个任务, args 的参数只要一个值的时候，参数后面需要加一个逗号，表示args是可迭代的，后面可能还有别的参数，不加逗号会出错
    p1 = mp.Process(target=job,args=(q,))
    p2 = mp.Process(target=job,args=(q,))
    p1.start()
    p2.start()
    p1.join() # 主进程等待p1结束
    p2.join()
    res1 = q.get()
    res2 = q.get()
    print(res1+res2)
```

**进程池**

1. `Pool`默认调用是CPU的核数，传入`processes`参数可自定义CPU核数
2. `map()` 放入迭代参数，返回多个结果的列表
3. `apply_async()`只能放入一组参数，并返回一个结果，若想要类似`map()`的效果，需要通过迭代

```python
import multiprocessing as mp
def job(i):
    return i

def multicore():
    pool = mp.Pool()
    res = pool.map(job, range(10))
    print(res) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    res = pool.apply_async(job,(2,))  # 使用非阻塞方式调用func（并执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；
    # 用get获得结果
    print(res.get()) # 2

def multicore2():
    pool = mp.Pool()
    res = pool.map(job, range(10)) 
    print(res) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    res = pool.apply_async(job, (2,))
    # 用get获得结果
    print(res.get()) # 2
    # 迭代器，i=0时apply一次，i=1时apply一次等等
    multi_res = [pool.apply_async(job, (i,)) for i in range(10)]
    # 从迭代器中取出
    print([res.get() for res in multi_res]) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

进程池中的Queue

如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：

```python
RuntimeError: Queue objects should only be shared between processes through inheritance.
```

**进程锁**

```python
def job(v, num, l):
    l.acquire() # 锁住
    for _ in range(5):
        time.sleep(0.1) 
        v.value += num # 获取共享内存
        print(v.value)
    l.release() # 释放

def multicore():
    l = mp.Lock() # 定义一个进程锁
    v = mp.Value('i', 0) # 定义共享内存
    p1 = mp.Process(target=job, args=(v,1,l)) # 需要将lock传入
    p2 = mp.Process(target=job, args=(v,3,l)) 
    p1.start()
    p2.start()
    p1.join()
    p2.join()

if __name__ == '__main__':
    multicore()
```

**分布式进程**

Python的`multiprocessing`模块不但支持多进程，其中`managers`子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于`managers`模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。

举个例子：如果我们已经有一个通过`Queue`通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？

```ascii
┌─────────────────────────────────────────┐     ┌──────────────────────────────────────┐
│task_master.py                           │  │  │task_worker.py                        │
│                                         │     │                                      │
│  task = manager.get_task_queue()        │  │  │  task = manager.get_task_queue()     │
│  result = manager.get_result_queue()    │     │  result = manager.get_result_queue() │
│              │                          │  │  │              │                       │
│              │                          │     │              │                       │
│              ▼                          │  │  │              │                       │
│  ┌─────────────────────────────────┐    │     │              │                       │
│  │QueueManager                     │    │  │  │              │                       │
│  │ ┌────────────┐ ┌──────────────┐ │    │     │              │                       │
│  │ │ task_queue │ │ result_queue │ │<───┼──┼──┼──────────────┘                       │
│  │ └────────────┘ └──────────────┘ │    │     │                                      │
│  └─────────────────────────────────┘    │  │  │                                      │
└─────────────────────────────────────────┘     └──────────────────────────────────────┘
                                          Network
```

先看服务进程，服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务：

```python
# task_master.py
import random, time, queue
from multiprocessing.managers import BaseManager

# 发送任务的队列:
task_queue = queue.Queue()
# 接收结果的队列:
result_queue = queue.Queue()

# 从BaseManager继承的QueueManager:
class QueueManager(BaseManager):
    pass

# 把两个Queue都注册到网络上, callable参数关联了Queue对象:
QueueManager.register('get_task_queue', callable=lambda: task_queue)
QueueManager.register('get_result_queue', callable=lambda: result_queue)
# 绑定端口5000, 设置验证码'abc':保证两台机器正常通信，不被其他机器恶意干扰
manager = QueueManager(address=('', 5000), authkey=b'abc')
# 启动Queue:
manager.start()
# 获得通过网络访问的Queue对象:
task = manager.get_task_queue()
result = manager.get_result_queue()
# 放几个任务进去:
for i in range(10):
    n = random.randint(0, 10000)
    print('Put task %d...' % n)
    task.put(n)
# 从result队列读取结果:
print('Try get results...')
for i in range(10):
    r = result.get(timeout=10)
    print('Result: %s' % r)
# 关闭:
manager.shutdown()
print('master exit.')
```

在另一台机器上启动任务进程（本机上启动也可以）：

```python
# task_worker.py

import time, sys, queue
from multiprocessing.managers import BaseManager

# 创建类似的QueueManager:
class QueueManager(BaseManager):
    pass

# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:
QueueManager.register('get_task_queue')
QueueManager.register('get_result_queue')

# 连接到服务器，也就是运行task_master.py的机器:
server_addr = '127.0.0.1'
print('Connect to server %s...' % server_addr)
# 端口和验证码注意保持与task_master.py设置的完全一致:
m = QueueManager(address=(server_addr, 5000), authkey=b'abc')
# 从网络连接:
m.connect()
# 获取Queue的对象:
task = m.get_task_queue()
result = m.get_result_queue()
# 从task队列取任务,并把结果写入result队列:
for i in range(10):
    try:
        n = task.get(timeout=1)
        print('run task %d * %d...' % (n, n))
        r = '%d * %d = %d' % (n, n, n*n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print('task queue is empty.')
# 处理结束:
print('worker exit.')
```

##### 迭代器

![image-20200426174101298](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194920.png)

```python
迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。
迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
可通过for.in.语句迭代读取一条数据的对象称之为可迭代对象（Iterable）,它具备了__iter__方法
可迭代对象通过__iter__方法提供一个迭代器，先获取该对象提供的迭代器，后通过迭代器来依次获取对象中数据
迭代器是用来帮助我们记录每次迭代访问到的位置
在使用迭代器next()函数的时候，调用的就是迭代器对象的__next__方法，返回它所记录位置的下一个位置的数据
for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。
#也可以在myList中实现__next__()
class MyList(object):
    """自定义的一个可迭代对象"""
    def __init__(self):
        self.items = []
    def add(self, val):
        self.items.append(val)
    def __iter__(self):
        myiterator = MyIterator(self)
        return myiterator

class MyIterator(object):
    """自定义的供上面可迭代对象使用的一个迭代器"""
    def __init__(self, mylist):
        self.mylist = mylist
        # current用来记录当前访问到的位置
        self.current = 0
    def __next__(self):
        if self.current < len(self.mylist.items):
            item = self.mylist.items[self.current]
            self.current += 1
            return item
        else:
            raise StopIteration
    def __iter__(self):
        return self

if __name__ == '__main__':
    mylist = MyList()
    mylist.add(1)
    mylist.add(2)
    mylist.add(5)
    for num in mylist:
        print(num)
     
除了for循环能接收可迭代对象，list、tuple等也能接收。
    li = list(FibIterator(15))
    print(li)
```

![image-20200426173446340](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194921.png)

##### 生成器和yield

```python
如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>
>>> next(g)
0
>>> for n in g:
...     print(n)
生成器(generator)。生成器是一类特殊的迭代器
对于生成器G，我们可以按照迭代器的使用方法来使用，即可以通过next()函数、for循环、list()等方法使用
只要在def中有yield关键字的 就称为 生成器
按调函数方式使用生成器就不再是执行函数体了，而是会返回一个生成器对象，就可以按使用迭代器方式来使用生成器了
yield关键字有两点作用：
    保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起
    将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用
    可使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数），从yield处开始执行，而非开始处执行

除了可以使用next()函数来唤醒生成器继续执行外，还可以使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。
temp = yield i
f.send('haha') #此时haha会传给temp
```

![image-20200426175250683](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194922.png)

如果直接对文件对象调用 read() 方法，会导致不可预测的内存占用。好的方法是利用固定长度的缓冲区来不断读取文件内容。通过 yield，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取：

```python
def read_file(fpath): 
    BLOCK_SIZE = 1024 
    with open(fpath, 'rb') as f: 
        while True: 
            block = f.read(BLOCK_SIZE) 
            if block: 
                yield block 
            else: 
                return
```

##### 协程

```python
协程，又称微线程，协程是python个中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元
通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定
线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。每个线程都有自己缓存Cache等数据，操作系统还会帮你做这些数据的恢复操作。
线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。
import time
def work1():
    while True:
        print("----work1---")
        yield
        time.sleep(0.5)
def work2():
    while True:
        print("----work2---")
        yield
        time.sleep(0.5)
def main():
    w1 = work1()
    w2 = work2()
    while True:
        next(w1)
        next(w2)
if __name__ == "__main__":
    main()

    
#coding=utf-8
from greenlet import greenlet
import time
def test1():
    while True:
        print "---A--"
        gr2.switch()
        time.sleep(0.5)
def test2():
    while True:
        print "---B--"
        gr1.switch()
        time.sleep(0.5)
gr1 = greenlet(test1)
gr2 = greenlet(test2)
#切换到gr1中运行
gr1.switch()

greenlet已经实现了协程，但是这个还的人工切换
能够自动切换任务的模块gevent，其原理是当一个greenlet遇到IO(比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。
from gevent import monkey
import gevent
import random
import time
# 有耗时操作时需要
monkey.patch_all()  # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块
def coroutine_work(coroutine_name):
    for i in range(10):
        print(coroutine_name, i)
        time.sleep(random.random())

gevent.joinall([
        gevent.spawn(coroutine_work, "work1"),
        gevent.spawn(coroutine_work, "work2")
])
```

进程线程协程

```
进程是资源分配的单位
线程是操作系统调度的单位
进程切换需要的资源很最大，效率很低
线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）
协程切换任务资源很小，效率高
多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发
```

##### GIL（全局解释器锁）

```
任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。
GIL（Global Interpreter Lock）面试题如下
描述Python GIL的概念， 以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。
Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。
GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。
线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100
Python使用多进程是可以利用多核的CPU资源的。
多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁
```

##### 深拷贝、浅拷贝

浅拷贝是对于一个对象的顶层拷贝，通俗的理解是：拷贝了引用，并没有拷贝内容

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194923.png)

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194924.png)

深拷贝是对于一个对象所有层次的拷贝(递归)

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194925.png)

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194926.png)

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194927.png)

**浅拷贝对不可变类型和可变类型的**copy不同

1. copy.copy对于可变类型，会进行浅拷贝
2. copy.copy对于不可变类型，不会拷贝，仅仅是指向

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194928.png)

**copy.copy和copy.deepcopy的区别**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194929.png)

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194930.png)

##### 发布模块

- 如果希望自己开发的模块，**分享** 给其他人，可以按照以下步骤操作

1) 创建 setup.py

- `setup.py` 的文件

```python
from distutils.core import setup

setup(name="hm_message",  # 包名
      version="1.0",  # 版本
      description="itheima's 发送和接收消息模块",  # 描述信息
      long_description="完整的发送和接收消息模块",  # 完整描述信息
      author="itheima",  # 作者
      author_email="itheima@itheima.com",  # 作者邮箱
      url="www.itheima.com",  # 主页
      py_modules=["hm_message.send_message",
                  "hm_message.receive_message"])
```

有关字典参数的详细信息，可以参阅[官方网站](https://docs.python.org/2/distutils/apiref.html)

2) 构建模块

```bash
$ python3 setup.py build
```

3) 生成发布压缩包

```bash
$ python3 setup.py sdist
```

> 注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！

**安装模块**

```bash
$ tar -zxvf hm_message-1.0.tar.gz 
$ sudo python3 setup.py install
```

**卸载模块**

```bash
直接从安装目录下，把安装模块的 **目录** 删除就可以
$ cd /usr/local/lib/python3.5/dist-packages/
$ sudo rm -r hm_message*
```

##### 安装第三方模块

- pip install retrying
- 下载源码解码，进入解压后的目录，```python setup.py install```
- `***.whl` 安装方法 `pip install ***.whl`

##### 直接运行py文件

能不能像.exe文件那样直接运行`.py`文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在`.py`文件的第一行加上一个特殊的注释：

```python
#!/usr/bin/env python3
print('hello, world')
```

然后，通过命令给`hello.py`以执行权限：最后执行./hello.py

```sh
$ chmod a+x hello.py
```

##### 装饰器

```python
假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：

def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：

@log
def now():
    print('2015-3-25')
调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：
>>> now()
call now():
2015-3-25

@函数名 是python的一种语法糖。把@log放到now()函数的定义处，相当于执行了语句：
首先执行log函数 ，并将 @log 下面的函数作为log函数的参数，即：@log 等价于 log(now) 
其次将执行完的log函数返回值 赋值 给@log下面的函数的函数名now 即将log的返回值再重新赋值给 now,now = log(now)
由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数

一个完整的decorator的写法如下：
import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper

或者针对带参数的decorator：
import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

#### 内建及三方模块

##### datetime

datetime是Python处理日期和时间的标准库。

```python
>>> from datetime import datetime
>>> now = datetime.now() # 获取当前datetime
>>> print(now)
2015-05-18 16:28:07.198690
>>> print(type(now))
<class 'datetime.datetime'>
>>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime
>>> print(dt)
2015-04-19 12:20:00
>>> dt.timestamp() # 把datetime转换为timestamp
1429417200.0#多少秒
>>> t = 1429417200.0
>>> print(datetime.fromtimestamp(t)) # 本地时间
2015-04-19 12:20:00
>>> print(datetime.utcfromtimestamp(t)) # UTC时间 格林威治标准时间
2015-04-19 04:20:00
        
# str转换为datetime，需要一个日期和时间的格式化字符串：
>>> cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')
>>> print(cday)
2015-06-01 18:19:59
# datetime转换为str，同样需要一个日期和时间的格式化字符串：
>>> now = datetime.now()
>>> print(now.strftime('%a, %b %d %H:%M'))
Mon, May 05 16:28
>>> now + timedelta(days=2, hours=12)
datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)

# 拿到UTC时间，并强制设置时区为UTC+0:00:
>>> utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)
>>> print(utc_dt)
2015-05-18 09:05:12.377316+00:00
# astimezone()将转换时区为北京时间:
>>> bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))
>>> print(bj_dt)
2015-05-18 17:05:12.377316+08:00
```

![image-20200504115212284](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194931.png)

##### collections

collections是Python内建的一个集合模块，提供了许多有用的集合类

**namedtuple**

`namedtuple`是一个函数，它用来创建一个自定义的`tuple`对象，并且规定了`tuple`元素的个数，并可以用属性而不是索引来引用`tuple`的某个元素。

```python
>>> from collections import namedtuple
>>> Point = namedtuple('Point', ['x', 'y'])
>>> p = Point(1, 2)
>>> p.x
1
>>> isinstance(p, tuple)
True
```

**deque**

deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：

```python
>>> from collections import deque
>>> q = deque(['a', 'b', 'c'])
>>> q.append('x')
>>> q.appendleft('y')
>>> q
deque(['y', 'a', 'b', 'c', 'x'])
>>> q.pop()
x
```

##### Base64

二进制数据进行处理，每3个字节一组，一共是`3x8=24`bit，划为4组，每组正好6个bit：

![base64-encode](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194932.png)

这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。

Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。

```python
>>> import base64
>>> base64.b64encode(b'binary\x00string')
b'YmluYXJ5AHN0cmluZw=='
>>> base64.b64decode(b'YmluYXJ5AHN0cmluZw==')
b'binary\x00string'
```

##### 摘要算法

```python
import hashlib
md5 = hashlib.md5()
md5.update('how to use md5 in python hashlib?'.encode('utf-8'))
print(md5.hexdigest())
计算结果如下：
d26a53750bc40b38b65a520292f69306
#另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似
```

hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。

```python
>>> import hmac
>>> message = b'Hello, world!'
>>> key = b'secret'
>>> h = hmac.new(key, message, digestmod='MD5')
>>> # 如果消息很长，可以多次调用h.update(msg)
>>> h.hexdigest()
'fa4ee7d173f2d97ee79022d1a7355bcf'
可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。
```

##### DOM vs SAX

操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。

##### Pillow

PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。

```python
from PIL import Image
# 打开一个jpg图像文件，注意是当前路径:
im = Image.open('test.jpg')
# 获得图像尺寸:
w, h = im.size
print('Original image size: %sx%s' % (w, h))
# 缩放到50%:
im.thumbnail((w//2, h//2))
print('Resize image to: %sx%s' % (w//2, h//2))
# 把缩放后的图像用jpeg格式保存:
im.save('thumbnail.jpg', 'jpeg')
# 打开一个jpg图像文件，注意是当前路径:
im = Image.open('test.jpg')
# 应用模糊滤镜:
im2 = im.filter(ImageFilter.BLUR)
im2.save('blur.jpg', 'jpeg')

生成验证码
from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random
# 随机字母:
def rndChar():
    return chr(random.randint(65, 90))
# 随机颜色1:
def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))
# 随机颜色2:
def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))
# 240 x 60:
width = 60 * 4
height = 60
image = Image.new('RGB', (width, height), (255, 255, 255))
# 创建Font对象:
font = ImageFont.truetype('Arial.ttf', 36)
# 创建Draw对象:
draw = ImageDraw.Draw(image)
# 填充每个像素:
for x in range(width):
    for y in range(height):
        draw.point((x, y), fill=rndColor())
# 输出文字:
for t in range(4):
    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())
# 模糊:
image = image.filter(ImageFilter.BLUR)
image.save('code.jpg', 'jpeg')
```

##### chardet

```
当我们拿到一个bytes时，就可以对其检测编码。用chardet检测编码，只需要一行代码：
>>> chardet.detect(b'Hello, world!')
{'encoding': 'ascii', 'confidence': 1.0, 'language': ''}
```

##### logging

```python
日志一共分成5个等级，从低到高分别是：
DEBUG：详细的信息,通常只出现在诊断问题上
INFO：确认一切按预期运行
WARNING：一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”)。这个软件还能按预期工作。
ERROR：更严重的问题,软件没能执行一些功能
CRITICAL：一个严重的错误,这表明程序本身可能无法继续运行

import logging  
logging.basicConfig(level=logging.WARNING,  
                    filename='./log.txt',  
                    filemode='w',  
                    format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')  
# use logging  
logging.info('这是 loggging info message')  
logging.debug('这是 loggging debug message')  
logging.warning('这是 loggging a warning message')  
logging.error('这是 an loggging error message')  
logging.critical('这是 loggging critical message')

###控制台文件都输出日志
# 第一步，创建一个logger  
logger = logging.getLogger()  
logger.setLevel(logging.INFO)  # Log等级总开关  
# 第二步，创建一个handler，用于写入日志文件  
logfile = './log.txt'  
fh = logging.FileHandler(logfile, mode='a')  # open的打开模式这里可以进行参考
fh.setLevel(logging.DEBUG)  # 输出到file的log等级的开关  
# 第三步，再创建一个handler，用于输出到控制台  
ch = logging.StreamHandler()  
ch.setLevel(logging.WARNING)   # 输出到console的log等级的开关
# 第四步，定义handler的输出格式  
formatter = logging.Formatter("%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s")  
fh.setFormatter(formatter)  
ch.setFormatter(formatter)  
# 第五步，将logger添加到handler里面  
logger.addHandler(fh)  
logger.addHandler(ch)
```

#### code规范

##### 命名

```python
命名：项目和类驼峰，其余小写下划线
1.项目名称
首字母大写+大写式驼峰，
ProjectName
2.模块名和包名
全部小写+下划线驼峰
module_name  package_name
3.类名称，异常
首字母大写+大写式驼峰，
class ClassName:   ExceptionName
4.全局变量、常量
全部使用大写字母+下划线驼峰
GLOBAL_VAR_NAME，CONSTANT_NAME
5.方法名，函数名，其余变量，参数，实例
全部小写+下划线驼峰，私有函数在函数前加一个下划线_
method_name，function_name，instance_var_name, function_parameter_name, local_var_name，
def _private_func():
6.处理计数器外，不使用单字母命名
```

##### 行

```python
不要在行尾加分号, 也不要用分号将两条命令放在同一行.
每行不超过80个字符
Python会将 圆括号, 中括号和花括号中的行隐式的连接起来
Yes: foo_bar(self, width, height, color='black', design=None, x='foo',
             emphasis=None, highlight=0)
顶级定义之间空两行, 比如函数或者类定义. 
方法定义, 类定义与第一个方法之间, 都应该空一行
```

##### 空格

```python
用4个空格来缩进代码，绝对不要用tab, 也不要tab和空格混用.
括号内不要有空格.
Yes: spam(ham[1], {eggs: 2}, [])
不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).
Yes: if x == 4:
         print x, y
     x, y = y, x
参数列表, 索引或切片的左括号前不应加空格.
Yes: spam(1)
不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):
Yes: foo = 1000  # comment
     long_name = 2  # comment that should not be aligned
     dictionary = {
         "foo": 1,
         "long_name": 2,
         }
```

##### 编码

```sh
如无特殊情况, 文件一律使用 UTF-8 编码
如无特殊情况, 文件头部必须加入#--coding:utf-8--标识                              
大部分.py文件不必以#!作为文件的开始. 但main文件应该以#!/usr/bin/python3开始.
#!用于帮助内核找Python解释器, 但在导入模块时, 将会被忽略. 因此只有被直接执行的文件中才有必要加入#!.
```

##### 导包

```python
导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 
导入应该按照从最通用到最不通用的顺序分组:
    标准库导入
    第三方库导入
    应用程序指定导入
每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.
import语句应该使用 absolute import
Yes: from foo.bar import Bar
No: from ..bar import Bar  
```

##### 字符串 

```python
使用%操作符或者格式化方法格式化字符串.少使用+
Yes: x = a + b
     x = '%s, %s!' % (imperative, expletive)
     x = '{}, {}!'.format(imperative, expletive)
     x = 'name: %s; score: %d' % (name, n)
     x = 'name: {}; score: {}'.format(name, n)
No: x = '%s%s' % (a, b)  # use + in this case
    x = '{}{}'.format(a, b)  # use + in this case
    x = imperative + ', ' + expletive + '!'
    x = 'name: ' + name + '; score: ' + str(n)                             
避免在循环中用+和+=操作符来累加字符串
由于字符串是不可变的, 这样做会创建不必要的临时对象, 可以将每个子串加入列表, 用 .join 连接列表. 
也可以将每个子串写入一个 cStringIO.StringIO 缓存中.
Yes: items = ['<table>']
     for last_name, first_name in employee_list:
         items.append('<tr><td>%s, %s</td></tr>' % (last_name, first_name))
     items.append('</table>')
     employee_table = ''.join(items)                           
为多行字符串使用三重双引号”“”而非三重单引号’‘’. 不过通常用隐式行连接更清晰
Yes:print ("This is much nicer.\n"
           "Do it this way.\n") 
```

##### 数据类3.7+

```python
# 传统实现
class RegularCard:
    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit

    def __repr__(self):
        return (f'{self.__class__.__name__}'
                f'(rank={self.rank!r}, suit={self.suit!r})')

    def __eq__(self, other):
        if other.__class__ is not self.__class__:
            return NotImplemented
        return (self.rank, self.suit) == (other.rank, other.suit)

# 使用数据类 data class
from dataclasses import dataclass
@dataclass
class Card:
    rank: str
    suit: str = "hearts" # 位置参数， 设置默认值
card = Card("Q", "hearts")
print(card == card)
print(card.__eq__(card))
print(card.__repr__())  # Card(rank='Q', suit='hearts') __repr__
```

##### 控制台文本加色

```python
# pip install colorama
from colorama import Fore, Back, Style
print(Fore.RED + 'some red text')
print(Back.GREEN + 'and with a green background')
print(Style.DIM + 'and in dim text')
print(Style.RESET_ALL)
print('back to normal now')
```

##### enum替代数字字面量 

```python
# 使用enum 避免直接使用 数字字面量
# -*- coding: utf-8 -*-
from enum import IntEnum

class TripSource(IntEnum):
    FROM_WEBSITE = 11
    FROM_IOS_CLIENT = 12

def mark_trip_as_featured(trip):
    if trip.source == TripSource.FROM_WEBSITE:
        do_some_thing(trip)
    elif trip.source == TripSource.FROM_IOS_CLIENT:
        do_some_other_thing(trip)
    ... ...
    return
```

#### 数据读写与保存

##### csv

```python
>>> import csv
>>> students = [[’name’, ’gender’, ’age’],
... [’zhangsan’, ’male’, 13],
... [’lisi’, ’female’, 14]]
>>> handle = open(’students.csv’, ’w’)
>>> writer = csv.writer(handle)
>>> writer.writerows(students)
>>> handle.close()
>>> handle = open(’students.csv’, ’r’)
>>> reader = csv.reader(handle)
>>> for row in reader:
... print(row)
```

##### xls

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194933.png)

```python
 import xlrd  #引入模块
 #打开文件，获取excel文件的workbook（工作簿）对象
workbook=xlrd.open_workbook("DataSource/Economics.xls")  #文件路径
'''对workbook对象进行操作'''
#获取所有sheet的名字
names=workbook.sheet_names()
print(names) #['各省市', '测试表']  输出所有的表名，以列表的形式
#通过sheet索引获得sheet对象
worksheet=workbook.sheet_by_index(0)
print(worksheet)  #<xlrd.sheet.Sheet object at 0x000001B98D99CFD0>
#通过sheet名获得sheet对象
worksheet=workbook.sheet_by_name("各省市")
print(worksheet) #<xlrd.sheet.Sheet object at 0x000001B98D99CFD0>
#由上可知，workbook.sheet_names() 返回一个list对象，可以对这个list对象进行操作
sheet0_name=workbook.sheet_names()[0]  #通过sheet索引获取sheet名称
print(sheet0_name)  #各省市
'''对sheet对象进行操作'''
name=worksheet.name  #获取表的姓名
print(name) #各省市 
nrows=worksheet.nrows  #获取该表总行数
print(nrows)  #32
ncols=worksheet.ncols  #获取该表总列数
print(ncols) #13
for i in range(nrows): #循环打印每一行
    print(worksheet.row_values(i))  #以列表形式读出，列表中的每一项是str类型
#['各省市', '工资性收入', '家庭经营纯收入', '财产性收入', ………………]
#['北京市', '5047.4', '1957.1', '678.8', '592.2', '1879.0，…………]
col_data=worksheet.col_values(0)  #获取第一列的内容
print(col_data)
#通过坐标读取表格中的数据
cell_value1=sheet0.cell_value(0,0)
cell_value2=sheet0.cell_value(1,0)
print(cell_value1)  #各省市
print(cell_value2)   #北京市
cell_value1=sheet0.cell(0,0).value
print(cell_value1) #各省市
cell_value1=sheet0.row(0)[0].value
print(cell_value1)  #各省市 


# 导入xlwt模块
import xlwt
#创建一个Workbook对象，相当于创建了一个Excel文件
book=xlwt.Workbook(encoding="utf-8",style_compression=0)
'''
Workbook类初始化时有encoding和style_compression参数
encoding:设置字符编码，一般要这样设置：w = Workbook(encoding='utf-8')，就可以在excel中输出中文了。默认是ascii。
style_compression:表示是否压缩，不常用。
''' 
# 创建一个sheet对象，一个sheet对象对应Excel文件中的一张表格。
sheet = book.add_sheet('test01', cell_overwrite_ok=True)
# 其中的test是这张表的名字,cell_overwrite_ok，表示是否可以覆盖单元格，其实是Worksheet实例化的一个参数，默认值是False
# 向表test中添加数据
sheet.write(0, 0, '各省市')  # 其中的'0-行, 0-列'指定表中的单元，'各省市'是向该单元写入的内容
sheet.write(0, 1, '工资性收入')
# 最后，将以上操作保存到指定的Excel文件中
book.save('DataSource\\test1.xls')  
```

##### sqlite3

```python
# 导入SQLite驱动:
>>> import sqlite3
# 连接到SQLite数据库
# 数据库文件是test.db
# 如果文件不存在，会自动在当前目录创建:
>>> conn = sqlite3.connect('test.db')
# 创建一个Cursor:
>>> cursor = conn.cursor()
# 执行一条SQL语句，创建user表:
>>> cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
<sqlite3.Cursor object at 0x10f8aa260>
# 继续执行一条SQL语句，插入一条记录:
>>> cursor.execute('insert into user (id, name) values (\'1\', \'Michael\')')
<sqlite3.Cursor object at 0x10f8aa260>
# 通过rowcount获得插入的行数:
>>> cursor.rowcount
1
# 关闭Cursor:
>>> cursor.close()
# 提交事务:
>>> conn.commit()
# 关闭Connection:
>>> conn.close()

我们再试试查询记录：
>>> conn = sqlite3.connect('test.db')
>>> cursor = conn.cursor()
# 执行查询语句:
>>> cursor.execute('select * from user where id=?', ('1',))
<sqlite3.Cursor object at 0x10f8aa340>
# 获得查询结果集:
>>> values = cursor.fetchall()
>>> values
[('1', 'Michael')]
>>> cursor.close()
>>> conn.close()

如果SQL语句带有参数，那么需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数，防止sql注入，例如：
cursor.execute('select * from user where name=? and pwd=?', ('abc', 'password'))
```

**执行sql脚本**

```python
$ cat a.sql
create table news (id integer, score integer, title text, href text);
insert into news values (1, 8, "hello world", "http://oscar-lab.org");
insert into news values (2, 2, "hello charlie", "http://www.dlut.edu.cn");
$ python3
>>> import sqlite3
>>> conn = sqlite3.connect(’a.db’)
>>> c = conn.cursor()
>>> c.executescript(open(’a.sql’).read())
>>> list(c.execute(’select * from news’))
[(1, 8, ’hello world’, ’http://oscar-lab.org’),
(2, 2, ’hello charlie’, ’http://www.dlut.edu.cn’)]
```

**Row Objects**

```python
>>> conn.row_factory = sqlite3.Row
>>> c = conn.cursor()
>>> c.execute(’select* from stocks’)
<sqlite3.Cursor object at 0x7f4e7dd8fa80>
>>> r = c.fetchone()
>>> type(r)
<class ’sqlite3.Row’>
>>> tuple(r)
(’2006-01-05’, ’BUY’, ’RHAT’, 100.0, 35.14)
>>> len(r)
5
>>> r[2]
’RHAT’

>>> for row in c.execute(’SELECT * FROM stocks ORDER BY price’):
		print(row)
(’2006-01-05’, ’BUY’, ’RHAT’, 100, 35.14)
(’2006-03-28’, ’BUY’, ’IBM’, 1000, 45.0)
(’2006-04-06’, ’SELL’, ’IBM’, 500, 53.0)
(’2006-04-05’, ’BUY’, ’MSFT’, 1000, 72.0)
```

```
Python type ——SQLite type
None ——NULL
int—— INTEGER
float ——REAL
str ——TEXT
bytes—— BLOB
```

##### MySQL

```python
# 导入MySQL驱动:
>>> import mysql.connector
# 注意把password设为你的root口令:
>>> conn = mysql.connector.connect(user='root', password='password', database='test')
>>> cursor = conn.cursor()
# 创建user表:
>>> cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
# 插入一行记录，注意MySQL的占位符是%s:
>>> cursor.execute('insert into user (id, name) values (%s, %s)', ['1', 'Michael'])
>>> cursor.rowcount
1
# 提交事务:
>>> conn.commit()
>>> cursor.close()
# 运行查询:
>>> cursor = conn.cursor()
>>> cursor.execute('select * from user where id = %s', ('1',))
>>> values = cursor.fetchall()
>>> values
[('1', 'Michael')]
# 关闭Cursor和Connection:
>>> cursor.close()
True
>>> conn.close()
```

##### SQLAlchemy

在Python中，最有名的ORM（“Object Relational Mapping”，即对象-关系映射）框架是SQLAlchemy。

```python
# 导入:
from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# 创建对象的基类:
Base = declarative_base()

# 定义User对象:
class User(Base):
    # 表的名字:
    __tablename__ = 'user'

    # 表的结构:
    id = Column(String(20), primary_key=True)
    name = Column(String(20))

# 初始化数据库连接:
engine = create_engine('mysql+mysqlconnector://root:password@localhost:3306/test')
# 创建DBSession类型:
DBSession = sessionmaker(bind=engine)

# 创建新User对象:
new_user = User(id='5', name='Bob')
# 添加到session:
session.add(new_user)
# 提交即保存到数据库:
session.commit()
# 关闭session:
session.close()

# 创建Session:
session = DBSession()
# 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:
user = session.query(User).filter(User.id=='5').one()
# 打印类型和对象的name属性:
print('type:', type(user))
print('name:', user.name)
# 关闭Session:
session.close()
运行结果如下：
type: <class '__main__.User'>
name: Bob
```

#### Web服务

##### WSGI

WSGI接口(Web Server Gateway Interface)定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。

```python
def application(environ, start_response):
    #start_response()函数接收两个参数，一个是HTTP响应码，一个是一组list表示的HTTP Header，每个Header用一个包含两个str的tuple表示。
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'<h1>Hello, web!</h1>']
```

再编写一个`server.py`，负责启动WSGI服务器，加载`application()`函数：

```python
# server.py
# 从wsgiref模块导入:
from wsgiref.simple_server import make_server
# 导入我们自己编写的application函数:
from hello import application

# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:
httpd = make_server('', 8000, application)
print('Serving HTTP on port 8000...')
# 开始监听HTTP请求:
httpd.serve_forever()
```

##### flask

```python
from flask import Flask
app = Flask(__name__)
@app.route(’/’)
def hello_world():
	return ’Hello, World!’
```

**启动服务器**

```python
使用--host=0.0.0.0 使能跨 IP 访问
$ export FLASK_APP=hello.py (run set FLASK_APP=hello.py on Windows)
$ flask run
*Running on http://127.0.0.1:5000/
```

**路由**

有时候需要接收URL中的参数变量，可以把参数标记为一个变量`<变量名>`，这个部分将会作为命名参数传递给函数。同时还可以限制参数变量的类型`<类型:变量名>`。

```python
@app.route(’/hello’)
def hello():
	return ’Hello, World’
	
@app.route(’/user/<username>’)
def show_user_profile(username):
    # show the user profile for that user
    return ’User %s’ % username
@app.route(’/post/<int:post_id>’)
def show_post(post_id):
    # show the post with the given id, the id is an integer
    return ’Post %d’ % post_id

#redirect
@app.route(’/’)
def index():
		return redirect(url_for(’login’))
    
from flask import request
@app.route(’/login’, methods=[’GET’, ’POST’])
def login():
	if request.method == ’POST’:
		do_the_login()
	else:
		show_the_login_form()
```

**使用模板**

![mvc-seq](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194934.png)

```python
from flask import render_template
@app.route(’/hello/’)
@app.route(’/hello/<name>’)
def hello(name=None):
	return render_template(’hello.html’, name=name)
	
@app.route('/signin', methods=['POST'])
def signin():
    username = request.form['username']
    password = request.form['password']
    if username=='admin' and password=='password':
        return render_template('signin-ok.html', username=username)
    return render_template('form.html', message='Bad username or password', username=username)
```

**接收前端传来数据**

```python
from flask import request

def get():
    dict = request.args['name']
    print(dict)
def formdata():
    dict = request.form['name']
    print(dict)
def file():
    dict = request.files['file']
    print(dict)
def json():
    dict = request.get_json()
    print(dict)
```

#### 可视化

画图

```python
• 使用 plt.plot(x, y) 和 plot.show() 画图（推荐 jupyter）
• 使用 plt.xlabel(”)，plt.ylabel(”)，plt.title(”) 设置标题
• 使用 plt.savefig(fname, dpi) 保存图片
• 使用 fig, ax = plt.subplots() 返回图片句柄和坐标轴
• fig.savefig() 保存图片
• ax.plot 画图
• ax.set(xlabel=“x”, ylabel=“y”, title=“title”)
```

##### 例子

```python
import numpy as np
import matplotlib.pyplot as plt
from pylab import *
mpl.rcParams['font.sans-serif'] = ['SimHei']
print("常见绘图")
X=np.linspace(-np.pi,np.pi,256,endpoint=True)#-π to+π的256个值
C,S=np.cos(X),np.sin(X)
plt.plot(X,C,'r--',label="$sin(x)$")
plt.scatter(X,C,color='g')
plt.plot(X,S,'b',label="$cos(x)$")
plt.xlim(-np.pi,np.pi)
#图像标签说明,设置label的都显示(loc=2位于第二个角洛)
plt.legend()
plt.show()

print("多图画在一起")
x=np.arange(-2*np.pi,2*np.pi,0.1*np.pi)
y=np.sin(x)
y2=np.cos(x)
fig,(ax,ax1)=plt.subplots(1,2)
#指定曲线的颜色和线性，如‘b--’表示蓝色虚线（b：蓝色，-：虚线）
ax.plot(x,y,'r--',label="$sin(x)$")
ax1.plot(x,y2,'g')
#将$包围的内容渲染为数学公式
ax.set(xlabel="x",ylabel="$sin(x)$")
ax.set_title("sin(x)图像")
ax1.set(xlabel="x",ylabel="sin(x)")
ax1.set_title("cos(x)图像")
ax.grid()
ax1.grid()
ax.axis([-2*np.pi,2*np.pi,-1,1])
ax1.axis([-2*np.pi,2*np.pi,-1,1])
ax.legend(loc=2)
plt.show()
```

```python
import matplotlib.pyplot as plt
#折线图
x = [10,100,180,310,400,500]#点的横坐标
Sparrow=[0,180,310,560,630,750]
ZkCheck=[0,110,200,310,400,590]
CSA=[0,210,420,780,1030,1180]
Clouseau=[0,200,360,605,800,1005]
plt.grid(linestyle='-.')
plt.plot(x,Sparrow,'s--',color = 'b',label="Sparrow")#s-:方形
plt.plot(x,CSA,'^-.',color = 'k',label="CSA")#s-:方形
plt.plot(x,Clouseau,'+:',color = 'g',label="Clouseau")#s-:方形
plt.plot(x,ZkCheck,'o-',color = 'r',label="ZkCheck")#o-:圆形
plt.xlabel("code Quantity/Kloc")#横坐标名字
plt.ylabel("Detection Time/s")#纵坐标名字
plt.legend(loc = "best")#图例
plt.show()
```

```
=============    ===============================
character        description
=============    ===============================
``'-'``          solid line style 实线
``'--'``         dashed line style 虚线
``'-.'``         dash-dot line style 点画线
``':'``          dotted line style 点线
=============    ===============================
```

附颜色表

![image-20200827144703701](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194935.png)

Marker常见参数

![image-20200827144728129](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210329194936.png)

##### histogram (hist) function直方图

```python
import numpy as np
import matplotlib.pyplot as plt
np.random.seed(19680801)
mu, sigma = 100, 15
x = mu + sigma * np.random.randn(10000)
# the histogram of the data
n, bins, patches = plt.hist(x, 50, normed=1, facecolor=’g’, alpha=0.75)
plt.xlabel(’Smarts’)
plt.ylabel(’Probability’)
plt.title(’Histogram of IQ’)
plt.axis([40, 160, 0, 0.03])
plt.grid(True)
plt.show()
```

##### Basic pie chart

```python
import matplotlib.pyplot as plt
# Pie chart, where the slices will be ordered and plotted counter-clockwise:
labels = ’Frogs’, ’Hogs’, ’Dogs’, ’Logs’
sizes = [15, 30, 45, 10]
explode = (0, 0.1, 0, 0) # only "explode" the 2nd slice (i.e. ’Hogs’)
fig1, ax1 = plt.subplots()
ax1.pie(sizes, explode=explode, labels=labels, autopct=’%1.1f%%’,
		shadow=True, startangle=90)
ax1.axis(’equal’) # Equal aspect ratio ensures that pie is drawn as a circle.
plt.show()
```

####  Pandas 

主要处理类似于数据表的二维数组

```python
import  pandas as pd
import  numpy as np
import matplotlib.pyplot as plt

dates = pd.date_range('20130101', periods=6)
df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=list('ABCD'))

#描述
print(df.head())
print(df.tail(3))
print(df.index,df.columns,df.values)
print(df.describe())
print(df.T)
print(df.sort_values(by="A"))

#选取
print(df.A)
print(df[0:3])
print(df.loc[:,["A","B"]])
print(df.iloc[3:5,0:2])
print( df.iloc[[1,2,4],[0,2]])
print(df.iat[1,1])

#条件筛选
print( df[df.A > 0])

#更改
df2 = df.copy()
df2['E'] = list("123456")
print(df2)
df.at[dates[0],"E"] = 0
df.iat[0,1] = 0
df.loc[:,'D'] = np.array([5] * len(df))
print(df)
print(df.mean())
print(df.mean(1))
s = pd.Series(np.random.randint(0, 7, size=10))
print(s)
print(s.value_counts())

#拼接合并分组
df = pd.DataFrame(np.random.randn(10, 4))
print(df)
pieces = [df[:3], df[3:7], df[7:]]
print(pieces[0])
print(pieces[1])
print(pd.concat(pieces))
left = pd.DataFrame({'key': ['foo', 'foo'], 'lval': [1, 2]})
right = pd.DataFrame({'key': ['foo', 'foo'], 'rval': [4, 5]})
print(left,right)
dd=pd.merge(left, right, on='key')
print(dd)
print(dd.groupby('key').sum())

#读写
df.to_csv('foo.csv')
print(pd.read_csv('foo.csv'))
```

#### MongoDB

NoSQL 是对不同于传统的关系数据库的数据库管理系统的统称。两者存在许多显著的不同点，其中最重要的是 NoSQL 不使用 SQL 作为查询语言。其数据存储可以不需要固定的表格模式，也经常会避免使用 SQL的 JOIN 操作，一般有水平可扩展性的特征。
NoSQL 的结构通常提供弱一致性的保证，如最终一致性，或交易仅限于单个的数据项。
• 图形关系存储：Neo4J、ArangoDB
• 键-值存储：Redis、MemcacheD、BerkeleyDB
• 列存储: HBase、Cassandra
• 文档存储: MongoDB、CouchDB

##### 参数

```
--dbpath arg   directory for datafiles - defaults to /data/db
--port arg     specify port number - 27017 by default
--replSet arg  arg is <setname>
--configsvr    declare this is a config db of a cluster;
               default port 27019; default dir /data/configdb
--journal      enable journaling
--nojournal    disable journaling (journaling is on by default for 64 bit)
--logpath arg  log file to send write to instead of stdout - has to be a file, not                  directory
```

##### 运行

```
命令行下运行 MongoDB 服务器
从 MongoDB 目录的 bin 目录中执行 mongod.exe 文件。
C:\mongodb\bin\mongod --dbpath c:\data\db

连接MongoDB
在命令窗口中运行 mongo.exe 命令即可连接上 MongoDB，执行如下命令：
C:\mongodb\bin\mongo.exe
```

##### MongoDB 数据结构

JSON
JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c 制定的 js 规范) 的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。

```shell
导入json文件
mongoimport --db db_demo --collection users --file 文件路径
```

BSON
BSON( Binary Serialized Document Format) 是一种二进制形式的存储格式，采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的特点，可以有效描述非结构化数据和结构化数据。

##### CRUD 操作

```python
CRUD (1): Create
#choose db
>use test
#insert json object into collection
>db.students.insert({"id": 123, "name": "zhangsan", "age": 19})
WriteResult({ "nInserted" : 1 })

CRUD (2): Retrieve
#choose db
>use test
> db.students.find({"id": 123})
{ "_id" : ObjectId("..."), "id" : 123, "name" : "zhangsan", "age" : 19 }

CRUD (3): Update
> db.students.update({"id":123}, {"$inc": {"age":1}})
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
> db.students.find()
{ "_id" : ObjectId("..."), "id" : 123, "name" : "zhangsan", "age" : 20 }

CRUD (4): Delete
> db.students.deleteMany({"id":123})
{ "acknowledged" : true, "deletedCount" : 1 }
```

##### pymongo 安装

```
• via pip
$pip install pymongo
• via distro (e.g., apt)
$sudo apt-get install python-pymongo
```

##### pymongo API 使用

```python
import pymongo
from pymongo import MongoClient
client = MongoClient()
# Get the sampleDB database
db = client.sampleDB
# equivalently, use db = client[’sampleDB’]
coll = db.sampleCollection
# equivalently, use coll = db[’sampleCollection’]

#CRUD: Create
coll.insert_one({"id": 123, "name": "zhangsan", "age": 18})
coll.insert_one({"id": 124, "name": "lisi", "age": 17})

#CRUD: Retrieve
for entry in coll.find():
	print("id: %d, name: %s, age: %d" %
		(entry[’id’], entry[’name’], entry[’age’])
		
#CRUD: Update
col.update({"age": {"$lt": 20}}, {"$inc": {"age": 1}})
#{u’n’: 1, u’nModified’: 1, u’ok’: 1, ’updatedExisting’: True}
col.update({"age": {"$lt": 20}}, {"$inc": {"age": 1}}, multi=True)
#{u’n’: 2, u’nModified’: 2, u’ok’: 1, ’updatedExisting’: True}

#CRUD: Delete
col.remove({"age": {"$gt": 10}})
#{u’n’: 2, u’ok’: 1}
coll.insert_one({"id": 123, "name": "zhangsan", "age": 18})
coll.insert_one({"id": 124, "name": "lisi", "age": 17})
col.remove({"age": {"$gt": 10}}, multi=False)
#{u’n’: 1, u’ok’: 1}
```

