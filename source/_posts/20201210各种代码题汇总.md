---
layout: post
title: "刷题问题汇总"
date: 2020-12-10 10:36
toc: true
comments: true
categories: 技术学习
tags: 
	- Code
---

#### 代码模板

##### 快排

```c
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];//中间数最好
    while (i < j)
    {
        //while (q[++i] < x);
		//while (q[--j] > x);
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

<!--more-->

##### 归并

```c
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
    //多出来的合并
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

##### 二分

整数二分算法模板 —— 模板题 AcWing 789. 数的范围

![image-20210325214301736](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161114.png)

```c
bool check(int x) {/* ... */} // 检查x是否满足某种性质
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：//有减要加1
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
```

浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根

```c
bool check(double x) {/* ... */} // 检查x是否满足某种性质
double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

##### 高精度

```java
Java语法糖，秒杀高精度
import java.io.*;
import java.math.BigInteger;
class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));
        String[] s = cin.readLine().split(" ");
        BigInteger n = new BigInteger(s[0]);
        s = cin.readLine().split(" ");
        BigInteger m = new BigInteger(s[0]);
        System.out.println(m.add(n));
        System.out.println(n.subtract(m));
        System.out.println(n.multiply(m));
        System.out.println(n.divide(m));
        System.out.println(n.remainder(m));//取余
    }
}
高精度加法 —— 模板题 AcWing 791. 高精度加法
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if (t) C.push_back(t);
    return C;
}
高精度减法 —— 模板题 AcWing 792. 高精度减法
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
	//去除前面的0
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法
// C = A * b, A >= 0, b > 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
高精度除以低精度 —— 模板题 AcWing 794. 高精度除法
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

##### 前缀和

一维前缀和 —— 模板题 AcWing 795. 前缀和

输入一个长度为 n 的整数序列。输出原序列中从第 l 个数到第 r 个数的和

```c
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

二维前缀和 —— 模板题 AcWing 796. 子矩阵的和

![image-20210104161136636](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161111.png)

```
第i行j列格子左上部分所有元素的和
S[i, j] = S[i-1,j]+S[i,j-1]-S[i-1,j-1]+a[i,j]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

##### 差分

一维差分 —— 模板题 AcWing 797. 差分

```c
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```

二维差分 —— 模板题 AcWing 798. 差分矩阵

```c
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
B[x1, y1] += c, B[x2 + 1, y1] -= c, B[x1, y2 + 1] -= c, B[x2 + 1, y2 + 1] += c
```

##### 位运算

```c
求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n&-n=n&(~n+1)  x=1010 lowbit(x)=10
整数的二进制表示中的最右边一个1变成0：n = (n - 1) & n;
```

##### 双指针

```c
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
(1) 对于一个序列，用两个指针维护一段区间
(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

##### 离散化

```c
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

##### 区间合并

```c
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

##### 回溯

回溯算法其实就是不断尝试的过程，一旦尝试成功了，就算成功了，如果尝试失败了还会回到上一步，注意回到上一步的时候还要把状态还原到上一步的状态。回溯算法这里就不在过多介绍，关于回溯算法的解题思路可以看下450，什么叫回溯算法，一看就会，一写就废。

回溯算法其实有一个经典的模板

```
private void backtrack("原始参数") {
    //终止条件(递归必须要有终止条件)
    if ("终止条件") {
        //一些逻辑操作（可有可无，视情况而定）
        return;
    }

    for (int i = "for循环开始的参数"; i < "for循环结束的参数"; i++) {
        //一些逻辑操作（可有可无，视情况而定）

        //做出选择

        //递归
        backtrack("新的参数");
        //一些逻辑操作（可有可无，视情况而定）

        //撤销选择
    }
}
```

#### 背包问题

![image-20210325214000189](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161113.png)

##### 01背包

![image-20210104145246880](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161112.png)

```java
public class Main{
    public static void main(String[] args) throws Exception {
        // 读入数据的代码
        Scanner reader = new Scanner(System.in);
        // 物品的数量为N
        int N = reader.nextInt();
        // 背包的容量为V
        int V = reader.nextInt();
        // 一个长度为N的数组，第i个元素表示第i个物品的体积；
        int[] v = new int[N + 1] ;
        // 一个长度为N的数组，第i个元素表示第i个物品的价值；
        int[] w = new int[N + 1] ;

        for (int i=1 ; i <= N ; i++){
            // 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值
            v[i] = reader.nextInt();
            w[i] = reader.nextInt();
        }
        reader.close() ;

        // 正式工作的代码
        /*
        定义一个二阶矩阵dp[N+1][V+1],
        这里之所以要N+1和V+1，是因为第0行表示只能选择第0个物品的时候，即没有物品的时候
        第0列表示背包的体积为0的时候，即不能装任何东西的时候

        dp[i][j]表示在 只能选择前i个物品，背包容量为j的情况下，背包中物品的最大价值
        对于dp[i][j]有两种情况：
        1. 不选择当前的第i件物品/第i件物品比背包容量要大，则dp[i][j] = dp[i-1][j]
        2. 选择当前的第i件物品（潜在要求第i件物品体积小于等于背包总容量），则能装入的物品最大价值为：
            当前物品的价值 加上 背包剩余容量在只能选前i-1件物品的情况下的最大价值
            dp[i][j] = dp[i-1][j-v[i]] + w[i]
        dp[i][j]在两种情况中选择比较大的情况作为当前的最优解；
        即：
        if(j >= v[i]):
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])
        else:
            dp[i][j] = dp[i-1][j]
        */
        int[][] dp = new int[N+1][V+1];
        dp[0][0] = 0;
        for(int i = 1; i <= N; i++){
            for(int j = 0; j <= V; j++){
                if(j >= v[i]){
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        System.out.println(dp[N][V]);
    }
}

//有优化版
/*
1. f[i] 仅用到了f[i-1]层, 
2. j与j-v[i] 均小于j
3.若用到上一层的状态时,从大到小枚举, 反之从小到大哦

注意，这里第二层循环的时候，还是小到大循环的话，那么
 dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])
实际上变成了
dp[i][j] = Math.max(dp[i][j], dp[i][j-v[i]] + w[i]);
因为i-1的值已经在前面被更新过了，覆盖了
为了避免这个问题，所以要逆序更新，即先更新第i个，然后更新第i-1个，从而保证第i-1个不被覆盖
*/
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int [N+2];
    int[] w=new int [N+2];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
    }
    int[] f=new int[V+1];//多开
    for(int i=1;i<=N;i++){
        for(int j=V;j>=v[i];j--){
            f[j]=Math.max(f[j],f[j-v[i]]+w[i]);
        }
    }
    System.out.println(f[V]);
}
```

##### 完全背包

![image-20210325211930272](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161115.png)

```java
//会爆
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int[N+1];
    int[] w=new int[N+1];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
    }
    int dp[][]=new int [N+1][V+1];
    for(int i=1;i<=N;i++){
        for(int j=1;j<=V;j++){//体积
            for(int k=0;k*v[i]<=j;k++){//枚举k ,找最大
                dp[i][j]=Math.max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);
            }
        }
    }
    System.out.println(dp[N][V]);
}
```

**优化**

![image-20210325215256820](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161116.png)

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int[N+1];
    int[] w=new int[N+1];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
    }
    int dp[][]=new int [N+1][V+1];
    for(int i=1;i<=N;i++){
        for(int j=1;j<=V;j++){
            dp[i][j]=dp[i-1][j];
            if(j>=v[i])dp[i][j]=Math.max(dp[i-1][j],dp[i][j-v[i]]+w[i]);
        }
    }
    System.out.println(dp[N][V]);
}
```

**在优化为一维**

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int[N+1];
    int[] w=new int[N+1];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
    }
    int dp[]=new int [V+1];
    for(int i=1;i<=N;i++){
        for(int j=v[i];j<=V;j++){
            dp[j]=Math.max(dp[j],dp[j-v[i]]+w[i]);
        }
    }
    System.out.println(dp[V]);
}
```

##### 多重背包

![image-20210325230403204](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161117.png)

```java
//f[i][j]=Math.max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); k=0,1,2,3,...s[i]
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int[N+1];
    int[] w=new int[N+1];
    int[] s=new int[N+1];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
        s[i]=sc.nextInt();

    }
    int [][]f=new int [N+1][V+1];
    for(int i=1;i<=N;i++){
        for(int j=0;j<=V;j++){
            for(int k=0;k<=s[i]&&k*v[i]<=j;k++){//枚举k,不超过s[i]
                f[i][j]=Math.max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
            }
        }
    }
    System.out.println(f[N][V]);
}
```

##### 分组背包

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int [] s=new int [N+1];
    int[][] v=new int[N+1][101];
    int[][] w=new int[N+1][1013];
    for(int i=1;i<=N;i++){
        s[i]=sc.nextInt();
        for(int j=1;j<=s[i];j++){
            v[i][j]=sc.nextInt();
            w[i][j]=sc.nextInt();
        }
    }
    int dp[][]=new int [N+1][V+1];
    for(int i=1;i<=N;i++){
        for(int j=1;j<=V;j++){//体积
            for(int k=0;k<=s[i];k++)
                if(j>=v[i][k])dp[i][j]=Math.max(dp[i][j],dp[i-1][j-v[i][k]]+w[i][k]);
        }
    }
    System.out.println(dp[N][V]);
}
```

#### 经典题目

##### 大顶推求最小的K个元素

```java
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;
public class Solution {
   public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
       ArrayList<Integer> result = new ArrayList<Integer>();
       int length = input.length;
       if(k > length || k == 0){
           return result;
       }
       //大顶推
        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(k, new Comparator<Integer>() {
            @Override
            //降序
            public int compare(Integer o1, Integer o2) {
                return o2.compareTo(o1);
            }
        });
        for (int i = 0; i < length; i++) {
            if (maxHeap.size() != k) {
                maxHeap.offer(input[i]);
            } else if (maxHeap.peek() > input[i]) {
                Integer temp = maxHeap.poll();
                temp = null;
                maxHeap.offer(input[i]);
            }
        }
        for (Integer integer : maxHeap) {
            result.add(integer);
        }
        return result;
    }
}
```

##### 最长连续不重复子序列

给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。 **双指针算法**

```java
public static void main(String[] a){
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int[] A=new int[n];
    int[] num=new int[100001];//记录i，j之前出现的数的次数，超过2表示有重复
    for(int i=0;i<n;i++){
        A[i]=sc.nextInt();
    }
    int ans=0;
    for(int i=0,j=0;j<n;j++){
        num[A[j]]++;
        //有重复 i向右移
        while(i<j&&num[A[j]]>1) {
            num[A[i]]--;
            i++;
        }
        ans=Math.max(ans,j-i+1);
    }
    System.out.println(ans);
}
```

##### 树的最大路径和

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

![8021.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161120.png)

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int[][] f=new int [n+1][n+1];
    for(int i=0;i<n;i++){
        for(int j=0;j<=i;j++){
            f[i][j]=sc.nextInt();   
        }
    }
    //f[i][j]表示从下到上的最大值
    for(int i=n-1;i>=0;i--){
        for(int j=0;j<=i;j++){
            f[i][j]+=Math.max(f[i+1][j],f[i+1][j+1]);
        }
    }
    System.out.println(f[0][0]);
}
```

##### 货仓选址求最小

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

**中位数就是答案**

![image-20210314132800964](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161118.png)

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int[] A=new int [n];
    for(int i=0;i<n;i++){
        A[i]=sc.nextInt();
    }
    Arrays.sort(A);
    int ans=0;
    for(int i=0;i<n;i++){
        ans+=Math.abs(A[i]-A[n/2]);
    }
    System.out.println(ans);
}
```

##### 区间和

假定有一个无限长的数轴，数轴上每个坐标上的数都是0。

现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。

接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。

![image-20210314142819114](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161119.png)

```java
import java.util.*;
class Pair{
    int first;
    int second;
    Pair(int first,int second){
        this.first=first;
        this.second=second;
    }
}
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        int N = 300010; //因为需要将所有x，l，r存在数组中，这样就是n + 2m <= 300000
        int[] a = new int[N]; //从1开始，需要通过x找到离散量，然后+1，
        int[] s = new int[N]; //前缀和来做，所以需要从1开始记录a

        List<Integer> alls = new ArrayList<>(); //将所有的使用到的数存在alls中，比如x，l，r
        //但其中会有先后顺序的差别，以及重复，所以需要排序和去重
        List<Pair> add = new ArrayList<>(); //用来存n次操作
        List<Pair> query = new ArrayList<>(); //用来存m次询问
        
        for (int i = 0; i < n; i++) {
            int x = sc.nextInt();
            int c = sc.nextInt();
            add.add(new Pair(x, c));
            alls.add(x); //存入alls中，为后续操作做准备
        }

        for (int i = 0; i < m; i++) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            query.add(new Pair(l, r));
            alls.add(l);
            alls.add(r);
        }
        
         //到此为止，alls中存好了所有会被用到的数轴上的点，可以进行离散化操作
        // 1. 排序 2. 去重
        Collections.sort(alls);
        int unique = unique(alls);
        alls = alls.subList(0, unique); //将去重后的List保存下来，或者此处也可以将unique作为最后一个数，用r作为二分


        for (Pair item:add) {
            int index = find(item.first, alls);
            a[index] += item.second;
        }

        //求前缀和
        for (int i = 1; i <= alls.size(); i++) s[i] = s[i - 1] + a[i];
        
        
        for (Pair item:query) {
            int l = find(item.first, alls);
            int r = find(item.second, alls);
            System.out.println(s[r] - s[l - 1]);
        }

    }
    
    
    //排序list去重
    static int unique(List<Integer> list) {
        int j = 0;
        for (int i = 0; i < list.size(); i++) {
            if (i == 0 || list.get(i) != list.get(i - 1)) {
                list.set(j, list.get(i));
                j++;
            }  
        }
        return j;
    } 

    
    //找到x所在的位置
    static int find(int x, List<Integer> list) {
        int l = 0;
        int r = list.size() - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (list.get(mid) >= x) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l + 1; //因为要考虑到前缀和
    }

}
```

##### 区间合并

给定 n 个区间，要求合并所有有交集的区间。

```java
import java.util.*;
class Pair {
    int first;
    int second;
    Pair(int first,int second) {
        this.first = first;
        this.second = second;
    }
    @Override
    public String toString() {
        return "Pair{" +
                "first=" + first +
                ", second=" + second +
                '}';
    }
}
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        List<Pair> list=new ArrayList<Pair>();
        for(int i=0;i<n;i++){
            list.add(new Pair(sc.nextInt(),sc.nextInt()));
        }
        Collections.sort(list, new Comparator<Pair>() {
            @Override
            public int compare(Pair o1, Pair o2) {
                return o1.first-o2.first;
            }
        });
        //System.out.println(list.toString());
        List<Pair> ans=new ArrayList<Pair>();
        int st=list.get(0).first,ed=list.get(0).second;
        for(Pair p:list){
            if(ed<p.first){
                ans.add(new Pair(st,ed));
                st=p.first;
                ed=p.second;
            }else{
                ed=Math.max(ed,p.second);
            }
        }
        ans.add(new Pair(st,ed));
        System.out.println(ans.size());
    }
}
```

##### 两个栈实现队列

```java
/**
stack1主要存放数据，stack2是为了实现各方法而起到了临时中转站的作用（具体的实现往下看），设置不对等地位一方面也是为了编写易理解的代码。
push(int x)方法的实现
    队列元素入队，就是为了存放数据，我在这里直接使元素x入栈stack1。
pop()
    队列的pop是取队头元素，即最先push进来的元素，但该元素存储在栈stack1的栈底，因此若想取出栈底元素，就要想办法把它变为栈顶元素。OK，这个时候stack2就该上场了。把stack1的栈顶元素入栈进入到stack2，即语句stack2.push(stack1.pop());重复此操作直至全部元素进入到stack2。现在让stack2栈顶元素出栈即为队列的队头元素出队。完成出队操作后，还要把stack2剩下的元素放回stack1内，因为stack1是存放数据的，而且下文empty()方法也是依据stack1完成的。
*/
class MyQueue {
    Deque<Integer> stack1 =new LinkedList<Integer>();
    Deque<Integer> stack2 =new LinkedList<Integer>();
    public void push(int x) {
        stack1.push(x);
    }
    public int pop() {
        while (!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        int ans=stack2.pop();
        while (!stack2.isEmpty()){
            stack1.push(stack2.pop());
        }
        return ans;
    }
    public int peek() {
        while (!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        int ans=stack2.peek();
        while (!stack2.isEmpty()){
            stack1.push(stack2.pop());
        }
        return ans;
    }
    public boolean empty() {
        return stack1.isEmpty();
    }
}
```

##### 翻转链表

```java
public ListNode reverseList(ListNode head) {
    if(head==null||head.next==null){
        return head;
    }
    ListNode cur=head,pre=null;
    while(cur!=null){
        ListNode next=cur.next;
        cur.next=pre;
        pre=cur;
        cur=next;
    }
    return pre;
}
//递归
public ListNode reverseList(ListNode head) {
    if(head==null||head.next==null){
        return head;
    }
    ListNode p=reverseList(head.next);
    ListNode tmp=head.next;
    tmp.next=head;
    head.next=null;
    return p;
}
```

##### 最长上升子序列

![image-20210411111508252](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210411111534.png)

```java
public static void main(String[] args){
    int N=1001;
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int a[]=new int [N];
    for(int i=1;i<=n;i++){
        a[i]=sc.nextInt();
    }
    int f[]=new int[N];
    for(int i=1;i<=n;i++){
        f[i]=1;
        for(int j=0;j<i;j++){
            if(a[i]>a[j]){
                f[i]=Math.max(f[j]+1,f[i]);
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        ans=Math.max(ans,f[i]);
    }
    System.out.println(ans);
}
```

##### 最长公共子序列

![image-20210411160037389](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210411160039.png)

```java
public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    int n = scan.nextInt();
    int m = scan.nextInt();
    //i=0情况
    String A = " " + scan.next();
    String B = " " + scan.next();
    int[][] f = new int[n + 1][m + 1];
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= m;j++)
        {
            f[i][j] = Math.max(f[i-1][j], f[i][j - 1]);
            //包含A[i] = B[j]情况的集合
            if(A.charAt(i) == B.charAt(j)) 
                f[i][j] = Math.max(f[i][j],f[i - 1][j - 1] + 1);
        }
    }
    System.out.println(f[n][m]);
}
```

##### 石头合并-区间dp

合并 N 堆石子，每次只能合并相邻的两堆石子，求最小代价

![image-20210412103922273](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210412103924.png)

```
import java.util.*;
class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int []a =new int [n+1];
        for(int i=1;i<=n;i++){
            a[i]=sc.nextInt();
        }
        int []s=new int [n+1];
        for(int i=1;i<=n;i++){
            s[i]+=s[i-1]+a[i];
        }
        int f[][]=new int[n+1][n+1];
        for(int len=2;len<=n;len++){
            for(int i=1;i+len-1<=n;i++){
                int l=i,r=l+len-1;
                f[l][r]=Integer.MAX_VALUE;
                for(int j=l;j<r;j++){
                    f[l][r]=Math.min(f[l][r],f[l][j]+f[j+1][r]+s[r]-s[l-1]);
                }
            }
        }
        System.out.println(f[1][n]);
    }
}
```

