---
layout: post
title: "区块链原理"
date: 2020-10-03 10:36
toc: true
comments: true
categories: 生活随笔
tags: 
	- 金融
---

#### 比特币原理

2008年，网络极客中本聪提出了比特币的概念，这是一种全新的电子货币。比特币是一种去中心化的记账系统，人们通过挖矿获得比特币，通过公开记账的方式完成支付。

<!--more-->

##### 相关术语

```
比特币地址：（例如：1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV）由一串字符和数字组成，以阿拉伯数字“1”开头。就像别人向你的email地址发送电子邮件一样，他可以通过你的比特币地址向你发送比特币。

比特币：既可以指这种虚拟货币单位，也指比特币网络或者网络节点使用的比特币软件。

区块：一个区块就是若干交易数据的集合，它会被标记上时间戳和之前一个区块的独特标记。区块头经过哈希运算后会生成一份工作量证明，从而验证区块中的交易。有效的区块经过全网络的共识后会被追加到主区块链中。

区块链：是一串通过验证的区块，当中的每一个区块都与上一个相连，一直连到创世区块。

交易确认：当一项交易被区块收录时，我们可以说它有一次确认。矿工们在此区块之后每再产生一个区块，此项交易的确认数就再加一。当确认数达到六及以上时，通常认为这笔交易比较安全并难以逆转。

难度：整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力。

难度目标：使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标。

难度调整：整个网络每产生2,106个区块后会根据之前2,106个区块的算力进行难度调整。

矿工费：交易的发起者通常会向网络缴纳一笔矿工费，用以处理这笔交易。大多数的交易需要0.5毫比特币的矿工费。

矿工：指通过不断重复哈希运算来产生工作量证明的各网络节点。

比特币网络：是一个由若干节点组成的用以广播交易信息和数据区块的P2P网络。

交易：简单地说，交易指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”指一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。

钱包：指保存比特币地址和私钥的软件，可以用它来接受、发送、储存你的比特币。

比特币组成：
    一个去中心化的点对点网络（比特币协议）
    一个公共的交易账簿（区块链）
    一个去中心化的数学的和确定性的货币发行（分布式挖矿）
    一个去中心化的交易验证系统（交易脚本）
```

##### 李永乐简单讲解 

![1572410085065](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213224.png)

 区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。 

```
 每个区块包含两个部分 
    区块头（Head）：记录当前区块的特征值
    区块体（Body）：实际数据
```

区块头包含很多内容，其中有当前区块体的哈希，还有上一个区块的哈希。

这意味着，如果当前区块体的内容变了，或者上一个区块的哈希变了，一定会引起当前区块的哈希改变。  正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。  

区块头里面所有的特征值都是固定的，为了让区块头产生变化，中本聪故意增加了一个随机项，叫做 Nonce。 

```
生成时间
实际数据（即区块体）的哈希
上一个区块的哈希
随机数 Nonce
...
```

![1572410872011](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213225.png)

#### 北大肖臻《区块链技术与应用》

内容部分节选自[sam_nau](https://space.bilibili.com/34990713)的笔记和[Sinocifengs](https://blog.csdn.net/Mu_Xiaoye)博客

![image-20200311171057282](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213226.png)

![image-20200311171118951](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213227.png)

##### BTC密码学原理篇

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213228.jpeg)

比特币属于加密货币，可见其中必然会涉及到密码学的知识。而比特币本身开放，其交易记录、交易金额、交易内容甚至源代码都面向全网开放，加密又使用在哪里呢？

在比特币中，正是加密确保了信息的不可篡改，保证了区块链本身的优势——不可篡改。加密主要涉及两个内容：hash和签名

**hash（哈希）**

【目前并不存在一个hash函数可以从数学上证明具有collision resistance的性质】

![image-20200312131300824](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213229.png)

![image-20200312131336498](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213230.png)

**签名：比特币中账户管理**

在比特币系统中，申请账户是用户自己来处理的，即自己创建一个公钥-私钥对。【注意：比特币系统中，很难通过生成大量公私钥对来获取他人私钥】

![image-20200311174937768](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213231.png)

##### BTC数据结构

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213232.jpeg)

**Hash pointer（哈希指针）**

【一般的链表我们都可以改造为使用哈希指针的链表，但当链表中存在环时，哈希指针便不能再使用】

每个区块根据自己的区块内容生成自己哈希值，此外，每个区块（除创世纪块）都保存有前一个区块哈希值。本区块哈希生成依赖于本区块内容，而本区块内容中又包含有前一个区块的哈希值。从而保证了区块内容不被篡改。

而用户只需要记住最后一个区块链的哈希地址，就可以检测区块链上内容是否被篡改。

![image-20200312124635119](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213233.png)

![image-20200312125105259](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213234.png)

![image-20200312125225972](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213235.png)

**Markle Tree(默克尔树)**

![image-20200312125631031](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213236.png)

比特币中节点分为**轻节点**和**全节点**。全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。因为硬件的局限。一个区块大小为1MB，如果存储区块所有内容，则所需空间过大，不现实。

![image-20200312145940197](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213237.png)

当需要向轻节点证明某条交易是否被写入区块链，便需要用到Markle proof。我们将交易到根节点这一条路径称为Markle proof，全节点将整个Markle proof发送给轻节点（如下图所示），轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改过。

![image-20200312132552787](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213238.png)

##### BTC共识协议

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213239.jpeg)

**数字货币发行问题**

![image-20200312133329901](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213240.png)

**验证交易有效性**

在进行交易时，需要付款人签名和收款人地址（收款人的公钥的哈希）。在交易中，收款方需要知道付款方的公钥，从而验证A签名是否有效。

在比特币系统中，通过执行脚本实现上述验证过程。将当前交易输入脚本与前一个交易输出脚本（说明币的来源的交易）拼接执行，如果可以正确执行，说明交易合法。

![image-20200312133409401](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213241.png)

可否各个节点独立完成区块链构建？
很明显不行，各个节点独立打包交易，形成区块链，必然无法避免区块链内容不一致。从分布式系统角度来说，**账本内容需要取得分布式共识**，从而保证区块链内容在不同节点上的一致性。

在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种nonce值，这就是挖矿。[H(block header)<=target]
当某个节点找到符合要求的nonce，便获得了记账权，从而可以将区块发布到系统中。其他节点收到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。

![image-20200312134253009](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213242.png)

![image-20200312134532906](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213243.png)

##### BTC具体实现

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213244.jpeg)

**UTXO**

区块链是一个去中心化的账本，比特币采用了 **基于交易的账本模式** 。然而，系统中并无显示记录账户包含比特币数，实际上其需要通过交易记录进行推算。在比特币系统中，全节点需要维护一个名为 **UTXO(Unspent Transaction Output尚未被花掉的交易输出)** 的数据结构。

UTXO便于快速检测double spending（双花攻击），如果想要花掉的BTC不在UTXO中，那么说明这个BTC要么根本不存在，要么已经被花过。

UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出。

![image-20200312135958995](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213245.png)

![image-20200312140619197](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213246.png)

**比特币区块信息**

Version(版本协议)，Hash of previous block header（指向前一个区块指针），Merkle root hash（默克尔树根哈希值），time（区块产生时间，可调），target（nBits挖矿难度目标阈值,只能按协议定期修改），nonce（随机数）

每个发布区块者可以得到出快奖励，也就是可以在区块中发布一个 **铸币交易(coinbase交易)** ,这也是BTC系统中产生新比特币的唯一方式。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213247.png)

有一个CoinBase域，其中可以写入任何内容，在这里写什么都没有影响。所以可以在这里添加一些任意信息，便可以实现无法篡改（也无法删除）。只要我们改变了写入内容，便可以改变Merkle Tree 的根哈希值

所以，在实际的挖矿中，包含两层循环。外层循环调整coinbase域（可以规定只将其中前x个字节作为另一个nonce），算出block header中根哈希值后，内层循环再调整nonce。

这样就解决了，挖矿人员越来越多，挖矿难度已经调整的比较大了，而nonce的2^32这一搜索空间太小的问题。

**挖矿过程**

```
挖矿求解问题：Hash（block header）<=target
Hash of previous block header只计算区块块头部分的哈希（ Merkle root hash保证了block body内容不被篡改，所以只需要计算block header即可保证整个区块内容不会被篡改）
区块链系统中，轻节点（只存储区块block header信息）只利用区块链，但并不参与区块链系统维护和构造
挖矿之初便要选择上一个区块是谁。也就是说，并不是获得记账权之后才选择插入到哪一个区块之后。
```

![image-20200312140750785](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213248.png)

![image-20200312140812217](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213249.png)比特币系统中，假如发生以下情况，各个节点以自己先收到的区块所在链为主链，对后收到的合法区块会不予认可（但会先保存起来）。此时便变成了两批算力分布挖1和2，具体哪一个成为主链，取决于哪一条链先挖到下一个区块，使得两个等长合法链出现长短不一致，最终胜者成为最长合法链。
![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213250.png)

##### BTC网络

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213251.jpeg)

```
新发布的交易和区块在比特币网络上是如何传播的呢？
比特币工作于网络应用层，其底层（网络层）是一个P2P Overlay network（P2P覆盖网络）。
比特币系统中所有节点完全平等，不像一些其他网络存在超级节点(super node)。
要加入网络，至少需要知道一个种子节点，通过种子节点告知自己它所知道的节点。
节点之间的通信采用了TCP协议，便于穿透防火墙。
当节点离开时，只需要自行退出即可，其他节点在一定时间后仍然没有收到该节点消息，便会将其删掉。
比特币网络设计原则：简单、鲁棒（最坏情况下能达到最优状况，即健壮性）而非高效。
每个节点维护一个邻居节点集合，消息传播在网络中采用洪泛法，某个节点在收到一条消息会将其发送给所有邻居节点并标记，下次再收到便不会再发送该消息
比特币系统中，每个节点要维护一个等待上链的交易集合。
第一次听到交易，若是合法交易，则将其加入该交易集合并转发给邻居节点，以后再收到该交易就不再转发
假如网络中存在两个冲突交易，如A->B,A->C。先到先接受，之后收到另一个交易会将其放弃。
假如某个节点先听到A->B，但又听到A->C已经上链，则此时A->B为非法交易，在等待上链交易集合中删除A->B
新发布区块在网络中传播方式与新发布交易传播方式类似，每个节点除检查该区块内容是否合法，还要检查是否位于最长合法链上。
比特币网络传播属于 Best effort（尽力而为） ，不能保证一定传输成功
```

![image-20200312144135875](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213252.png)

##### BTC挖矿难度

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213253.jpeg)

```
在BTC协议中规定，每隔2016个区块需要调整一次难度，根据10min产生一个新区块可以得到，大概需要14天的时间
上调和下调都是有4倍限制，实际最近2016个区块出块时间超过8个星期(正常2个星期)，计算也只按照8个星期计算
```

![image-20200312144859545](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213254.png)

![image-20200312145056919](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213255.png)

##### BTC挖矿

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213256.jpeg)

**全节点和轻节点**

![image-20200312145940197](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213237.png)

![image-20200312150347874](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213257.png)

![image-20200312150410470](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213258.png)

```
矿池
    优点：解决了矿工收入不稳定的问题，减轻了矿工的负担。
    缺点：威胁到了区块链系统的安全，使得51%攻击变得容易起来。
思考一：有没有可能，某个矿工平时正常提交share，但真正挖到区块后不提交给矿主而是自己偷偷发布出去，从而避免他人分走挖矿所得到的出块奖励？
事实上，这种情况是不可能的。因为每个矿工挖矿任务是矿主分配的。矿主组装区块，交给矿工计算，而区块中铸币交易的收款人地址是矿主，如果矿工修改该地址，计算的nonce值也会作废。

思考二：如果矿工自己刚开始就自己偷偷组装一个区块，自己挖矿，这样就类似于其脱离了该矿池。因为其自己所组织的区块不会被矿主所认可，其提交的share也不会被认可，也就得不到分配的收益。

思考三：有没有可能矿工捣乱？平时提交share，等挖到后扔掉区块，不提交？
这种可能是有的，如果矿工本身仅仅想捣乱，是可以这么做的。但扔掉区块后，对其本身来说，也没有相应的奖励获得，看似是损人不利己的情况。
```

##### BTC脚本

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213259.jpeg)

```
比特币系统中使用的脚本语言非常简单，唯一可以访问的内存空间只有栈，所以也被称为“基于栈的语言”
```

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213300.png)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213301.png)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213302.png)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213303.png)

**输入输出脚本的执行**

在早期，直接将两个脚本按照如图顺序(input script在前，output script在后) 拼接后执行

后来考虑到安全性问题，两个脚本改为分别执行：先执行input script，若无出错，再执行output script。
若脚本顺利执行，最终栈顶结果为true，则验证通过，交易合法；如果执行过程中出现任何错误，交易非法。
若一个交易有多个输入脚本，则每个输入脚本都要和对应输出脚本匹配执行，全部验证通过才能说明该交易合法。

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213304.png)
**输入输出脚本的几种形式**

```
P2PK形式(Pay to public key)
	特点：输出脚本直接给出收款人公钥。(CHECKSIG为检查签名操作)
P2PKH形式(Pay to public key hash)——最常用
	特点：输出脚本不直接给出收款人公钥，而是公钥的哈希。
P2SH形式(Pay to script hash)
	特点：输出脚本给出的不是收款人公钥的哈希，而是收款人提供的一个脚本的哈希。该脚本称为redeemScript,即赎回脚本。等未来花钱的时候，输入脚本要给出redeemScript的具体内容以及可以使之正确运行需要的签名。
```

P2PKH形式(Pay to public key hash)

```
图中第5步，两个公钥哈希是不同的。上面一个是输出脚本提供的收款人的哈希，下面一个是要花钱时候输入脚本要给出的公钥通过HASH160操作得到的。
图中第6步，该操作的目的是为了防止冒名顶替(公钥)。假设比较正确，则两个元素消失（不往栈中压入TRUE或FALSE）
```

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213305.png)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213306.png)

P2SH形式(Pay to script hash)

```
第一阶段执行拼接后的输入和输出脚本。
第二阶段执行反序列化后的赎回脚本
在BTC系统中，一个输出可能需要多个签名才能取出钱来。例如，对于公司账户，可能会要求5个合伙人中任意3个的签名才能取走钱，这样便为私钥泄露和丢失提供了一定程度的保护。
P2SH形式本质上是将复杂度从输出脚本转移到输入脚本，可见此时输出脚本只有三行，原本复杂度被转入到赎回脚本redeemScript中。
输出脚本只需要给出赎回脚本的哈希值即可。该赎回脚本在输入脚本提供，即收款人提供。
类似之前提到的电商，收款人只需要公布赎回脚本哈希值即可，用户只要在输出脚本中包含该哈希值，用户无需知道收款人的相关规则(对用户更加友好)。
现在的多重签名，大多都采用P2SH的形式
```

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213307.png)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213308.png)

Proof of Burn脚本：该方法是销毁比特币的一种方法。

![image-20200312151139767](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213309.png)

##### BTC分叉

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213310.jpeg)

```
soft fork
	特点：只要系统中拥有半数以上算力节点更新软件，系统就不会产生永久性分叉
hard fork
	特点：必须系统中所有节点更新软件，系统才不会产生永久性分叉
```

![image-20200312153437145](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213311.png)



![image-20200312153506761](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213312.png)

##### BTC问答

![image-20200312154332117](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213313.png)

##### BTC匿名性

⽐特币匿名性没有我们想象那么好

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213314.jpeg)

![image-20200312154534407](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213315.png)

![image-20200312154651091](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213316.png)

##### BTC思考

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213317.jpeg)

会不会BTC这种建立在密码学上的加密货币，在量子计算出来后会不会变得不安全。

```
一. 量子计算距离使用仍然有很长距离
二. 量子计算若真正使用到破坏现有加密算法，对传统金融业的破坏仍然是最大的。
三. 实际中使用的并非公钥，而是可以用公钥哈希。而哈希函数一般都是不可逆的，所以即使量子计算也无法反推私钥。
BTC中用的SHA-256，无论输入多大，最终结果都为256位，必然会导致信息丢失，无法反推原本数据。
总结：**加密可逆、哈希不可逆；加密不损失信息、哈希破坏信息**（加密和哈希的区别）
```

#### 比特币：一种点对点电子现金系统

本文提出了一种完全通过点对点技术实现的电子现金系统，它使得在线支付能够直接由一方发起并支付给另外一方，中间不需要通过任何的金融机构。

虽然数字签名（Digital signatures）部分解决了这个问题，但是如果仍然需要第三方的支持才能防止双重支付（double-spending）的话，那么这种系统也就失去了存在的价值。

我们(we)在此提出一种解决方案，使现金系统在点对点的环境下运行，并防止双重支付问题。

该网络通过随机散列（hashing）对全部交易加上时间戳（timestamps），将它们合并入一个不断延伸的基于随机散列的工作量证明（proof-of-work）的链条作为交易记录，除非重新完成全部的工作量证明，形成的交易记录将不可更改。

最长的链条不仅将作为被观察到的事件序列（sequence）的证明，而且被看做是来自 CPU计算能力最大的池（pool）。只要大多数的 CPU 计算能力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条。

这个系统本身需要的基础设施非常少。信息尽最大努力在全网传播即可，节点(nodes)可以随时离开和重新加入网络，并将最长的工作量证明链条作为在该节点离线期间发生的交易的证明。

##### 交易(Transactions)

一枚电子货币（an electronic coin）是这样的一串数字签名：每一位所有者通过对前一次交易和下一位拥有者的公钥(Public key) 签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾，电子货币就发送给了下一位所有者。而收款人通过对签名进行检验，就能够验证该链条的所有者。

![image-20191231160003140](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213318.png)

##### 时间戳服务器(Timestamp server)

时间戳服务器通过对以区块(block)形式存在的一组数据实施随机散列而加上时间戳，并将该随机散列进行广播。该时间戳能够证实特定数据必然于某特定时刻是的确存在的，因为只有在该时刻存在了才能获取相应的随机散列值。每个时间戳应当将前一个时间戳纳入其随机散列值中，每一个随后的时间戳都对之前的一个时间戳进行增强(reinforcing)，这样就形成了一个链条（Chain）。

![image-20191231160252279](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213319.png)

##### 工作量证明 （Proof-of-Work）

在进行随机散列运算时，工作量证明机制引入了对某一个特定值的扫描工作，比方说 SHA-256下，随机散列值以一个或多个 0 开始。那么随着 0 的数目的上升, 找到这个解所需要的工作量将呈指数增长，但是检验结果仅需要一次随机散列运算。

我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个 0。我们通过反复尝试来找到这个随机数，找到为止。这样我们就构建了一个工作量证明机制。只要该 CPU 耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。

![image-20191231160620734](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213320.png)

另一个问题是，硬件的运算速度在高速增长，且节点参与网络的程度会有所起伏。为了解决这个问题，工作量证明的难度(the proof-of-work difficulty)将采用移动平均目标的方法来确定，即令难度指向令每小时生成区块的速度为某一预设的平均数。如果区块生成的速度过快，那么难度就会提高。

节点始终都将最长的链条视为正确的链条，并持续工作和延长它。如果有两个节点同时广播不同版本的新区块，那么其他节点在接收到该区块的时间上将存在先后差别。当此情形，他们将在率先收到的区块基础上进行工作，但也会保留另外一个链条，以防后者变成最长的链条。该僵局（tie）的打破要等到下一个工作量证明被发现，而其中的一条链条被证实为是较长的一条，那么在另一条分支链条上工作的节点将转换阵营，开始在较长的链条上工作。

##### 回收硬盘空间

如果最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。为了同时确保不损害区块的随机散列值，交易信息被随机散列时，被构建成一种 Merkle 树（Merkle tree） 的形态，使得只有根(root)被纳入了区块的随机散列值。通过将该树（tree）的分支拔除（stubbing）的方法，老区块就能被压缩。而内部的随机散列值是不必保存的。

![image-20191231161504421](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213321.png)

##### 简化的支付确认（Simplified Payment Verification ）

在不运行完整网络节点的情况下，也能够对支付进行检验。一个用户需要保留最长的工作量证明链条的区块头的拷贝，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过 merkle 的分支通向它被加上时间戳并纳入区块的那次交易。节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。

![image-20191231161935995](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407213322.png)

##### 隐私

隐私依然可以得到保护：将公钥保持为匿名。公众得知的信息仅仅是有某个人将一定数量的货币发所给了另外一个人，但是难以将该交易同某个特定的人联系在一起，也就是说，公众难以确信，这些人究竟是谁。作为额外的预防措施，使用者可以让每次交易都生成一个新的地址，以确保这些交易不被追溯到一个共同的所有者。