---
layout: post
title: "Java并发复习"
date: 2021-03-10 10:36
toc: true
comments: true
categories: 技术学习
tags:
	- 基础
	- 复习 
---

### Java并发

<!--more-->

#### volatile原理

![image-20210307201619086](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105115.png)

##### volatile保证内存可见性

![image-20210307201753855](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105116.png)

![image-20210307201844818](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105117.png)

#### CAS原理

![image-20210307203345273](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105118.png)

##### ABA问题

乐观锁的实现中通常都会用版本戳version来对记录或对象标记，避免并发操作带来的问题，在Java中AtomicStampedReference<E>也实现了这个作用，它通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题

AtomicInteger实现原理：CAS操作volatile变量value

##### 循环时间长开销大。

自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

##### 只能保证一个共享变量的原子操作。

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作

#### Synchronized 原理

```
修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁
```

![image-20210307202329448](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105119.png)

![image-20210307202619317](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105120.png)

![image-20210307202650741](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105121.png)

```
 Contention List：所有请求锁的线程将被首先放置到该竞争队列
 Entry List：Contention List 中那些有资格成为候选人的线程被移到 Entry List
 Wait Set：那些调用 wait 方法被阻塞的线程被放置到 Wait Set
 OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为 OnDeck
 Owner：获得锁的线程称为 Owner
 !Owner：释放锁的线程
```

![image-20210307202749923](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105122.png)



新请求锁的线程将首先被加入到ConetentionList中，当某个拥有锁的线程（Owner状态）调用unlock之后，如果发现EntryList为空则从ContentionList中移动线程到EntryList，下面说明下ContentionList和EntryList的实现方式：
 **ContentionList虚拟队列**
ContentionList并不是一个真正的Queue，而只是一个虚拟队列，原因在于ContentionList是由Node及其next指针逻辑构成，并不存在一个Queue的数据结构。ContentionList是一个后进先出（LIFO）的队列，每次新加入Node时都会在队头进行，通过CAS改变第一个节点的的指针为新增节点，同时设置新增节点的next指向后续节点，而取得操作则发生在队尾。显然，该结构其实是个Lock-Free的队列。

因为只有Owner线程才能从队尾取元素，也即线程出列操作无争用，当然也就避免了CAS的ABA问题。

![image-20210307203933268](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105123.png)

**EntryList**
EntryList与ContentionList逻辑上同属等待队列，ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立EntryList。Owner线程在unlock时会从ContentionList中迁移线程到EntryList，并会指定EntryList中的某个线程（一般为Head）为Ready（OnDeck）线程。Owner线程并不是把锁传递给OnDeck线程，只是把竞争锁的权利交给OnDeck，OnDeck线程需要重新竞争锁。这样做虽然牺牲了一定的公平性，但极大的提高了整体吞吐量，在Hotspot中把OnDeck的选择行为称之为“竞争切换”。

OnDeck线程获得锁后即变为owner线程，无法获得锁则会依然留在EntryList中，考虑到公平性，在EntryList中的位置不发生变化（依然在队头）。如果Owner线程被wait方法阻塞，则转移到WaitSet队列；如果在某个时刻被notify/notifyAll唤醒，则再次转移到EntryList。


##### 对synchronized的优化,偏向锁、轻量级锁、自旋锁和重量级锁

锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。

synchronized锁膨胀过程：

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105124)

**偏向锁**
偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了**减少同一线程获取锁**(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么**锁就进入偏向模式**，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。

**轻量级锁**
倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。

**自旋锁**
轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程**做几个空循环**(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。

**锁消除**
消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，**去除不可能存在共享资源竞争的锁**，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。

##### 公平锁与非公平锁

![image-20210307205200297](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105125.png)

##### Volatile 与 synchronized 区别

![image-20210307201608665](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105126.png)

##### ReentrantLock 和 synchronized 区别

![image-20210307205249993](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105127.png)

#### AQS(AbstractQueuedSynchronizer)

**AQS原理**
AQS：AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。
AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包

使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。

同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。

同步器简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。

**AQS的核心思想**是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
**AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。**

AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS完成对status值的修改(0表示没有,1表示阻塞)，成功则获取锁成功，失败则进入等待队列，等待被唤醒。

**注意：AQS是自旋锁：**在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功

**实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105128.png)

AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：
getState();setState();compareAndSetState();

AQS 定义了两种资源共享方式：
1.**Exclusive**：独占，只有一个线程能执行，如ReentrantLock
2.**Share**：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier

不同的自定义同步器争用共享资源的方式也不同。**自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可**，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：

- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105129.png)



#### 重入锁实现

三要素：

- 原子状态。使用CAS操作获取和更改锁状态。
- 等待队列。
- 阻塞原语park()和unpark()。LockSupport

##### LockSupport的park()和unpark()

线程挂起和恢复，类似于suspend()和resume()。

但是suspend()和resume()操作必须保证suspend()操作在resume()之前，否则会发生线程永久性挂起的情况。

LockSupport的park()和unpark()不会发生这种情况。

这是因为LockSupport类使用类似信号量的机制。它为每个线程准备一个许可，若许可可用，那么park()函数会立即返回，并且消费这个许可(将许可变为不可用)，如果许可不可用，则阻塞。unpark()使许可变为可用。

LockSupport的park()支持中断响应，但不是抛出InterruptedException异常，只是默默返回，但仍可以从Thread.interruptd()方法获得中断标记。

#### ReentrantLock

ReentrantLock是基于AQS实现的，这在下面会讲到，AQS的基础又是CAS

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105130.png)

```
lock()：获取锁，如果锁被暂用则一直等待
unlock():释放锁
tryLock(): 注意返回类型是 boolean，如果获取锁的时候锁被占用就返回 false，
否则返回 true
tryLock(long time, TimeUnit unit)：比起 tryLock()就是给了一个时间期限，保
证等待参数时间
lockInterruptibly()：用该锁的获得方式，如果线程在获取锁的阶段进入了等待，
那么可以中断此线程，先去做别的事
```

线程1独占了锁。然后线程2也要尝试获取同一个锁，在线程1没有释放锁的情况下必然是行不通的，所以线程2就要阻塞。那么，线程2如何被阻塞？看下线程2的方法调用链，这就比较复杂了：

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105131.png)

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105132.png)



#### JUC包

![image-20210307220702101](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105133.png)

```
7.1.1 CountDownLatch
    这个类是一个同步计数器，主要用于线程间的控制，当 CountDownLatch 的 count 计数>0 时，
    await()会造成阻塞，直到 count 变为 0，await()结束阻塞，使用 countDown()会让 count 减 1。
    CountDownLatch 的构造函数可以设置 count 值，当 count=1 时，它的作用类似于 wait()和 notify()
    的作用。如果我想让其他线程执行完指定程序，其他所有程序都执行结束后我再执行，这时可以用
    CountDownLatch，但计数无法被重置，如果需要重置计数，请考虑使用 CyclicBarrier 。
7.1.2 CyclicBarrier
    该类从字面理解为循环屏障，它可以协同多个线程，让多个线程在这个屏障前等到，直到所有
    线程都到达了这个屏障时，再一起执行后面的操作。假如每个线程各有一个 await，任何一个线程运
    行到 await 方法时就阻塞，直到最后一个线程运行到 await 时才同时返回。和之前的 CountDownLatch
    相比，它只有 await 方法，而 CountDownLatch 是使用 countDown()方法将计数器减到 0，它创建的
    参数就是 countDown 的数量；CyclicBarrier 创建时的 int 参数是 await 的数量。
7.1.3 Semaphore
    该类用于控制信号量的个数，构造时传入个数。总数就是控制并发的数量。假如是 5，程序执
    行前用 acquire()方法获得信号，则可用信号变为 4，程序执行完通过 release()方法归还信号量，可用
    信号又变为 5.如果可用信号为 0，acquire 就会造成阻塞，等待 release 释放信号。acquire 和 release
    方法可以不在同一个线程使用。Semaphore 实现的功能就类似厕所有 5 个坑，假如有 10 个人要上厕
    所，那么同时只能有多少个人去上厕所呢？同时只能有 5 个人能够占用，当 5 个人中 的任何一个人
    让开后，其中等待的另外 5 个人中又有一个人可以占用了。另外等待的 5 个人中可以是随机获得优先
    机会，也可以是按照先来后到的顺序获得机会，这取决于构造 Semaphore 对象时传入的参数选项。
    单个信号量的 Semaphore 对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另
    一个线程释放“锁”，这可应用于死锁恢复的一些场合。
7.1.4 Exchanger
    这个类用于交换数据，只能用于两个线程。当一个线程运行到 exchange()方法时会阻塞，另一
    个线程运行到 exchange()时，二者交换数据，然后执行后面的程
```

#### Threadlocal

![image-20210305210233334](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105134.png)

#### 线程与进程

##### 创建线程方法

![image-20210307205718007](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105135.png)

##### 线程状态

![这里写图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105136.png)

##### 线程、进程与程序的区别

```
1、进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）
一个程序运行后至少有一个进程，一个进程中可以包含多个线程 。
2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC（Inter-Process Communication，进程间通信）)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
4、但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
5、同步方式不同：进程：无名管道、有名管道、信号、共享内存、消息队列、信号量
线程：互斥量、读写锁、自旋锁、线程信号、条件变量
6、进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换
```

##### 进程通信方式

![image-20210308095252651](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105137.png)

##### 线程池

![image-20210307210611167](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105138.png)

```java
4 种类型的线程池：
new FixedThreadPool()
说明：初始化一个指定线程数的线程池，其中 corePoolSize == maxiPoolSize，使用 LinkedBlockingQuene 作为阻塞队列
特点：即使当线程池没有可执行任务时，也不会释放线程。
new CachedThreadPool()
说明：初始化一个可以缓存线程的线程池，默认缓存 60s，线程池的线程数可达到 Integer.MAX_VALUE，即 2147483647，内部使用 SynchronousQueue 作为阻塞队列；
特点：在没有任务执行时，当线程的空闲时间超过 keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；
因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。
new SingleThreadExecutor()
说明：初始化只有一个线程的线程池，内部使用 LinkedBlockingQueue 作为阻塞队列。
特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行
new ScheduledThreadPool()
特定：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据
```

##### submit() 和 execute()

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。

**线程池状态**

```java
RUNNING 自然是运行状态，指可以接受任务执行队列里的任务
SHUTDOWN 指调用了 shutdown() 方法，不再接受新任务了，但是队列里的任务得执行完毕。
STOP 指调用了 shutdownNow() 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。
TIDYING 所有任务都执行完毕，在调用 shutdown()/shutdownNow() 中都会尝试更新为这个状态。
TERMINATED 终止状态，当执行 terminated() 后会更新为这个状态
```

![image-20210307210704702](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105139.png)

##### 僵尸进程

![image-20210308095421429](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105140.png)

##### 进程死锁

![image-20210307210152075](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105141.png)

![image-20210308095513173](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105142.png)

##### 多线程共用一个数据变量

![image-20210307210445922](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105143.png)

##### 一般线程和守护线程的区别

所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如**垃圾回收线程**就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止

##### Sleep与wait

![image-20210307205958565](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105144.png)

#####  yield join notify notifyAll

![image-20210307210025423](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105145.png)

##### 中断线程

![image-20210307210233243](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105146.png)

##### 多线程抛异常

![image-20210307210810526](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105147.png)

