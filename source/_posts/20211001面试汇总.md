---
layout: post
title: "面试问题汇总"
date: 2021-03-10 10:36
toc: true
comments: true
categories: 技术学习
tags:
	- 基础
	- 复习 
---

### 项目

##### 自我介绍

我叫周思远，大工软院19届，现保研到华科计院。在校期间参加过计算机设计大赛等科创竞赛，也获得过三好学生、优秀毕业生，优秀党员等荣誉。

<!--more-->

项目方面，弄过一个毕业论文格式检测系统，在校上线至今检测超4000篇论文，搞过一个类豆瓣的电影推荐系统，现在刚结题一个科技大数据分析项目。
个人对后台开发比较感兴趣，学过计网，操作系统等核心课程，掌握Java基础知识及底层实现，了解jvm, java并发，innodb等相关内容。大概就这些。

##### 错题集

http长连接底层，linux内核，循环依赖，java默认排序算法,Redo,Undo,JDK8，Optional 类
ZGC,G1

分布式Redis锁

##### 反问：

实习生要求？部门实习生进去干啥活如何培养？

职业规划请教：做架构，还是做业务？

问部门要求、问部门定位、问部门发展等关系部门技术吸引力的地方

请问贵部门在应届毕业生的要求上，基础和应用技能更看重哪方面？

请问贵部门在整个集团中是作为一个怎么样的角色与其他部门做交互？网上的资料比较片面，想详细了解下

##### 大数据项目

爬虫，关键词谷歌爬取？

1.翻墙 自己搭vps

2.通用爬取，结构不同

2.反爬，user-agent模拟，selenium（模拟浏览器）（一个多小时封），换谷歌URL（台湾，香港服务器不同、不同网址有事结构不同），花钱ip代理池（解决），微信->搜狗搜索—>定向爬取（根据微信id封，id解析真实地址，2000次）->三方机构爬取（提微信号）

**数据处理**

不相关，标注软件，每个人不一样（反向标注，修改快）

**实体识别**

通用性

##### 电影推荐

DataModel：DataModel 是用户喜好信息的抽象接口，它的具体实现支持从任意类型的数据源抽取用户喜好信息。Taste 默认提供 JDBCDataModel 和 FileDataModel，分别支持从数据库和文件中读取用户的喜好信息。
    UserSimilarity 和 ItemSimilarity：UserSimilarity 用于定义两个用户间的相似度，它是基于协同过滤的推荐引擎的核心部分，可以用来计算用户的“邻居”，这里我们将与当前用户口味相似的用户称为他的邻居。ItemSimilarity 类似的，计算内容之间的相似度。
    UserNeighborhood：用于基于用户相似度的推荐方法中，推荐的内容是基于找到与当前用户喜好相似的“邻居用户”的方式产生的。UserNeighborhood 定义了确定邻居用户的方法，具体实现一般是基于 UserSimilarity 计算得到的。

​    Recommender：Recommender 是推荐引擎的抽象接口，Taste 中的核心组件。程序中，为它提供一个 DataModel，它可以计算出对不同用户的推荐内容。Recommender是Taste中的核心组件，它可以根据提供的数据模型计算出对不同用户的推荐结果。其中包含的子类可以从内存中缓存其他的推荐结果，因此在低内存情况下可以通过让Java虚拟机取回推荐的结果再输出。在Recommender组件里包含的推荐方法一般会将结果储存在List中，另外estimatePreference()方法还能预估用户对物品的评分。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105022.png)

![image-20191229215007041](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105023.png)

```java
public class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication auth)
            throws IOException, ServletException {
        UserAuth userAuth = (UserAuth) auth.getPrincipal();
        HttpSession session = request.getSession();
        switch (userAuth.getRole()) {
        case "ADMIN":
            session.setAttribute("id", userAuth.getId());
            session.setAttribute("name", userAuth.getUsername());
            session.setAttribute("role", "ADMIN");
            response.sendRedirect("admin");
            break;
        case "USER":
            session.setAttribute("id", userAuth.getId());
            session.setAttribute("name", userAuth.getUsername());
            session.setAttribute("role", "USER");
            response.sendRedirect("user");
            break;
        }
    }
}
```

##### 论文格式检测系统

**文档英文，自己摸索对应关系，有错误的，段落格式，单字格式**

**瞎搞，把无关的文档往里面传，系统崩溃，try catch** 

**修改论文，有些不能改，只能给提示**

（1） 研究word论文格式与对应的xml映射关系，利用OpenXML等工具研究word下.doc及.docx文件实现过程中用到的标签、类、库，为提取属性及属性对比打下基础。

（2） 如何从xml中提取格式特征,即利用C#语言提取出每个格式特征的XML标签，并运用到检测过程当中。

（3） 上传的的论文与指定的模板进行对比，须分别提取上传论文与给定模板的同种属性，依次完成所有属性的对比。

（4） 全面且准确的将word论文格式封装进库，拟建立一个新的架构层次，避免对比过程中出现耦合，利于系统后期维护与升级。

通过修改docx文件的后缀名为zip并解压，或得到一个名为word的文件夹，其包含了一篇Word文档中的全部内容。Word文件夹下的document.xml文件则包含了文档之中绝大多数的文本内容。

**WordprocessingML和命名空间中的类的对照表**

| 包部分   | WordprocessingML元素 | OpenXml SDK中的类 | 说明               |
| -------- | -------------------- | ----------------- | ------------------ |
| 主文档   | document             | Document          | 表示主文档的元素   |
| 页脚     | ftr                  | Footer            | 表示页脚部分的元素 |
| 页眉     | hdr                  | Header            | 表示页眉部分的元素 |
| 文档样式 | styles               | Styles            | 表示样式定义的元素 |

通过上述表中的内容分析，
Paragraph类表示在当前的XML格式文档之中的段落，并使用<.p>标签来表示，通过使用Paragrapgh类可以而已解析OpenXml文档之中的<.p>标签。在WordprocessingML中，使用段落属性<.pPr>元素来表示段落的属性。段落的属性包括字体、字号、颜色、行距、缩进等。而<.rPr>元素在WordprocessingML中表示的则是文档的运行属性，其与文档的段落属性基本一致。一篇有Word编写的文档在其段落之中通常都会傲寒这大量的文本内容，在WordprocessingML文档所使用的架构中，<.r>元素被用来划分文本块中的那些连续的文字。相对于<.r>元素，<.t>元素则相当于一个容器，代替其保存那些文本化的内容。一段连续的文儿内容通常会有相同的属性，这些属性被称为样式或者格式，使用<.r>元素能够保存这些属性的设置，并将其运用在一段连续文本的整体或者部分之中。每一段连续的文本和段落一样都会有自己的属性，<.r>元素的属性则是通过段落运行属性元素<.rPr>来设置，通过对<.rPr>元素的设置，可以对<.t>元素中保存的文本内容加上例如加粗、下划线、颜色、字体、字号等各种各样的属性。

**WordprocessingML表格元素和类的对应关系**

| WordprocessingML元素 | OpenXML SDK中的类                  |
| -------------------- | ---------------------------------- |
| tr tblPr gridCol     | TableRow TableProperties GridColum |
| tblGrid              | TableGrid                          |
| tc                   | TableCell                          |

**2.字号**

< sz>指出了< r>元素中的文本< t>的字号样式。< sz>的属性Val的值代表了字号的大小，如<w:sz w:val=”24”/>代表字号为24/2=12磅。查询字号对照表【参考文献】得到字号和磅数的对应关系，就可以得到实际的字号为“小四”。

#### 常考题

![image-20210518212121074](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210518212123.png)

![image-20210518212156755](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210518212159.png)

![image-20210518212224791](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210518212226.png)

![image-20210518212302615](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210518212304.png)

### 场景题

#### O(1)时间内删除链表节点

![这里写图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105024.png)

#### 海量数据处理

##### 怎样对10亿个数字（字符串）快速去重？

对于海量数据处理，思路基本上是：必须分块处理，然后再合并起来。

方法一：

通过哈希算法，将10亿个电话号码按照哈希值落在多个文件中，

重复的电话号码有相同的哈希值，肯定位于一个文件中，

这样就可以分别对每个文件排序删除重复的电话号码。

方法二：

使用位图来进行处理。比如说这10亿个数的范围为【0-10亿】，那么就申请一个10亿的数组，

数组类型为boolen，只有0和1，0表示没有，1表示有。

这样自然而然的就删掉了重复的部分。

##### 100亿个数取出最大的10000个

算法：如果把100亿个数全部读入内存，需要100 0000 0000 * 4B 大约40G的内存，这显然是不现实的。　　

我们可以在内存中维护一个**大小为10000的最小堆**，每次从文件读一个数，与最小堆的堆顶元素比较（也可先分割排序），若比堆顶元素大，则替换掉堆顶元素，然后调整堆。最后剩下的堆内元素即为最大的1万个数，算法复杂度为O(NlogN)　　

为了**加速并行处理**，可以先hash为n份，每份求最大的10000个，然后在这n*10000个中用最小堆

实现：从文件读数据有讲究，如果每次只读一个数，效率太低，可以维护一个输入缓冲区，一次读取一大块数据到内存，用完了又从文件接着读，这样效率高很多，缓冲区的大小也有讲究，一般要设为4KB的整数倍，因为磁盘的块大小一般就是4KB。

##### 如何在海量数据中找出重复最多⼀个。（提取出某⽇访问百度次数最多的那个IP）

通过hash映射为⼩⽂件
通过hash_map统计各个⼩⽂件重读最多的并记录次数
对每个⼩⽂件重复最多的进⾏建⽴⼤根堆

##### 有10个1G⽂件，每⾏都是⼀个可重复⽤户query，按query频度排序。

顺序读取⼗个⽂件并采取哈希，将query写⼊10个⽂件中
通过hash_map(query, count)统计每个query出现次数，⾄少2G内存
通过得到的hashmap 中 query 和 querycount，对query_count排序并将重新输出到⽂件
中，得到已排序好的⽂件
对⼗个⽂件进⾏归并排序（外排序）

##### A,B两个⽂件各存放50亿url，每个为64Byte，限制内存4G找出公共url。

对A和B两个⼤⽂件，先通过url % 1000将数据映射到1000个⽂件中，单个⽂件⼤⼩约
320M（我们只需要检查对应⼩⽂件A1 V B1......，不对应⼩⽂件不会有相同url）
通过hashset 统计，把 A1 的 url 存储到 hashset中，再遍历对应的B1⼩⽂件，检查是否在
hash_set中，若存在则写⼊外存。重复循环处理对应的1000个对。

#### BitMap

32位机器上，对于一个整型数，比如int a=1 在内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费，因为我们可以用对应的32bit位对应存储十进制的0-31个数，而这就是Bit-
map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。 Bitmap在用户群做交集和并集运算的时候也有极大的便利。

![image-20210408124030233](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105025.png)

![image-20210408124139472](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105026.png)

![image-20210408124156380](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105027.png)

#### 常见的限流算法

##### 计数器法

计数器法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个 请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置
counter，具体算法的示意图如下：

![image-20210408124654747](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105028.png)

这个算法虽然简单，但是有一个十分致命的问题，那就是临界问题，我们看下图：

![image-20210408124747364](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105029.png)

从上图中我们可以看到，假设有一个恶意用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100
个请求，那么其实这个用户在 1秒里面，瞬间发送了200个请求。我们刚才规定的是1分钟最多100个请求，也就是
每秒钟最多1.7个请求，用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制。用户有可能
通过算法的这个漏洞，瞬间压垮我们的应用。

##### 滑动窗口

滑动窗口，又称rolling window。为了解决这个问题，我们引入了滑动窗口算法。

![image-20210408124904461](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105030.png)

在上图中，整个红色的矩形框表示一个时间窗口，在我们的例子中，一个时间窗口就是一分钟。然后我们将时间窗
口进行划分，比如图中，我们就将滑动窗口 划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器counter，比如当一个请求 在0:35秒的时候到达，那么
0:30~0:39对应的counter就会加1。
那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，而
1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触 发了限流

##### 漏桶算法

漏桶算法，又称leaky bucket。首先，我们有一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多 少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率。而且，当桶满了之后，多余的水将会溢出。

![image-20210408125032043](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105031.png)

##### 令牌桶算法

令牌桶算法，又称token bucket。从图中我们可以看到，令牌桶算法比漏桶算法稍显复杂。首先，我们有一个固定容量的桶，桶里存放着令牌（token）。桶一开始是空的，token以 一个固定的速率r往桶里填充，直到达到桶的容量，多余的令牌将会被丢弃。每当一个请求过来时，就会尝试从桶里移除一个令牌，如果没有令牌的话，请求无法通 过。

令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况
下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送(百科)。

![image-20210408125304994](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105032.png)

**计数器 VS 滑动窗口**
计数器算法是最简单的算法，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格
子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间
就越大。
**漏桶算法 VS 令牌桶算法**
漏桶算法和令牌桶算法最明显的区别是令牌桶算法允许流量一定程度的突发。因为默认的令牌桶算法，取走token
是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。
令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要具体情况
具体分析，只有最合适的算法，没有最优的算法。

#### 分布式环境下全局唯一的发号器

##### 1、UUID

常见的方式。可以利用数据库也可以利用程序生成，一般来说全球唯一。
优点：

1. 简单，代码方便。
2. 生成ID性能非常好，基本不会有性能问题。 \3. 全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更
   等情况下，可以从容应对。

缺点：

1. 没有排序，无法保证趋势递增。
2. UUID往往是使用字符串存储，查询的效率比较低。
3. 存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。
4. 传输数据量大
5. 不可读。

##### 2、数据库自增长序列或字段

最常见的方式。利用数据库，全数据库唯一。
优点：

1. 简单，代码方便，性能可以接受。
2. 数字ID天然排序，对分页或者需要排序的结果很有帮助。

缺点：

1. 不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。
2. 在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。
3. 在性能达不到要求的情况下，比较难于扩展。
4. 如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。
5. 分表分库的时候会有麻烦。

优化方案：
针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个
数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以
有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。

##### 3、数据库sequence表以及乐观锁

我们可以单独设置一张表，来存储所有表的下一个主键的值，例如现在有A、B、C三个表，sequence表结构如下

![image-20210408205931380](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105033.png)

然后，每当需要获取下一个主键值的时候，首先使用select语句获取主键，然后使用数据库的乐观锁机制去update
这个sequence表，更新成功则说明获取主键成功，更新失败则说明存在并发，当前主键被别的机器抢走了，需要
重新select出新的主键，载update。例如要获取表B的下一个主键，需要发送sql

```sql
select id from sequence where name=B
//获得id=100,更新sequence表
update sequence set id=id+1 where name=B and id=100
```

优点：

1. 操作简单，使用乐观锁可以提高性能
2. 生成的id有序递增，连续
3. 可适用于分布式环境，可以进行分库分表

缺点

1. 需要单独设置一张表，浪费存储空间
2. 数据库更新比较频繁，写压力太大

改进方案
可以将每次获取一个主键，改为每次获取500个或者更多，然后缓存再当前机器中，用完这500个后，再去请求数
据库，做更新操作，可以减少数据库的读写压力，但是会造成主键的不连续

##### 4、Redis生成ID

当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。
可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：
A：1,6,11,16,21 B：2,7,12,17,22 C：3,8,13,18,23 D：4,9,14,19,24 E：5,10,15,20,25
这个，随便负载到哪个机确定好，未来很难做修改。但是3-5台服务器基本能够满足器上，都可以获得不同的ID。
但是步长和初始值一定需要事先需要了。使用Redis集群也可以方式单点故障的问题。
另外，比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生
成一个Key，使用INCR进行累加。
优点：

1. 不依赖于数据库，灵活方便，且性能优于数据库。
2. 数字ID天然排序，对分页或者需要排序的结果很有帮助。

缺点：

1. 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。
2. 需要编码和配置的工作量比较大。

##### 5、Twitter的snowflake算法

snowflake 是 twitter 开源的分布式ID生成算法，其核心思想为，一个long型的ID：

41 bit 作为毫秒数 - 41位的长度可以使用69年
10 bit 作为机器编号 （5个bit是数据中心，5个bit的机器ID） - 10位的长度最多支持部署1024个节点
12 bit 作为毫秒内序列号 - 12位的计数顺序号支持每个节点每毫秒产生4096个ID序号

```sql
select id from sequence where name=B
//获得id=100,更新sequence表
update sequence set id=id+1 where name=B and id=100
```

![image-20210408210308572](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105034.png)

Snowflake图示
算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。
snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数
以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。
优点：

1. 不依赖于数据库，灵活方便，且性能优于数据库。
2. ID按照时间在单机上是递增的。

缺点：
在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全
局递增的情况。

#### Java实现线程安全的List

参考CopyOnWrite 写入时复制，它使一个List同步的替代品，通常情况下提供了更好的并发性，并且避免了再迭代时候对容器的加锁和复制。通常更适合用于迭代，在多插入的情况下由于多次的复制性能会一定的下降。

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock; // 加锁 只允许获得锁的线程访问
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        // 创建个长度加1的数组并复制过去
        Object[] newElements = Arrays.copyOf(elements, len + 1); 
        newElements[len] = e; // 赋值
        setArray(newElements); // 设置内部的数组
        return true;
    } finally {
        lock.unlock();
    }
}
```

#### Java实现阻塞队列

阻塞队列的实现原理
1、生产者向队尾添加元素
2、消费者向队头消费元素
3、添加和消费过程是线程安全的

实现一的方法很简单，原理是synchronized+wait+notify实现，但是notify的时候是会唤醒生产者线程和消费者线程的，想象一下，当前生产者线程已经生产了MAX个元素，当他唤醒其他线程的时候，也会唤醒生产者线程，在这里显然是没有必要的。

```java
public class MyBlockingContainer<T> {
    private Queue<T> queue=new LinkedList<>();
    private final int MAX;

    public MyBlockingContainer(int limit){
        this.MAX=limit;
    }

    public void put(T t) throws InterruptedException {
        synchronized (this){
            while(queue.size()==MAX){
                this.wait();//释放锁并且阻塞自己，要想唤醒必须先获取锁
            }
            queue.offer(t);
            this.notifyAll();//唤醒消费者线程，此时还没有释放锁
        }
    }

    public T get() throws InterruptedException {
        T t;
        synchronized (this){
            while(queue.size()==0){
                this.wait();
            }
            t=queue.poll();
            this.notifyAll();
        }
        return t;
    }
}
```

实现二用AQS的条件队列实现了唤醒线程的灵活性，可以说比实现一更进了一步

```java
public class MyBlockingQueueForLock<T> {
    private Queue<T> queue=new LinkedList<>();
    private final int MAX;
    private ReentrantLock lock=new ReentrantLock();
    private Condition producer=lock.newCondition();
    private Condition consumer=lock.newCondition();

    public MyBlockingQueueForLock(int limit){
        this.MAX=limit;
    }

    public void put(T t) throws InterruptedException {
        final ReentrantLock lock=this.lock;
        lock.lockInterruptibly();
        try {
            while(queue.size()==MAX){
                producer.await();//响应中断
            }
            queue.offer(t);
            consumer.signalAll();
        }finally {
            lock.unlock();
        }
    }

    public T get() throws InterruptedException {
        final ReentrantLock lock=this.lock;
        lock.lockInterruptibly();
        T t;
        try {
            while (queue.size()==0){
                consumer.await();//响应中断
            }
            t=queue.poll();
            producer.signalAll();
        }finally {
            lock.unlock();
        }
        return t;
    }
}
```

### JavaSE

#### 基础

##### JDK、JRE、JVM

<!--more-->

![image-20200207122805940](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104735.png)

##### java程序执行

![image-20210308103111593](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104736.png)

##### ==与equals()

== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
 情况 1：类没有覆盖 equals() 方法。等价于通过“==”比较这两个对象。
 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true 。

##### 方法参数传值

方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.

##### final和static

![image-20210305205122482](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104737.png)

final 的好处：

```
1. final 关键字提高了性能。JVM 和 Java 应用都会缓存 final 变量。
2. final 变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
3. 使用 final 关键字，JVM 会对方法、变量及类进行优化。
```

##### 数据类型

![image-20200207131438485](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104738.png)

**类型转换**：byte、short、char‐‐>int‐‐>long‐‐>float‐‐>double

```java
Integer.MAX_VALUE = 0x7fffffff 最大值 (2^31-1)
Integer.MIN_VALUE = 0x80000000 最小值 (-2^31)
```

**b3=1 + 2 是正确的。但b3=1+200报错**

b3 = 1 + 2 ， 1 和  2 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 1+2 的结果并没有超过byte类型的取值范围，可以赋值给变量 b3 。

**short s1 = 1; s1 = s1 + 1;错。 short s1 = 1; s1 +=1;对**

```
1) 对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。

2) 对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。+= 操作符会进行隐式自动类型转换,
```

**switch语句能否作用在byte上，能否作用在long上，能否作用在string上？**

```
在switch(expr1)中，expr1只能是一个整数表达式或者枚举常量，
整数表达式可以是int基本类型或Integer包装类型。
由于，byte,short,char都可以隐式转换为int，所以，这些类型以及这些类型的包装类型也是可以的。

long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，
所以，它们不能作用于swtich语句中。
不过，在1.7版本之后switch就可以作用在string上了。
```

**包装类**分成引用和实例，引用在栈（stack）中，具体实例在堆（heap）中，jdk5.0开始增加自动装箱/拆箱。

```java
Integer i = Integer.valueOf(1); //手动装箱
Integer j = 1; //自动装箱
Integer i0 = new Integer(1);
int i1 = i0; //自动拆箱
int i2 = i0.intValue(); //手动拆箱
```

![image-20210305202513862](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104739.png)

**valueOf陷阱：**

```java
Double i1 = Double.valueOf(0.1);
Double i2 = Double.valueOf(0.1);
System.out.println(i1 == i2); //false valueOf方法内部实际上也是new
```

**valueOf内部也是用的new方法来构造对象的**。2个new出来的对象，内存地址肯定是不一样的。

![image-20200207145702858](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104740.png)

##### 包装类缓存机制

下面的代码运行结果却让人大跌眼镜：（**缓存机制**）

Java对部分经常使用的数据采用缓存技术，在类第一次被加载时换创建缓存和数据。当使用等值对象时直接从缓存中获取，从而提高了程序执行性能。（通常只对常用数据进行缓存）

```java
System.out.println(Integer.valueOf(1) ==Integer.valueOf(1)); //true 
System.out.println(Integer.valueOf(999) ==Integer.valueOf(999)); //false 
```

查看Integer.valueOf方法的源码：

![image-20200207150009985](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104741.png)

```
1. Integer类型有缓存-128-127的对象。缓存上限可以通过`-XX:AutoBoxCacheMax=size`修改
2. Byte,Short,Long类型有缓存(-128-127)
3. Character缓存0-127
4. Boolean缓存TRUE、FALSE
```

 **自动包装时实际上还是调用的valueOf方法**。而上面我们讲过的，valueOf方法用到了缓存池。

```java
Integer i4 = Integer.valueOf(1);
Integer i5 =1;
System.out.println(i4 == i5); //true
```

##### ASCII

![image-20200207172124800](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210507093240.png)

##### Java内存计算

**内存公式**：Java对象的内存布 = 对象头(Header) + 实例数据(Instance Data) + 补齐填充(Padding)。

在64位机器上，对象头不开压缩（-XX:-UseCompressedOops）16字节（默认），开压缩12字节；对象引用不开压缩8字节，开压缩4字节；填充到8字节的倍数；数组对象头24字节，压缩后16字节；String包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode

**对象头：Instance Header**，Java对象最复杂的一部分，采用C++定义了头的协议格式，存储了Java对象hash、GC年龄、锁标记、class指针、数组长度等信息。

**实例数据：Instance Data**，这部分数据才是真正具有业务意义的数据，实际上就是当前对象中的实例字段。在VM中，对象的字段是由基本数据类型和引用类型组成的。**对象引用（ref）类型在64位机器上，关闭指针压缩时占用8bytes， 开启时占用4bytes。**

**补齐填充**：Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数



**包装类（Boolean/Byte/Short/Character/Integer/Long/Double/Float）占用内存的大小 = 对象头大小 + 底层基础数据类型的大小**。包装类和其他引用类一样，会产生一个引用（reference）

![image-20200207152330555](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104742.png)

**数组内存占用**

**64位机器上，数组对象的对象头占用24 bytes，启用压缩后占用16字节。**对象数组本身的大小=数组对象头+length * 引用指针大小，总大小为对象数组本身大小+存放的数据的大小之和。

```c
int[10]:
开启压缩：16 + 10 * 4 = 56 bytes；
关闭压缩：24 + 10 * 4 = 64bytes。
new Integer[3]:
关闭压缩：
    Integer数组本身：24(header) + 3 * 8(Integer reference) = 48 bytes;
    总共：48 + 3 * 24(Integer) = 120 bytes。
开启压缩：
    Integer数组本身：16(header) + 3 * 4(Integer reference) = 28(padding) -> 32 (bytes)
    总共：32 + 3 * 16(Integer) = 80 (bytes)
```

**String内存占用**

在JDK1.7及以上版本中，String包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode。字符串"abcde"在开启指针压缩时的大小为：

```
String本身：12(Header) + 4(char[] reference) + 4(int hash) = 20(padding) -> 24 (bytes); 
存储数据：16(char[] header) + 5*2 = 26(padding) -> 32 (bytes)         
总共：24 + 32 = 56 (bytes) 
```

**复杂对象**

```java
class Parent {
    protected int x; // 4字节
    protected int y; // 4字节 
    protected boolean flag; // 1字节
}
class Child extends Parent {
    private int z; // 4字节
}
```

不开压缩40字节 = 16 + (4 + 4 + 1 + 7) + 4 + 7

![image-20200207161601497](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104743.png)

##### String，StringBuffer，StringBuider

```
1. 操作少量的数据 = String
2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer
```

**1. 是否可变** 

- String 不可变: 类为 final，类中 char[] 为final，（在 Java 9 之后，String 类的实现改⽤ byte 数组存储字符串
  private final byte[] value）
- StringBuffer 和 StringBuilder 可变，继承自 AbstractStringBuilder 类，char[] value 没有用 final 关键字修饰

![image-20210305203955846](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104744.png)

![image-20210305204136342](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104745.png)

##### String 不可变的原因

**1. 可以缓存 hash 值** 

因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 等情况。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。

**2. String Pool 的需要** 

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。如果可变，多个引用指向一个String，修改会影响。

**3. 安全性** 

String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。
String 经常作为 HashMap 的 key，key 对象需要是不可变的。

**4. 线程安全** 

String 不可变性天生具备线程安全，可以在多个线程中使用。

##### 重写equals还要重写hashcode？

![image-20210305204307273](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104746.png)

```
重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上。
重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。
```

##### String#intern()

使用 String.intern() 可以保证所有相同内容的字符串变量引用相同的内存对象。

直接使用双引号声明出来的`String`对象会直接存储在常量池中，字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。

当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中**添加一个新的字符串**，并返回这个新字符串的引用。

##### new String("abc")

使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。

- "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
- 而使用 new 的方式会在堆中创建一个字符串对象。

以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并**不会完全复制 value 数组内容**，而是都会指向同一个 value 数组。

```java
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
```

##### Object类

```java
protected Object clone() 创建并返回此对象的一个副本。 
boolean equals(Object obj) 指示某个其他对象是否与此对象“相等”。 
protected void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 
Class<? extendsObject> getClass() 返回一个对象的运行时类。 
int hashCode() 返回该对象的哈希码值。 
void notify() 唤醒在此对象监视器上等待的单个线程。 
void notifyAll() 唤醒在此对象监视器上等待的所有线程。 
String toString() 返回该对象的字符串表示。 
void wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。 
void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。 
void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify()
int hashCode() 针对不同的对象返回不同的整数。一般是通过将该对象的内部地址转换成一个整数来实现
```

##### Runtime 类

Runtime:运行时，是一个封装了 JVM 的类。每一个 JAVA 程序实际上都是启动了一个JVM 进程，每一个 JVM 进程都对应一个 Runtime 实例，此实例是由 JVM 为其实例化的。
所以我们不能实例化一个 Runtime 对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前 Runtime 运行时对象的引用。一旦得到了一个当前的Runtime 对象的引用，就可以调用 Runtime 对象的方法去控制 Java 虚拟机的状态和行为。

##### Enum类

使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应public static final Day MONDAY;，同时编译器会为该类创建两个方法，分别是values()和valueOf()

```java
public class EnumDemo {
    public static void main(String[] args){
        //直接引用
        Day day =Day.MONDAY;
    }
}
//定义枚举类型
enum Day {
    MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

//反编译Day.class
final class Day extends Enum
{
    //编译器为我们添加的静态的values()方法
    public static Day[] values()
    {
        return (Day[])$VALUES.clone();
    }
    //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法
    public static Day valueOf(String s)
    {
        return (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);
    }
    //私有构造函数
    private Day(String s, int i)
    {
        super(s, i);
    }
     //前面定义的7种枚举实例
    public static final Day MONDAY;
    public static final Day TUESDAY;
    public static final Day WEDNESDAY;
    public static final Day THURSDAY;
    public static final Day FRIDAY;
    public static final Day SATURDAY;
    public static final Day SUNDAY;
    private static final Day $VALUES[];

    static 
    {    
        //实例化枚举实例
        MONDAY = new Day("MONDAY", 0);
        TUESDAY = new Day("TUESDAY", 1);
        WEDNESDAY = new Day("WEDNESDAY", 2);
        THURSDAY = new Day("THURSDAY", 3);
        FRIDAY = new Day("FRIDAY", 4);
        SATURDAY = new Day("SATURDAY", 5);
        SUNDAY = new Day("SUNDAY", 6);
        $VALUES = (new Day[] {
            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
        });
    }
}
```

##### finally  代码块和 finalize()方法有什么区别？

无论是否抛出异常，finally 代码块都会执行，它主要是用来释放应用占用的资源。

finalize()方法是 Object 类的一个 protected 方法，它是在对象被垃圾回收之前由 Java 虚拟机来调用的。它最主要的用途是回收特殊渠道申请的内存。如 JNI(Java Native Interface)调用 non-Java程序（C 或 C++），finalize()的工作就是回收这部分的内存。

##### comparable和 comparator 接口区别

Comparable和Comparator接口被用来对对象集合或者数组进行排序。
Comparable接口被用来提供对象的自然排序，可使用它来提供基于单个逻辑的排序。
Comparator接口被用来提供不同的排序算法，可根据制定字段选择需要使用的Comparator来对指定的对象集合进行排序。

##### 接口和抽象类的区别

1，抽象类里可以有构造方法，而接口内不能有构造方法。
2，抽象类中可以有普通成员变量，而接口中不能有普通成员变量。
3，抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法。
4，抽象类中的抽象方法的访问类型可以是public ，protected和private，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
5，抽象类中可以包含静态方法，接口内不能包含静态方法。
6，抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static类型，并且默认为public static final类型。
7，一个类可以实现多个接口，但只能继承一个抽象类。

##### session与cookie

![image-20210305205425880](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104747.png)

cookie 是 Web 服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个 Web服务器存储 cookie。以后浏览器在给特定的 Web 服务器发请求的时候，同时会发送所有为该服务器存储的 cookie。

##### hash算法

![image-20210307200727001](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104748.png)

##### Java动态代理

通过 Proxy 的 ProxyInstance 类创建出一个代理类，这个代理类执行的关于它代理的对象（真正的对象）的方法（代理类可以自己定义自己的方法，要区别）

InvocationHandler 是一个接口，接口中有 invoke 方法，invoke 方法关联到一个真正的对象，然后去执行真正对象的方法，来实现代理。

![image-20210307221526701](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104749.png)

#### 面向对象

##### Java创建对象四种方法

![image-20210305203852177](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104750.png)

![image-20210307193025213](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104751.png)

##### 强、软、弱和虚引用

![1567505930559](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104752.png)

```java
//强引用 即使该对象永远不会被用到，JVM 也不会回收。强引用是造成 Java 内存泄漏的主要原因之一。
String str = new String("str");

// 软引用 
// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T
//创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。
//运用：用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效避免内存溢出的问题。
SoftReference<String> wrf = new SoftReference<String>(new String("str"));

//弱引用 
WeakReference<String> wrf = new WeakReference<String>(str);   

//虚引用
PhantomReference<String> prf = new PhantomReference<String>(newString("str"), new ReferenceQueue<>());
```

##### 封装

封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。
封装的一些好处：
1) 通过隐藏对象的属性来保护对象内部的状态;
2) 提高了代码的可用性和可维护性;
3) 禁止对象之间的不良交互提高模块化。

![image-20200210161241969](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104753.png)

##### 继承

类似于this，子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量

在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。

super与this的内存图

![03-super与this的内存图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104754.png)

##### 多态

相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。多态分两种类型：
**编译时多态**：在编译时能够确定执行多态方法中的哪一个，称为编译时多态； 方法重载是编译时多态。
**运行时多态**：在执行期间根据实际类型判断并调用相应的属性和方法。主要用于继承父类和实现接口时，父类引用指向子类对象。

![05-抽象的概念](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104755.png)

##### 重载与重写

![image-20210305202652712](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104756.png)

#####  内部类

内部类可以直接访问外部类的成员，包括私有成员。
外部类要访问内部类的成员，必须要建立内部类的对象。

```
外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；
```

内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的 .class文件，但是前面冠以外部类的类名
和$符号 。比如，Person$Heart.class

**匿名内部类**
匿名内部类就是没有名字的内部类；
匿名内部类不能定义任何静态成员、方法。
匿名内部类中的方法不能是抽象的；
匿名内部类必须实现接口或抽象父类的所有抽象方法。
匿名内部类访问的外部类成员变量或成员方法必须用 static 修饰
1、匿名内部类因为没有类名，可知匿名内部类不能定义构造器。
2、因为在创建匿名内部类的时候，会立即创建它的实例，可知匿名内部类不能是抽象类，必须实现接口或抽象父类的所有抽象方法。
3、匿名内部类会继承一个父类（有且只有一个）或实现一个接口（有且只有一个），实现父类或接口中所有抽象方法，可以改写父类中的方法，添加自定义方法。
5、当匿名内部类和外部类有同名变量（方法）时，默认访问的是匿名内部类的变量（方法），要访问外部类的变量（方法）则需要加上外部类的类名。

##### 类加载器初始化

类加载（先父后子,静态代码块（执行一次）---->非静态代码块(执行多次）---->成员变量---->构造函数)

static在涉及到继承的时候，会先初始化父类的static变量，然后是子类的，依次类推。

存在继承的情况下，初始化顺序为：

1. 父类（静态变量、静态语句块块 执行一次）
2. 子类（静态变量、静态语句块 执行一次）
3. 父类（实例变量、普通语句块）
4. 父类（构造函数）
5. 子类（实例变量、普通语句块）
6. 子类（构造函数）

```java
对类的主动使用：
    1. 创建类的实例
    2. 访问某个类或者接口的静态变量，或者对该静态变量赋值。
    3. 调用类的静态方法。
    4. 反射（Class.forName）
    5. 初始化类的子类
    6. java虚拟机启动时被标明为启动类的类
public class Test {
    Person person = new Person("Test");
    static{
        System.out.println("test static");
    }
    public Test() {
        System.out.println("test constructor");
    }
    public static void main(String[] args) {
        new MyClass();
    }
}

class Person{
    static{
        System.out.println("person static");
    }
    public Person(String str) {
        System.out.println("person "+str);
    }
}

class MyClass extends Test {
    Person person = new Person("MyClass");
    static{
        System.out.println("myclass static");
    }
    public MyClass() {
        System.out.println("myclass constructor");
    }
}
输出结果为：
test static
myclass static
person static
person Test
test constructor
person MyClass
myclass constructor

为什么输出结果是这样的？我们来分析下这段代码的执行过程：
找到main方法入口，main方法是程序入口，但在执行main方法之前，要先加载Test类
加载Test类的时候，发现Test类有static块，而是先执行static块，输出test static结果
然后执行new MyClass(),执行此代码之前，先加载MyClass类，发现MyClass类继承Test类，而是要先加载Test类，Test类之前已加载
加载MyClass类，发现MyClass类有static块，而是先执行static块，输出myclass static结果
然后调用MyClass类的构造器生成对象，在生成对象前，需要先初始化父类Test的成员变量，而是执行Person person = new Person("Test")代码，发现Person类没有加载
加载Person类，发现Person类有static块，而是先执行static块，输出person static结果
接着执行Person构造器，输出person Test结果
然后调用父类Test构造器，输出test constructor结果，这样就完成了父类Test的初始化了
再初始化MyClass类成员变量，执行Person构造器，输出person MyClass结果
最后调用MyClass类构造器，输出myclass constructor结果，这样就完成了MyClass类的初始化了
```

#### 泛型

```java
public class Box<T> {
    // T stands for "Type"
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

##### 为什么使用泛型

使代码可以被不同类型的对象重复使用。典型的使用场景是集合，如果没有泛型，我们要么需要为不同的对象编写集合类，这样存在大量重复代码。或者编写通用的Object集合类，但这样做需要在使用之前进行强制类型转换。另外，在放入元素的时候也没有类型检查，任何类型的对象都可以放入集合，在使用时进行类型转换可能会发生 ClassCastException 类型转换异常。

泛型的好处：

增强代码可读性和安全性（提供编译期类型检查）。

##### 泛型的实现

java 泛型是伪泛型，是在编译器层面通过**泛型擦除**实现的。在编译期间，所有的泛型信息都会被擦除掉，以类型界限代替。在使用泛型的时候，编译器也会帮我们自动进行类型转换。

##### 通配符

**限定通配符**：对类型进行了限制。

&lt;? extends T&gt; 确保类型必须是T的子类来设定类型的上界。<br>
&lt;? super T&gt; 确保类型必须是T的父类来设定类型的下界。

**非限定通配符**：&lt;?&gt;

#### 文件与IO

![image-20200220140633788](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104757.png)

1.Java IO是采用的是装饰模式，即采用**处理流**来包装**节点流**的方式，来达到代码通用性。

2.处理流和节点流的区分方法，**节点流**在新建时需要一个数据源（文件、网络）作为参数，而**处理流**需要一个节点流作为参数。

3.**处理流**的作用就是提高代码通用性，编写代码的便捷性，提高性能。

4.**节点流**都是对应抽象基类的实现类，它们都实现了抽象基类的基础读写方法。其中read（）方法如果返回-1，代表已经读到数据源末尾。

![image-20210305213044888](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104758.png)

##### IO  NIO BIO  AIO 

什么是阻塞和非阻塞，什么是同步和异步

同步和异步是针对应用程序和内核的交互而言的，
同步指的是用户进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否就绪

而异步是指用户进程触发 IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知。

阻塞和非阻塞是针对于进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式

阻塞方式下读取或者写入函数将一直等待

非阻塞方式下，读取或者写入函数会立即返回一个状态值。

![image-20210305205609457](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104759.png)

```
一般来说 I/O 模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞 IO
同步阻塞 IO：在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。JAVA 传统的 IO 模型属于此种方式！

同步非阻塞 IO:在此种方式下，用户进程发起一个 IO 操作以后边可返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 JAVA 的 NIO 就属于同步非阻塞 IO。

异步阻塞 IO：此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！

异步非阻塞 IO:在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为真正的 IO 读取或者写入操作已经由内核完成了。
```

##### NIO原理

![image-20210316115415231](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104800.png)



![image-20210305210736184](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104801.png)

![image-20210305210750572](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104802.png)

##### select/epoll 

![image-20210305210453472](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104803.png)

#### 异常

![image-20210305210951921](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104804.png)

![image-20210305210931353](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104805.png)

#### 序列化

![image-20210305211157202](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104806.png)

![image-20210305211140190](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104807.png)

![image-20210305211219663](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104808.png)

![image-20210305211242847](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104809.png)

#### 反射

![image-20210305204941639](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104810.png)

#### java各版本的特性

##### JDK1.5

1.**泛型**、2. 自动装箱/拆箱、3. for-each、4. static、import、5. 变长参数、协变返回类型（实际返回类型可以是要求的返回类型的一个子类型）、6. 枚举

##### JDK1.6

1.**增强的 for 循环**、2. 监视和管理、3. 插入式注解处理、4. 安全性

##### JDK1.7

1.模块化新特性、2. 多语言支持、3. 改善开发效率、4. 改善执行效率、5. **提供了新的垃圾回收器 G1**

##### JDK1.8

1. 接口允许默认方法 / 扩展方法

   default 关键字

2. 方法与构造函数引用

   允许使用 :: 关键字来传递方法或者构造函数引用

3. Lambda

   - 表达式：无需再使用传统匿名对象方式

   - 函数式接口

     每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 

   - 访问局部变量：可以直接在lambda表达式中访问外层的局部变量

   - 访问对象字段与静态变量

     和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的。

   - 访问接口的默认方法

     JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。

### Java集合

#### 集合总览

arraylist数组实现，随机访问快；linklist链表实现，插入删除快

hashset使用hash散列,获取元素很快，Treeset使用红黑树，按照比较结果升序保存，linkedhashset用来链表按照被添加的顺序保存，用hash保留查找速度(set中元素不可重复)

hashmap没有顺序，查找快，Treemap按照比较结果升序保存key ,LinkedHashMap按照插入结果保存Key，保留查找速度

Vector ,Hashtable,Stack弃用

点框表示接口，实框表示具体类，空心箭头表示特定类实现接口，实心箭头表示某类可以生成箭头所指类的对象

![image-20200210163111068](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104812.png)

#### ArrayList

使用场景：ArrayList的底层是一个数组，适合快速匹配，不适合频繁的增删

**允许**add null 值，会自动扩容，其中size(),isEmpty(),get(),add()方法的复杂度为O(1)

使用Collentions.synchronizedList()，实现线程安全或者Vector也可（Vector在方法上加的synchronized锁）

调用无参构造函数的时候，在JDK1.8默认为空数组（**DEFAULT_EMPTY_ELEMENTDATA** = {}），数字大小为10是我们第一次调用add方法是进行扩容的数组大小
若我们在执行构造函数传入的数组大小为0时，它使用的不是DEFAULT_EMPTY_ELEMENTDATA，而是另一个空数组**EMPTY_ELEMENTDATA** = {}（这个知识点面试没说过）

**add方法的过程**
先确定数组大小是否足够，如果我们创建ArrayList的时候指定了大小，那么则以给定的大小创建一个数组，否则默认大小为10；容量够大的情况，直接赋值；如果容量不够大，则进行扩容方法grow()，扩容的大小为原来大小的1.5倍（newCapicity = oldCapicity + oldCapicity >> 1，其中>>1，右移一位除以2），如果扩容后的大小还不够的话，则会将数组大小直接设置为我们需要的大小，扩容的最大值为Integer.MAX_VALUE，之后会调用Arrays.copyOf()方法将原数组中的数组复制过来
其中Arrays.copyOf()底层调用的是System.arrayCopy()，大家可以去简单了解下

**remove方法**
该方将被删除位置后的元素**向前复制**，底层调用的也是System.arrayCopy()方法，复制完成后，将数组元素的最后一个设置为null（因为向前复制一个位置，所以最后位置的元素是重复的），这样就解决了复制重复元素的问题

迭代器和增强for是一样的（这是一个Java语法糖，我后边还会再写语法糖相关的），过程中会判断modCount的值是否符合循环过程中的期望，如果不符合的话则会抛出并发修改异常，比较常见的情况就是在增强for中进行删除操作

**随机访问**

实现了 RandomAccess 接口，因此**支持随机访问**，这是理所当然的，因为 ArrayList 是基于数组实现的。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

基于数组实现，保存元素的**数组使用 transient 修饰**，该关键字声明数组默认不会被序列化。这是 ArrayList 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。ArrayList 重写了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那么部分内容。

```java
transient Object[] elementData; // non-private to simplify nested class access
```

数组的**默认大小为 10**。

```java
private static final int DEFAULT_CAPACITY = 10;
```

删除元素时需要调用 System.arraycopy() 对元素进行复制，因此**删除操作成本很高**。

```java
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
```

添加元素时使用 ensureCapacity() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，使得新容量为**旧容量的 1.5 倍**（oldCapacity + (oldCapacity >> 1))。扩容操作需要把原数组整个复制到新数组中，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。

```java
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

##### Iterator和ListIterator区别

Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

##### ArrayList、LinkedList、Vector

![image-20210307201033444](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104813.png)

![image-20210307201305145](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104814.png)

##### 快速失败(fail-fast) 和安全失败(fail-safe)

![image-20210307201414967](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104815.png)

##### RandomAccess 接⼝

查看源码我们发现实际上  RandomAccess 接⼝中什么都没有定义。所以，在我看来RandomAccess 接⼝不过是⼀个标识罢了。标识什么？ 标识实现这个接⼝的类具有随机访问功能。
在  binarySearch?) ⽅法中，它要判断传⼊的 list 是否  RamdomAccess 的实例，如果是，调⽤ indexedBinarySearch() ⽅法，如果不是，那么调⽤ iteratorBinarySearch() ⽅法

##### ArrayList扩容

底层其实是调用了`Arrays.copyOf`方法来进行扩充数组容量的。

`ArrayList`里面有两个概念，一个是`capacity`，它表示的就是“容量”，其实质是数组`elementData`的长度。而`size`则表示的“存放的元素的个数”。

在JDK1.8中，如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时（即添加第一个元素时），才真正分配容量，默认分配容量为10；当容量不足时（容量为size，添加第size+1个元素时），先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容。

ArrayList的最大容量为Integer.MAX_VALUE

**为什么需要手动扩容？**试想一下，如果用户已经知道即将存入大量的元素，比如目前有20个元素，即将存入2000个。那这个时候使用自动扩容就会扩容多次。而手动扩容可以一次性扩容到2000，可以提高性能。

**ArrayList有缩容吗？**

`ArrayList`没有缩容。无论是`remove`方法还是`clear`方法，它们都不会改变现有数组`elementData`的长度。但是它们都会把相应位置的元素设置为`null`，以便垃圾收集器回收掉不使用的元素，节省内存。

##### Collections.sort  原理

![image-20210307200607804](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104816.png)

####  CopyOnWriteArrayList

- 线程安全的，通过锁 + 数组拷贝 + volatile 保证线程安全（底层数组被volatile修饰） 
- 每次进行数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作之后再赋值回去 
- 对数组的操作，一般分为四步
  1 加锁
  2 从原数组中拷贝出新数组
  3 在新数组上进行操作，并把新数组赋值给原引用
  4 解锁 
- 已经加锁了，为什么还需要拷贝新数组？
  因为在原数组上进行修改，没有办法触发volatile的可见性，需要修改内存地址，即将新拷贝的数组赋值给原引用 
- 在进行写操作的时候，是能读的，但是读的数据是老数组的，能保证数组最终的一致性，不能保证实时一致性； 
- 存在内存占用问题，写时复制比较影响性能

#### HashMap

在JDK1.8之前，哈希表底层采用**数组+链表**实现，而JDK1.8中，哈希表存储采用**数组+链表+红黑树**实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

![image-20210305214229565](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104817.png)

![哈希流程图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104818.png)

```java
public class HashMap<K,V> extends AbstractMap<K,V> 
	implements Map<K,V>, Cloneable, Serializable {

	 /**
     * HashMap的默认初始容量大小 16
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

    /**
     * HashMap的最大容量 2的30次方
     */
    static final int MAXIMUM_CAPACITY = 1 << 30;

    /**
     * 负载因子，代表了table的填充度有多少，默认是0.75。当数组中的数据大于总长度的0.75倍时
     * HashMap会自动扩容，默认扩容到原长度的两倍。为什么是两倍，而不是1.5倍，或是3倍。length=2的n次方，h&(length-1)==h%length
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * 默认阈值，当桶(bucket)上的链表长度大于这个值时会转成红黑树，put方法的代码里有用到
     * 在jdk1.7中链表就是普通的单向链表，很多数据出现哈希碰撞导致这些数据集中在某一个哈希桶上，
     * 因而导致链表很长，会出现效率问题，jdk1.8对此做了优化，默认当链表长度大于8时转化为红黑树
     */
    static final int TREEIFY_THRESHOLD = 8;
    
    /**
     * 和上一个的阈值相对的阈值，当桶(bucket)上的链表长度小于这个值时红黑树退化成链表
     */
    static final int UNTREEIFY_THRESHOLD = 6;
    
    /**
     * 用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap  * 的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException
     */
    transient int modCount;
    
}
```

##### hashcode 的计算

![image-20210305214636891](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104819.png)

![image-20210305214838703](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104820.png)

```java
//计算hash，扰动函数
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
//计算索引位置：
static int indexFor(int h, int length) {
    return h & (length-1);
}
int hash = hash(key.hashCode());
int i = indexFor(hash, table.length);
```

##### 扩容机制

![image-20210305214934547](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104821.png)

![image-20210305220438552](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104822.png)

**jdk1.8 扩容元素的位置要么是在原位置，要么是在原位置加原数组长度的位置**。

##### 负载因子0.75

泊淞分布啊

简单翻译一下就是在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布，注释同时给出了桶中元素个数和概率的对照表。

从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。0.00000006，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。

##### get方法（不加锁）

![image-20210305215442825](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104823.png)

##### put方法

![哈希流程图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104818.png)

```java
public V put(K key, V value) {
    //调用putVal()方法完成
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    //判断table是否初始化，否则初始化操作
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    //计算存储的索引位置，如果没有元素，直接赋值
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        //节点若已经存在，执行赋值操作
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        //判断链表是否是红黑树
        else if (p instanceof TreeNode)
            //红黑树对象操作
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            //为链表，
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    //链表长度8，将链表转化为红黑树存储
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                //key存在，直接覆盖
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    //记录修改次数
    ++modCount;
    //判断是否需要扩容
    if (++size > threshold)
        resize();
    //空操作
    afterNodeInsertion(evict);
    return null;
}
```

##### 对key为NULL的特别处理

![image-20210305215635335](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104824.png)

![image-20210305215617963](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104825.png)

```java
private V putForNullKey(V value) {
    // 若key==null，则将其放入table的第一个桶，即 table[0]
    for (Entry<K,V> e = table[0]; e != null; e = e.next) {   
        if (e.key == null) {   // 若已经存在key为null的键，则替换其值，并返回旧值
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;        // 快速失败
    addEntry(0, null, value, 0);       // 否则，将其添加到 table[0] 的桶中
    return null;
}
```

##### 线程不安全

添加删除和扩容时有问题

要想实现线程安全，那么需要调用 collections 类的静态方法 synchronizeMap（）实现

![image-20210305215705647](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104826.png)

#####  key 可以为任意对象或数据类型吗？

![image-20210305220242863](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104827.png)

![image-20210305220252516](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104828.png)

##### 树化操作的阈值是8和6？

[链表]()的查询时间复杂度为O(n)，[红黑树]()的查询时间复杂度为O(logn)，在数据量不多的时候，使用[链表]()比较快，只有当数据量比较大的时候，才会转化为[红黑树]()，但是[红黑树]()占用的空间大小是[链表]()的2倍，考虑到时间和空间上的损耗，所以要设置边界值（其实[链表]()长度为8的概率很低，在HashMap注释中写了，出现的概率不择千万分之一，[红黑树]()只是为了在极端情况下来保证性能）

为什么还要有一个阈值是6？
避免频繁的进行树退化为[链表]()的操作，因为退化也是有开销的，当我们移除一个[红黑树]()上的值的时候，如果只有阈值8的话，那么它会直接退化，我们若再添加一个值，它有可能又需要变为[红黑树]()了，添加阈值6相当于添加了一个缓冲

##### HashMap - JDK 1.8

**链表转红黑树**

一个桶存储的链表长度大于 8 时会将链表转换为红黑树。

**解决扩容时的死循环问题**

使用lo和hi分别指向两个新的链表。原来的链表中的元素扩容后位置不变，就放到lo中，位置改变，就放到hi中。采用尾插法进行移动，因此扩容之后元素顺序不改变，也不会发生死循环。而JDK1.7采用头插法则会改变元素顺序。最后分别将lo和hi放入新hashMap的桶中。

#### ConcurrentHashMap

一个 ConcurrentHashMap 维护一个 **Segment 数组,**一个 Segment 维护一个 **HashEntry 数组**。Segment 继承了 **ReentrantLock**，表明每个 segment 都可以当做一个锁。这样对每个 segment 中的数据需要同步操作的话都是使用每个 segment 容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的 segment。 JDK1.8 的时候已经摒弃了  Segment 的概念，⽽是直接⽤  **Node 数组+链表+红⿊树**的数据结构来实现，并发控制使⽤  **synchronized 和 CAS** 来操作。（JDK1.6 以后 对  synchronized 锁做了很多优化） synchronized 只锁定当前**链表或红⿊⼆叉树的⾸节点**，这样只要 hash 不冲突，就不会产⽣并发，效率⼜提升 N 倍。整个看起来就像是优化过且线程安全的  HashMap ，虽然在 JDK1.8 中还能看到Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

![image-20210305222249650](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104829.png)

![image-20210305222139377](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104830.png)

![image-20210305222500466](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104831.png)

#####  size 操作

每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。

```java
/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;
```

在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。

ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。

尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。

如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。

##### Get 原理

![image-20210307195131476](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104832.png)先判断一下 count != 0；count 变量表示 segment 中存在 entry的个数。如果为 0 就不用找了。

假设这个时候恰好另一个线程 put 或者 remove了这个 segment 中的一个 entry，会不会导致两个线程看到的 count 值不一致呢？ **依赖 volatile 关键字保证可见**。看一下 count 变量的定义： transient volatile int count;

![image-20210307195102182](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104833.png)

##### Put原理

- 如果没有初始化就先进行初始化过程
- 如果没有hash冲突就直接CAS插入
- 如果存在hash冲突，就加锁来保证线程安全，链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入

下图大致描述了 put 一个新的 entry 的过程

![image-20210307195250159](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104834.png)

删除

![image-20210307195521157](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104835.png)

作者：方圆想当图灵
链接：https://www.nowcoder.com/discuss/634573?type=2&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack
来源：牛客网



##### ConcurrentHashMap（JDK1.8）

- 底层基于CAS + synchronized实现，所有操作都是线程安全的，允许多个线程同时进行put、remove等操作 
- 底层数据结构：数组、[链表]()和[红黑树]()的基础上还添加了一个转移节点，在扩容时应用 
- table数组被volatile修饰 
- 其中有一个比较重要的字段，sizeCtl= -1 时代表table正在初始化
  table未初始化时，代表需要初始化的大小
  table初始化完成，表示table的容量，默认为0.75table大小 
- put过程
  key和value都是不能为空的，否则会产生空指针异常，之后会进入自旋（for循环自旋），如果当前数组为空，那么进行初始化操作，初始化完成后，计算出数组的位置，如果该位置没有值，采用CAS操作进行添加；如果当前位置是转移节点，那么会调用helptransfer方法协助扩容；如果当前位置有值，那么用synchronized加锁，锁住该位置，如果是[链表]()的话，采用的是尾插发，如果是[红黑树]()，则采用[红黑树]()新增的方法，新增完成后需要判断是否需要扩容，大于sizeCtl的话，那么执行扩容操作 
- 初始化过程
  在进行初始化操作的时候，会将sizeCtl利用CAS操作设置为-1，CAS成功之后，还会判断数组是否完成初始化，有一个双重检测的过程
  过程：进入自旋，如果sizeCtl < 0, 线程礼让（Thread.yield()）等待初始化；否则CAS操作将sizeCtl设置为-1，再次检测是否完成了初始化，若没有则执行初始化操作

##### HashMap与HashTable区别

![image-20210307195855649](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104836.png)

##### HashMap与ConcurrentHashMap区别

![image-20210307195927117](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104837.png)

##### ConcurrentHashMap与HashTable区别

![image-20210307200123574](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104838.png)

#### LinkedHashMap

![image-20210307200236633](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104839.png)

**LinkedHashMap 实现LRU 缓存**

- 设定最大缓存空间 MAX_ENTRIES  为 3；
- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；
- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。

```java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}
public static void main(String[] args) {
    LRUCache<Integer, String> cache = new LRUCache<>();
    cache.put(1, "a");
    cache.put(2, "b");
    cache.put(3, "c");
    cache.get(1);
    cache.put(4, "d");
    System.out.println(cache.keySet());
}
//[3, 1, 4]
```

#### HashSet

对于 HashSet 而言，它是基于 HashMap 实现的,可以看出 hashset 底层是 hashmap 但是存储的是一个对象，hashset 实际将该元素 e 作为 key 放入 hashmap,当 key 值(该元素 e)相同时，只是进行更新 value，并不会新增
加，所以 set 中的元素不会进行改变。

![image-20210307200433269](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104840.png)

![image-20210307200449786](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104841.png)

![image-20210307200457322](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104842.png)

#### PriorityQueue

Java中PriorityQueue通过二叉小顶堆实现，可以用一棵完全二叉树表示。PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素
排序的比较器。PriorityQueue 不允许 null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))。

![image-20210305203257400](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104843.png)

**添加元素 add()和 offer()**
原理：添加元素位于末尾，同时队列长度加 1，然后这个元素与它的父节点进行比较，

如果比父节点小那么就与父节点进行交换，然后再与交换后的位置的父节点进行比较，
重复这个过程，直到该元素的值大于父节点结束这个过程。
区别: add(E e)和 offer(E e)的语义相同，都是向优先队列中插入元素，只是 Queue 接口规
定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回 false。

![image-20210305203430221](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104844.png)

**寻找队列的头部元素 element()和 peek()头部元素**
element()和 peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回 null。 时间复杂度为 1，根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0 下标处的那个元素既是堆顶元素。所以直接返回数组 0 下标处的那个元素即可。

**最大堆 获取数组中最小的几个数 最小堆  获取数组中最大的几个数**

**删除元素 remove() 和 poll()**
区别:remove()和 poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回 null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。
原理：该方法的作用是从 k 指定的位置开始，将 x 逐层向下与当前点的左右孩子中较小的那个交换，直到 x 小于或等于左右孩子中的任何一个为止

![image-20210305203627842](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104845.png)

#### WeakHashMap

**存储结构**

WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。

WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。

```java
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V>
```

**ConcurrentCache**

Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。

ConcurrentCache 采取的是分代缓存：

- 经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；
- 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。
- 当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。
- 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。

```java
public final class ConcurrentCache<K, V> {

    private final int size;

    private final Map<K, V> eden;

    private final Map<K, V> longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap<>(size);
        this.longterm = new WeakHashMap<>(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() >= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
```

### JVM

![image-20210308100929752](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105244.png)

<!--more-->

#### JMM 内存模型

JMM (Java Memory Model)是 Java 内存模型,JMM 定义了程序中各个**共享变量的访问规则**,即在虚拟机中将变量存储到内存和从内存读取变量这样的底层细节.并提供了内置解决方案（happen-before 原则）及其外部可使用的同步手段(synchronized/volatile 等)，确保了程序执行在多线程环境中的应有的 **原子性，可视性及其有序性**。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105245.png)

JMM 规定了所有的变量都存储在主内存 规定了所有的变量都存储在主内存（ （Main Memory） ） 中 。 每个线程还有自己的工作内存（ 己的工作内存（Working Memory ）,线程的工作内存中保存了该线程使用到的变量的 线程的工作内存中保存了该线程使用到的变量的**主内存的副本拷贝**，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行 ， 而不能直接读写主内存中的变量（ （volatile 变量仍然有工作内存的拷贝 变量仍然有工作内存的拷贝 ， 但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，**线程之间值的传递都需要通过主内存**来完成.

##### JMM 的 happens-before 原则

![image-20210307211631353](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105246.png)

##### 为什么要实现内存模型

![image-20210307211402249](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105247.png)

#### 内存分区

![image-20210307211804692](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105248.png)

![image-20210307211854961](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105249.png)

##### 什么是堆中的永久代

答： 永久代是用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类，永久代中一般包含：

```
类的方法(字节码...)
类名(Sring 对象)
.class 文件读到的常量信息
class 对象相关的对象列表和类型列表 (e.g., 方法对象的 array).
JVM 创建的内部对象
JIT 编译器优化用的信息
```

#####  程序计数器为什么是私有的

程序计数器主要有下⾯两个作⽤：

1. 字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、选择、循环、异常处理。

2. 在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时候能够知道该线程上次运⾏到哪⼉了。

  需要注意的是，如果执⾏的是 native ⽅法，那么程序计数器记录的是 undefined 地址，只有执⾏的是 Java 代码时程序计数器记录的才是下⼀条指令的地址。
  所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执⾏位置**。

##### 对象初始化过程 newA()

Student s = new Student() 为例
1.首先查看类的符号引用，看是否已经在常量池中，在说明已经加载过了，不在的话需要进行类的加载，验证，准备，解析，初始化的过程。
2.上诉过程执行完毕以后，又将 Student 加载进内存，也就是存储 Student.class的字段信息和方法信息，存储到方法区中
字段信息：存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。
方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。
3。然后在自己的线程私有的虚拟机栈中，存储该引用，然后在每个线程的私有空间里面去分配空间存储 new Student()
4，对类中的成员变量进行默认初始化（设置0值，设置对象头）
5，对类中的成员变量进行显示初始化
6，有构造代码块就先执行构造代码块，如果没有，则省略
7，执行构造方法，通过构造方法对对对象数据进行初始化
8，堆内存中的数据初始化完毕，把内存值复制给 s 变量

##### 分配内存两种方式

![image-20210417165515649](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210417165517.png)

##### 并发下对象分配内存时线程安全

例如同时创建对象A和B，在给A分配内存时，指针还未来得及移动的情况下，B又在原来的基础上分配内存,两种解决方案：

1. 虚拟机采取**CAS操作**配上**失败重试**来保证更新操作的原子性
2. 每个线程在java堆eden区中分配一小块区域，称为**本地线程分配缓冲**(TLAB)，哪个线程要分配内存时，就在自己的TLAB上分配。

##### 对象的内存布局

- 在HotSpot虚拟机中，对象的内存布局可以分为：**对象头**，**实例数据**，**对齐填充**
- **对象头**包括两部分的信息：
  1. 存储对象自身运行时数据，如哈希码，**GC分代年龄**，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等
  2. **类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例
- **实例数据**是对象真正存储的有效信息，也是在程序段中所定义的各种类型字段(包括父类的)。

![图片说明](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210513111121.png)

##### 对象的访问定位方式

通过栈上的reference数据来操作堆上的对象有两种访问方式：

1. **句柄**。java堆中专门划分出一个句柄池，reference存储的是句柄的地址，而句柄包含了对象实例数据和类型数据各自的具体地址信息。

   优点：对象移动时，只需要修改句柄中的指针即可，reference不需要修改

   ![image-20200423105805390.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105250.png)

2. **直接指针**。reference直接存储对象地址

   优点：节省了一次地址定位的时间

   ![image-20200423105905341.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105251.png)

##### java堆内存溢出

```java
/**
     * VM:-verbose:gc
     * -Xms20M
     * -Xmx20M
     * -Xmn10M
     * -XX:+PrintGCDetails
     * -XX:SurvivorRatio=8
     */
static class OOMObject{

}
public static void main(String[] args) {
    List<OOMObject> list=new ArrayList<>();
    while (true){
        list.add(new OOMObject());
    }
}
```

通过设置参数：`-XX:+HeapDumpOnOutOfMemoryError`可以在虚拟机出现内存溢出时Dump出当前的内存堆转储快照。

然后用内存映像分析工具(VisualVM)对Dump出的堆转储快照进行分析，重点是确认内存中的对象是否有必要存在，即判断是发生了**内存泄漏**还是**内存溢出**。

- 如果是**内存泄漏**，可进一步查看泄漏对象到GC Roots的引用链，就可以找到泄漏对象是怎么和GC Roots相连的导致垃圾回收器无法自动回收它们。
- 如果**内存溢出**,那就应当检查虚拟机的堆参数，能不能调大一点。

##### 对象的强、软、弱和虚引用

强引用>软引用>弱引用>虚引用

- **强引用**。类似Object obj=new Object()这类的引用，只要强引用在，垃圾回收器就无法回收掉引用的对象。

- **软引用**。被软引用关联的对象只有在**内存不够**的情况下才会被回收，通常用在对内存敏感的程序中。

  ```
  SoftReference<Object> sf=new SoftReference<>(new Object());
  ```

- **弱引用**。被弱引用关联的对象只能活到**下次垃圾收集发生之前**。当垃圾收集器工作时，弱引用关联的对象总会被回收

  ```
  WeakReference<Object> wf=new WeakReference<>(new Object());
  ```

- **虚引用**。虚引用对对象的生存时间不会构成影响，也无法通过虚引用来获取对象实例。

  ```
  ReferenceQueue<Object> rq=new ReferenceQueue<>();   //引用队列
  PhantomReference<Object> pr=new PhantomReference<>(new Object(),rq);
  System.out.println(pr.get());  //null
  System.out.println(rq.poll()); //null
  ```

##### 如何减少 GC 的次数

```
1.对象不用时最好显示置为 NULL
一般而言，为 NULL 的对象都会被作为垃圾处理，所以将不用的对象置为NULL，有利于 GC 收集器判定垃圾，从而提高了 GC 的效率。
2.尽量少使用 System,gc()
此函数建议 JVM 进行主 GC，会增加主 GC 的频率，增加了间接性停顿的次数。
3.尽量少使用静态变量
静态变量属于全局变量，不会被 GC 回收，他们会一直占用内存
4.尽量使用 StringBuffer,而不使用 String 来累加字符串
5.分散对象创建或删除的时间
集中在短时间内大量创建新对象，特别是大对象，会导致突然需要大量内存，JVM 在这种情况下只能进行主 GC 以回收内存，从而增加主 GC 的频率。
6.尽量少用 finaliza 函数,会加大 GC 的工作量。
7.如果有需要使用经常用到的图片，可以使用软引用类型，将图片保存在内存中，而不引起 outofmemory
8.能用基本类型入 INT 就不用对象 Integer
9.增大-Xmx 的值
```

##### OutOfMemory和StackOverflow

**如何产生OutOfMemory？**
堆内存不够用了，会抛出这个OutOfMemoryError 

**你能用什么方法来抛出这个Error？**
可以通过把堆内存通过参数-Xmx调小一些，然后写一个while的死循环，不断的执行append操作 

**那如何产生Stack Overflow Error？**
这个是栈溢出，我们可以通过写两个方法，A方法调用B方法，B方法在调用A方法，这样可以产生这个Error

**你还知道其他的JVM参数嘛？**
知道，-Xms指定堆的初始大小，-Xss指定栈的大小，-XX:+HeapDumpOnOutOfMemoryError内存快照的Dump文件，可以分析Dump文件来查看OutOfMemoryError 

**列举一些垃圾回收的参数**
指定期望的GC的停顿时间（在Parallel Scavenge、Parallel Old和G1回收器中指定）：-XX:MaxGCPauseMills
改变G2的Rigion容量：-XX:G1HeapRegionSize
年轻代大小:-Xmn
比例：-XX:Sur[vivo]()rRatio=8(8:1:1)
大对象直接进入老年代的阈值：-XX:PretenureSizeThreshold

#### GC  算法（YGC and  FGC）

![image-20210308101949605](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105252.png)

##### 判断一个对象是否存活?(GC 对象判定方法)

引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）的情况
引用链法(可达性分析法）： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，如果有一条链能够到达 GC ROOT 就说明，不能到达 GC ROOT 就说明

![image-20210307212135054](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105253.png)

![image-20210307213754774](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105254.png)

##### Minor GC 和 Full GC

* Minor GC：回收新生代，复制算法，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
* Full GC / Major GC：回收老生代和新生代，标记清除整理算法，老生代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。出现了 Full GC，经常会伴随至少一次 Minor GC。

![image-20210308101949605](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105252.png)

堆里面分为新生代和老生代（java8 取消了永久代 Perm Space，采用了 Metaspace,字符串常量存放到堆内存中），新生代包含 **Eden+Survivor 区**，1 部分 Eden 区较大，1 部分 Survivor 比较小,survivor 区里面分为 from 和 to 区，**8:1:1**,内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后(年龄阈值15，可以通过-XX:MaxTenuringThreshold 来设置)，存活下来的对象会被移动到老年区，当 **JVM 内存不够**用的时候，会触发 Full GC，清理 JVM 老年区。
当**新生区满了**之后会触发 YGC,先把存活的对象放到其中一个 Survice区，然后进行垃圾清理。一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。

FGC 就是标记整理或者是标记清除算法来清除老年代。

##### 内存分配与回收策略

**对象优先在Eden区分配**

* 大多数情况下，对象在新生代的 Eden 区上分配，**当 Eden 空间不够时，发起 Minor GC**
* 若启动了本地线程分配缓冲，则将按线程优先在 TLAB （本地线程分配缓冲）上分配

**大对象直接进入老生代**

* 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组

* 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象

* -XX:PretenureSizeThreshold，大于此值的对象直接在老生代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

  该参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge收集器一般并不需要设置，若遇到必须使用该参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。

**长期存活的对象进入老年代**

* 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄（默认 15）则移动到老生代中。
* -XX:MaxTenuringThreshold 用来定义年龄的阈值。

**动态对象年龄判定**

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老生代，如果在 Survivor 中**相同年龄所有对象大小的总和大于 Survivor 空间的一半**，则年龄大于或等于该年龄的对象可以直接进入老生代，无需等到 MaxTenuringThreshold 中要求的年龄。

**空间分配担保**

在进行 Minorgc前，虚拟机会查看 Handle Promotion Failure设置值是否为True，那么说明允许担保失败（会检查虚拟机老年代剩余空间的大小与平均晋升到老年代空间的大小，如果大于说明“可能"是安全的），为True那么进行一次 Minora，如果此时刻发现进入到老年代的新对象的大小是大于老年代的剩余空间，说明担保失败了，只能进行一次Fu|GC清除老年代的剩余空间。

**JDK 6 Update 24 之后不再使用 HandlePromotionFailure  参数**，规则变为只要**老生代的连续空间大于新生代对象总大小或者历次晋升的平均大小**就会进行Minor GC，否则将进行Full GC。

**实例：**

1. 内存大小设定

```java
// 限制堆大小为 20M，不可扩展，10M 分配给新生代、10M 分配给老生代
-Xms20M -Xmx20M -Xmn10M
// 决定新生代中 Eden：Survivor = 8：1
-XX:SurvivorRatio=8
```

2. 内存分配

```java
byte[] allocation1，allocation2，allocation3，allocation4;
allocation1=new byte[2*_1MB];
allocation2=new byte[2*_1MB];
allocation3=new byte[2*_1MB];
allocation4=new byte[4*_1MB]; // 出现一次Minor GC
```

​	分配 allocation4 对象的语句时会发生一次 Minor GC，这次 GC 的结果是新生代 6651KB 变为 148KB，而总内存占用量则几乎没有减少（因为 allocation1、allocation2、allocation3 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。

​	这次 GC 发生的原因是给 allocation4 分配内存的时候，发现 Eden 已经被占用了 6MB，剩余空间已不足以分配 allocation4 所需的 4MB 内存，因此发生 Minor GC。GC 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 Survivor 空间（ Survivor 空间只有 1MB 大小），所以**只好通过分配担保机制提前转移到老生代去。**

3. 结果

​	Eden 占用 4 MB（被 allocation4 占用），Survivor 空闲，老生代被占用 6MB（被allocation1、 allocation2、allocation3 占用）。

##### Full GC 触发条件

对于 Minor GC，其触发条件非常简单，**当 Eden 空间满时，就将触发一次 Minor GC**。而 Full GC 则相对复杂，有以下条件：

**调用 System.gc()**

只是**建议虚拟机执行 Full GC**，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

**老生代空间不足**

老生代空间不足的常见场景为前文所讲的大对象直接进入老生代、长期存活的对象进入老生代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老生代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老生代的年龄，让对象在新生代多存活一段时间。

**空间分配担保失败**

使用复制算法的 Minor GC 需要老生代的内存空间作担保，如果担保失败会执行一次 Full GC。

**JDK 1.7 及以前的永久代空间不足**

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 信息、Meta 信息、常量、静态变量等数据。GC 不会在主程序运行期对永久代区域进行清理。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

**Concurrent Mode Failure**

执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

#### 垃圾收集器  

![1553654058045.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105255.png)

**串行、并行与并发**

* 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
* 串行：**串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；**
* 并行：多条垃圾收集线程并行工作，但**此时用户线程仍处于等待状态**；
* 并发：**用户线程与垃圾收集线程同时执行**（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上。
* 除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

##### Serial收集器

![image-20210307212331377](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105256.png)

##### ParNew收集器

- ParNew收集器是Serial收集器的多线程版本，使用多条线程进行垃圾收集，新生代使用**复制**算法。
- 默认开启线程数与 CPU 的数量相同
- 它是 **Server** 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

![image-20200424094451166.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105257.png)

##### Parallel Scavenge收集器

与 ParNew 一样是并行多线程收集器，使用**复制**算法，新生代使用。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是**达到一个可控制的吞吐量**，因此它被称为 “**吞吐量优先**” 收集器。这里的**吞吐量指 CPU 用于运行用户程序的时间占总时间的比值**。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，**适合在后台运算而不需要太多交互的任务**。

提供了精确控制吞吐量的参数：

```java
-XX:MaxGCPauseMills		// 控制最大垃圾收集停顿时间
-XX:GCTimeRatio			// 垃圾收集时间占总时间的比率，即吞吐量的倒数，例如19，则表示垃圾收集时间							   占比为1/(1+19)=5%
```

* 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打开 **GC 自适应的调节策略（GC Ergonomics）**，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老生代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

```java
-XX:+UseAdaptiveSizePolicy  // 开关参数
```

##### Serial Old 收集器

![1557456534404.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105258.png)

是 **Serial 收集器的老生代版本**，同样是一个**单线程**收集器（无法充分利用服务器多 CPU 的处理能力），使用 **”标记 - 整理“** 算法。该收集器主要是给 **Client** 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

* 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
* 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

##### Parallel Old收集器

![1557471744502.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105259.png)

JDK 1.6 中开始提供，是 Parallel Scavenge 收集器的老生代版本，使用**多线程**和 **”标记 - 整理“** 算法。

在JDK1.6之前，新生代使用 ParallelScavenge 收集器只能搭配老生代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了**在老生代同样提供吞吐量优先**的垃圾收集器，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

##### CMS收集器

![1557471755660.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105300.png)

CMS（Concurrent Mark Sweep）是一种以**获取最短回收停顿时间**为目标的收集器，Mark Sweep 指的是**标记 - 清除**算法。

分为以下四个流程：

* **初始标记：**仅仅只是**标记一下 GC Roots 能直接关联到的对象**，速度很快，**需要停顿**。

* **并发标记：**进行 **GC Roots Tracing** 的过程，它在整个回收过程中耗时最长，**不需要停顿**。

* **重新标记：**为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，**需要停顿**，时间长于初始标记、短于并发标记。

* **并发清除：****不需要停顿**。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

**缺点：**

* **吞吐量低**：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。

* **无法处理浮动垃圾，可能出现 Concurrent Mode Failure。**浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老生代快满的时候再回收。**如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure**，这时虚拟机将临时启用 **Serial Old** 来替代 CMS。

* **标记 - 清除**算法导致的空间碎片，往往出现老生代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

  可使用 ` -XX：+UseCMSCompactAtFullCollection` 参数（默认开启）在需要进行 Full GC 时开启内存碎片合并整理过程，该过程无法并发，导致停顿时间变长。

  可使用 `-XX：CMSFullGCsBeforeCompaction` 参数设置执行多少次不压缩的 Full GC 后进行带压缩的 Full GC（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。

##### G1收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

* 适用于**追求低停顿情况**，不适用于追求吞吐量的情况

1. G1收集器的特点：

   1. 并行与并发
   2. 分代收集
   3. 空间整合
   4. 可预测的停顿
2. G1收集器化整为零的思路，每个region都有一个Remembered Set区域
3. 一共有四个步骤：

   1. 初始标记（停止用户线程）
   2. 并发标记（时间较长，但是可以可用户并发进行）
   3. 最终标记（停止用户线程）
   4. 筛选回收（停止用户线程）

堆被分为新生代和老生代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和老生代一起回收。

![4cf711a8-7ab2-4152-b85c-d5c226733807.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105301.png)

**G1 把堆划分成多个大小相等的独立区域**（Region），区大小为 2 的幂，范围为 1M 到 32M，目标是根据最小的 Java 堆大小划分出约 2048 个区域。

新生代和老生代不再物理隔离，仅保留逻辑上的分代概念，每个分区都可能随着 G1 的运行在不同代之间前后切换。

![9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105302.png)

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收，**避免全内存扫描**。这种划分方法带来了很大的灵活性，使得**可预测的停顿时间模型**（软目标）成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个**优先列表**，每次根据允许的收集时间，**优先回收价值最大的 Region**，有计划地避免在整个 Java 堆中进行全区域的垃圾收集，确保在有限时间内获得最高的垃圾收集效率。

每个 Region 都有一个 **Remembered Set**，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![1557474325452.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105303.png)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

* 初始标记：

  标记 GC Roots 能直接关联到的对象并修改 TAMS（Next Top at Mark Set）的值，使下一阶段用户程序并发运行时能在正确可用的 Region 中创建新对象。需要停顿，但耗时很短。

* 并发标记：

  从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象。耗时较长，但可以与用户程序并发执行。

* 最终标记：

  为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要**停顿线程**，但是可并行执行。

* 筛选回收：

  首先，对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

**特点：**

* **并行与并发**：利用多个 CPU 缩短停顿时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作， G1 收集器仍然可以通过并发的方式使 Java 程序继续执行。
* **分代收集**：分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。
* **空间整合**：整体来看是基于 **“标记 - 整理”** 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 **“复制”** 算法实现的，这意味着运行期间不会产生内存空间碎片。
* **可预测的停顿**：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

##### CMS 与 G1 整体区别

- 两者都追求最短停顿时间，无法兼顾吞吐量

- **CMS 使用标记清除算法**实现，会导致空间碎片，提前触发 GC 

  **G1 使用标记整理算法**，不会导致空间碎片

- G1 中分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。

  **CMS 针对理整个老年代进行处理。G1可以回收新生代和老年代**

##### **总结**

|      收集器       |                      定义                      |                             特点                             |             垃圾算法              |                          应用场景                          |                   备注                   |
| :---------------: | :--------------------------------------------: | :----------------------------------------------------------: | :-------------------------------: | :--------------------------------------------------------: | :--------------------------------------: |
|      Serial       |        最基本、发展历史最长的垃圾收集器        |                      并发、单线程、高效                      |               复制                |              客户端模式下，虚拟机的新生代区域              |                                          |
|    Serial Old     |      Serial 收集器应用在老年代区域的版本       |                      并发、单线程、高效                      |            标记 - 整理            |              客户端模式下，虚拟机的老生代区域              |        CMS 的后备预案，失败时使用        |
|      ParNew       |           Serial 收集器的多线程版本            |                并发、多线程、性能低于 Serial                 |               复制                |              客户端模式下，虚拟机的新生代区域              |       唯一可配合 CMS 工作的收集器        |
| Parallel Scavenge |             ParNew 收集器的升级版              |      并发、多线程、自适应调节，以达到可控制吞吐量为目标      |               复制                |              服务器模式下，虚拟机的新生代区域              |                                          |
|   Parallel Old    | Parallel Scavenge 收集器应用在老年代区域的版本 |      并发、多线程、自适应调节，以达到可控制吞吐量为目标      |            标记 - 整理            |              服务器模式下，虚拟机的老生代区域              |                                          |
|        CMS        |        基于**标记 - 清除**算法的收集器         | 并行、单线程、垃圾收集停顿时间短，总吞吐量低，无法处理浮动垃圾，产生空间碎片 |            标记 - 清除            | 重视应用的响应速度、希望系统停顿时间最短的场景（如老年代） | 初始标记、并发标记、重新标记、并发清除、 |
|        G1         |            最新、技术最前沿的收集器            | 并行、多线程、垃圾回收效率高（可预测的停顿时间模型），分代收集、无空间碎片 | 新生代：复制、老生代：标记 - 整理 |        服务器端虚拟机的内存区域（含新生代与老生代）        | 初始标记、并发标记、最终标记、筛选回收、 |

##### 组合选择

* **单 CPU 或小内存，单机程序：**

  **-XX:+UseSerialGC：**新生代 Serial + 复制，老生代 SerialOld + 标记整理

* **多 CPU，需要最大吞吐量，如后台计算型应用：**

  **-XX:+UseParallelGC：**新生代 Parallel + 复制，老生代 ParallelOld + 标记整理

  **-XX:+UseParallelOldGC：**同上

* **多 CPU，追求低停顿时间，需要快速响应如互联网应用**

  **-XX:+UseConcMarkSweepGC：**新生代 ParNew + 复制，老生代 CMS +SerialOld 的收集器组合 + 标记清除

  **-XX:+UseG1GC：**整体采用标记整理，局部使用复制，不会产生碎片

####  Java 类加载机制 

##### Class文件字节码结构组织示意图

```
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类会可以有个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

![类文件字节码结构组织示意图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105304.png)

##### 类加载过程

![image-20210307214358957](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105305.png)

```
加载
    1. 通过一个类的全限名来获取定义此类的二进制节流。（实现这个代码模块就是类加载器）
    2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    3. 在内存中生成一个代表这个类的 java.lang.Class 对象,作为方法区这个类的各种数据的访问入口。
验证
    文件格式验证
    – [x] 是否以魔数 0xCAFEBABE 开头
    – [x] 主次版本号是否在当前虚拟机处理范围之内
    – [x] 常量池中的常量是否有不被支持的常量类型
    – [x] 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
    – [x] CONSTANTUtf8info 型的常量中是否有不符合 UTF8 编码的数据
    – [x] Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息
    – [x] 等等
    元数据验证
    – [x] 这个类是否有父类
    – [x] 这个类的父类是否继承了不准许被继承的类
    – [x] 如果这个类不是抽象类,是否实现了其父类或者接口之中要求实现的所有方法
    – [x] 类中的字段方法是否与父类产生矛盾
    –
    字节码验证
    – [x] 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
    – [x] 保证跳转指令不会跳转到方法体以外的字节码指令上
    – [x] 保证方法体重的类型转换是有效的
    符号引用验证
    – [x] 符号引用中通过字符串描述的全限定名是否找到相应的类
    – [x] 在指定的类中是否存在符合方法的字段描述符以及简单名称说描述的方法和字段
    – [x] 符号引用中的类、字段、方法的访问性是否被当前类访问
准备
    准备阶段是正式为类变量分配内存并设置类变量初始值(被static修饰的变量)的阶段,这些变
    量所使用的内存都将在方法区中进行分配
解析
	解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程
初始化
	初始化就是执行类构造器方法的过程
```

```
说说类加载的过程
类加载分三个阶段，加载、连接和初始化，其中连接阶段分为验证、准备和解析。
1 加载主要是加载二进制字节流，比如Class文件，在方法区中生成Class对象
2 验证阶段是确保Class文件中的字节流包含的信息是否符合《Java虚拟机规范》的全部约束要求，保证这些信息不会危害虚拟机的安全
（有文件格式验证、元数据验证、字节码验证、符号引用验证，我面试从没被问过具体的这几个阶段）
3 准备阶段是为类中定义的变量（静态变量）分配内存并设置变量的初始值，但是有一种特殊情况，被final修饰的话，则会直接赋值为我们要指定的值（初始值！就是0，false，null那种，初始化阶段才是我们程序员写的值，谨记）
4 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，有类和接口的解析，字段解析、方法解析和接口方法解析（符号引用是以一组符号来描述所引用的目标，它是编译原理方面的概念，有被模块到处或者开放的包，类和接口的全限定名，字段的名称和描述符，方法的名称和描述符，方法的句柄和方法类型，动态调用点和动态常量 《深入理解JVM 》 p218；直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄）
5 初始化阶段是类加载的最后一个步骤，它会收集所有为类变量赋值和静态语句块中的语句，为这些静态变量赋值
```

##### 双亲委派机制

**避免重复加载 + 避免核心类篡改**

![image-20210307214738509](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105306.png)

![image-20210307214648663](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105307.png)

#### JVM对锁的优化

- 自旋锁与自适应自旋：互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，如果我们可以通过上后面请求锁的线程自旋一会儿，那么将会避免线程切换的开销，但是它还是要占用处理器时间的，如果自旋时间很短的话，它的效果很好，否则长时间的自旋只会白白的浪费处理器时间，自旋的默认值是10次；自适应自旋意味着自旋次数不再是固定的了，而是由前一个在同一个锁上的自旋时间及锁的拥有者的状态来决定的，如果很可能获得到锁，那么将自旋等待的次数增多，否则直接省略掉自旋过程，进入阻塞状态，避免浪费处理器资源 
- 锁消除：对被检测到不可能存在共享数据竞争的锁进行消除
- 锁粗化：如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，虚拟机将会把同步锁的范围扩大到整个操作序列的外部，比如上例中，加锁到第一个append操作，解锁到最后一个append结束 
- 轻量级锁：是通过MarkWord来实现的，在进入同步块的时候，虚拟机会在当前线程的栈帧空开辟出锁记录的空间，用来存储锁对象的MarkWord的拷贝，加锁操作是使用一次CAS操作把对象的MarkWord更新为指向锁记录的指针，解锁操作也是通过一次CAS操作实现的，把复制到锁记录空间的MarkWord替换回来；但是轻量级锁不能发生竞争，如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效了，必须要膨胀为重量级锁 
- 偏向锁：在无竞争的情况下把整个同步都消除掉，连CAS操作都省去了，（偏就是偏袒的意思，会偏向第一个获取到它的线程，如果在接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不再需要进行同步），当锁对象第一次被线程获取的时候，通过CAS操作把获取到这个锁的线程ID记录到对象的MarkWord中，CAS成功的话，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都不会再进行任何同步操作，一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式立刻宣告结束。
  当对象进入偏向状态的时候，MarkWord大部分空间都用于存储持有锁的线程ID了，若计算一次哈希值后，就需要在该位置存储哈希值，而不能再进入偏向锁模式了，而当一个对象处于偏向锁模式，又收到了需要计算其一致性哈希值的请求，它的偏向模式会理解被撤销，并且锁会膨胀为重量级锁

#### 内存泄漏

![image-20210307214840464](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105308.png)

##### jstat jmap jps jinfo jconsole查看内存

![image-20210308100816201](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105309.png)

![image-20210307215245377](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105310.png)

##### 参数设置

```
-Xmx3550m：设置 JVM 最大堆内存为 3550M。
-Xms3550m：设置 JVM 初始堆内存为 3550M。此值可以设置与-Xmx 相同，以避免每次垃
圾回收完成后 JVM 重新分配内存。
-Xss128k：设置每个线程的栈大小。JDK5.0 以后每个线程栈大小为 1M，之前每个线程栈
大小为 256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个
值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，
经验值在 3000~5000 左右。需要注意的是：当这个值被设置的较大（例如>2MB）时将会
在很大程度上降低系统的性能。
-Xmn2g：设置年轻代大小为 2G。在整个堆内存大小确定的情况下，增大年轻代将会减小
年老代，反之亦然。此值关系到 JVM 垃圾回收，对系统性能影响较大，官方推荐配置为整
个堆大小的 3/8。
-XX:NewSize=1024m：设置年轻代初始值为 1024M。
-XX:MaxNewSize=1024m：设置年轻代最大值为 1024M。
-XX:PermSize=256m：设置持久代初始值为 256M。
-XX:MaxPermSize=256m：设置持久代最大值为 256M。
-XX:NewRatio=4：设置年轻代（包括 1 个 Eden 和 2 个 Survivor 区）与年老代的比值。表
示年轻代比年老代为 1:4。
-XX:SurvivorRatio=4：设置年轻代中 Eden 区与 Survivor 区的比值。表示 2 个 Survivor 区
（JVM 堆内存年轻代中默认有 2 个大小相等的 Survivor 区）与 1 个 Eden 区的比值为 2:4，
即 1 个 Survivor 区占整个年轻代大小的 1/6。
-XX:MaxTenuringThreshold=7：表示一个对象如果在 Survivor 区（救助空间）移动了 7 次
还没有被垃圾回收就进入年老代。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，
直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为
一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象在年轻代存
活时间，增加对象在年轻代被垃圾回收的概率，减少 Full GC 的频率，这样做可以在某种程
度上提高服务稳定性。
-XX:PretenureSizeThreshold 直接晋升到老年代的对象大小，设置这个参数后，大于这个参
数的对象将直接在老年代分配。
-XX：MaxTenuringThreshold 每次 minorGC 就增加一次，超过这个值，在 from 中的对象直
接进入到老年代
```

![image-20210307215333634](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105311.png)

![image-20210307215341119](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105312.png)

### Java并发

<!--more-->

#### volatile原理

![image-20210307201619086](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105115.png)

**volatile保证内存可见性**

![image-20210307201753855](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105116.png)

![image-20210307201844818](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105117.png)

#### CAS原理

![image-20210307203345273](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105118.png)

##### ABA问题

乐观锁的实现中通常都会用版本戳version来对记录或对象标记，避免并发操作带来的问题，在Java中AtomicStampedReference<E>也实现了这个作用，它通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题

AtomicInteger实现原理：CAS操作volatile变量value

##### 循环时间长开销大。

自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

##### 只能保证一个共享变量的原子操作。

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作

#### Synchronized 原理

synchronized 关键字解决的是多个线程之间访问资源的**同步性**， synchronized 关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有**⼀个线程执⾏**。

```
修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁
```

![image-20210307202329448](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105119.png)

![image-20210307202619317](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105120.png)

![image-20210307202650741](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105121.png)

```
 Contention List：所有请求锁的线程将被首先放置到该竞争队列
 Entry List：Contention List 中那些有资格成为候选人的线程被移到 Entry List
 Wait Set：那些调用 wait 方法被阻塞的线程被放置到 Wait Set
 OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为 OnDeck
 Owner：获得锁的线程称为 Owner
 !Owner：释放锁的线程
```

![image-20210307202749923](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105122.png)



新请求锁的线程将首先被加入到ConetentionList中，当某个拥有锁的线程（Owner状态）调用unlock之后，如果发现EntryList为空则从ContentionList中移动线程到EntryList，下面说明下ContentionList和EntryList的实现方式：
 **ContentionList虚拟队列**
ContentionList并不是一个真正的Queue，而只是一个虚拟队列，原因在于ContentionList是由Node及其next指针逻辑构成，并不存在一个Queue的数据结构。ContentionList是一个后进先出（LIFO）的队列，每次新加入Node时都会在队头进行，通过CAS改变第一个节点的的指针为新增节点，同时设置新增节点的next指向后续节点，而取得操作则发生在队尾。显然，该结构其实是个Lock-Free的队列。

因为只有Owner线程才能从队尾取元素，也即线程出列操作无争用，当然也就避免了CAS的ABA问题。

![image-20210307203933268](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105123.png)

**EntryList**
EntryList与ContentionList逻辑上同属等待队列，ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立EntryList。Owner线程在unlock时会从ContentionList中迁移线程到EntryList，并会指定EntryList中的某个线程（一般为Head）为Ready（OnDeck）线程。Owner线程并不是把锁传递给OnDeck线程，只是把竞争锁的权利交给OnDeck，OnDeck线程需要重新竞争锁。这样做虽然牺牲了一定的公平性，但极大的提高了整体吞吐量，在Hotspot中把OnDeck的选择行为称之为“竞争切换”。

OnDeck线程获得锁后即变为owner线程，无法获得锁则会依然留在EntryList中，考虑到公平性，在EntryList中的位置不发生变化（依然在队头）。如果Owner线程被wait方法阻塞，则转移到WaitSet队列；如果在某个时刻被notify/notifyAll唤醒，则再次转移到EntryList。

##### 双检锁实现单例（线程安全）

```java
public class Singleton {
private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        //先判断对象是否已经实例过，没有实例化过才进⼊加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
                synchronized (Singleton.class) {
                    if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

##### 对synchronized的优化,偏向锁、轻量级锁、自旋锁和重量级锁

锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。

synchronized锁膨胀过程：

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105124)

**偏向锁**
偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了**减少同一线程获取锁**(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么**锁就进入偏向模式**，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。

**轻量级锁**
倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。

**自旋锁**
轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程**做几个空循环**(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。

**锁消除**
消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，**去除不可能存在共享资源竞争的锁**，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。

##### 公平锁与非公平锁

![image-20210307205200297](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105125.png)

##### Volatile 与 synchronized 区别

![image-20210307201608665](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105126.png)

##### ReentrantLock 和 synchronized 区别

![image-20210307205249993](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105127.png)

#### AQS(AbstractQueuedSynchronizer)

**AQS原理**
AQS：AbstractQuenedSynchronizer抽象的队列式同步器。这个类在java.util.concurrent.locks包，AQS 是⼀个⽤来**构建锁和同步器的框架**，使⽤ AQS 能**简单且⾼效地构造同步器**。  ReentrantLock ， Semaphore ，其他的诸如 ReentrantReadWriteLock ， SynchronousQueue ， FutureTask 等等皆是基于 AQS 的。当然，我们⾃⼰也能利⽤ AQS ⾮常轻松容易地构造出符合我们⾃⼰需求的同步器。

使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。

同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。

同步器简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。

**AQS的核心思想**是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
**AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。**

AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS完成对status值的修改(0表示没有,1表示阻塞)，成功则获取锁成功，失败则进入等待队列，等待被唤醒。

**注意：AQS是自旋锁：**在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功

**实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105128.png)

AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：
getState();setState();compareAndSetState();

AQS 定义了两种资源共享方式：
1.**Exclusive**：独占，只有一个线程能执行，如ReentrantLock
2.**Share**：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier

不同的自定义同步器争用共享资源的方式也不同。**自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可**，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：

```java
- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。
```

　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。

**AQS 组件总结**

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105129.png)

```
7.1.1 CountDownLatch
    这个类是一个同步计数器，主要用于线程间的控制，当 CountDownLatch 的 count 计数>0 时，
    await()会造成阻塞，直到 count 变为 0，await()结束阻塞，使用 countDown()会让 count 减 1。
    CountDownLatch 的构造函数可以设置 count 值，当 count=1 时，它的作用类似于 wait()和 notify()
    的作用。如果我想让其他线程执行完指定程序，其他所有程序都执行结束后我再执行，这时可以用
    CountDownLatch，但计数无法被重置，如果需要重置计数，请考虑使用 CyclicBarrier 。
7.1.2 CyclicBarrier
    该类从字面理解为循环屏障，它可以协同多个线程，让多个线程在这个屏障前等到，直到所有
    线程都到达了这个屏障时，再一起执行后面的操作。假如每个线程各有一个 await，任何一个线程运
    行到 await 方法时就阻塞，直到最后一个线程运行到 await 时才同时返回。和之前的 CountDownLatch
    相比，它只有 await 方法，而 CountDownLatch 是使用 countDown()方法将计数器减到 0，它创建的
    参数就是 countDown 的数量；CyclicBarrier 创建时的 int 参数是 await 的数量。
7.1.3 Semaphore
    该类用于控制信号量的个数，构造时传入个数。总数就是控制并发的数量。假如是 5，程序执
    行前用 acquire()方法获得信号，则可用信号变为 4，程序执行完通过 release()方法归还信号量，可用
    信号又变为 5.如果可用信号为 0，acquire 就会造成阻塞，等待 release 释放信号。acquire 和 release
    方法可以不在同一个线程使用。Semaphore 实现的功能就类似厕所有 5 个坑，假如有 10 个人要上厕
    所，那么同时只能有多少个人去上厕所呢？同时只能有 5 个人能够占用，当 5 个人中 的任何一个人
    让开后，其中等待的另外 5 个人中又有一个人可以占用了。另外等待的 5 个人中可以是随机获得优先
    机会，也可以是按照先来后到的顺序获得机会，这取决于构造 Semaphore 对象时传入的参数选项。
    单个信号量的 Semaphore 对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另
    一个线程释放“锁”，这可应用于死锁恢复的一些场合。
7.1.4 Exchanger
    这个类用于交换数据，只能用于两个线程。当一个线程运行到 exchange()方法时会阻塞，另一
    个线程运行到 exchange()时，二者交换数据，然后执行后面的程
```

#### 重入锁实现

三要素：

- 原子状态。使用CAS操作获取和更改锁状态。
- 等待队列。
- 阻塞原语park()和unpark()。LockSupport

**LockSupport的park()和unpark()**

线程挂起和恢复，类似于suspend()和resume()。

但是suspend()和resume()操作必须保证suspend()操作在resume()之前，否则会发生线程永久性挂起的情况。

LockSupport的park()和unpark()不会发生这种情况。

这是因为LockSupport类使用类似信号量的机制。它为每个线程准备一个许可，若许可可用，那么park()函数会立即返回，并且消费这个许可(将许可变为不可用)，如果许可不可用，则阻塞。unpark()使许可变为可用。

LockSupport的park()支持中断响应，但不是抛出InterruptedException异常，只是默默返回，但仍可以从Thread.interruptd()方法获得中断标记。

#### ReentrantLock

ReentrantLock是基于AQS实现的，这在下面会讲到，AQS的基础又是CAS
ReentrantLock的静态内部类Sync实现了抽象类AQS（AbstractQueuedSynchronizer），其中有一个重要的字段是state，它在ReentrantLock中代表的是重入次数，为0是代表锁没有被任何线程持有，为1是被一个线程持有，每重入一次，state加一，每执行一次unlock方法，state减一；而ReentrantLock的公平锁和非公平锁机制是通过AQS中的队列来实现的，若是公平锁的话，每有一个线程想要获取这个锁，需要进入队列排队，而且不能插队，若是非公平锁的话，队列中的线程是可以插队的

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105130.png)

```
lock()：获取锁，如果锁被暂用则一直等待
unlock():释放锁
tryLock(): 注意返回类型是 boolean，如果获取锁的时候锁被占用就返回 false，
否则返回 true
tryLock(long time, TimeUnit unit)：比起 tryLock()就是给了一个时间期限，保
证等待参数时间
lockInterruptibly()：用该锁的获得方式，如果线程在获取锁的阶段进入了等待，
那么可以中断此线程，先去做别的事
```

线程1独占了锁。然后线程2也要尝试获取同一个锁，在线程1没有释放锁的情况下必然是行不通的，所以线程2就要阻塞。那么，线程2如何被阻塞？看下线程2的方法调用链，这就比较复杂了：

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105131.png)

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105132.png)



#### JUC包

![image-20210307220702101](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105133.png)

#### Threadlocal

每个Thread中都有一个ThreadLocalMap对象，而ThreadLocalMap中存储的是多个ThreadLocal对象，其中ThreadLocalMap中的`key`为ThreadLocal对象，`value`为ThreadLocal中是我们要存储的值

![image-20210305210233334](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105134.png)

**ThreadLocal 内存泄露问题**

ThreadLocalMap 中使⽤的 key 为  ThreadLocal 的**弱引⽤**,⽽ value 是强引⽤。所以，如果ThreadLocal 没有被外部强引⽤的情况下，在垃圾回收的时候，key 会被清理掉，⽽ value 不会被清理掉。这样⼀来， ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，**value 永远⽆法被 GC 回收**，这个时候就可能会产⽣内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调⽤  set() 、 get() 、 remove() ⽅法的时候，会**清理掉 key 为 null**的记录。使⽤完  ThreadLocal ⽅法后 最好⼿动调⽤ remove() ⽅法

#### 线程与进程

##### 创建线程方法

![image-20210307205718007](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105135.png)

##### 线程状态

![这里写图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105136.png)

##### 线程、进程与程序的区别

```
1、进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）
一个程序运行后至少有一个进程，一个进程中可以包含多个线程 。
2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC（Inter-Process Communication，进程间通信）)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
4、但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
5、同步方式不同：进程：无名管道、有名管道、信号、共享内存、消息队列、信号量
线程：互斥量、读写锁、自旋锁、线程信号、条件变量
6、进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换
```

##### 进程通信方式

![image-20210308095252651](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105137.png)

##### 线程池

![image-20210307210611167](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105138.png)

![image-20210417163430983](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210417163437.png)

```
当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。
当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行
当workQueue已满，且maximumPoolSize>corePoolSize时，新提交任务会创建新线程执行任务
当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理
当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，释放空闲线程
当设置allowCoreThreadTimeOut(true)时，该参数默认false，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭
```

```
场景1：快速响应用户请求
场景2：快速处理批量任务
```

```java
import java.util.concurrent.*;

public class LearnThreadPoolExecutor {
    public static void main(String[] args) throws InterruptedException {
        //CPU密集型,设置最大线程数为：CPU核数
        Runtime.getRuntime().availableProcessors();
        //IO密集型，根据io任务的线程数来规定最大线程数量

        //核心线程数
        //最大线程数，线程池的伸缩性，达到开启条件后，才会不断开启
        //开启条件：当阻塞队列是ArrayBlockingQueue的时候，核心线程全部都处于工作状态，↓
        //且阻塞队列已经被任务塞满了，那么再来新的任务请求，便会开启新的线程
        //若是LinkedBlockingQueue的话，它会不断的存储任务，永远都不会向最大线程数进行线程的扩展！！！
        //活跃时间和活跃时间的单位，当线程的空闲时间超过活跃时间，线程就会被回收
        //阻塞队列：全部核心线程处于忙碌状态，新来的任务放在阻塞队列中
        // 最大承载：队列大小（如果是ArrayBlockingQueue的话）+最大的线程数
        //线程工厂，用于创建线程
        //拒绝策略:AbortPolicy:超过最大承载的话，会发生异常RejectedExecutionException
        //CallerRunsPolicy:哪来的去哪里执行，这里安排不了了
        //DiscardPolicy():多的任务都给我扔了，不执行！
        //DiscardOldestPolicy():将最早执行的任务停止掉，来执行新来的任务
        ExecutorService threadPool = new ThreadPoolExecutor(3, 5,
                5, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(3),
                Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy());

        for (int i = 0; i < 33; i++) {
            int finalI = i;
            threadPool.execute(() -> {
                System.out.println(Thread.currentThread().getName() + " ok " + finalI);
            });
        }

        threadPool.shutdown();

        //线程池的作用：统一管理线程，实现线程的复用，更好的利用系统资源
        //四大方法，单个线程的池子；固定线程数的池子；自由伸缩的池子；执行定时任务的池子
        //前两个的阻塞队列为LinkedBlockingQueue
        //CachedThreadPool的阻塞队列为SynchronousQueue
        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(8);
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);

        for (int i = 0; i < 33; i++) {
            cachedThreadPool.execute(() -> {
                System.out.println(Thread.currentThread().getName());
            });
        }

        //关闭别忘了
        cachedThreadPool.shutdown();

        //TODO 线程池的五种状态
        //RUNNING 接收新任务并处理排队中的任务
        //SHUTDOWN 不接受新任务，处理剩下的任务
        //STOP 不再接收新任务，不处理剩下的任务
        //TIDYING 所与线程都执行完了
        //TERMINATED 线程池终止了

        //TODO 线程池的执行流程
        //1. 如果要执行的线程小于核心线程数的话，开启核心线程，直接执行
        //2. 如果大于核心线程数的话，将进程放入阻塞队列中进行排队
        //3. 如果队列中满了话，会开启临时线程执行线程任务
        //4. 如果线程任务超过最大的阈值，也就是大于最大线程数+阻塞队列的值的话，就会采用拒绝策略

        //判断是否停止了
        cachedThreadPool.isTerminated();
        //等待3秒后再进行判断
        cachedThreadPool.awaitTermination(3, TimeUnit.SECONDS);

        cachedThreadPool.execute( () -> System.out.println("在shutDown之后，将不再能继续执行任务"));

        //强制的立即结束
        fixedThreadPool.shutdownNow();
    }
}
```

##### 4种类型的线程池

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210506110557.webp)

```
new FixedThreadPool()
说明：初始化一个指定线程数的线程池，其中 corePoolSize == maxiPoolSize，使用 LinkedBlockingQuene 作为阻塞队列
特点：即使当线程池没有可执行任务时，也不会释放线程。
new CachedThreadPool()
说明：初始化一个可以缓存线程的线程池，默认缓存 60s，线程池的线程数可达到 Integer.MAX_VALUE，即 2147483647，内部使用 SynchronousQueue 作为阻塞队列；
特点：在没有任务执行时，当线程的空闲时间超过 keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；
因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。
new SingleThreadExecutor()
说明：初始化只有一个线程的线程池，内部使用 LinkedBlockingQueue 作为阻塞队列。
特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行
new ScheduledThreadPool()
特定：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据
```

##### 线程池基本参数

```
1、corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）

2、maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。

3、keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。

4、workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。

5、threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。

5、handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。
    AbortPolicy：直接抛出异常。
    CallerRunsPolicy：只用调用者所在线程来运行任务。
    DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
    DiscardPolicy：不处理，丢弃掉。
    可根据应用场景来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。
```

##### 线程池实现原理

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210506105010.png)

ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。

AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210506105108.jpeg)

线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210506111742.jpeg)

##### submit() 和 execute()

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。

**线程池状态**

```java
RUNNING 自然是运行状态，指可以接受任务执行队列里的任务
SHUTDOWN 指调用了 shutdown() 方法，不再接受新任务了，但是队列里的任务得执行完毕。
STOP 指调用了 s hutdownNow() 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。
TIDYING 所有任务都执行完毕，在调用 shutdown()/shutdownNow() 中都会尝试更新为这个状态。
TERMINATED 终止状态，当执行 terminated() 后会更新为这个状态
```

##### 僵尸进程

![image-20210308095421429](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105140.png)

##### 进程死锁

![image-20210307210152075](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105141.png)

![image-20210308095513173](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105142.png)

##### 多线程共用一个数据变量

![image-20210307210445922](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105143.png)

##### 一般线程和守护线程的区别

所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如**垃圾回收线程**就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止

##### Sleep与wait

![image-20210307205958565](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105144.png)

#####  yield join notify notifyAll

![image-20210307210025423](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105145.png)

##### 中断线程

![image-20210307210233243](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105146.png)

##### 多线程抛异常

![image-20210307210810526](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105147.png)

### MySQL

#### MySQL基础

##### 常用操作数据库的命令

<!--more-->

```SQL
show databases; 查看所有的数据库
create database test; 创建一个叫test的数据库
drop database test;删除一个叫test的数据库
show tables; 在选中的数据库之中查看所有的表
use test;选中库 ,在建表之前必须要选择数据库
drop table 表名; 删除表
truncate table 表名;清空表
create table 表名 (字段1 类型, 字段2 类型 not null，primary key(字段1),foreign key(字段2) references 表2[on delete cascade],check(字段1>0));创建表
default 0;默认值
desc 表名;查看所在的表的字段
show create table 表名; 查看创建表的详细信息
show create databases 库名;查看创建库的详细信息
```

![image-20210414105457070](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105510.png)

##### MySQL数据类型

![image-20200223175524201](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105511.png)

```
date '2001-04-25'
time '09:30:00'
timestamp '2001-04-25 10:29:01.45'
```

##### 改表 ：DDL 数据定义语言

```SQL
修改字段类型 alter table 表名 modify 字段 字段类型;
添加新的字段 alter table 表名 add 字段 字段类型
添加字段并指定位置  alter table 表名 add 字段 字段类型   after 字段;
删除表字段  alter table 表名 drop 字段名;
修改指定的字段  alter table 表名 change 原字段名字  新的字段名字 字段类型
```

##### 完整select

```SQL
SELECT select_expr [,select_expr,...] [      
      FROM tb_name
      [WHERE 条件判断]
      [GROUP BY {col_name | postion} [ASC | DESC], ...] 
      [HAVING WHERE 条件判断]
      [ORDER BY {col_name|expr|postion} [ASC | DESC], ...]
      [ LIMIT {[offset,]rowcount | row_count OFFSET offset}]
]
执行顺序为：
    from 表名
    where ....
    group by ...
    select distinct *
    having ...
    order by ...
    limit start,count
```

##### 数据操作：DQL数据查询语言 && DML数据操纵语言

```SQL
1.增加数据(insert)3种方式 
insert into 表名 values(值1，值2，...)(很少用)
insert into 表名(字段1，字段2...) values(值1，值2，....);（较常用）
insert into 表名(字段1，字段2...) values(值1，值2，....)，(值1，值2，....)，(值1，值2，....);

2.删除数据(delete) 
delete from 表名 where 条件 注意：where 条件必须加，否则数据会被全部删除

3.更新数据(update) 
update 表名 set 字段1 = 值1, 字段2 = 值2 where 条件
注意：where 必须加，否则数据全部修改

3.筛选重复值的字段    
select distinct 字段 from 表名

4.查询数据(select)
1.查询表中的所有数据   select * from 表名
2.指定数据查询    select [distinct] 字段 from 表名 
字符串函数 串联（||）,upper(s),trim(s),lower（s）,escape “\” 定义转义字符
集合 id [not] in(1,2)  模糊查询  ：like '%a%';%任意子串，_任意一个字符

4.根据条件查询出来的数据  select 字段 from 表名 where 条件 (最常用的)
where 条件后面跟的条件
 关系：>,<,>=,<=,!=  
 逻辑：or, and 
 区间：id between 4 and 6 ;闭区间，包含边界
 集合运算 并集 union [all],  交集 intersect, 补集 except
 >some 集合 :至少比一个大；>all 集合 比所有都大
 
5.结果集排序
    1, 通过字段来排序
    例如 ：select * from star orser by money desc, age asc; 
    select 字段 from 表 order by 字段  排序关键词(desc | asc)
    排序关键词 desc 降序 asc 升序(默认)
    2, 多字段排序
    select 字段 from 表 order by 字段1  desc |asc,...字段n desc| asc;

6.限制结果集
select  字段 from 表 limit 数量;
例如:select sum(id) from star                                                         
select * from 表名  limit 偏移量,数量
说明:
1.不写偏移量的话就是默认的为0
2.实现分页的时候必须写偏移量
  偏移量怎么计算？:
    limit (n-1)*数量 ,数量 
    
7.常用的统计函数
sum，avg，count，max,min
只分组:select * from 表 group by 字段
例子: select count(sex) as re,sex from star group by sex having re > 3;
分组统计: select count(sex) from star group by sex;
```

##### 多表联合查询

```SQL
1，内连接
隐式内连接 select username,name from user,goods where user.gid=gods.gid;
显示内连接
select username,from user inner join goods on user.gid=goods.gid;
select * from user left join goods on user.gid=goods.gid;
2.外链接
左连接 包含所有的左边表中的记录以及右边表中没有和他匹配的记录
右连接 
select * from user where gid in(select gid from goods);
select * from user right join goods on user.gid=goods.gid;
子嵌套查询
数据联合查询
select * from user left join goods on user.gid=goods.gid union select * from user right join goods on user.gid=goods.gid;
两个表同时更新
update user u, goods g set u.gid=12,g.price=1 where u.id=2 and u.gid=g.gid;
```

##### DCL 数据控制语言

```SQL
创建用户:create user'xiaoming'@'localhost' identified by '666666';
授权用户:grant all on test.* to 'xiaoming'@'localhost';
刷新权限:flush privileges;
取消授权:revoke all on test.* from 'xiaoming'@'localhost';
删除用户: drop user 'xiaoming'@'localhost';
```

##### DTL 数据事务语言

如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

```SQL
开启事务：set autocommit=0;
操作回滚：rollback;
提交事务：commit;
```

##### 视图

通俗的讲，视图就是一条SELECT语句执行后返回的结果集。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；视图一般不能插入。

```SQL
定义视图 建议以v_开头
create view 视图名称 as select语句;
查看表会将所有的视图也列出来
show tables;
视图的用途就是查询
select * from v_stu_score;
删除视图
drop view 视图名称; eg：drop view v_stu_sco;
```

##### JDBC

```java
//1. 导入驱动jar包
//2.注册驱动
Class.forName("com.mysql.jdbc.Driver");
//3.获取数据库连接对象
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "root");
//4.定义sql语句
String sql = "update account set balance = 500 where id = 1";
//5.获取执行sql的对象 Statement
Statement stmt = conn.createStatement();
//6.执行sql
int count = stmt.executeUpdate(sql);
String sql2 = "update account set balance = balance + ? where id = ?";
pstmt2 = conn.prepareStatement(sql2);
//4. 设置参数
pstmt2.setDouble(1, 500);
pstmt2.setInt(2, 2);
pstmt2.executeUpdate();
//7.处理结果
System.out.println(count);
//8.释放资源
stmt.close();
conn.close();
```

##### 数据库连接池

```
1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。
	    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。

2. 好处：
	1. 节约资源
	2. 用户访问高效

3. 实现：
	1. 标准接口：DataSource   javax.sql包下的
		1. 方法：
			* 获取连接：getConnection()
			* 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接

	2. 一般我们不去实现它，有数据库厂商来实现
		1. C3P0：数据库连接池技术
		2. Druid：数据库连接池实现技术，由阿里巴巴提供的
```

##### C3P0和Druid

```java
4. C3P0：数据库连接池技术
	* 步骤：
		1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，
			* 不要忘记导入数据库驱动jar包
		2. 定义配置文件：
			* 名称： c3p0.properties 或者 c3p0-config.xml
			* 路径：直接将文件放在src目录下即可。
			  	<!--  连接参数 -->
                <property name="driverClass">com.mysql.jdbc.Driver</property>
                <property name="jdbcUrl">jdbc:mysql://localhost:3306/day25</property>
                <property name="user">root</property>
                <property name="password">root</property>   
                <!-- 连接池参数 -->
                <property name="initialPoolSize">5</property>
                <property name="maxPoolSize">10</property>
                <property name="checkoutTimeout">3000</property>
		3. 创建核心对象 数据库连接池对象 ComboPooledDataSource
		4. 获取连接： getConnection
	* 代码：
		 //1.创建数据库连接池对象
        DataSource ds  = new ComboPooledDataSource();
        //2. 获取连接对象
        Connection conn = ds.getConnection();
5. Druid：数据库连接池实现技术，由阿里巴巴提供的
	1. 步骤：
		1. 导入jar包 druid-1.0.9.jar
		2. 定义配置文件：
			* 是properties形式的
			* 可以叫任意名称，可以放在任意目录下
			driverClassName=com.mysql.jdbc.Driver
            url=jdbc:mysql:///db3
            username=root
            password=root
            initialSize=5
            maxActive=10
            maxWait=3000
		3. 加载配置文件。Properties
		4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory
		5. 获取连接：getConnection
	* 代码：
		 //3.加载配置文件
        Properties pro = new Properties();
        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");
        pro.load(is);
        //4.获取连接池对象
        DataSource ds = DruidDataSourceFactory.createDataSource(pro);
        //5.获取连接
        Connection conn = ds.getConnection();
```

##### JDBCTemplate

```java
* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发
* 步骤：
	1. 导入jar包
	2. 创建JdbcTemplate对象。依赖于数据源DataSource
		* JdbcTemplate template = new JdbcTemplate(ds);

	3. 调用JdbcTemplate的方法来完成CRUD的操作
		* update():执行DML语句。增、删、改语句
		* queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合
			* 注意：这个方法查询的结果集长度只能是1
		* queryForList():查询结果将结果集封装为list集合
			* 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中
		* query():查询结果，将结果封装为JavaBean对象
			* query的参数：RowMapper
				* 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装
				* new BeanPropertyRowMapper<类型>(类型.class)
		* queryForObject：查询结果，将结果封装为对象
			* 一般用于聚合函数的查询

```

```java
public class JdbcTemplateDemo2 {
    //1. 获取JDBCTemplate对象
    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
    /**
     * 1. 修改1号数据的 salary 为 10000
     */
    @Test
    public void test1(){
        //2. 定义sql
        String sql = "update emp set salary = 10000 where id = 1001";
        //3. 执行sql
        int count = template.update(sql);
        System.out.println(count);
    }

    /**
     * 2. 添加一条记录
     */
    @Test
    public void test2(){
        String sql = "insert into emp(id,ename,dept_id) values(?,?,?)";
        int count = template.update(sql, 1015, "郭靖", 10);
        System.out.println(count);

    }

    /**
     * 3.删除刚才添加的记录
     */
    @Test
    public void test3(){
        String sql = "delete from emp where id = ?";
        int count = template.update(sql, 1015);
        System.out.println(count);
    }

    /**
     * 4.查询id为1001的记录，将其封装为Map集合
     * 注意：这个方法查询的结果集长度只能是1
     */
    @Test
    public void test4(){
        String sql = "select * from emp where id = ? or id = ?";
        Map<String, Object> map = template.queryForMap(sql, 1001,1002);
        System.out.println(map);
        //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}

    }

    /**
     * 5. 查询所有记录，将其封装为List
     */
    @Test
    public void test5(){
        String sql = "select * from emp";
        List<Map<String, Object>> list = template.queryForList(sql);

        for (Map<String, Object> stringObjectMap : list) {
            System.out.println(stringObjectMap);
        }
    }

    /**
     * 6. 查询所有记录，将其封装为Emp对象的List集合
     */
    @Test
    public void test6(){
        String sql = "select * from emp";
        List<Emp> list = template.query(sql, new RowMapper<Emp>() {

            @Override
            public Emp mapRow(ResultSet rs, int i) throws SQLException {
                Emp emp = new Emp();
                int id = rs.getInt("id");
                String ename = rs.getString("ename");
                int job_id = rs.getInt("job_id");
                int mgr = rs.getInt("mgr");
                Date joindate = rs.getDate("joindate");
                double salary = rs.getDouble("salary");
                double bonus = rs.getDouble("bonus");
                int dept_id = rs.getInt("dept_id");

                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setJoindate(joindate);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                return emp;
            }
        });
        for (Emp emp : list) {
            System.out.println(emp);
        }
    }

    /**
     * 6. 查询所有记录，将其封装为Emp对象的List集合
     */
    @Test
    public void test6_2(){
        String sql = "select * from emp";
        List<Emp> list = template.query(sql, new BeanPropertyRowMapper<Emp>(Emp.class));
        for (Emp emp : list) {
            System.out.println(emp);
        }
    }

    /**
     * 7. 查询总记录数
     */
    @Test
    public void test7(){
        String sql = "select count(id) from emp";
        Long total = template.queryForObject(sql, Long.class);
        System.out.println(total);
    }
}
```

##### 数据库三大范式

1、码：能唯一确定一条记录的一个/多个属性。码包括主码和候选码。任意一个候选码也能作为主键。其中主码/候选码的任意一个真子集都不能确定一条记录。

2、主属性：构成**主码**或**候选码**的属性都叫主属性！千万不要误认为候选码的属性不是主属性！

3、非主属性：除了主属性以外的属性都为非主属性。

4、传递依赖：如果存在A → B → C的决定关系，则C传递函数依赖于A。(学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)有如下传递依赖(学号) → (所在学院) → (学院地点, 学院电话)

5、部分依赖：（学号和身份证）->姓名，姓名部分函数依赖于(学号和身份证)

第一范式：数据库的字段是单一属性，不可再分

第二范式：每个非主属性都完全函数依赖于主键，目的是去除**非主属性**对**码**的部分依赖。（学号和身份证）->姓名

第三范式：非关键字字段必须直接依赖任一侯选关键字，目的是去除**非主属性**对**码**的传递依赖。(学号) → (所在学院) → (学院地点)

BC范式：消除主属性对码的传递和函数依赖，消除（仓库名，管理员，物品名）->数量中仓库名 → 管理员主属性部分依赖

#### 索引

```SQL
查看索引
show index from 表名;
创建索引
如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致
字段类型如果不是字符串，可以不填写长度部分
create index 索引名称 on 表名(字段名称(长度))
删除索引：
drop index 索引名称 on 表名;
```

##### 索引特点和优缺点

![image-20210307222031035](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105512.png)

##### 在哪里建索引

![image-20210308105225087](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105513.png)

##### 索引建立原则

（id，name) where id=1 and name='xxx'

```
1.最左前缀匹配原则，mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，范围查询会导致组合索引半生效。比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，c 可以用到索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。where范围查询要放在最后 （这不绝对，但可以利用一部分索引）。
2. 特别注意：and 之间的部分可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。where 字句有 or 出现还是会遍历全表。
3. 尽量选择区分度高的字段作为索引,某字段的区分度的公式是 count(distinctcol)/count(*)，表示字段不重复的比例，比例越大，我们扫描的记录数越少，查找匹配的时候可以过滤更多的行， 唯一索引的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0。
4. 不在索引列做运算或者使用函数。
5. 尽量扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
6. Where 子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。
7. like 模糊查询中，右模糊查询（321%）会使用索引，而%321 和%321%会放弃索引而使用全局扫描。
```

##### 索引分类

![image-20210308141645229](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105514.png)

##### EXPLAIN SQL

在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。

expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra,下面对这些字段出现的可能进行解释：

```sql
type表示MySQL在表中找到所需行的方式，又称“访问类型”。
常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）
Select_type 说明查询中使用到的索引类型，如果没有用有用到索引则为all
ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
index: Full Index Scan，index与ALL区别为index类型只遍历索引树
range:只检索给定范围的行，使用一个索引来选择行
ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system
NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
```

#### InnoDB

innoDB 的数据保存在表空间中，表空间又包含各种段，其中有数据段，索引段，回滚段。InnoDB中数据以B+Tree的数据结构存储的，非叶子节点既是索引，叶子节点既是数据行，回滚段用于存储undoLog，undoLog中记录的就是多版本数据，用于快照读和事务失败后的数据回滚,MySQL在合适的时机会清理undoLog。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105515.webp)

#### InnoDB与MyISAM

![image-20210308105617479](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105516.png)

![image-20210308141746008](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105517.png)

![image-20210308105654476](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105518.png)

**自增主键删除**

一张表,里面有 ID 自增主键,当 insert 了 17 条记录之后,删除了第 15,16,17 条记录,再把 Mysql 重启,再 insert 一
条记录,这条记录的 ID 是 18 还是 15 ？
如果表的类型是 MyISAM， 那么是 18。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里， 重启MySQL自增主键的最大 ID 也不会丢失。
如果表的类型是 InnoDB， 那么是 15。InnoDB 表只是把自增主键的最大 ID 记录到内存中， 所以重启数据库会导
致最大 ID 丢失。

#### MVCC

MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。

如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读者，**在某个瞬间看到的是数据库的一个快照**，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于**其他的读者来说是不可见**的。

一句话讲，MVCC就是用 **同一份数据临时保留多版本的方式** 的方式，实现并发控制。

什么是多版本并发控制呢 ？其实就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，而每一个事务在启动的时候，都有一个唯一的递增的版本号。
1、在插入操作时 ： 记录的创建版本号就是事务版本号。
比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。

![image-20210408163551921](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105519.png)

2、在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新
的记录的方式。
比如，针对上面那行记录，事务Id为2 要把name字段更新
update table set name= 'new_value' where id=1;

![image-20210408163628472](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105520.png)

3、删除操作的时候，就把事务版本号作为删除版本号。比如
delete from table where id=1;

![image-20210408163653776](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105521.png)

4、查询操作：
从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：
1）InnoDB只查找**版本早于当前事务版本**的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，只么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2）行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删
除。
这样就保证了各个事务互不影响。从这里也可以体会到一种提高系统性能的思路，就是：
**通过版本号来减少锁的争用**。

#### 事务

##### 事务的四大特征

```
1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
3. 隔离性：并发的事务之间不会互相影响，相互独立。
4. 一致性：事务操作前后，数据总量不变
```

##### 并发事务带来的问题

**丢失更新**
如果两个事务都要更新数据库一个字段X，x=100

![image-20210408162727975](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105522.png)

两个不同事物同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务更新会被后提交事务的
更新给覆盖掉，这种情况事务A的更新就被覆盖掉了、丢失了。
**脏读（未提交读）**
防止一个事务读到另一个事务还没有提交的记录。 如：

![image-20210408162746429](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105523.png)

事务读取了未提交的数据，事务B的回滚，导致了事务A的数据不一致，导致了事务A的脏读 ！
**不可重复读**
一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的；如果不一致，
就说明为不可重复读。 还是用上面的例子

![image-20210408162804468](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105524.png)

这种情况事务A多次读取x的结果出现了不一致，即为不可重复读 。
**幻读（Phantom Read）**
事务A读的时候读出了15条记录，事务B在事务A执行的过程中 增加 了1条，事务A再读的时候就变成了 16 条，这
种情况就叫做幻影读。 不可重复读说明了做数据库读操作的时候可能会出现的问题。

##### 事务隔离级别（恶果：脏读、 不可重复读、幻读 ）

![image-20210307222230326](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105525.png)

![image-20210308105723199](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105526.png)

```
read uncommited ：读到未提交数据 A线程读到B未submit的数据
read committed：脏读，不可重复读  A线程读到B submit的数据，两次查询不同
repeatable read：可重读  A线程读到B insert的数据，第一次没有，第二次有了
serializable ：串行事物
```

##### GAP 锁（间隙锁解决幻读）

在索引记录的间隙上加锁，禁止插入，这样就避免了幻读

![image-20210308154325058](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105527.png)

#####  next-key 锁

![image-20210308154445909](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105528.png)

##### 分布式事务

指事务的资源分别位于不同的分布式系统的不同节点上的事务，需要保证事务的 ACID 特性。

![image-20210408121957422](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105529.png)

**产生原因**

* 数据库分库分表

* 业务服务化

  业务按照面向服务（SOA）的架构拆分整个网站系统：如金融网站拆分为交易系统、账务系统等。

分布式事务用于在分布式系统中保证不同节点之间的数据一致性。分布式事务的实现有很多种，最具有代表性的是
由Oracle Tuxedo系统提出的XA分布式事务协议。
XA协议包含**两阶段提交（2PC）和三阶段提交（3PC）**两种实现

##### 事务两阶段提交（2PC）

在XA协议中包含着两个角色：事务协调者和事务参与者。

![image-20210408122202911](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105530.png)

在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。
在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。
当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。

![image-20210408122223925](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105531.png)

在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。
接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。
当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。
以上所描述的是XA两阶段提交的正向流程，接下来我们看一看失败情况的处理流程：

![image-20210408122438925](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105532.png)

在XA的第一阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。
于是在第二阶段，事务协调节点向所有的事务参与者发送Abort请求。接收到Abort请求之后，各个事务参与者节点需要在本地进行事务的回滚操作，回滚操作依照Undo Log来进行。
以上就是XA两阶段提交协议的详细过程。

##### XA两阶段提交的不足

XA两阶段提交究竟有哪些不足呢？
**1.性能问题 同步阻塞**
XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。
**2.协调者单点故障问题**
事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。
**3.丢失消息导致的不一致问题。**
在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。

**4 太过保守**

任意一个节点失败就会导致整个事务失败，没有完善的容错机制。

##### XA三阶段提交（3PC）

XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。

##### MQ事务

利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。

##### TCC事务

TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于XA两阶段提交，但是实现方式是在代码层面来人为实现。

![image-20210408123158032](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105533.png)

##### 柔性事务

单数据库事务完全遵循 ACID 规范，属于刚性事务，分布式事务要完全遵循 ACID 规范比较困难，属于柔性事务，满足 **BASE** 理论。

* **BA：Basic Availability** 基本业务可用性

* **S：Soft state** 柔性状态

* **E：Eventual consistency** 最终一致性

柔性事务对 ACID 的支持：

1. 原子性：严格遵循
2. 一致性：事务完成后的一致性严格遵循，事务中的一致性可适当放宽
3. 隔离性：并行事务间不可影响，事务中间结果可见性允许安全放宽
4. 持久性：严格遵循

**分类**

1. **两阶段型**

   XA、JTA/JTS 属于该类型，为分布式环境下事务处理的典型模式。

2. **补偿型**

   TCC 可以归为该类型，其思路为：尽早释放锁，在 Try 成功的情况下如果事务要回滚，则 Cancel 将作为补偿机制回滚 Try 操作。

3. **异步确保型**

   将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用；比如消息事务机制。

4. **最大努力通知型**

   通过通知服务器（消息通知）进行，允许失败，有补充机制；

#### Sql 优化

![image-20210308142154220](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105534.png)

![image-20210308142212180](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105535.png)

#### 分库分表

![image-20210308142549375](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105536.png)

#### 数据库锁

![image-20210308142652289](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105537.png)

![image-20210308142707570](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105538.png)

##### 封锁协议（解决脏读不可重复读）

![image-20210308142817068](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105539.png)

![image-20210308142833910](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105540.png)

![image-20210308142845141](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105541.png)

![image-20210308143011980](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105542.png)

##### 死锁活锁

![image-20210308145752680](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105543.png)

![image-20210308145808709](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105544.png)

##### 两阶段协议

![image-20210308145850964](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105545.png)

### 计网

#### 分层协议

![image-20210414111154114](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111343.png)

<!--more-->

![image-20210307223025471](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111344.png)

#### 一次网页访问

![image-20210307153953158](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111345.png)

#### HTTP

##### http请求和响应报文

![image-20210307223219011](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111346.png)

![image-20210307223241867](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111347.png)

![image-20210307223249141](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111348.png)

##### http请求方法

![image-20210307223624541](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111349.png)

![image-20210307223613666](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111350.png)

##### http 请求过程

![image-20210307224005898](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111351.png)

##### get与post

![image-20210307224203352](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111352.png)

![image-20210307224141797](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111353.png)

![image-20210307224235985](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111354.png)

##### http长连接

HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。

无状态：HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。

![image-20210307223744070](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111355.png)

![image-20210307224611197](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111356.png)

**原理**

再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。

如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：

1. 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
2. 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
3. 客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
4. 客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。

##### http状态码

![image-20210307224335187](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111357.png)

![image-20210307224402115](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111358.png)

![image-20210307224420773](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111359.png)

![image-20210307224436398](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111400.png)

##### 转发与重定向

转发是服务器行为，重定向是客户端行为。

![image-20210329203213395](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111401.png)

##### http1.0,1.1,2.X

![image-20210307224656500](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111402.png)

![image-20210307224713263](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111403.png)

#### HTTPS=HTTP+ 加密 + 认证 + 完整性保护

![image-20210307231641138](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111404.png)

```
1. A 与 B 通过 TCP 建立链接，初始化 SSL 层。
2. 进行 SSL 握手，A 发送 https 请求，传送客户端 SSL 协议版本号、支持的加密算法、随机数等。
3. 服务器 B 把 CA 证书（包含 B 的公钥），把自己支持的加密算法、随机数等回传给A。
4. A 接收到 CA 证书，验证证书有效性。
5. 校验通过，客户端随机产生一个字符串作为与 B 通信的对称密钥，通过 CA 证书解出服务器 B 的公钥，对其加密，发送给服务器。
6. B 用私钥解开信息，得到随机的字符串（对称密钥），利用这个密钥作为之后的通信密钥。
7. 客户端向服务器发出信息，指明后面的数据使用该对称密钥进行加密，同时通知服务器 SSL 握手结束。
8. 服务器接收到信息，使用对称密钥通信，通知握手接收。
9. SSL 握手结束，使用对称密钥加密数据。
```

##### https与http区别

![image-20210307231552528](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111405.png)

##### 加密

![image-20210307231408268](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111406.png)

##### 认证

![image-20210307231433548](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111407.png)

#### TCP、UDP

##### TCP与UDP区别

![image-20210307224826315](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111408.png)

##### TCP头部

```
ACK ： TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的ACK 必须为 1。
SYN(SYNchronization) ： 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则在响应报文中使 SYN=1 和 ACK=1.因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。
FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接
```

![image-20210307224740805](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111409.png)

![image-20210307232127447](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111410.png)

##### TCP 三次握手

![image-20210307224945140](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111411.png)

![image-20210307225054471](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111412.png)

##### TCP四次挥手

![image-20210307225333703](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111413.png)

#####  tcp 粘包问题 nagle 算法

![image-20210307225439361](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111414.png)

![image-20210307225456168](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111415.png)

#####  tcp 如何保证可靠性传输

![image-20210307225655607](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111416.png)

#####  TCP 流量控制 拥塞控制

![image-20210307225751924](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111417.png)

##### 滑动窗口机制

![image-20210307230532476](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111421.png)

##### 慢开始与拥塞避免

发送方维持一个叫做口 拥塞窗口 cwnd （congestion window） ）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

![image-20210307230036650](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111418.png)

![image-20210307230134036](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111419.png)



##### 快速重传快速恢复

![image-20210307230435445](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111420.png)

##### TCP状态转移

![image-20210307230601261](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111422.png)

##### TIME_WAIT 和 CLOSE_WAIT

![image-20210307230830662](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111423.png)

**当一个 tcp 监听了 80 端口后，Udp 还能否监听 80 端口**
答：由于 TCP/IP 传输层的两个协议 TCP 和 UDP 是完全独立的两个软件模块，因此各自的端口号也相互独立，如 TCP 有一个 255 号端口，UDP 也可以有一个 255 号端口，二者并不冲突。

#### IP

![image-20210307231023027](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111424.png)

![image-20210307231036546](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111425.png)

![image-20210307231047743](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414111426.png)





### 操作系统

<!--more-->

##### 大端和小端序

如果数据都是单字节，怎么存储无所谓，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。

Big-endian（大端序）：数据的高位字节存放在地址的低端 低位字节存放在地址高端

Little-endian（小端序）：数据的高位字节存放在地址的高端 低位字节存放在地址低端

if(((char*)&a)[3] ==1) 则为大端序，由于a是int，所以占四个字节，其值是00000001，存储方式如下。所以a[3]是0，不是大端序。一个更标准的写法是将a[3]替换为a[sizeof(int) - 1]。

##### 程序的内存模型

32 位操作系统进程地址空间有 4G，0~3G 为用户空间，3~4G 为内核空间。用户空间从低地址到高地址分别为：代码段、初始化数据段、未初始化数据段、堆段、栈段。

![image-20210506103236816](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210506103242.png)

##### IO多路复用

```
select、poll、epoll 的区别
Select 底层采用数组存储文件描述符，存在以下四个问题：
1. 单进程监听的文件描述符最大数量存在限制，32 位操作系统上是 1024
2. 内核/用户态空间内存拷贝问题，select 复制大量的句柄数据结构，产生巨大开销
3. select 仅支持水平触发模式，存在重复触发风险
4. select 返回后应用程序需要遍历整个数组，效率低。
Poll 底层采用队列存储文件描述符，因此没有文件描述符数量限制，select 其它三个缺点它也有。
Epoll 解决 select 和 poll 的缺点，底层采用队列加红黑树方式实现，除了不受文件描述符数量限制之外，还支持边缘触发模式。
```

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210506104724.png)

##### 僵尸进程和孤儿进程

```
14. 介绍僵尸进程和孤儿进程
僵尸进程指的是子进程退出后，父进程没有回收子进程的资源。僵尸进程过多导致系统资源不足。
孤儿进程指的是父进程退出，子进程变成孤儿进程，孤儿进程由 init 进程进行资源回收。
15. 如何解决僵尸进程过多问题
1. 可以在父进程的 SIG_CHLD 信号处理函数中回收子进程资源。
2. 设置父进程的 SIG_CHLD 信号处理函数位 SIG_IGN，子进程会自动回收
```

##### 常见Linux命令

```shell
ls列出目录；cd切换目录；pwd显示当前目录；mkdir创建目录；rmdir删除目录
cp复制目录或文件；rm移除文件或目录；mv移动文件或目录
# 压缩文件
tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...
# 解压缩文件
tar -zxvf 打包文件.tar.gz
# 修改文件|目录的拥有者
chown 用户名 文件名|目录名
# 递归修改文件|目录的组
chgrp -R 组名 文件名|目录名
# 递归修改文件权限 r:4 w:2 x:1 拥有者／组/其他
chmod -R 755 文件名|目录名
cat从第一行正序显示内容；tac从最后一行开始显示内容；head -n20 显示前20行；tail看尾几行
开启端口 firewall-cmd --zone=public --add-port=80/tcp --permanent；
firewall-cmd --state 查看状态；
service firewall start/restar/stop 开启/重启/停止
ps -ef|grep redis 查看redis的进程信息 ps -aux 查看进程
kill [-9] 进程代号	终止指定代号的进程，-9 表示强行终止	
top 查看各个进程的资源占用状况 Cache 主要是文件缓存，buffer 主要是磁盘缓存。
df -h	disk free 显示磁盘剩余空间
service iptables status 查看防火墙状态
# 查看网卡对应的 IP 地址
ifconfig | grep inet
Iostat 查看磁盘。
netstat -apn 查看所有端口
Vmstat 查看虚拟内存
Awk 主要用于列处理，sed 用于行处理。开发常用命令包括 grep 搜索，wc 统计，tcpdump 抓包等等。
```



#### CPU调度

![image-20210308095803977](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414114329.png)

**多级反馈队列调度算法** ：前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。

#### 内存管理方式（页式、段式、段页式）

##### **页式**

为了便于在内存中找到进程的每个页面所对应的物理块，系统为**每个进程建立一张页表**，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见页表作用是实现从页号到物理块号的地址映射，这种是 页存储管理方式。

![image-20210308100029250](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414114330.png)

##### 段式

将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配，这种是 段存储管理方式。

![image-20210308100112242](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414114331.png)

##### 段页存储

作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位，这种是 段页存储管理方式。

![image-20210308100147792](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414114332.png)



##### 快表和多级⻚表

**我 ：在分⻚内存管理中，很重要的两点是：**

1. 虚拟地址到物理地址的转换要快。
2. 解决虚拟地址空间⼤，⻚表也会很⼤的问题。

**快表**

为了解决虚拟地址到物理地址的转换速度，操作系统在 ⻚表⽅案 基础之上引⼊了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为⼀种特殊的⾼速缓冲存储器（Cache），其中的内容是⻚表的⼀部分或者全部内容。作为⻚表的 Cache，它的作⽤与⻚表相似，但是提⾼了访问速率。由于采⽤⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。使⽤快表之后的地址转换流程是这样的：

```
1. 根据虚拟地址中的⻚号查快表；
2. 如果该⻚在快表中，直接从快表中读取相应的物理地址；
3. 如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；
4. 当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。
```

 **多级⻚表**引⼊多级⻚表的主要⽬的是为了避免把全部⻚表⼀直放在内存中占⽤过多空间，特别是那些根本就不需要的⻚表就不需要保留在内存中。

#### 页面置换算法

缺页中断：缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。
页面置换算法：在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用**来选择淘汰哪一页**的规则叫做页面置换算法。

#### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为**孤儿进程**。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

#### 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait () 或 waitpid () 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait () 或 waitpid ()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为**僵尸进程**。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

#### 原码，反码和补码

##### 原码

- 原码就是符号位加上所要表达值得绝对值，即用第一位表示符号，其他位表示值，比如在8位二进制中：

  [+1]~原~=0000 0001

  [-1]~原~=1000 0001

- 所以可以得到8位二进制得取值范围是[1111 1111] - [0111 1111]即-127到127

##### 反码

- 正数的反码是自己，负数的反码是在其原码基础上，符号位不变，其他位取反，例如：

  [0000 0001]=[+1]~原~=[+1]~反~

  [-1]~原~=1000 0001 ，[-1]~反~=1111 1110

##### 补码

- 正数的补码就是自己，负数的补码是反码加1

  [0000 0001]=[+1]~原~=[+1]~反~=[+1]~补~

  [-1]~原~=1000 0001 ，[-1]~反~=1111 1110 ，[-1]~补~= 1111 1111

##### 为什么使用原码，反码和补码

- 以原码为例，当涉及到减法时，计算机会将其转换为加法，以1-1为例

  1 - 1 = 1 + (-1) = [00000001]~原~ + [10000001]~原~ = [10000010]~原~ = -2

- 补码可以解决这个问题，统一加法和减法

  1-1 = 1 + (-1) =[0000 0001]~补~ + [1111 1111]~补~ = [0000 0000]~补~=[0000 0000]~原~

### 设计模式

##### Java中的设计模式

装饰器设计模式（Decorator design pattern）被用于多个 Java IO 类中。

⼯⼚设计模式 : Spring使⽤⼯⼚模式通过  BeanFactory 、 ApplicationContext 创建 bean 对象。
代理设计模式 : Spring AOP 功能的实现。
单例设计模式 : Spring 中的 Bean 默认都是单例的。 Runtime，Calendar 
包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。  Swing 
适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。

### 网站架构

#### 大型网站架构演化发展历程

![image-20210407163257554](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110734.png)

<!--more-->

1. 拆分：不同的多台服务器上面部署不同的服务模块，模块之间通过RPC通信和调用，用于拆分业务功能，独立部署，多个服务器共同组成一个整体对外提供服务。
2. 集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，用于分流容灾，降低单个服务器的访问压力。

##### 初始阶段的网站架构

小型网站最开始没有太多人访问，只需要一台服务器就绰绰有余，应用程序、数据库、文件等所有资源都在一台服务器上。这时的网站架构如下图所示：

![image-20210407162234274](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110735.png)

##### 应用服务和数据服务分离

```
应用服务器需要处理大量的业务逻辑，因此需要更快更强大的CPU；
数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的磁盘和更大的内存；
文件服务器需要存储大量用户上传的文件，因此需要更大的硬盘。
```

![image-20210407162339201](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110736.png)

##### 使用缓存改善网站性能

如果把这一小部分数据缓存在内存中，就可以减少数据库的访问压力，提高整个网站的数据访问速度，改善数据库的写入性能了。

```
本地缓存的访问速度更快一些，但是受应用服务器内存限制，其缓存数据量有限，而且会出现和应用程序争用内存的情况。
远程分布式缓存可以使用集群的方式，部署大内存的服务器作为专门的缓存服务器，可以在理论上做到不受内存容量限制的缓存服务。
```

![image-20210407162524730](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110737.png)

##### 使用应用服务器集群改善网站的并发处理能力

通过负载均衡调度服务器，可以将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多用户，就在集群中加入更多的应用服务器，使应用服务器的压力不再成为整个网站的瓶颈。

![image-20210407162559564](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110738.png)

##### 数据库读写分离

目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。

![image-20210407162717596](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110739.png)

##### 使用反向代理和 CDN 加速网站响应

CDN 和反向代理的基本原理都是缓存。

```
CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据
反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户
```

使用 CDN 和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力。

![image-20210407162753331](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110740.png)

##### 使用分布式文件系统和分布式数据库系统

分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数据部署在不同的物理服务器上。

![image-20210407162911704](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110741.png)

##### 使用 NoSQL 和搜索引擎

NoSQL 和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。

![image-20210407163015722](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110742.png)

##### 业务拆分

大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将整个网站业务分成不同的产品线。如大型购物交易网站都会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。
具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署。应用之间可以通过一个超链接建立关系（在首页上的导航链接每个都指向不同的应用地址），也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统，如下图所示：

![image-20210407163152524](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110743.png)

##### 分布式微服务

随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。
既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些**共用的业务提取出来，独立部署**。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。如下图所示：

![image-20210407163251463](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110744.png)

#### 数据库架构发展历程

##### 单机MySQL的美好年代

![image-20210408103732149](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110745.png)

##### Memcached(缓存)+MySQL+垂直拆分

![image-20210408103912789](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110746.png)

Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在
Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性
hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端

##### Mysql主从复制读写分离

由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。

![image-20210408104213351](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110747.png)

##### 分表分库+水平拆分+mysql集群

在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。

同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。

![image-20210408104334954](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110748.png)

##### NoSQL

![image-20210408104521288](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110749.png)

##### 数据的水平拆分和垂直拆分

当我们使用读写分离、缓存后，数据库的压力还是很大的时候，这就需要使用到数据库拆分了。
数据库拆分简单来说，就是指通过某种特定的条件，按照某个维度，将我们存放在同一个数据库中的数据分散存放
到多个数据库（主机）上面以达到分散单库（主机）负载的效果。
切分模式： 垂直（纵向）拆分、水平拆分。

垂直拆分
一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据
库上面，这样也就将数据或者说压力分担到不同的库上面，如下图：

![image-20210408121335272](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110750.png)

优点：

1. 拆分后业务清晰，拆分规则明确。
2. 系统之间整合或扩展容易。
3. 数据维护简单

缺点：

1. 部分业务表无法join，只能通过接口方式解决，提高了系统复杂度。
2. 受每种业务不同的限制存在单库性能瓶颈，不易数据扩展跟性能提高。
3. 事务处理复杂。

水平拆分
垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆到不同的数据库中。
相对于垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中
包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中 的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，主要有分表，分库两种模式，如图：

![image-20210408121426591](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110751.png)

优点：

1. 不存在单库大数据，高并发的性能瓶颈。
2. 对应用透明，应用端改造较少。
3. 按照合理拆分规则拆分，join操作基本避免跨库。
4. 提高了系统的稳定性跟负载能力。

缺点：

1. 拆分规则难以抽象。
2. 分片事务一致性难以解决。
3. 数据多次扩展难度跟维护量极大。
4. 跨库join性能较差。

```
拆分原则
1. 尽量不拆分，架构是进化而来，不是一蹴而就。(SOA)
2. 最大可能的找到最合适的切分维度。
3. 由于数据库中间件对数据Join 实现的优劣难以把握，而且实现高性能难度极大，业务读取 尽量少使用多表Join -
尽量通过数据冗余，分组避免数据垮库多表join。
4. 尽量避免分布式事务。
5. 单表拆分到数据1000万以内。
切分方
范围、枚举、时间、取模、哈希、指定等

场景3:上海公积金，养老金，社保系统
分析：
    社保系统
    实时性要求不高
    不存在瞬时压力
    大规模分析？
    数据规模大
    数据重要不可丢失
    偏于查询？
方案1：按照用户取模，
带来的问题：后续扩容困难
方案2：按用户ID范围分片（1-1000万=分片1，xxx）
带来的问题：用户活跃度无法掌握，可能存在热点问题
方案3：按省份区县地区枚举
数据分配不一定均匀
```



### 中间件

#### 缓存

##### 为什么要使用缓存

（一）性能 如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。

![image-20210407164425598](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110752.png)

（二）并发 如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。

![image-20210407164450638](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110753.png)

##### Redis与mencached

![image-20210417223000949](C:\Users\zsy\AppData\Roaming\Typora\typora-user-images\image-20210417223000949.png)

##### 优秀的缓存系统Redis

```java
	Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。
	官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求。目前为止Redis支持的键值数据类型如下：
1) 字符串类型 string：一些复杂的计数功能的缓存。
	1. 存储： set key value
	2. 获取： get key
	3. 删除： del key
	
2) 哈希类型 hash ： map格式，单点登录，cookieId为key，30分钟过期，模拟session
	1. 存储： hset key field value
	2. 获取： hget key field: 获取指定的field对应的值 
			 hgetall key：获取所有的field和value
	3. 删除： hdel key field
	
3) 列表类型 list ： linkedlist格式。支持重复元素,消息队列,分页功能
	1. 添加：
		1. lpush key value: 将元素加入列表左表	
		2. rpush key value：将元素加入列表右边
	2. 获取：lrange key start end ：范围获取
	3. 删除：
		lpop key： 删除列表最左边的元素，并将元素返回
		rpop key： 删除列表最右边的元素，并将元素返回
		
4) 集合类型 set  ： 不允许重复元素,全局去重,交集、并集、差集
	1. 存储：sadd key value
	2. 获取：smembers key:获取set集合中所有元素
	3. 删除：srem key value:删除set集合中的某个元素	
	
5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序,排行榜应用，范围查找，延时应用
	1. 存储：zadd key score value
	2. 获取：zrange key start end [withscores]
	3. 删除：zrem key value
	
通用命令
    1. keys * : 查询所有的键
    2. type key ： 获取键对应的value的类型
    3. del key：删除指定的key value
```

具有如下优点：

```
Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储
Redis支持数据的备份，即master-slave模式的数据备份
```

 redis的应用场景

```
•	缓存（数据查询、短连接、新闻内容、商品内容等等）
•	聊天室的在线好友列表
•	任务队列。（秒杀、抢购、12306等等）
•	应用排行榜
•	网站访问统计
•	数据过期处理（可以精确到毫秒
•	分布式集群架构中的session分离
```

##### redis为什么这么快

```
纯内存操作
单线程操作，避免了频繁的上下文切换
采用了非阻塞I/O多路复用机制
```

我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。 需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库

![image-20210407165146422](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110754.png)

##### Redis持久化

```
1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。
2. redis持久化机制：
    1. RDB：默认方式，不需要进行配置，默认就使用这种机制
    * 在一定的间隔时间中，检测key的变化情况，然后持久化数据
    1. 编辑redis.windwos.conf文件
    #   after 900 sec (15 min) if at least 1 key changed
    save 900 1
    #   after 300 sec (5 min) if at least 10 keys changed
    save 300 10
    #   after 60 sec if at least 10000 keys changed
        save 60 10000

        2. 重新启动redis服务器，并指定配置文件名称
        D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9>redis-server.exe redis.windows.conf	

            2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据
            1. 编辑redis.windwos.conf文件
            appendonly no（关闭aof） --> appendonly yes （开启aof）

            # appendfsync always ： 每一次操作都进行持久化
            appendfsync everysec ： 每隔一秒进行一次持久化
            # appendfsync no	 ： 不进行持久化
```

##### redis的过期策略及内存淘汰机制

redis采用的是定期删除+惰性删除策略。

定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 

**采用定期删除+惰性删除就没其他问题了么?** 

不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。

##### Redis内存淘汰机制

在redis.conf中有一行配置该配置就是配内存淘汰策略的

```
maxmemory-policy volatile-lru
```

1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。

 2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。 

3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。 

4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐 

5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐

6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键
空间中，有更早过期时间的key优先移除。不推荐 ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。

4.0 版本后增加以下两种：
7. volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使⽤的数据淘汰
8. allkeys-lfu（least frequently used）：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最不经常使⽤的 key

**为什么不用定时删除策略?** 

定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略. 

##### 渐进式ReHash

扩展或收缩哈希表需要将 `ht[0]` 里面的所有键值对 rehash 到 `ht[1]` 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。

如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 `ht[1]` 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。渐进式rehash的好处在于它采取分为而治的方式，将rehash键值对的计算均摊到每个字典增删改查操作，避
免了集中式rehash的庞大计算量。

以下是哈希表渐进式 rehash 的详细步骤：

1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。
2. 在字典中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ， 表示 rehash 工作正式开始。
3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。
4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110755.png)

在进行渐进式 rehash 的过程中， 字典会同时使用 `ht[0]` 和 `ht[1]` 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 `ht[0]` 里面进行查找， 如果没找到的话， 就会继续到 `ht[1]` 里面进行查找， 诸如此类。

另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 `ht[1]` 里面， 而 `ht[0]` 则不再进行任何添加操作： 这一措施保证了 `ht[0]` 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。

##### 缓存穿透

概念访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。
解决方案：
采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；
访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。

##### 缓存雪崩

大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。
解决方案
可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效；
采用限流算法，限制流量；
采用分布式锁，加锁访问。

#### 消息队列

消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题
实现高性能，高可用，可伸缩和最终一致性架构
使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ

![image-20210307191714942](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110756.png)

缺点：系统可用性降低、系统复杂性提高：怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性、一致性问题

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110757.png)

##### 异步处理

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110758.png)

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110759.png)

##### 应用解耦

场景说明：用户下单后，订单系统需要通知库存系统。传统做法是，订单系统调用库存系统的接口。如下图

![image-20210407225046264](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110800.png)

传统模式的缺点：
假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，同时，订单系统与库存系统耦合

![image-20210407225145007](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110801.png)

订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作
假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦

##### 流量削锋

流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛
应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。
可以控制活动的人数
可以缓解短时间内高流量压垮应用

![image-20210407225344907](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110802.png)

用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面
秒杀业务根据消息队列中的请求信息，再做后续处理

##### 日志处理

日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下

![image-20210407225433351](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110803.png)

日志采集客户端，负责日志数据采集，定时写受写入Kafka队列
Kafka消息队列，负责日志数据的接收，存储和转发
日志处理应用：订阅并消费kafka队列中的日志数据

##### 消息通讯

消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等
点对点通讯：

![image-20210407225557334](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110804.png)

聊天室通讯：

![image-20210407225619737](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110805.png)



##### 电商系统

![image-20210407225743294](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110806.png)

消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。
（1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）
（2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。
（3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。

##### 日志收集系统

![image-20210407225849548](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110807.png)

为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。
Zookeeper注册中心，提出负载均衡和地址查找服务
日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列
Kafka集群：接收，路由，存储，转发等消息处理
Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据

##### JMS消息服务

讲消息队列就不得不提JMS 。JMS（JAVA Message Service,java消息服务）API是一个消息服务的标准/规范，允许
应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。
在EJB架构中，有消息bean可以无缝的与JM消息服务集成。在J2EE架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。

##### 两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)

如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式。

P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。
P2P的特点
每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)，发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列
接收者在成功接收消息之后需向队列应答成功

![image-20210407230426794](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110808.png)

如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。

Pub/sub模式包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。
Pub/Sub的特点
每个消息可以有多个消费者
发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息
为了消费消息，订阅者必须保持运行的状态
为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运
行），它也能接收到发布者的消息。

![image-20210407230510471](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110809.png)

在JMS中，消息的产生和消费都是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。
（1）同步
订阅者或接收者通过receive方法来接收消息，receive方法在接收到消息之前（或超时之前）将一直阻塞；
（2）异步
订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。

##### 防止消息丢失

由于网络问题，我们很难保证生产者发送的消息能100%到达消息队列服务器，也就是说有消息丢失的可能性，因此，生产者就必须具有消息丢失检测和重发机制，也就是我们常说的消息队列的事物机制

不能把可靠性的保证全部交给TCP，TCP只保证了传输层的可靠传输，但是无法保证与应用层的交互是否出错
TCP无法给应用层任何反馈，因此必须在应用层处理差错
**同步的事务——停止等待**
所谓停止等待协议就是没发送完一组数据后，等待对方确认并且收到确认后，再发送下一组数据。

![image-20210407230625065](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110810.png)

**同步的事务——连续ARQ**
类似于TCP的滑动窗口模型

![image-20210407230654497](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110811.png)

**异步的事务——回调机制**
生产者在发送消息的时候，注册一个回调函数，这样生产者便不用停下来等待确认了，而是可以一直持续发送消
息，当消息到达消息队列服务器的时候，服务器便会调用生产者注册的回调函数，告知生产者消息发送成功了还是
失败了，进而做进一步的处理，从而提高了并发量。

![image-20210407230718032](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110812.png)

#### 负载均衡

##### dns域名解析负载均衡

原理：在DNS服务器上配置多个域名对应IP的记录。例如一个域名www.baidu.com对应一组web服务器IP地址，域名解析时经过DNS服务器的算法将一个域名请求分配到合适的真实服务器上。

![image-20210408160022369](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110813.png)

优点：将负载均衡的工作交给了DNS，省却了网站管理维护负载均衡服务器的麻烦，许多DNS还支持基于地
理位置的域名解析，将域名解析成距离用户地理最近的一个服务器地址，加快访问速度，改善性能。
缺点：目前的DNS解析是多级解析，每一级DNS都可能缓存记录A，当某一服务器下线后，该服务器对应的DNS
记录A可能仍然存在，导致分配到该服务器的用户访问失败。
DNS负载均衡的控制权在域名服务商手里，网站可能无法做出过多的改善和管理。
不能够按服务器的处理能力来分配负载。DNS负载均衡采用的是**简单的轮询算法**，不能区分服务器之间的差异，
不能反映服务器当前运行状态，所以其的负载均衡效果并不是太好。
可能会造成额外的网络问题。为了使本DNS服务器和其他DNS服务器及时交互，保证DNS数据及时更新，使地址
能随机分配，一般都要将DNS的刷新时间设置的较小，但太小将会使DNS流量大增造成额外的网络问题。

##### 反向代理负载均衡

原理：反向代理处于web服务器这边，反向代理服务器提供负载均衡的功能，同时管理一组web服务器，它根据负载均衡算法将请求的浏览器访问转发到不同的web服务器处理，处理结果经过反向服务器返回给浏览器。

![image-20210408160246561](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110814.png)

例如：浏览器访问请求的地址是反向代理服务器的地址114.100.80.10，反向代理服务器收到请求，经过负载均衡算法后得到一个真实物理地址10.0.03，并将请求结果发给真实无服务，真实服务器处理完后通过反向代理服务器返回给请求用户。
优点：部署简单，处于http协议层面。
缺点：使用了反向代理服务器后，web 服务器地址不能直接暴露在外，因此web服务器不需要使用外部IP地址，
而反向代理服务作为沟通桥梁就需要配置双网卡、外部内部两套IP地址。

##### http重定向协议实现负载均衡

原理：根据用户的http请求计算出一个真实的web服务器地址，并将该web服务器地址写入http重定向响应中返回给浏览器，由浏览器重新进行访问。

![image-20210408160410793](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110815.png)

优点：比较简单
缺点：浏览器需要两次次请求服务器才能完成一次访问，性能较差。
http重定向服务器自身的处理能力可能成为瓶颈。
使用http302响应重定向，有可能使搜索引擎判断为SEO作弊，降低搜索排名。

##### 一致性hash+虚拟节点

**一致性hash**——改进的分布式方法

1）求出服务器节点的哈希值， 将其配置到0～232的圆上；

2）用同样的方法求出存储数据的键的哈希值并映射到圆上；

3）从数据映射到的位置开始顺时针查找，将数据保存到找到的第一台服务器上；

4）如果超过232仍然找不到服务器，就保存到第一台服务器上。

![image-20210408161138645](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110816.png)

**虚拟节点：** 

使用一般的hash函数，服务器的映射地点的分布可能出现不均匀的情况。

  为每个物理节点（服务器）在圆环上分配100～200个点，从而抑制分布不均匀，最大限度地减小服务器增减时的缓存重新分布。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110817.jpg)

#### Zookeeper

##### ZK简述

Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架， 它负责存储和管理大家都关心的数据， 然后接受观察者的注册， 一旦这些数据的状态发生变化， Zookeeper就将负责通知已经在
Zookeeper上注册的那些观察者做出 相应 的反 应 ， 从而 实现集群中类似Master/Slave管理模式

##### 数据结构

![image-20210408164737111](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110818.png)

![image-20210408164850759](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110819.png)

```
此外，znode还有操作权限。如果我们把以上几类属性细化，又可以得到以下属性的细节：
czxid：创建节点的事务的zxid
mzxid：对znode最近修改的zxid
ctime：以距离时间原点(epoch)的毫秒数表示的znode创建时间
mtime：以距离时间原点(epoch)的毫秒数表示的znode最近修改时间
version：znode数据的修改次数
cversion：znode子节点修改次数
aversion：znode的ACL修改次数
ephemeralOwner：如果znode是临时节点，则指示节点所有者的会话ID；如果不是临时节点，则为零。
dataLength：znode数据长度。
numChildren：znode子节点个数。
```

znode中的存在类型
我们知道了zookeeper内部维护了一套数据结构：由znode构成的集合，znode的集合又是一个树形结构。每一个znode又有很多属性进行描述。并且znode的存在性还分为四类，如下如所示：

![image-20210408165138724](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110820.png)

```
znode是由客户端创建的，它和创建它的客户端的内在联系，决定了它的存在性：
PERSISTENT-持久化节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点也不会被删除（除非您使用API强制删除）。
PERSISTENT_SEQUENTIAL-持久化顺序编号节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当客户端与zookeeper服务的连接断开后，这个节点也不会被删除。
EPHEMERAL-临时目录节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点（还有涉及
到的子节点）就会被删除。
EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当创建这个节点的客户端与zookeeper服务的连接断开后，这个节点被删除。
另外，无论是EPHEMERAL还是EPHEMERAL_SEQUENTIAL节点类型，在zookeeper的client异常终止后，节
点也会被删除。
```

##### 统一命名服务

![image-20210408165643277](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110821.png)

##### 负载均衡

![image-20210408165657899](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110822.png)

##### 统一配置管理

![image-20210408165714977](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110823.png)

##### 集群管理

![image-20210408165736904](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110824.png)

##### 服务器动态上下线

![image-20210408165752431](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110825.png)

##### 写数据流程

Zookeeper提供的是 弱一致性，CAP限制，读的的数据可能不是最新的，如果想读到最新的数据，应该手动调用sync方法从Leader同步数据

![image-20210408165826077](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110826.png)

##### Leader选举

ZK的Leader负责同步数据，发起选举
1）半数机制：集群中半数以上机器存活，集群可用。所以zookeeper适合装在奇数台机器上。
2）Zookeeper虽然在配置文件中并没有指定master和slave。但是，zookeeper工作时，是有一个节点为leader，
其他则为follower，Leader是通过内部的选举机制临时产生的
3）以一个简单的例子来说明整个选举的过程。
假设有五台服务器组成的zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么。

![image-20210408165856735](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110827.png)

```
（1）服务器1启动，此时只有它一台服务器启动了，它发出去的报没有任何响应，所以它的选举状态一直是
LOOKING状态。
（2）服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，
所以id值较大的服务器2胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是
3)，所以服务器1、2还是继续保持LOOKING状态。
（3）服务器3启动，根据前面的理论分析，服务器3成为服务器1、2、3中的老大，而与上面不同的是，此时有三
台服务器选举了它，所以它成为了这次选举的leader。
（4）服务器4启动，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是由于前面已经有半
数以上的服务器选举了服务器3，所以它只能接收当小弟的命了。
（5）服务器5启动，同4一样当小弟
```

#### 秒杀

##### 业务特点

![image-20210408095317899](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110828.png)

##### 技术难点

**现有业务的冲击**
秒杀是营销活动中的一种，如果和其他营销活动应用部署在同一服务器上，肯定会对现有其他活动造成冲击，极端情况下可能导致整个电商系统服务宕机。
**直接下订单**
下单页面是一个正常的 URL 地址，需要控制在秒杀开始前，不能下订单，只能浏览对应活动商品的信息。简单来说，需要 Disable 订单按钮。
**页面流量突增**
秒杀活动开始前后，会有很多用户请求对应商品页面，会造成后台服务器的流量突增，同时对应的网络带宽增加，需要控制商品页面的流量不会对后台服务器、DB、Redis 等组件的造成过大的压力

##### 架构设计思想

![image-20210408095639159](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110829.png)

##### 客户端优化

客户端优化主要有两个问题：
**秒杀页面**
秒杀活动开始前，其实就有很多用户访问该页面了。如果这个页面的一些资源，比如 CSS、JS、图片、商品详情
等，都访问后端服务器，甚至 DB 的话，服务肯定会出现不可用的情况。所以一般我们会把这个页面整体进行静态化，并将页面静态化之后的页面分发到 CDN 边缘节点上，起到压力分散的作用。
**防止提前下单**
防止提前下单主要是在静态化页面中加入一个 JS 文件引用，该 JS 文件包含活动是否开始的标记以及开始时的动态下单页面的 URL 参数。同时，这个 JS 文件是不会被 CDN 系统缓存的，会一直请求后端服务的，所以这个 JS 文件一定要很小。当活动快开始的时候（比如提前），通过后台接口修改这个 JS 文件使之生效。

##### API 接入层优化

客户端优化，对于不是搞计算机方面的用户还是可以防止住的。但是稍有一定网络基础的用户就起不到作用了，他会自己写post,因此服务端也需要加些对应控制，不能信任客户端的任何操作。一般控制分为 2 大类：
**限制用户维度访问频率**
针对同一个用户（ Userid 维度），做页面级别缓存，单元时间内的请求，统一走缓存，返回同一个页面。
**限制商品维度访问频率**
大量请求同时间段查询同一个商品时，可以做页面级别缓存，不管下回是谁来访问，只要是这个页面就直接返回。

##### 秒杀整体流程图

![image-20210408102940798](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414110830.png)

通过上面流程图就会发现压力最大的地方在哪里？
MQ 排队服务，只要 MQ 排队服务顶住，后面下订单与扣减库存的压力都是自己能控制的，根据数据库的压力，可以定制化创建订单消费者的数量，避免出现消费者数据量过多，导致数据库压力过大或者直接宕机。
库存服务专门为秒杀的商品提供库存管理，实现提前锁定库存，避免超卖的现象。同时，通过超时处理任务发现已抢到商品，但未付款的订单，并在规定付款时间后，处理这些订单，将恢复订单商品对应的库存量。

总结核心思想：**层层过滤**
尽量将请求拦截在上游，降低下游的压力
充分利用缓存与消息队列，提高请求处理速度以及削峰填谷的作用

#### 素质测评

##### 文字理解能力考查

这个主要是看语言的理解能力，紧跟材料就可以，往往是考察大家的分析能力和阅读能力，一般不会有那种刻意饶的陷阱，就是注意不要主观的臆测，一切以所给的材料为主就可以。

做这种题目很忌讳同学们不认真读材料，仅靠判断选项就得出答案，其实选项往往都是正确，而题目考察的是选项与材料的关联度，不仅仅是选项本身观点的正确与否；还有一种是同学们容易犯的错误，容易过度解读，属于“想的太多”，也容易曲解出题人的本意、

**还有一种是要求你从所给的四个选项中选出一个填空，使句子的意思表达得最准确：**



##### 数字推理能力考查

这个考察比较多的，一般就是小学奥数或者公务员行测中的那种数字推理填空题，总体上不难，但是要求考生对数字比较敏感，或者是掌握了一定答题套路，知道从哪几种常见规律入手。

**技巧总结：这就要求我们对于常见的等差或等比的数量关系比较熟悉，因为数字与数字之间的差值往往就是这几种关系的组合。**

如

1、差值是**固定递增的关系**：1，3，5，7，9或者2，4，6，8，10等等

2、**平方递增的关系**，就要对于平方关系比较熟悉：4（2的平方），9（3），16（4），25（5），36，49，64，81，100，121，144，169，196，225，256，289，324，361，400...最好是1~20的平方自己都能背出来

3、**立方关系**：8（2的立方），27（3），64（4），125，216，343，512，729，1000...最好1`10的立方能够自己背下来

4、**质数关系**：2，3，5，7，11，13，17，19，23，29....

5、**开方关系**：2（4的开方），3（9），4（16）....

如**例题2**：1，3，5，7，（）...这里是9，差值是2

1，2，6，15，31，（）...这里是56，差值是平方

1，2，10，37，（）...这里是101，差值是立方

**例题3**：0，9，26，65，124，（）

A．165 B．193 C．217 D．239

**解答：**数列中除了0、9是多次方数，其他的三个附件有多次方数，如26有25、27，65有64，124有125、121，分析差值情况，显然只能选项差为1的，所以将他们转化为多次方的形式就很清楚，1的三次方-1，2的三次方+1，3的三次方-1，4的三次方+1，5的三次方-1，6的三次方+1，所以答案很清楚选C。当然这里面也加入了奇偶列的考察。

**技巧在总结：上面的这些规律都可以跟奇偶列数结合来考察同学，所以考察的方式是多样的**，一般而言如果数列的数都较小，且比较分散，我们就要采用做和或者做积的方法来尝试，可以是两两做和，也可以是三三做和。当数列的最后一项或者是给出的选项变化较大的时候，我们基本可以判定数列为递推数列，且为倍数、乘积或者是方递推数列。

**例题4：**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104632.jpg)

**解析：**像这种分数的也是一样，要学会去找两个数字之间的关系，我们发现前一个分数的分子加分母的值，等于后面一个分数分母的值，所以很快可以判断出答案选A。



**技巧总结：**一般我们判断，在同一个数列中，分数的个数多于整数个数时，定义此为分数数列，在解答时用到的技巧主要有：约分、通分、反约分、做差、做积或者考虑前后项的关系。

而在同一个数列中，当分数的个数少于整数个数时，如果：

1、数列看起来好像两头小，中间大，此时应考虑多次方数列；

2、数列具有单调性，且只有一项或者两项分数，此时考虑等比数列或者递推数列，递推的规律是前两项的和或者乘积除以某个数值。

##### 图像推理能力考查

**技巧总结：**

\1. 图形相同看位置——平移，旋转，翻转（注意位置移动的方向和距离；时针法判断旋转和翻转）。

2、图形相似看样式 ——遍历，运算。遍历指的是每行或列有相同个数的组成元素，但排列不同，

3、图形杂乱看属性和数量——对称，曲直，封闭和点线面角素：属性： 封闭，曲直，对称——注意对称轴的方位和数量；点——线线接触时数点：交点，顶点，割点，切点；线——线多，数线条，优先数直线；面——所给图形有明显的区域划分（封闭区间）；角——（180度以内的内角）题中有扇形出现时——数角；棱角分明且多的图形——数角；素（部分）——图形的组成元，或者有几个独立的部分组成

4、折叠图形先看特征面，再看双面关系，旋转确定三面关系；

**例题1**：

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104633.jpg)

因为在第一套图形中多边形均有一条边双线，在第二套图形中均有二条相邻的边双线。所以选C，当然，这是最简单的一种考题。

**例题2：**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104634.jpg)

**【解答】**D。本题属于数量类。按照“直线居多数直线”的原则，发现每一列的第一个图形的直线数减去第二个等于第三个。

**例题3：**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104635.jpg)

**【解答】**B。本题属于数量类。数面，都有1个封闭区间，选B。



**例题4：**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104636.jpg)

**【解答】B，**本题属于样式类。求同，每一行三个图形都有一个相同元素，第三行都有一平行四边形。



**例题5：**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104637.jpg)

**【解答】**D。本题属于样式类。分别是横轴对称、竖轴对称、横竖轴对称、横竖轴对称、竖轴对称，所以选D。

**例题6：**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104638.jpg)

**【解答】**B。平面组成型，元素相同看时针方向，四个扇形组成相同，从黑点向白点画一个箭头，发现四个扇形都是顺时针方向，选B。

**例题7：**

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104639.jpg)

**【解答】**A。本题属于位置类。在图形外面的曲线上添上箭头，会发现，每一行的第一个图形与第三个图形方向一样，第二个方向相反，所以选A。

### 代码题

#### JavaSTL

```java
String：
public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。
public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象比较，忽略大小写。
public int length () ：返回此字符串的长度。
public String concat (String str) ：将指定的字符串连接到该字符串的末尾。
public char charAt (int index) ：返回指定索引处的 char值。
public int indexOf (String str) ：返回指定子字符串第一次出现的索引。如果没有返回-1
public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取到结尾。
public String substring (int beginIndex, int endIndex) ：含beginIndex，不含endIndex
public char[] toCharArray () ：将此字符串转换为新的字符数组。
public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。
public String replace (CharSequence target, CharSequence replacement) ：、后者替换前者。
public String[] split(String regex) ：regex（规则）拆分为字符串数组。“,|=”表示分割符分为“，”和“=”
trim()方法返回字符串的副本，忽略前导空格和尾部空格。
boolean startsWith()方法与endsWith()方法分别用于判断字符串是否以指定的内容开始或结束。
toLowerCase()大写字母改写为小写字母，而tuUpperCase()方法将小写字母改写为大写字母。
```



```java
//打印list
System.out.println(Arrays.toString(list.toArray()));
//拷贝数组src从0开始拷贝到dest,包含0，不包含3
System.arraycopy( src, 0, dest, 0, 3);
import java.util.*;
public class STLUse {
    public static void arrayList() {
        System.out.println("================arraylist================");
        ArrayList<Integer> list = new ArrayList<Integer>();
        for (int i = 0; i < 5; i++) {
            list.add(i);
        }
        System.out.println(list.contains(new Integer(2)));

        // 遍历
        for (Integer i : list) {
            System.out.print(i + " ");
        }
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.get(i) + " ");
        }
        Iterator<Integer> it = list.iterator();
        while (it.hasNext()) {
            System.out.print(it.next() + " ");
        }
        // ACID
        list.add(0, 9);
        System.out.println(list.indexOf(3));
        System.out.println(list.lastIndexOf(3));
        list.remove(2);
        list.remove(new Integer(3));
        System.out.println(list.toString());
        list.set(0, 1000);

        //Collections 交换
        Collections.swap(list, 1, 4);
        //最大max 最小min
        //static int binaryScarch ( List list,Object key)
		//使用二分法搜索指定对象在List集合中的索引，查找的 List集合中的元素必须是有序的
        // 排序
        Collections.sort(list);
        System.out.println(list.toString());
        Collections.sort(list, new Comparator<Integer>() {
            @Override
            // o1排在o2后面,返回值大于0 ，来查看升序还是降序
            public int compare(Integer o1, Integer o2) {
                // TODO Auto-generated method stub
                return o2 - o1;
            }
        });
        System.out.println(list.toString());
        System.out.println("================linklist================");
        list.addFirst(1);
        list.addLast(9);
        list.getFirst();
        list.getLast();
    }
    
    public static void queue() {
        System.out.println("================queue================");
        Queue<Integer> q = new LinkedList<Integer>();
        q.offer(1);
        q.offer(2);
        q.offer(3);
        q.offer(4);
        // q.element();//返回队头
        System.out.println(q.peek());
        // q.remove();//移除并返回队头
        System.out.println(q.poll());
        System.out.println(q.toString());
    }

    private static void stack() {
        System.out.println("================stack================");
        LinkedList<Integer> s = new LinkedList<Integer>();
        for (int i = 0; i < 4; i++) {
            s.push(i);
        }
        System.out.println(s.peek());
        System.out.println(s.pop());
        System.out.println(s.toString());

    }

    // 无序不可重复,非线程安全的
    // 首先，hashCode()方法返回的是一个哈希值，这个哈希值是由对象在内存中的地址所形成的，
    // 如果两个对象的哈希值不一样，那么这两个对象肯定是不相同的，如果哈希值一样，那么这还不能肯定这两个对象是否一样，
    // 还需要通过equlas()方法比较一下两个对象是否一样，equals()返回true才能说明这两个对象是相同的
    private static void hashset() {
        System.out.println("================hashset================");
        Set<String> set = new HashSet<String>();
        set.add("123");
        set.add("456");
        set.add("zsy");
        set.add("123");
        System.out.println(set.size());
        set.remove("zsy");
        set.remove(new String("456"));
        System.out.println(set.toString());
    }

    // 非线程安全的，排序规则是默认使用元素的自然排序,重不重复也是通过compareTo()方法来完成的，当compareTo()方法返回值为0时，两个对象是相同的。
    // LinkedHashSet将会以元素的放入顺序来依次访问
    private static void treeset() {
        System.out.println("================treeset================");
        Set<String> set = new TreeSet<String>();
        set.add("123");
        set.add("963");
        set.add("125");
        set.add("456");
        set.add("zsy");
        set.add("123");
        System.out.println(set.size());
        set.remove("zsy");
        set.remove(new String("456"));
        System.out.println(set.toString());
    }

    private static void hashmap() {
        System.out.println("================hashmap================");
        Map<String, Integer> map = new HashMap<String, Integer>();
        map.put("zsy", 93);
        map.put("syz", 86);
        map.put("ysz", 88);

        // 1.通过遍历键的Set集合来遍历整个Map集合
        System.out.println("foreach遍历");
        for (String str : map.keySet()) {
            System.out.println(str + ":" + map.get(str));
        }

        System.out.println("迭代器遍历");
        Iterator<String> intertor = map.keySet().iterator();
        while (intertor.hasNext()) {
            String key = intertor.next();
            System.out.println(key + ":" + map.get(key));
        }

        // 2.使用Map集合的关系遍历
        System.out.println("Map关系遍历");
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }
        
        //以key排序用treemap
        TreeMap treemap = new TreeMap(map); 
		//以value排序，先转为list
        ArrayList<Map.Entry<Integer, Integer>> entries = new ArrayList<>(map.entrySet());
        Collections.sort(entries, new Comparator<Map.Entry<Integer, Integer>>() {
            @Override
            public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
                return o2.getValue().compareTo(o1.getValue());//降序
            }
        });

        map.remove("zsy");
        System.out.println(map.toString());
    }

    private static void treemap() {

        System.out.println("================treemap================");
        Map<String, Integer> map = new TreeMap<String, Integer>();
        map.put("zsy", 93);
        map.put("syz", 86);
        map.put("ysz", 88);

        // 1.通过遍历键的Set集合来遍历整个Map集合
        System.out.println("foreach遍历");
        for (String str : map.keySet()) {
            System.out.println(str + ":" + map.get(str));
        }

        System.out.println("迭代器遍历");
        Iterator<String> intertor = map.keySet().iterator();
        while (intertor.hasNext()) {
            String key = intertor.next();
            System.out.println(key + ":" + map.get(key));
        }

        // 2.使用Map集合的关系遍历
        System.out.println("Map关系遍历");
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }

        map.remove("zsy");
        System.out.println(map.toString());
    }

    public static void main(String[] args) {
        arrayList();
        linklist();
        queue();
        stack();
        hashset();
        treeset();
        hashmap();
        treemap();
    }
}
```

#### 代码模板

##### 快排

```c
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];//中间数最好
    while (i < j)
    {
        //while (q[++i] < x);
		//while (q[--j] > x);
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

<!--more-->

##### 归并

```c
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
    //多出来的合并
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

##### 二分

整数二分算法模板 —— 模板题 AcWing 789. 数的范围

![image-20210325214301736](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161114.png)

```c
bool check(int x) {/* ... */} // 检查x是否满足某种性质
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：//有减要加1
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
```

浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根

```c
bool check(double x) {/* ... */} // 检查x是否满足某种性质
double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

##### 高精度

```java
Java语法糖，秒杀高精度
import java.io.*;
import java.math.BigInteger;
class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));
        String[] s = cin.readLine().split(" ");
        BigInteger n = new BigInteger(s[0]);
        s = cin.readLine().split(" ");
        BigInteger m = new BigInteger(s[0]);
        System.out.println(m.add(n));
        System.out.println(n.subtract(m));
        System.out.println(n.multiply(m));
        System.out.println(n.divide(m));
        System.out.println(n.remainder(m));//取余
    }
}
高精度加法 —— 模板题 AcWing 791. 高精度加法
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if (t) C.push_back(t);
    return C;
}
高精度减法 —— 模板题 AcWing 792. 高精度减法
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
	//去除前面的0
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法
// C = A * b, A >= 0, b > 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
高精度除以低精度 —— 模板题 AcWing 794. 高精度除法
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

##### 前缀和

一维前缀和 —— 模板题 AcWing 795. 前缀和

输入一个长度为 n 的整数序列。输出原序列中从第 l 个数到第 r 个数的和

```c
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

二维前缀和 —— 模板题 AcWing 796. 子矩阵的和

![image-20210104161136636](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161111.png)

```
第i行j列格子左上部分所有元素的和
S[i, j] = S[i-1,j]+S[i,j-1]-S[i-1,j-1]+a[i,j]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

##### 差分

一维差分 —— 模板题 AcWing 797. 差分

```c
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```

二维差分 —— 模板题 AcWing 798. 差分矩阵

```c
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
B[x1, y1] += c, B[x2 + 1, y1] -= c, B[x1, y2 + 1] -= c, B[x2 + 1, y2 + 1] += c
```

##### 位运算

```c
求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n&-n=n&(~n+1)  x=1010 lowbit(x)=10
整数的二进制表示中的最右边一个1变成0：n = (n - 1) & n;
```

##### 双指针

```c
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
(1) 对于一个序列，用两个指针维护一段区间
(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

##### 离散化

```c
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

##### 区间合并

```c
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

##### 回溯

回溯算法其实就是不断尝试的过程，一旦尝试成功了，就算成功了，如果尝试失败了还会回到上一步，注意回到上一步的时候还要把状态还原到上一步的状态。回溯算法这里就不在过多介绍，关于回溯算法的 可以看下450，什么叫回溯算法，一看就会，一写就废。

回溯算法其实有一个经典的模板

```
private void backtrack("原始参数") {
    //终止条件(递归必须要有终止条件)
    if ("终止条件") {
        //一些逻辑操作（可有可无，视情况而定）
        return;
    }

    for (int i = "for循环开始的参数"; i < "for循环结束的参数"; i++) {
        //一些逻辑操作（可有可无，视情况而定）

        //做出选择

        //递归
        backtrack("新的参数");
        //一些逻辑操作（可有可无，视情况而定）

        //撤销选择
    }
}
```

### 经典题目

#### 背包问题

![image-20210325214000189](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161113.png)

##### 01背包

![image-20210104145246880](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161112.png)

```java
public class Main{
    public static void main(String[] args) throws Exception {
        // 读入数据的代码
        Scanner reader = new Scanner(System.in);
        // 物品的数量为N
        int N = reader.nextInt();
        // 背包的容量为V
        int V = reader.nextInt();
        // 一个长度为N的数组，第i个元素表示第i个物品的体积；
        int[] v = new int[N + 1] ;
        // 一个长度为N的数组，第i个元素表示第i个物品的价值；
        int[] w = new int[N + 1] ;

        for (int i=1 ; i <= N ; i++){
            // 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值
            v[i] = reader.nextInt();
            w[i] = reader.nextInt();
        }
        reader.close() ;

        // 正式工作的代码
        /*
        定义一个二阶矩阵dp[N+1][V+1],
        这里之所以要N+1和V+1，是因为第0行表示只能选择第0个物品的时候，即没有物品的时候
        第0列表示背包的体积为0的时候，即不能装任何东西的时候

        dp[i][j]表示在 只能选择前i个物品，背包容量为j的情况下，背包中物品的最大价值
        对于dp[i][j]有两种情况：
        1. 不选择当前的第i件物品/第i件物品比背包容量要大，则dp[i][j] = dp[i-1][j]
        2. 选择当前的第i件物品（潜在要求第i件物品体积小于等于背包总容量），则能装入的物品最大价值为：
            当前物品的价值 加上 背包剩余容量在只能选前i-1件物品的情况下的最大价值
            dp[i][j] = dp[i-1][j-v[i]] + w[i]
        dp[i][j]在两种情况中选择比较大的情况作为当前的最优解；
        即：
        if(j >= v[i]):
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])
        else:
            dp[i][j] = dp[i-1][j]
        */
        int[][] dp = new int[N+1][V+1];
        dp[0][0] = 0;
        for(int i = 1; i <= N; i++){
            for(int j = 0; j <= V; j++){
                if(j >= v[i]){
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        System.out.println(dp[N][V]);
    }
}

//有优化版
/*
1. f[i] 仅用到了f[i-1]层, 
2. j与j-v[i] 均小于j
3.若用到上一层的状态时,从大到小枚举, 反之从小到大哦

注意，这里第二层循环的时候，还是小到大循环的话，那么
 dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])
实际上变成了
dp[i][j] = Math.max(dp[i][j], dp[i][j-v[i]] + w[i]);
因为i-1的值已经在前面被更新过了，覆盖了
为了避免这个问题，所以要逆序更新，即先更新第i个，然后更新第i-1个，从而保证第i-1个不被覆盖
*/
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int [N+2];
    int[] w=new int [N+2];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
    }
    int[] f=new int[V+1];//多开
    for(int i=1;i<=N;i++){
        for(int j=V;j>=v[i];j--){
            f[j]=Math.max(f[j],f[j-v[i]]+w[i]);
        }
    }
    System.out.println(f[V]);
}
```

##### 完全背包

![image-20210325211930272](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161115.png)

```java
//会爆
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int[N+1];
    int[] w=new int[N+1];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
    }
    int dp[][]=new int [N+1][V+1];
    for(int i=1;i<=N;i++){
        for(int j=1;j<=V;j++){//体积
            for(int k=0;k*v[i]<=j;k++){//枚举k ,找最大
                dp[i][j]=Math.max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);
            }
        }
    }
    System.out.println(dp[N][V]);
}
```

**优化**

![image-20210325215256820](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161116.png)

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int[N+1];
    int[] w=new int[N+1];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
    }
    int dp[][]=new int [N+1][V+1];
    for(int i=1;i<=N;i++){
        for(int j=1;j<=V;j++){
            dp[i][j]=dp[i-1][j];
            if(j>=v[i])dp[i][j]=Math.max(dp[i-1][j],dp[i][j-v[i]]+w[i]);
        }
    }
    System.out.println(dp[N][V]);
}
```

**在优化为一维**

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int[N+1];
    int[] w=new int[N+1];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
    }
    int dp[]=new int [V+1];
    for(int i=1;i<=N;i++){
        for(int j=v[i];j<=V;j++){
            dp[j]=Math.max(dp[j],dp[j-v[i]]+w[i]);
        }
    }
    System.out.println(dp[V]);
}
```

##### 多重背包

![image-20210325230403204](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161117.png)

```java
//f[i][j]=Math.max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); k=0,1,2,3,...s[i]
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int[] v=new int[N+1];
    int[] w=new int[N+1];
    int[] s=new int[N+1];
    for(int i=1;i<=N;i++){
        v[i]=sc.nextInt();
        w[i]=sc.nextInt();
        s[i]=sc.nextInt();

    }
    int [][]f=new int [N+1][V+1];
    for(int i=1;i<=N;i++){
        for(int j=0;j<=V;j++){
            for(int k=0;k<=s[i]&&k*v[i]<=j;k++){//枚举k,不超过s[i]
                f[i][j]=Math.max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
            }
        }
    }
    System.out.println(f[N][V]);
}
```

##### 分组背包

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int N=sc.nextInt();
    int V=sc.nextInt();
    int [] s=new int [N+1];
    int[][] v=new int[N+1][101];
    int[][] w=new int[N+1][1013];
    for(int i=1;i<=N;i++){
        s[i]=sc.nextInt();
        for(int j=1;j<=s[i];j++){
            v[i][j]=sc.nextInt();
            w[i][j]=sc.nextInt();
        }
    }
    int dp[][]=new int [N+1][V+1];
    for(int i=1;i<=N;i++){
        for(int j=1;j<=V;j++){//体积
            for(int k=0;k<=s[i];k++)
                if(j>=v[i][k])dp[i][j]=Math.max(dp[i][j],dp[i-1][j-v[i][k]]+w[i][k]);
        }
    }
    System.out.println(dp[N][V]);
}
```



#### 链表

无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。

##### 数组模拟链表

![数组表示单链表.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210519111500.png)

为什么使用数组来模拟链表
如果数据规模很大, 一个一个的new操作太慢了, 会超时, 使用数组会大大加快速度

单链表
数组模拟单链表

```java

private static int N = 100010;  // 数据规模为 10w

private static int head;                // 表示头结点的下标
private static int[] e = new int[N];    // 表示结点 i的值
private static int[] ne = new int[N];   // 表示结点 i的 next指针是多少
private static int idx;                 // 表示存储当前结点已经使用结点的下一个结点

// 初始化数据
private static void init() {
    head = -1;  // 没有头结点
    idx = 0;    // 没有存入数据
}

// 将 val插到头结点
private static void addToHead(int val) {
    e[idx] = val;   // 赋值
    ne[idx] = head; // 插入之前头结点的前面
    head = idx;     // 更新头结点信息
    idx++;          // idx向右移动
}

// 将下标是 k的点后面的点删掉
private static void remove(int k) {
    ne[k] = ne[ne[k]];  // 让下标为 k的结点指向 下个结点的下个结点
}

// 将 val插入下标为 k的点的后面
private static void add(int k, int val) {
    e[idx] = val;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}
```

##### 双指针判断环

```java
public boolean hasCycle(ListNode head) {
    //快慢指针 从同一起点走
    ListNode fast = head;
    ListNode slow = head;
    while(fast != null && fast.next !=null){
        fast =fast.next.next; //快指针走两步
        slow = slow.next; //慢指针走一步
        if(slow==fast){ //快慢指针相遇,证明有环
            return true;
        }
    }
    //否则 无环
    return false;
}
```

**求环节点**

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

```java
public boolean hasCycle(ListNode head) {
    Set<ListNode> seen = new HashSet<ListNode>();
    while (head != null) {
        if (!seen.add(head)) {
            return true;
        }
        head = head.next;
    }
    return false;
}
```

![fig1](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210508141930.png)

*a*+(*n*+1)*b*+*n**c*=2(*a*+*b*)⟹*a*=*c*+(*n*−1)(*b*+*c*)

```java
public ListNode detectCycle(ListNode head) {
    ListNode slow = head, fast = head;

    while (slow != null && fast != null && fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
        if(slow == fast) break;
    }
    //如果满足下面的条件，说明无环
    if(fast == null || fast.next == null) return null;
    //下面开始找环的入口节点  
    //刚才的循环 慢指针走了a + b (a是从开始到入口节点) 假设等于cnt
    //快指针走了 a + b + c + b (b + c = 环)，应该等于2 * cnt
    //推导出 a = c，所以把慢指针再放到头节点，下一次快慢指针相遇的节点即环的入口节点
    slow = head;
    while (slow != null && fast != null){
        if(slow == fast) break;
        slow = slow.next;
        fast = fast.next;
    }
    return fast;
}
```

##### 双指针找交点



##### 翻转链表

```java
public ListNode reverseList(ListNode head) {
    if(head==null||head.next==null){
        return head;
    }
    ListNode cur=head,pre=null;
    while(cur!=null){
        ListNode next=cur.next;
        cur.next=pre;
        pre=cur;
        cur=next;
    }
    return pre;
}
//递归
public ListNode reverseList(ListNode head) {
    if(head==null||head.next==null){
        return head;
    }
    ListNode p=reverseList(head.next);
    ListNode tmp=head.next;
    tmp.next=head;
    head.next=null;
    return p;
}
```

##### 两个栈实现队列

```java
/**
stack1主要存放数据，stack2是为了实现各方法而起到了临时中转站的作用（具体的实现往下看），设置不对等地位一方面也是为了编写易理解的代码。
push(int x)方法的实现
    队列元素入队，就是为了存放数据，我在这里直接使元素x入栈stack1。
pop()
    队列的pop是取队头元素，即最先push进来的元素，但该元素存储在栈stack1的栈底，因此若想取出栈底元素，就要想办法把它变为栈顶元素。OK，这个时候stack2就该上场了。把stack1的栈顶元素入栈进入到stack2，即语句stack2.push(stack1.pop());重复此操作直至全部元素进入到stack2。现在让stack2栈顶元素出栈即为队列的队头元素出队。完成出队操作后，还要把stack2剩下的元素放回stack1内，因为stack1是存放数据的，而且下文empty()方法也是依据stack1完成的。
*/
class MyQueue {
    Deque<Integer> stack1 =new LinkedList<Integer>();
    Deque<Integer> stack2 =new LinkedList<Integer>();
    public void push(int x) {
        stack1.push(x);
    }
    public int pop() {
        while (!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        int ans=stack2.pop();
        while (!stack2.isEmpty()){
            stack1.push(stack2.pop());
        }
        return ans;
    }
    public int peek() {
        while (!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        int ans=stack2.peek();
        while (!stack2.isEmpty()){
            stack1.push(stack2.pop());
        }
        return ans;
    }
    public boolean empty() {
        return stack1.isEmpty();
    }
}
```

#### 二叉树

##### 先序遍历（LeetCode144）

1、申请一个栈stack，然后将头节点压入stack中。

2、从stack中弹出栈顶节点，打印，再将其右孩子节点（不为空的话）先压入stack中，最后将其左孩子节点（不为空的话）压入stack中。

3、不断重复步骤2，直到stack为空，全部过程结束。

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list=new ArrayList<Integer>();
        Stack<TreeNode> stack=new Stack<TreeNode>();
        if (root!=null) {
            stack.push(root);
            while(!stack.empty()) {
                TreeNode tr=stack.pop();
                list.add(tr.val);
                if(tr.right!=null) {
                    stack.push(tr.right);
                }
                if(tr.left!=null) {
                     stack.push(tr.left);
                }
            }
        }
        return list;
    }
}
```

##### 中序遍历（LeetCode94）

1、申请一个栈stack，初始时令cur=head

2、先把cur压入栈中，依次把左边界压入栈中，即不停的令cur=cur.left，重复步骤2

3、不断重复2，直到为null，从stack中弹出一个节点，记为node，打印node的值，并令cur=node.right,重复步骤2

4、当stack为空且cur为空时，整个过程停止。

```
class Solution {
    public List<Integer> inorderTraversal(TreeNode head) {
        List<Integer> list=new ArrayList<Integer>();
        Stack<TreeNode> stack=new Stack<TreeNode>();
        if (head!=null) {
            while(head!=null||!stack.empty()) {
                if(head!=null) {
                    stack.push(head);
                    head=head.left;
                }else {
                    head=stack.pop();
                    list.add(head.val);
                    head=head.right;
                }
            }
        }
        return list;
    }
}
```

##### 后序遍历（LeetCode145）

用非递归的方式实现后序遍历有点麻烦。

1、申请一个栈s1，然后将头节点压入栈s1中。

2、从s1中弹出的节点记为cur，然后依次将cur的左孩子节点和右孩子节点压入s1中。

3、在整个过程中，每一个从s1中弹出的节点都放进s2中。

4、不断重复步骤2和步骤3，直到s1为空，过程停止。

5、从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序。

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode head) {
        List<Integer> list=new ArrayList<Integer>();
        Stack<TreeNode> stack1=new Stack<TreeNode>();
        Stack<TreeNode> stack2=new Stack<TreeNode>();
        if (head!=null) {
            stack1.push(head);
            while(!stack1.empty()) {
                head=stack1.pop();
                stack2.push(head);
                if (head.left!=null) {
                    stack1.push(head.left);
                }
                if (head.right!=null) {
                    stack1.push(head.right);
                }
            }
            while(!stack2.empty()) {
                list.add(stack2.pop().val);
            }
        }
        return list;
    }
}
```

![image-20210517112626536](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210517112628.png)

![image-20210518215858611](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210518215900.png)

#### 双指针

##### 最长连续不重复子序列

给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。 **双指针算法**

```java
public static void main(String[] a){
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int[] A=new int[n];
    int[] num=new int[100001];//记录i，j之前出现的数的次数，超过2表示有重复
    for(int i=0;i<n;i++){
        A[i]=sc.nextInt();
    }
    int ans=0;
    for(int i=0,j=0;j<n;j++){
        num[A[j]]++;
        //有重复 i向右移
        while(i<j&&num[A[j]]>1) {
            num[A[i]]--;
            i++;
        }
        ans=Math.max(ans,j-i+1);
    }
    System.out.println(ans);
}
```

#### 动态规划

##### 数字三角形的最大路径和

给定一个如下图所示的，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

![8021.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161120.png)

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int[][] f=new int [n+1][n+1];
    for(int i=0;i<n;i++){
        for(int j=0;j<=i;j++){
            f[i][j]=sc.nextInt();   
        }
    }
    //f[i][j]表示从下到上的最大值
    for(int i=n-1;i>=0;i--){
        for(int j=0;j<=i;j++){
            f[i][j]+=Math.max(f[i+1][j],f[i+1][j+1]);
        }
    }
    System.out.println(f[0][0]);
}
```

##### 最长上升子序列

![image-20210411111508252](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210411111534.png)

```java
public static void main(String[] args){
    int N=1001;
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int a[]=new int [N];
    for(int i=1;i<=n;i++){
        a[i]=sc.nextInt();
    }
    int f[]=new int[N];
    for(int i=1;i<=n;i++){
        f[i]=1;
        for(int j=0;j<i;j++){
            if(a[i]>a[j]){
                f[i]=Math.max(f[j]+1,f[i]);
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        ans=Math.max(ans,f[i]);
    }
    System.out.println(ans);
}
```

##### 最长公共子序列

![image-20210411160037389](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210411160039.png)

```java
public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    int n = scan.nextInt();
    int m = scan.nextInt();
    //i=0情况
    String A = " " + scan.next();
    String B = " " + scan.next();
    int[][] f = new int[n + 1][m + 1];
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= m;j++)
        {
            f[i][j] = Math.max(f[i-1][j], f[i][j - 1]);
            //包含A[i] = B[j]情况的集合
            if(A.charAt(i) == B.charAt(j)) 
                f[i][j] = Math.max(f[i][j],f[i - 1][j - 1] + 1);
        }
    }
    System.out.println(f[n][m]);
}
```

##### 石头合并-区间dp

合并 N 堆石子，每次只能合并相邻的两堆石子，求最小代价

![image-20210412103922273](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210412103924.png)

```java
import java.util.*;
class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int []a =new int [n+1];
        for(int i=1;i<=n;i++){
            a[i]=sc.nextInt();
        }
        int []s=new int [n+1];
        for(int i=1;i<=n;i++){
            s[i]+=s[i-1]+a[i];
        }
        int f[][]=new int[n+1][n+1];
        for(int len=2;len<=n;len++){
            for(int i=1;i+len-1<=n;i++){
                int l=i,r=l+len-1;
                f[l][r]=Integer.MAX_VALUE;
                for(int j=l;j<r;j++){
                    f[l][r]=Math.min(f[l][r],f[l][j]+f[j+1][r]+s[r]-s[l-1]);
                }
            }
        }
        System.out.println(f[1][n]);
    }
}
```

#### 其他

##### 大顶推求最小的K个元素

```java
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;
public class Solution {
   public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
       ArrayList<Integer> result = new ArrayList<Integer>();
       int length = input.length;
       if(k > length || k == 0){
           return result;
       }
       //大顶推
        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(k, new Comparator<Integer>() {
            @Override
            //降序
            public int compare(Integer o1, Integer o2) {
                return o2.compareTo(o1);
            }
        });
        for (int i = 0; i < length; i++) {
            if (maxHeap.size() != k) {
                maxHeap.offer(input[i]);
            } else if (maxHeap.peek() > input[i]) {
                Integer temp = maxHeap.poll();
                temp = null;
                maxHeap.offer(input[i]);
            }
        }
        for (Integer integer : maxHeap) {
            result.add(integer);
        }
        return result;
    }
}
```

##### 货仓选址求最小

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

**中位数就是答案**

![image-20210314132800964](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161118.png)

```java
public static void main(String[] args){
    Scanner sc=new Scanner(System.in);
    int n=sc.nextInt();
    int[] A=new int [n];
    for(int i=0;i<n;i++){
        A[i]=sc.nextInt();
    }
    Arrays.sort(A);
    int ans=0;
    for(int i=0;i<n;i++){
        ans+=Math.abs(A[i]-A[n/2]);
    }
    System.out.println(ans);
}
```

##### 区间和

假定有一个无限长的数轴，数轴上每个坐标上的数都是0。

现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。

接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。

![image-20210314142819114](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210327161119.png)

```java
import java.util.*;
class Pair{
    int first;
    int second;
    Pair(int first,int second){
        this.first=first;
        this.second=second;
    }
}
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        int N = 300010; //因为需要将所有x，l，r存在数组中，这样就是n + 2m <= 300000
        int[] a = new int[N]; //从1开始，需要通过x找到离散量，然后+1，
        int[] s = new int[N]; //前缀和来做，所以需要从1开始记录a

        List<Integer> alls = new ArrayList<>(); //将所有的使用到的数存在alls中，比如x，l，r
        //但其中会有先后顺序的差别，以及重复，所以需要排序和去重
        List<Pair> add = new ArrayList<>(); //用来存n次操作
        List<Pair> query = new ArrayList<>(); //用来存m次询问
        
        for (int i = 0; i < n; i++) {
            int x = sc.nextInt();
            int c = sc.nextInt();
            add.add(new Pair(x, c));
            alls.add(x); //存入alls中，为后续操作做准备
        }

        for (int i = 0; i < m; i++) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            query.add(new Pair(l, r));
            alls.add(l);
            alls.add(r);
        }
        
         //到此为止，alls中存好了所有会被用到的数轴上的点，可以进行离散化操作
        // 1. 排序 2. 去重
        Collections.sort(alls);
        int unique = unique(alls);
        alls = alls.subList(0, unique); //将去重后的List保存下来，或者此处也可以将unique作为最后一个数，用r作为二分


        for (Pair item:add) {
            int index = find(item.first, alls);
            a[index] += item.second;
        }

        //求前缀和
        for (int i = 1; i <= alls.size(); i++) s[i] = s[i - 1] + a[i];
        
        
        for (Pair item:query) {
            int l = find(item.first, alls);
            int r = find(item.second, alls);
            System.out.println(s[r] - s[l - 1]);
        }

    }
    
    
    //排序list去重
    static int unique(List<Integer> list) {
        int j = 0;
        for (int i = 0; i < list.size(); i++) {
            if (i == 0 || list.get(i) != list.get(i - 1)) {
                list.set(j, list.get(i));
                j++;
            }  
        }
        return j;
    } 

    
    //找到x所在的位置
    static int find(int x, List<Integer> list) {
        int l = 0;
        int r = list.size() - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (list.get(mid) >= x) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l + 1; //因为要考虑到前缀和
    }

}
```

##### 区间合并

给定 n 个区间，要求合并所有有交集的区间。

```java
import java.util.*;
class Pair {
    int first;
    int second;
    Pair(int first,int second) {
        this.first = first;
        this.second = second;
    }
    @Override
    public String toString() {
        return "Pair{" +
                "first=" + first +
                ", second=" + second +
                '}';
    }
}
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        List<Pair> list=new ArrayList<Pair>();
        for(int i=0;i<n;i++){
            list.add(new Pair(sc.nextInt(),sc.nextInt()));
        }
        Collections.sort(list, new Comparator<Pair>() {
            @Override
            public int compare(Pair o1, Pair o2) {
                return o1.first-o2.first;
            }
        });
        //System.out.println(list.toString());
        List<Pair> ans=new ArrayList<Pair>();
        int st=list.get(0).first,ed=list.get(0).second;
        for(Pair p:list){
            if(ed<p.first){
                ans.add(new Pair(st,ed));
                st=p.first;
                ed=p.second;
            }else{
                ed=Math.max(ed,p.second);
            }
        }
        ans.add(new Pair(st,ed));
        System.out.println(ans.size());
    }
}
```

#### 剑指offer

##### 变量命名约定

- nums 表示数字数组，array 表示通用数组，matrix 表示矩阵；
- n 表示数组长度、字符串长度、树节点个数，以及其它具有一维性质的数据结构的元素个数；
- m, n 表示矩阵的行数和列数；
- first, last 表示闭区间，在需要作为函数参数时使用：[first, last]；
- l, h 也表示闭区间，在只作为局部变量时使用：[l, h]；
- begin, end 表示左闭右开区间：[begin, end)；
- ret 表示结果相关的变量；
- dp 表示动态规划保存子问题的数组；

##### 复杂度简写说明

O(nlog<sub>n</sub>) + O(n<sup>2</sup>)，第一个指时间复杂度，第二个指空间复杂度。

##### 3. 数组中重复的数字

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 {2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。

这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素放到第 i 个位置上。

以 (2, 3, 1, 0, 2, 5) 为例，以下代码的运行过程为：

```html
position-0 : (2,3,1,0,2,5) // 2 <-> 1
             (1,3,2,0,2,5) // 1 <-> 3
             (3,1,1,0,2,5) // 3 <-> 0
             (0,1,1,3,2,5) // already in position
position-1 : (0,1,1,3,2,5) // already in position
position-2 : (0,1,1,3,2,5) // nums[i] == nums[nums[i]], exit
```

遍历到位置 2 时，该位置上的数为 1，但是第 1 个位置上已经有一个 1 的值了，因此可以知道 1 重复。

复杂度：O(n) + O(1)

```java
public boolean duplicate(int[] nums, int length, int[] duplication) {
    if (nums == null || length <= 0) return false;
    for (int i = 0; i < length; i++) {
        while (nums[i] != i && nums[i] != nums[nums[i]]) {
            swap(nums, i, nums[i]);
        }
        if (nums[i] != i && nums[i] == nums[nums[i]]) {
            duplication[0] = nums[i];
            return true;
        }
    }
    return false;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i]; nums[i] = nums[j]; nums[j] = t;
}
```

##### 4. 二维数组中的查找

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

从右上角开始查找。因为矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。

复杂度：O(m + n) + O(1)

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
    int m = matrix.length, n = matrix[0].length;
    int r = 0, c = n - 1; // 从右上角开始
    while (r <= m - 1 && c >= 0) {
        if (target == matrix[r][c]) return true;
        else if (target > matrix[r][c]) r++;
        else c--;
    }
    return false;
}
```

##### 5. 替换空格

请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy. 则经过替换之后的字符串为 We%20Are%20Happy。

在字符串尾部填充任意字符，使得字符串的长度等于字符串替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。

令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。

从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。

复杂度：O(n) + O(1)

<div align="center"> <img src="../pics//35b0caf8-6f34-49db-93ed-d505e9eb3d99.png"/> </div><br>

```java
public String replaceSpace(StringBuffer str) {
    int oldLen = str.length();
    for (int i = 0; i < oldLen; i++) {
        if (str.charAt(i) == ' ') {
            str.append("  ");
        }
    }
    int idxOfOld = oldLen - 1;
    int idxOfNew = str.length() - 1;
    while (idxOfOld >= 0 && idxOfNew > idxOfOld) {
        char c = str.charAt(idxOfOld--);
        if (c == ' ') {
            str.setCharAt(idxOfNew--, '0');
            str.setCharAt(idxOfNew--, '2');
            str.setCharAt(idxOfNew--, '%');
        } else {
            str.setCharAt(idxOfNew--, c);
        }
    }
    return str.toString();
}
```

##### 6. 从尾到头打印链表

输入链表的第一个节点，从尾到头反过来打印出每个结点的值。

使用栈

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    Stack<Integer> stack = new Stack<>();
    while (listNode != null) {
        stack.add(listNode.val);
        listNode = listNode.next;
    }
    ArrayList<Integer> ret = new ArrayList<>();
    while (!stack.isEmpty()) {
        ret.add(stack.pop());
    }
    return ret;
}
```

使用递归

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    ArrayList<Integer> ret = new ArrayList<>();
    if(listNode != null) {
        ret.addAll(printListFromTailToHead(listNode.next));
        ret.add(listNode.val);
    }
    return ret;
}
```

使用 Collections.reverse()

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    ArrayList<Integer> ret = new ArrayList<>();
    while (listNode != null) {
        ret.add(listNode.val);
        listNode = listNode.next;
    }
    Collections.reverse(ret);
    return ret;
}
```

**使用头插法**

利用链表头插法为逆序的特点。

头结点和第一个节点的区别：头结点是在头插法中使用的一个额外节点，这个节点不存储值；第一个节点就是链表的第一个真正存储值的节点。

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    // 头插法构建逆序链表
    ListNode head = new ListNode(-1);
    while (listNode != null) {
        ListNode memo = listNode.next;
        listNode.next = head.next;
        head.next = listNode;
        listNode = memo;
    }
    // 构建 ArrayList
    ArrayList<Integer> ret = new ArrayList<>();
    head = head.next;
    while (head != null) {
        ret.add(head.val);
        head = head.next;
    }
    return ret;
}
```

##### ++7. 重建二叉树++

根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。

```html
For example, given

preorder = [3,9,20,15,7]
inorder =  [9,3,15,20,7]

Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
```

##  

前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。

```java
private Map<Integer, Integer> inOrderNumsIdx = new HashMap<>(); // 缓存中序遍历数组的每个值对应的索引

public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
    for (int i = 0; i < in.length; i++) {
        inOrderNumsIdx.put(in[i], i);
    }
    return reConstructBinaryTree(pre, 0, pre.length - 1, in, 0, in.length - 1);
}

private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int[] in, int inL, int inR) {
    if (preL == preR) return new TreeNode(pre[preL]);
    if (preL > preR || inL > inR) return null;
    TreeNode root = new TreeNode(pre[preL]);
    int inIdx = inOrderNumsIdx.get(root.val);
    int leftTreeSize = inIdx - inL;
    root.left = reConstructBinaryTree(pre, preL + 1, preL + leftTreeSize, in, inL, inL + leftTreeSize - 1);
    root.right = reConstructBinaryTree(pre, preL + leftTreeSize + 1, preR, in, inL + leftTreeSize + 1, inR);
    return root;
}
```

##### ++8. 二叉树的下一个结点++

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

① 如果一个节点有右子树不为空，那么该节点的下一个节点是右子树的最左节点；

<div align="center"> <img src="../pics//931e112e-97d3-4a47-ac64-a86d70844e58.png" width="200"/> </div><br>

② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。

<div align="center"> <img src="../pics//350048d6-20f5-4ca9-8452-3957a09ef3af.png" width="200"/> </div><br>

```java
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
```

```java
public TreeLinkNode GetNext(TreeLinkNode pNode) {
    if (pNode.right != null) {
        TreeLinkNode node = pNode.right;
        while (node.left != null) node = node.left;
        return node;
    } else {
        while (pNode.next != null) {
            TreeLinkNode parent = pNode.next;
            if (parent.left == pNode) return parent;
            pNode = pNode.next;
        }
    }
    return null;
}
```

##### 9. 用两个栈实现队列

in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，此时先进入的元素先退出，这就是队列的顺序。

```java
Stack<Integer> in = new Stack<Integer>();
Stack<Integer> out = new Stack<Integer>();

public void push(int node) {
    in.push(node);
}

public int pop() {
    if (out.isEmpty()) {
        while (!in.isEmpty()) {
            out.push(in.pop());
        }
    }
    return out.pop();
}
```

##### 10.1 斐波那契数列

以 O(1) 的时间复杂度求菲波那切数列。

<div align="center"><img src="https://latex.codecogs.com/gif.latex?f(n)=\left\{\begin{array}{rcl}0&&{n=0}\\1&&{n=1}\\f(n-1)+f(n-2)&&{n>1}\end{array}\right."/></div> <br>

##  

如果使用递归求解，那么会重复计算一些子问题。例如，求 f(10) 需要计算 f(9) 和 f(8)，计算 f(9) 需要计算 f(8) 和 f(7)，可以看到 f(8) 被重复计算了。

<div align="center"> <img src="../pics//080f488c-75ef-49a8-a49d-78fa372ad422.png"/> </div><br>

递归方法是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，避免重复求解子问题。

```java
public class Solution {
    private int[] fib = new int[40];
    public Solution() {
        fib[1] = 1;
        fib[2] = 2;
        for(int i = 2; i < fib.length; i++) {
            fib[i] = fib[i - 1] + fib[i - 2];
        }
    }
    public int Fibonacci(int n) {
        return fib[n];
    }
}
```

##### 10.2 跳台阶

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

```java
public int JumpFloor(int n) {
    if (n == 1) return 1;
    int[] dp = new int[n];
    dp[0] = 1;
    dp[1] = 2;
    for (int i = 2; i < n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n - 1];
}
```

##### 10.3 变态跳台阶

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

```java
public int JumpFloorII(int n) {
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for(int i = 1; i < n; i++) {
        for(int j = 0; j < i; j++) {
            dp[i] += dp[j];
        }
    }
    return dp[n - 1];
}
```

##### 10.4 矩形覆盖

我们可以用 2\*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2\*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共有多少种方法？

```java
public int RectCover(int n) {
    if (n < 2) return n;
    int[] dp = new int[n];
    dp[0] = 1;
    dp[1] = 2;
    for (int i = 2; i < n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n - 1];
}
```

##### ==11. 旋转数组的最小数字==

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增数组(不存在重复元素)的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。

**二分查找**

当 nums[m] <= nums[h] 的情况下，说明解在 [l, m] 之间，此时令 h = m；
否则解在 [m + 1, h] 之间，令 l = m + 1。

循环：

复杂度：O(log<sub>n</sub>) + O(1)

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] <= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}
```

**递归:**

复杂度：O(log<sub>n</sub>) + O(log<sub>n</sub>) （java 无法对尾递归做优化）

```java
public int findMin(int[] nums) {
    if(nums == null || nums.length == 0) return -1;
    return findMin(nums, 0, nums.length -1);
}
    
public int findMin(int[] nums, int left, int right) {
    if(left >= right) return nums[left];
    int mid = left + ((right - left) >> 1);
    if(nums[right] > nums[left]){
        return nums[left];
    }else if(nums[mid] >= nums[left]){
        return findMin(nums, mid+1, right);
    }else{
        return findMin(nums, left, mid);
    }
}
```

情况2：非递减数组(存在重复元素)。leetcode 154

如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，那么此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[l] == nums[m] && nums[m] == nums[h])
            return minNumber(nums, l, h);
        else if (nums[m] <= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}

private int minNumber(int[] nums, int l, int h) {
    for (int i = l; i < h; i++)
        if (nums[i] > nums[i + 1])
            return nums[i + 1];
    return nums[l];
}
```

**分治**

是否存在重复元素都可以使用分治方法。

复杂度：O(log<sub>n</sub>) + O(n)，因为分治使用了递归栈，用到了额外的空间，如果对空间有要求就不能用这种方法。

```java
public int minNumberInRotateArray(int[] nums) {
    return minNumberInRotateArray(nums, 0, nums.length - 1);
}

private int minNumberInRotateArray(int[] nums, int first, int last) {
    if (nums[first] < nums[last]) return nums[first];
    if (first == last) return nums[first];
    int mid = first + (last - first) / 2;
    return Math.min(minNumberInRotateArray(nums, first, mid), minNumberInRotateArray(nums, mid + 1, last));
}
```

##### 12. 矩阵中的路径

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如 a b c e s f c s a d e e 矩阵中包含一条字符串 "bcced" 的路径，但是矩阵中不包含 "abcb" 路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

```java
private int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
private int rows;
private int cols;

public boolean hasPath(char[] array, int rows, int cols, char[] str) {
    if (rows == 0 || cols == 0) return false;
    this.rows = rows;
    this.cols = cols;
    boolean[][] hasUsed = new boolean[rows][cols];
    char[][] matrix = buildMatrix(array);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (backtracking(matrix, str, hasUsed, 0, i, j)) return true;
        }
    }
    return false;
}

private boolean backtracking(char[][] matrix, char[] str, boolean[][] hasUsed, int pathLen, int row, int col) {
    if (pathLen == str.length) return true;
    if (row < 0 || row >= rows || col < 0 || col >= cols) return false;
    if (matrix[row][col] != str[pathLen]) return false;
    if (hasUsed[row][col]) return false;
    hasUsed[row][col] = true;
    for (int i = 0; i < next.length; i++) {
        if (backtracking(matrix, str, hasUsed, pathLen + 1, row + next[i][0], col + next[i][1]))
            return true;
    }
    hasUsed[row][col] = false;
    return false;
}

private char[][] buildMatrix(char[] array) {
    char[][] matrix = new char[rows][cols];
    for (int i = 0, idx = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = array[idx++];
        }
    }
    return matrix;
}
```

##### 13. 机器人的运动范围

地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格（35, 37），因为 3+5+3+7=18。但是，它不能进入方格（35, 38），因为 3+5+3+8=19。请问该机器人能够达到多少个格子？

```java
private int cnt = 0;
private int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
private int rows;
private int cols;
private int threshold;
private int[][] digitSum;

public int movingCount(int threshold, int rows, int cols) {
    this.rows = rows;
    this.cols = cols;
    this.threshold = threshold;
    initDigitSum();
    boolean[][] hasVisited = new boolean[rows][cols];
    dfs(hasVisited, 0, 0);
    return cnt;
}

private void dfs(boolean[][] hasVisited, int r, int c) {
    if (r < 0 || r >= this.rows || c < 0 || c >= this.cols) return;
    if (hasVisited[r][c]) return;
    hasVisited[r][c] = true;
    if (this.digitSum[r][c] > this.threshold) return;
    this.cnt++;
    for (int i = 0; i < this.next.length; i++) {
        dfs(hasVisited, r + next[i][0], c + next[i][1]);
    }
}

private void initDigitSum() {
    int[] digitSumOne = new int[Math.max(rows, cols)];
    for (int i = 0; i < digitSumOne.length; i++) {
        int n = i;
        while (n > 0) {
            digitSumOne[i] += n % 10;
            n /= 10;
        }
    }
    this.digitSum = new int[rows][cols];
    for (int i = 0; i < this.rows; i++) {
        for (int j = 0; j < this.cols; j++) {
            this.digitSum[i][j] = digitSumOne[i] + digitSumOne[j];
        }
    }
}
```

##### ++14. 剪绳子++

把一根绳子剪成多段，并且使得每段的长度乘积最大。

**动态规划解法**

```java
public int maxProductAfterCutting(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j < i; j++) {
            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
        }
    }
    return dp[n];
}
```

**贪心解法**

尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现，如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。

证明：当 n >= 5 时，3(n - 3) - 2(n - 2) = n - 5 >= 0。因此把长度大于 5 的绳子切成两段，令其中一段长度为 3 可以使得两段的乘积最大。

```java
public int maxProductAfterCutting(int n) {
    if (n < 2) return 0;
    if (n == 2) return 1;
    if (n == 3) return 2;
    int timesOf3 = n / 3;
    if (n - timesOf3 * 3 == 1) timesOf3--;
    int timesOf2 = (n - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
}
```

##### ++15. 二进制中 1 的个数++

输入一个整数，输出该数二进制表示中 1 的个数。

**Integer.bitCount()**

```java
public int NumberOf1(int n) {
    return Integer.bitCount(n);
}
```

**n&(n-1)**

O(logM) 时间复杂度解法，其中 M 表示 1 的个数。

该位运算是去除 n 的位级表示中最低的那一位。

```
n       : 10110100
n-1     : 10110011
n&(n-1) : 10110000
```

```java
public int NumberOf1(int n) {
    int cnt = 0;
    while (n != 0) {
        cnt++;
        n &= (n - 1);
    }
    return cnt;
}
```

##### 16. 数值的整数次方

给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。

下面的讨论中 x 代表 base，n 代表 exponent。

<div align="center"><img src="https://latex.codecogs.com/gif.latex?x^n=\left\{\begin{array}{rcl}(x*x)^{n/2}&&{n\%2=0}\\x*(x*x)^{n/2}&&{n\%2=1}\end{array}\right."/></div> <br>

因为 (x\*x)<sup>n/2</sup> 可以通过递归求解，并且每递归一次，n 都减小一半，因此整个算法的时间复杂度为 O(logn)。

```java
//指数为int最小值时不太对？
public double Power(double base, int exponent) {
    if (exponent == 0) return 1;
    if (exponent == 1) return base;
    boolean isNegative = false;
    if (exponent < 0) {
        exponent = -exponent;
        isNegative = true;
    }
    double pow = Power(base * base, exponent / 2);
    if (exponent % 2 != 0) pow = pow * base;
    return isNegative ? (1 / pow) : pow;
}
```

快速幂：

```java
/**
 * 1.全面考察指数的正负、底数是否为零等情况。
 * 2.写出指数的二进制表达，例如13表达为二进制1101。
 * 3.举例:10^1101 = 10^0001*10^0100*10^1000。
 * 4.通过&1和>>1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。
 
 指数为int最小值时不太对？
 */
public double Power(double base, int n) {
    double res = 1,curr = base;
    int exponent;
    if(n>0){
        exponent = n;
    }else if(n<0){
        if(base==0)
            throw new RuntimeException("分母不能为0"); 
        exponent = -n;
    }else{// n==0
        return 1;// 0的0次方
    }
    while(exponent!=0){
        if((exponent&1)==1)
            res*=curr;
        curr*=curr;// 翻倍
        exponent>>=1;// 右移一位
    }
    return n>=0?res:(1/res);       
}
```

##### 17. 打印从 1 到最大的 n 位数

输入数字 n，按顺序打印出从 1 最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。

使用回溯法得到所有的数。

```java
public void print1ToMaxOfNDigits(int n) {
    if (n < 0) return;
    char[] number = new char[n];
    print1ToMaxOfNDigits(number, -1);
}

private void print1ToMaxOfNDigits(char[] number, int digit) {
    if (digit == number.length - 1) {
        printNumber(number);
        return;
    }
    for (int i = 0; i < 10; i++) {
        number[digit + 1] = (char) (i + '0');
        print1ToMaxOfNDigits(number, digit + 1);
    }
}

private void printNumber(char[] number) {
    int index = 0;
    while (index < number.length && number[index] == '0') index++;
    while (index < number.length) System.out.print(number[index++]);
    System.out.println();
}
```

##### 18.1 在 O(1) 时间内删除链表节点

① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，令该节点指向下下个节点，然后删除下一个节点，时间复杂度为 O(1)。

<div align="center"> <img src="../pics//72f9bc11-06a9-40b4-8939-14f72e5cb4c3.png"/> </div><br>

② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。

<div align="center"> <img src="../pics//2a398239-ee47-4ea1-b2d8-0ced638839ef.png"/> </div><br>

综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个为节点以 O(n) 的时间复杂度操作节点的总次数。(2N-1)/N \~ 2，因此该算法的平均时间复杂度为 O(1)。

```java
public ListNode deleteNode(ListNode head, ListNode tobeDelete) {
    if (head == null || head.next == null || tobeDelete == null) return null;
    if (tobeDelete.next != null) {
        // 要删除的节点不是尾节点
        ListNode next = tobeDelete.next;
        tobeDelete.val = next.val;
        tobeDelete.next = next.next;
    } else {
        ListNode cur = head;
        while (cur.next != tobeDelete) cur = cur.next;
        cur.next = null;
    }
    return head;
}
```

##### ++18.2 删除链表中重复的结点++

```html
Input : 1->2->3->3->4->4->5
Output : 1->2->5
```

```java
public ListNode deleteDuplication(ListNode pHead) {
    if (pHead == null) return null;
    ListNode next = pHead.next;
    if (next == null) return pHead;
    if (pHead.val == next.val) {
        while (next != null && pHead.val == next.val) next = next.next;
        return deleteDuplication(next);
    }
    pHead.next = deleteDuplication(pHead.next);
    return pHead;
}
```

##### ++19. 正则表达式匹配++

请实现一个函数用来匹配包括 '.' 和 '\*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '\*' 表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab\*ac\*a" 匹配，但是与 "aa.a" 和 "ab\*a" 均不匹配。

应该注意到，'.' 是用来代替一个任意字符，而 '\*' 是用来重复前面的字符。这两个的作用不同，不能把 '.' 的作用和 '\*' 进行类比，从而把它当成重复前面字符一次。

```html
p.charAt(j) == s.charAt(i)  :  dp[i][j] = dp[i-1][j-1];
p.charAt(j) == '.'          :  dp[i][j] = dp[i-1][j-1];
p.charAt(j) == '*'          :
   p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  // in this case, a* only counts as empty
   p.charAt(j-1) == s.charAt(i) or p.charAt(i-1) == '.':
            dp[i][j] = dp[i-1][j]   // in this case, a* counts as multiple a
         or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a
         or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty
```

```java
public boolean match(char[] str, char[] pattern) {
    int m = str.length, n = pattern.length;
    boolean[][] dp = new boolean[m + 1][n + 1];
    dp[0][0] = true;
    for (int i = 2; i <= n; i++) {
        if (pattern[i - 1] == '*') {
            dp[0][i] = dp[0][i - 2];
        }
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (str[i - 1] == pattern[j - 1] || pattern[j - 1] == '.') {
                dp[i][j] = dp[i - 1][j - 1];
            } else if (pattern[j - 1] == '*') {
                if (pattern[j - 2] == str[i - 1] || pattern[j - 2] == '.') {
                    dp[i][j] = dp[i][j - 1] || dp[i][j - 2] || dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i][j - 2];
                }
            }
        }
    }
    return dp[m][n];
}
```

##### 20. 表示数值的字符串

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 "+100","5e2","-123","3.1416" 和 "-1E-16" 都表示数值。 但是 "12e","1a3.14","1.2.3","+-5" 和 "12e+4.3" 都不是。

```java
public boolean isNumeric(char[] str) {
    return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
}
```

##### 21. 调整数组顺序使奇数位于偶数前面

保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。

复杂度：O(n<sup>2</sup>) + O(1)

```java
public void reOrderArray(int[] nums) {
    int n = nums.length;
    for (int i = 0; i < n; i++) {
        if (nums[i] % 2 == 0) {
            int nextOddIdx = i + 1;
            while (nextOddIdx < n && nums[nextOddIdx] % 2 == 0) nextOddIdx++;
            if (nextOddIdx == n) break;
            int nextOddVal = nums[nextOddIdx];
            for (int j = nextOddIdx; j > i; j--) {
                nums[j] = nums[j - 1];
            }
            nums[i] = nextOddVal;
        }
    }
}
```

复杂度：O(n) + O(n)

```java
public void reOrderArray(int[] nums) {
    int oddCnt = 0;
    for (int val : nums) if (val % 2 == 1) oddCnt++;
    int[] copy = nums.clone();
    int i = 0, j = oddCnt;
    for (int num : copy) {
        if (num % 2 == 1) nums[i++] = num;
        else nums[j++] = num;
    }
}
```

##### 22. 链表中倒数第 K 个结点

设链表的长度为 N。设两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到 N - K 个节点处，该位置就是倒数第 K 个节点。



<div align="center"> <img src="../pics//40d96c0d-156f-4eee-a183-2d597344f1cd.png"/> </div><br>

```java
public ListNode FindKthToTail(ListNode head, int k) {
    if (head == null) return null;
    ListNode P1 = head;
    while (k > 0){
        k--;
        if(P1 == null) return null;
        P1 = P1.next;
    }
    ListNode P2 = head;
    while (P1 != null) {
        P1 = P1.next;
        P2 = P2.next;
    }
    return P2;
}
```

##### 23. 链表中环的入口结点

使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。

在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。

<div align="center"> <img src="../pics//e7d7dc0d-fc22-4f95-8768-b8a216168792.jpg"/> </div><br>

```java
public ListNode EntryNodeOfLoop(ListNode pHead) {
    if (pHead == null) return null;
    ListNode slow = pHead, fast = pHead;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (slow == fast) {
            fast = pHead;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
}
```

##### 24. 反转链表

递归

```java
public ListNode ReverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode next = head.next;
    head.next = null;
    ListNode newHead = ReverseList(next);
    next.next = head;
    return newHead;
}
```

迭代

```java
public ListNode ReverseList(ListNode head) {
    ListNode newList = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newList.next;
        newList.next = head;
        head = next;
    }
    return newList.next;
}
```

##### 25. 合并两个排序的链表

<div align="center"> <img src="../pics//79f28233-f5cb-492a-9dc4-696cb714d434.png"/> </div><br>

递归

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    if (list1 == null) return list2;
    if (list2 == null) return list1;
    if (list1.val <= list2.val) {
        list1.next = Merge(list1.next, list2);
        return list1;
    } else {
        list2.next = Merge(list1, list2.next);
        return list2;
    }
}
```

迭代

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    ListNode head = new ListNode(-1);
    ListNode cur = head;
    while (list1 != null && list2 != null) {
        if (list1.val < list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    if (list1 != null) cur.next = list1;
    if (list2 != null) cur.next = list2;
    return head.next;
}
```

##### 26. 树的子结构

<div align="center"> <img src="../pics//26223561-eea4-463c-8ddb-3bb456c76267.png"/> </div><br>

```java
public boolean HasSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null || root2 == null) return false;
    return isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
}

private boolean isSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null && root2 == null) return true;
    if (root1 == null) return false;
    if (root2 == null) return true;
    if (root1.val != root2.val) return false;
    return isSubtree(root1.left, root2.left) && isSubtree(root1.right, root2.right);
}
```

##### 27. 二叉树的镜像

<div align="center"> <img src="../pics//7cfcfdf7-63a7-4111-a677-2eca29fbcf24.png"/> </div><br>

```java
public void Mirror(TreeNode root) {
    if (root == null) return;
    swap(root);
    Mirror(root.left);
    Mirror(root.right);
}

private void swap(TreeNode root) {
    TreeNode t = root.left;
    root.left = root.right;
    root.right = t;
}
```

##### 28 对称的二叉树

```html
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

```java
boolean isSymmetrical(TreeNode pRoot) {
    if (pRoot == null) return true;
    return isSymmetrical(pRoot.left, pRoot.right);
}

boolean isSymmetrical(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    if (t1.val != t2.val) return false;
    return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
}
```

##### 29. 顺时针打印矩阵

下图的矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10

<div align="center"> <img src="../pics//8615d9f7-bd1d-4240-8bb4-02b941d54a6f.png"/> </div><br>

<div align="center"> <img src="../pics//6afa9796-af1a-4495-9f02-63349ab68a19.png"/> </div><br>

```java
public ArrayList<Integer> printMatrix(int[][] matrix) {
    ArrayList<Integer> ret = new ArrayList<>();
    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;
    while (r1 <= r2 && c1 <= c2) {
        for (int i = c1; i <= c2; i++) ret.add(matrix[r1][i]);
        for (int i = r1 + 1; i <= r2; i++) ret.add(matrix[i][c2]);
        if (r1 != r2) for (int i = c2 - 1; i >= c1; i--) ret.add(matrix[r2][i]);
        if (c1 != c2) for (int i = r2 - 1; i > r1; i--) ret.add(matrix[i][c1]);
        r1++; r2--; c1++; c2--;
    }
    return ret;
}
```

##### 30. 包含 min 函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。

```java
private Stack<Integer> stack = new Stack<>();
private Stack<Integer> minStack = new Stack<>();
private int min = Integer.MAX_VALUE;

public void push(int node) {
    stack.push(node);
    if (min > node) min = node;
    minStack.push(min);
}

public void pop() {
    stack.pop();
    minStack.pop();
    min = minStack.peek();
}

public int top() {
    return stack.peek();
}

public int min() {
    return minStack.peek();
}
```

##### 31. 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。

```java
public boolean IsPopOrder(int[] pushA, int[] popA) {
    int n = pushA.length;
    Stack<Integer> stack = new Stack<>();
    for (int pushIndex = 0, popIndex = 0; pushIndex < n; pushIndex++) {
        stack.push(pushA[pushIndex]);
        while (popIndex < n && stack.peek() == popA[popIndex]) {
            stack.pop();
            popIndex++;
        }
    }
    return stack.isEmpty();
}
```

##### 32.1 从上往下打印二叉树

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

例如，以下二叉树层次遍历的结果为 8, 6, 10, 5, 7, 9, 11

<div align="center"> <img src="../pics//c8cdfa3d-d610-4731-9d89-564252378e7d.png"/> </div><br>

使用队列来进行层次遍历。

不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。

```java
public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    ArrayList<Integer> ret = new ArrayList<>();
    if (root == null) return ret;
    queue.add(root);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        for (int i = 0; i < cnt; i++) {
            TreeNode t = queue.poll();
            if (t.left != null) queue.add(t.left);
            if (t.right != null) queue.add(t.right);
            ret.add(t.val);
        }
    }
    return ret;
}
```

##### 32.2 把二叉树打印成多行

和上题几乎一样。

```java
ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    if (pRoot == null) return ret;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 0; i < cnt; i++) {
            TreeNode node = queue.poll();
            list.add(node.val);
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
        ret.add(list);
    }
    return ret;
}
```

##### 32.3 按之字形顺序打印二叉树

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

```java
public ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    if (pRoot == null) return ret;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);
    boolean reverse = false;
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 0; i < cnt; i++) {
            TreeNode node = queue.poll();
            list.add(node.val);
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
        if (reverse) Collections.reverse(list);
        reverse = !reverse;
        ret.add(list);
    }
    return ret;
}
```

##### 33. 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。

例如，下图中后序遍历序列 5, 7, 6, 9, 11, 10, 8 所对应的二叉搜索树。

```java
public boolean VerifySquenceOfBST(int[] sequence) {
    if (sequence == null || sequence.length == 0) return false;
    return verify(sequence, 0, sequence.length - 1);
}

private boolean verify(int[] sequence, int first, int last) {
    if (last - first <= 1) return true;
    int rootVal = sequence[last];
    int cutIndex = first;
    while (cutIndex < last && sequence[cutIndex] <= rootVal) cutIndex++;
    for (int i = cutIndex + 1; i < last; i++) {
        if (sequence[i] < rootVal) return false;
    }
    return verify(sequence, first, cutIndex - 1) && verify(sequence, cutIndex, last - 1);
}
```

##### 34. 二叉树中和为某一值的路径

输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12

```java
private ArrayList<ArrayList<Integer>> ret = new ArrayList<>();

public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {
    dfs(root, target, new ArrayList<>());
    return ret;
}

private void dfs(TreeNode node, int target, ArrayList<Integer> path) {
    if (node == null) return;
    path.add(node.val);
    target -= node.val;
    if (target == 0 && node.left == null && node.right == null) {
        ret.add(new ArrayList(path));
    } else {
        dfs(node.left, target, path);
        dfs(node.right, target, path);
    }
    path.remove(path.size() - 1);
}
```

##### 35. 复杂链表的复制

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。

第一步，在每个节点的后面插入复制的节点。

第二步，对复制节点的 random 链接进行赋值。

第三步，拆分。

```java
public RandomListNode Clone(RandomListNode pHead) {
    if (pHead == null) {
        return null;
    }
    // 插入新节点
    RandomListNode cur = pHead;
    while (cur != null) {
        RandomListNode clone = new RandomListNode(cur.label);
        clone.next = cur.next;
        cur.next = clone;
        cur = clone.next;
    }
    // 建立 random 链接
    cur = pHead;
    while (cur != null) {
        RandomListNode clone = cur.next;
        if (cur.random != null) {
            clone.random = cur.random.next;
        }
        cur = clone.next;
    }
    // 拆分
    cur = pHead;
    RandomListNode pCloneHead = pHead.next;
    while (cur.next != null) {
        RandomListNode next = cur.next;
        cur.next = next.next;
        cur = next;
    }
    return pCloneHead;
}
```

##### ==36. 二叉搜索树与双向链表==



输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

```java
private TreeNode pre = null;//记录尾节点
private TreeNode head = null;//记录头结点

public TreeNode Convert(TreeNode root) {
    if (root == null) return null;
    inOrder(root);
    return head;
}

private void inOrder(TreeNode node) {
    if (node == null) return;
    inOrder(node.left);
    node.left = pre;
    if (pre != null) pre.right = node;
    pre = node;
    if (head == null) head = node;
    inOrder(node.right);
}
```

##### ==37. 序列化二叉树==

请实现两个函数，分别用来序列化和反序列化二叉树。

需要分隔符的原因：一个节点序列化成字符串后可能不止一个字符，比如10

```java
public class Solution {

    private String deserializeStr;

    public String Serialize(TreeNode root) {
        if (root == null) return "#";
        return root.val + " " + Serialize(root.left) + " " + Serialize(root.right);
    }

    public TreeNode Deserialize(String str) {
        deserializeStr = str;
        return Deserialize();
    }

    private TreeNode Deserialize() {
        if (deserializeStr.length() == 0) return null;
        int index = deserializeStr.indexOf(" ");
        String node = index == -1 ? deserializeStr : deserializeStr.substring(0, index);
        deserializeStr = index == -1 ? "" : deserializeStr.substring(index + 1);
        if (node.equals("#")) return null;
        int val = Integer.valueOf(node);
        TreeNode t = new TreeNode(val);
        t.left = Deserialize();
        t.right = Deserialize();
        return t;
    }
}
```

##### 38. 字符串的排列

输入一个包含重复字符的字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abb，则打印出由字符 a, b, b 所能排列出来的所有字符串 abb, bab, 和 bba。

==重复条件==

```java
private ArrayList<String> ret = new ArrayList<>();

public ArrayList<String> Permutation(String str) {
    if (str.length() == 0) return ret;
    char[] chars = str.toCharArray();
    Arrays.sort(chars);
    backtracking(chars, new boolean[chars.length], new StringBuffer());
    return ret;
}

private void backtracking(char[] chars, boolean[] hasUsed, StringBuffer s) {
    if (s.length() == chars.length) {
        ret.add(s.toString());
        return;
    }
    for (int i = 0; i < chars.length; i++) {
        if (hasUsed[i]) continue;
        if (i != 0 && chars[i] == chars[i - 1] && !hasUsed[i - 1]) continue; // 保证不重复
        hasUsed[i] = true;
        s.append(chars[i]);
        backtracking(chars, hasUsed, s);
        s.deleteCharAt(s.length() - 1);
        hasUsed[i] = false;
    }
}
```

##### ++39. 数组中出现次数超过一半的数字++

partition 找中位数。平均时间复杂度为 O(n)。但 partition 的限制很多，例如修改了数组，且最坏情况下复杂度高，若数组分布均匀且采取三数取中的算法可达到平均复杂度。

这个数字出现的次数比其他所有数字出现的总和还多。因此可以保存两个值：一个是数字，一个是次数。遍历到一个字符时，如果和保存的数相等，次数加一，如果不相等，次数减一。如果次数为0，要保存新的数字，次数为1。时间复杂度为 O(n)。

```java
public int MoreThanHalfNum_Solution(int[] nums) {
    int majority = nums[0];
    for (int i = 1, cnt = 1; i < nums.length; i++) {
        cnt = nums[i] == majority ? cnt + 1 : cnt - 1;
        if (cnt == 0) {
            majority = nums[i];
            cnt = 1;
        }
    }
    int cnt = 0;
    for (int val : nums) if (val == majority) cnt++;
    return cnt > nums.length / 2 ? majority : 0;
}
```

##### 40. 最小的 K 个数

**快速选择**

- 复杂度：O(N) + O(1)
- 只有当允许修改数组元素时才可以使用

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。

找到第 K 个元素之后，就可以再遍历一次数组，所有小于等于该元素的数组元素都是最小的 K 个数。

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {
    if (k > nums.length || k <= 0) return new ArrayList<>();
    int kthSmallest = findKthSmallest(nums, k - 1);
    ArrayList<Integer> ret = new ArrayList<>();
    for (int val : nums) {
        if (val <= kthSmallest && ret.size() < k) ret.add(val);
    }
    return ret;
}

public int findKthSmallest(int[] nums, int k) {
    int l = 0;
    int h = nums.length - 1;
    while (l < h) {
        int j = partition(nums, l, h);
        if (j < k) {
            l = j + 1;
        } else if (j > k) {
            h = j - 1;
        } else {
            break;
        }
    }
    return nums[k];
}

private int partition(int[] nums, int l, int h) {
    int i = l;
    int j = h + 1;
    while (true) {
        while (i < h && nums[++i] < nums[l]) ;
        while (j > l && nums[l] < nums[--j]) ;
        if (i >= j) {
            break;
        }
        swap(nums, i, j);
    }
    swap(nums, l, j);
    return j;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

**大小为 K 的最小堆**

- 复杂度：O(NlogK) + O(K)
- 特别适合处理海量数据

应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。

维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {
    if (k > nums.length || k <= 0) return new ArrayList<>();
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);
    for (int num : nums) {
        maxHeap.add(num);
        if (maxHeap.size() > k) {
            maxHeap.poll();
        }
    }
    ArrayList<Integer> ret = new ArrayList<>(maxHeap);
    return ret;
}
```

##### 41.1 数据流中的中位数

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

```java
public class Solution {
    // 大顶堆，存储左半边元素
    private PriorityQueue<Integer> left = new PriorityQueue<>((o1, o2) -> o2 - o1);
    // 小顶堆，存储右半边元素，并且右半边元素都大于左半边
    private PriorityQueue<Integer> right = new PriorityQueue<>();
    // 当前数据流读入的元素个数
    private int N = 0;

    public void Insert(Integer val) {
        // 插入要保证两个堆存于平衡状态
        if (N % 2 == 0) {
            // N 为偶数的情况下插入到右半边。
            // 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，
            // 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边
            left.add(val);
            right.add(left.poll());
        } else {
            right.add(val);
            left.add(right.poll());
        }
        N++;
    }

    public Double GetMedian() {
        if (N % 2 == 0) {
            return (left.peek() + right.peek()) / 2.0;
        } else {
            return (double) right.peek();
        }
    }
}
```

##### 41.2 字符流中第一个不重复的字符

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。

```java
public class Solution {
    private int[] cnts = new int[256];
    private Queue<Character> queue = new LinkedList<>();

    public void Insert(char ch) {
        cnts[ch]++;
        queue.add(ch);
        while (!queue.isEmpty() && cnts[queue.peek()] > 1) {
            queue.poll();
        }
    }

    public char FirstAppearingOnce() {
        if (queue.isEmpty()) return '#';
        return queue.peek();
    }
}
```

##### 42. 连续子数组的最大和

{6,-3,-2,7,-15,1,2,2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。

```java
public int FindGreatestSumOfSubArray(int[] nums) {
    if (nums.length == 0) return 0;
    int ret = Integer.MIN_VALUE;
    int sum = 0;
    for (int val : nums) {
        if (sum <= 0) sum = val;
        else sum += val;
        ret = Math.max(ret, sum);
    }
    return ret;
}
```

##### ==43. 从 1 到 n 整数中 1 出现的次数==

依次计算1出现在个位、十位、百位...的次数，求和即为总次数。

计算个位1出现的次数时，每10个数有一个个位为1，分三种情况：<br>
个位为0：n/10取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
个位为1：n/10取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
个位大于等于2：n/10取整+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

计算十位1出现的次数时，每100个数有10个十位为1，分三种情况：<br>
十位为0：n/10取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
十位为1：n/10取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;个位+1<br>
十位大于等于2：n/10取整+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>


```java
public int NumberOf1Between1AndN_Solution(int n) {
    int cnt = 0;
    for (int m = 1; m <= n; m *= 10) {
        int a = n / m, b = n % m;
        cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
    }
    return cnt;
}
```

##### 44. 数字序列中的某一位数字

数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。

```java
public int digitAtIndex(int index) {
    if (index < 0) return -1;
    int digit = 1;
    while (true) {
        int amount = getAmountOfDigit(digit);
        int totalAmount = amount * digit;
        if (index < totalAmount) {
            return digitAtIndex(index, digit);
        }
        index -= totalAmount;
        digit++;
    }
}

/**
 * digit 位数的数字组成的字符串长度
 * 例如 digit = 2，return 90
 */
private int getAmountOfDigit(int digit) {
    if (digit == 1) return 10;
    return (int) Math.pow(10, digit - 1) * 9;
}

/**
 * 在 digit 位数组成的字符串中，第 index 为的数
 */
private int digitAtIndex(int index, int digit) {
    int number = beginNumber(digit) + index / digit;
    int remain = index % digit;
    return (number + "").charAt(remain) - '0';
}

/**
 * digit 位数的起始数字
 * 例如 digit = 2 return 10
 */
private int beginNumber(int digit) {
    if (digit == 1) return 0;
    return (int) Math.pow(10, digit - 1);
}
```

##### 45. 把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。

可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 < S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。

```java
public String PrintMinNumber(int[] numbers) {
    int n = numbers.length;
    String[] nums = new String[n];
    for (int i = 0; i < n; i++) nums[i] = numbers[i] + "";
    Arrays.sort(nums, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));
    String ret = "";
    for (String str : nums) ret += str;
    return ret;
}
```

##### 46. 把数字翻译成字符串

给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”... 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。

```java
public int getTranslationCount(String s) {
    if(s == null || s.length() == 0 || s.charAt(0) == '0') return 0;
    if(s.length() == 1) return 1;
    int n = s.length();
    int[] dp = new int[n+1];
    dp[0] = 1;
    dp[1] = s.charAt(n-1) == '0' ? 0 : 1;
    int two;
    for(int i=2; i<=n; i++){
        if(s.charAt(n-i) == '0'){
            dp[i] = 0;
        }else{
            two = Integer.parseInt(s.substring(n-i, n-i+2));
            dp[i] = dp[i-1] + (two <= 26 && two > 0? dp[i-2] : 0);
        }
    }
    return dp[n];
}
```

##### 47. 礼物的最大价值

在一个 m\*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘

```
1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
```

礼物的最大价值为 1+12+5+7+7+16+5=53。

应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。

```java
public int getMaxValue(int[][] values) {
    if(board == null || board.length == 0 || board[0].length == 0) return 0;
    int m = board.length;
    int n = board[0].length;
    int[][] dp = new int[m+1][n+1];
    for(int i=1; i<=m; i++){
        for(int j=1; j<=n; j++){
            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + board[i-1][j-1];
        }
    }
    return dp[m][n];
}
```

空间复杂度还可以优化：

```java
public int getMaxValue(int[][] values) {
    if (values == null || values.length == 0 || values[0].length == 0)
        return 0;
    int n = values[0].length;
    int[] dp = new int[n];
    for (int[] value : values) {
        dp[0] += value[0];
        for (int i = 1; i < n; i++)
            dp[i] = Math.max(dp[i], dp[i - 1]) + value[i];
    }
    return dp[n - 1];
}
```

##### 48. 最长不含重复字符的子字符串

输入一个字符串（只包含 a\~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。

```java
public int longestSubStringWithoutDuplication(String str) {
    int curLen = 0;
    int maxLen = 0;
    int[] indexs = new int[26];
    for (int i = 0; i < str.length(); i++) {
        int c = str.charAt(i) - 'a';
        int preIndex = indexs[c];
        if (preIndex == -1 || i - preIndex > curLen) curLen++;
        else {
            maxLen = Math.max(maxLen, curLen);
            curLen = i - preIndex;
        }
        indexs[c] = i;
    }
    maxLen = Math.max(maxLen, curLen);
    return maxLen;
}
```

##### 49. 丑数

把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。 习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。

```java
public int GetUglyNumber_Solution(int N) {
    if (N <= 6) return N;
    int i2 = 0, i3 = 0, i5 = 0;
    int cnt = 1;
    int[] dp = new int[N];
    dp[0] = 1;
    while (cnt < N) {
        int n2 = dp[i2] * 2, n3 = dp[i3] * 3, n5 = dp[i5] * 5;
        int min = Math.min(n2, Math.min(n3, n5));
        dp[cnt++] = min;
        if (min == n2) i2++;
        if (min == n3) i3++;
        if (min == n5) i5++;
    }
    return dp[N - 1];
}
```

##### 50. 第一个只出现一次的字符位置

在一个字符串 (1<=字符串长度 <=10000，全部由字母组成) 中找到第一个只出现一次的字符，并返回它的位置。

最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap。

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[256];
    for (int i = 0; i < str.length(); i++) cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++) if (cnts[str.charAt(i)] == 1) return i;
    return -1;
}
```

以上的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么我们只需要统计的次数信息只有 0,1,更大，那么使用两个比特位就能存储这些信息。

```java
public int FirstNotRepeatingChar(String str) {
    BitSet bs1 = new BitSet(256);
    BitSet bs2 = new BitSet(256);
    for (char c : str.toCharArray()) {
        if (!bs1.get(c) && !bs2.get(c)) bs1.set(c);     // 0 0
        else if (bs1.get(c) && !bs2.get(c)) bs2.set(c); // 0 1
    }
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (bs1.get(c) && !bs2.get(c)) return i;
    }
    return -1;
}
```

##### 51. 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数 P。题目保证输入的数组中没有的相同的数字。

```java
private long cnt = 0;
private int[] tmp;  // 在这里声明辅助数组，而不是在 merge() 递归函数中声明

public int InversePairs(int[] nums) {
    tmp = new int[nums.length];
    mergeSort(nums, 0, nums.length - 1);
    return (int) (cnt % 1000000007);
}

private void mergeSort(int[] nums, int l, int h) {
    if (h - l < 1)
        return;
    int m = l + (h - l) / 2;
    mergeSort(nums, l, m);
    mergeSort(nums, m + 1, h);
    merge(nums, l, m, h);
}

private void merge(int[] nums, int l, int m, int h) {
    int i = l, j = m + 1, k = l;
    while (i <= m || j <= h) {
        if (i > m)
            tmp[k] = nums[j++];
        else if (j > h)
            tmp[k] = nums[i++];
        else if (nums[i] < nums[j])
            tmp[k] = nums[i++];
        else if (nums[i] == nums[j]){
            tmp[k] = nums[j++];
            this.cnt += m - i; // nums[i] = nums[j]，说明 nums[i+1...mid] 都大于 nums[j]
        }else {
            tmp[k] = nums[j++];
            this.cnt += m - i + 1;  // nums[i] > nums[j]，说明 nums[i...mid] 都大于 nums[j]
        }
        k++;
    }
    for (k = l; k <= h; k++)
        nums[k] = tmp[k];
}
```

##### 52. 两个链表的第一个公共结点

```html
A:          a1 → a2
                  ↘
                    c1 → c2 → c3
                  ↗
B:    b1 → b2 → b3
```

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

```java
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    ListNode l1 = pHead1, l2 = pHead2;
    while (l1 != l2) {
        l1 = (l1 == null) ? pHead2 : l1.next;
        l2 = (l2 == null) ? pHead1 : l2.next;
    }
    return l1;
}
```

##### ==53 数字在排序数组中出现的次数==

```html
Input:
1, 2, 3, 3, 3, 3, 4, 6
3
Output:
4
```

可以用二分查找找出大于等于某数的第一个索引。若数组中所有数都小于该数，则返回数组的长度。

```java
public int GetNumberOfK(int[] nums, int K) {
    int first = binarySearch(nums, K);
    int last = binarySearch(nums, K + 1);
    return first == nums.length ? 0 : last - first;
}

private int binarySearch(int[] nums, int K) {
    int l = 0, h = nums.length;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= K)
            h = m;
        else
            l = m + 1;
    }
    return l;
}
```

##### ++54. 二叉搜索树的第 K 个结点++

利用二叉搜索数中序遍历有序的特点。

```java
private TreeNode ret;
private int cnt = 0;

public TreeNode KthNode(TreeNode pRoot, int k) {
    inOrder(pRoot, k);
    return ret;
}

private void inOrder(TreeNode root, int k) {
    if (root == null) return;
    if (cnt > k) return;
    inOrder(root.left, k);
    cnt++;
    if (cnt == k) ret = root;
    inOrder(root.right, k);
}
```

##### 55.1 二叉树的深度

从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

```java
public int TreeDepth(TreeNode root) {
    if (root == null) return 0;
    return 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
}
```

##### 55.2 平衡二叉树

```html
    3
   / \
  9  20
    /  \
   15   7
```

平衡二叉树左右子树高度差不超过 1。

```java
private boolean isBalanced = true;

public boolean IsBalanced_Solution(TreeNode root) {
    height(root);
    return isBalanced;
}

private int height(TreeNode root) {
    if (root == null) return 0;
    int left = height(root.left);
    int right = height(root.right);
    if (Math.abs(left - right) > 1) isBalanced = false;
    return 1 + Math.max(left, right);
}
```

##### 56. 数组中只出现一次的数字

一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。

两个不相等的元素在位级表示上必定会有一位存在不同。

将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。

diff &= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。

```java
public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
    int diff = 0;
    for (int num : array) diff ^= num;
    // 得到最右一位
    diff &= -diff;
    for (int num : array) {
        if ((num & diff) == 0) num1[0] ^= num;
        else num2[0] ^= num;
    }
}
```

##### 57.1 和为 S 的两个数字

输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。

使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

如果两个指针指向元素的和 sum == target，那么得到要求的结果；如果 sum > target，移动较大的元素，使 sum 变小一些；如果 sum < target，移动较小的元素，使 sum 变大一些。

```java
public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
    int i = 0, j = array.length - 1;
    while (i < j) {
        int cur = array[i] + array[j];
        if (cur == sum) return new ArrayList<Integer>(Arrays.asList(array[i], array[j]));
        else if (cur < sum) i++;
        else j--;
    }
    return new ArrayList<Integer>();
}
```

##### 57.2 和为 S 的连续正数序列

和为 100 的连续序列有 18, 19, 20, 21, 22。

```java
public ArrayList<ArrayList<Integer>> FindContinuousSequence(int sum) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    int first = 1, last = 2;
    int curSum = 3;
    while (first <= sum / 2 && last < sum) {
        if (curSum > sum) {
            curSum -= first;
            first++;
        } else if (curSum < sum) {
            last++;
            curSum += last;
        } else {
            ArrayList<Integer> list = new ArrayList<>();
            for (int i = first; i <= last; i++) {
                list.add(i);
            }
            ret.add(list);
            curSum -= first;
            first++;
            last++;
            curSum += last;
        }
    }
    return ret;
}
```

##### 58.1 翻转单词顺序列

输入："I am a student."

输出："student. a am I"

题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(n)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。

```java
public String ReverseSentence(String str) {
    if (str.length() == 0) return str;
    int n = str.length();
    char[] chars = str.toCharArray();
    int i = 0, j = 0;
    while (j <= n) {
        if (j == n || chars[j] == ' ') {
            reverse(chars, i, j - 1);
            i = j + 1;
        }
        j++;
    }
    reverse(chars, 0, n - 1);
    return new String(chars);
}

private void reverse(char[] c, int i, int j) {
    while(i < j) {
        char t = c[i]; c[i] = c[j]; c[j] = t;
        i++; j--;
    }
}
```

##### 58.2 左旋转字符串

对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”, 要求输出循环左移 3 位后的结果，即“XYZdefabc”。

```java
public String LeftRotateString(String str,int n) {
    if(str.length() == 0) return "";
    char[] c = str.toCharArray();
    reverse(c, 0, n - 1);
    reverse(c, n, c.length - 1);
    reverse(c, 0, c.length - 1);
    return new String(c);
}

private void reverse(char[] c, int i, int j) {
    while(i < j) {
        char t = c[i]; c[i] = c[j]; c[j] = t;
        i++; j--;
    }
}
```

##### 59. 滑动窗口的最大值

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。

```java
public ArrayList<Integer> maxInWindows(int[] num, int size) {
    ArrayList<Integer> ret = new ArrayList<>();
    if (size > num.length || size < 1) return ret;
    // 构建最大堆，即堆顶元素是堆的最大值。
    PriorityQueue<Integer> heap = new PriorityQueue<Integer>((o1, o2) -> o2 - o1);
    for (int i = 0; i < size; i++) heap.add(num[i]);
    ret.add(heap.peek());
    for (int i = 1; i + size - 1 < num.length; i++) {
        heap.remove(num[i - 1]);
        heap.add(num[i + size - 1]);
        ret.add(heap.peek());
    }
    return ret;
}
```

书上思路：队列

```java
public ArrayList<Integer> maxInWindows(int [] num, int size){
        ArrayList<Integer> res = new ArrayList<>();
        if(num == null || size <= 0 || num.length < size) return res;
        List<Integer> queue = new LinkedList<>();
        for(int i=0; i<num.length; i++){
            if(queue.size() != 0 && queue.get(0) <= i-size){
                queue.remove(0);
            }
            if(queue.size() != 0){
                if(num[i] >= num[queue.get(0)]){
                    queue.clear();
                }else{
                    while(queue.size() > 0 
                         && num[queue.get(queue.size()-1)] < num[i]){
                        queue.remove(queue.size()-1);
                    }
                }
            }
            queue.add(i);
            if(i >= size - 1){
                res.add(num[queue.get(0)]);
            }
        }
        return res;
    }
```

##### 60. n 个骰子的点数

把 n 个骰子仍在地上，求点数和为 s 的概率。

**动态规划解法**

空间复杂度：O(n<sup>2</sup>)

```java
private static int face = 6;

public double countProbability(int n, int s) {
    if (n < 1 || s < n) return 0.0;
    int pointNum = face * n;
    int[][] dp = new int[n][pointNum];
    for (int i = 0; i < face; i++) {
        dp[0][i] = 1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = i; j < pointNum; j++) { // 使用 i 个骰子最小点数为 i
            for (int k = 1; k <= face; k++) {
                if (j - k >= 0) {
                    dp[i][j] += dp[i - 1][j - k];
                }
            }
        }
    }
    int totalNum = (int) Math.pow(6, n);
    return (double) dp[n - 1][s - 1] / totalNum;
}
```

**动态规划解法 + 旋转数组**

空间复杂度：O(n)

```java
private static int face = 6;

public double countProbability(int n, int s) {
    if (n < 1 || s < n) return 0.0;
    int pointNum = face * n;
    int[][] dp = new int[2][pointNum];
    for (int i = 0; i < face; i++) {
        dp[0][i] = 1;
    }
    int flag = 1;
    for (int i = 1; i < n; i++) {
        for (int j = i; j < pointNum; j++) { // 使用 i 个骰子最小点数为 i
            for (int k = 1; k <= face; k++) {
                if (j - k >= 0) {
                    dp[flag][j] += dp[1 - flag][j - k];
                }
            }
        }
        flag = 1 - flag;
    }
    int totalNum = (int) Math.pow(6, n);
    return (double) dp[flag][s - 1] / totalNum;
}
```

##### 61. 扑克牌顺子

五张牌，其中大小鬼为癞子，牌面大小为 0。判断是否能组成顺子。

```java
public boolean isContinuous(int[] nums) {
    if (nums.length < 5) return false;
    Arrays.sort(nums);
    int cnt = 0;
    for (int num : nums) if (num == 0) cnt++;
    for (int i = cnt; i < nums.length - 1; i++) {
        if (nums[i + 1] == nums[i]) return false;
        int interval = nums[i + 1] - nums[i] - 1;
        if (interval > cnt) return false;
        cnt -= interval;
    }
    return true;
}
```

##### ==62. 圆圈中最后剩下的数==

让小朋友们围成一个大圈。然后 , 他随机指定一个数 m, 让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌 , 然后可以在礼品箱中任意的挑选礼物 , 并且不再回到圈中 , 从他的下一个小朋友开始 , 继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友 , 可以不用表演。

约瑟夫环

```java
public int LastRemaining_Solution(int n, int m) {
    if (n == 0) return -1;
    if (n == 1) return 0;
    return (LastRemaining_Solution(n - 1, m) + m) % n;
}
```

##### 63. 股票的最大利润

可以有一次买入和一次卖出，买入必须在前。求最大收益。

```java
public int maxProfit(int[] prices) {
    int n = prices.length;
    if(n == 0) return 0;
    int soFarMin = prices[0];
    int max = 0;
    for(int i = 1; i < n; i++) {
        if(soFarMin > prices[i]) soFarMin = prices[i];
        else max = Math.max(max, prices[i] - soFarMin);
    }
    return max;
}
```

##### ++64. 求 1+2+3+...+n++

求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。

```java
public int Sum_Solution(int n) {
    int sum = n;
    boolean b = (n > 0) && ((sum += Sum_Solution(n - 1)) > 0);
    return sum;
}
```

##### 65. 不用加减乘除做加法

a ^ b 表示没有考虑进位的情况下两数的和，(a & b) << 1 就是进位。递归会终止的原因是 (a & b) << 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。

```java
public int Add(int num1, int num2) {
    if(num2 == 0) return num1;
    return Add(num1 ^ num2, (num1 & num2) << 1);
}
```

##### 66. 构建乘积数组



给定一个数组 A[0, 1,..., n-1], 请构建一个数组 B[0, 1,..., n-1], 其中 B 中的元素 B[i]=A[0]\*A[1]\*...\*A[i-1]\*A[i+1]\*...\*A[n-1]。不能使用除法。

 

```java
public int[] multiply(int[] A) {
    int n = A.length;
    int[] B = new int[n];
    for (int i = 0, product = 1; i < n; product *= A[i], i++) {
        B[i] = product;
    }
    for (int i = n - 1, product = 1; i >= 0; product *= A[i], i--) {
        B[i] *= product;
    }
    return B;
}
```

##### 67. 把字符串转换成整数

```java
//2147483647+1 = -2147483648
//-(-2147483648) = -2147483648
public int StrToInt(String str) {
    if (str.length() == 0) return 0;
    char[] chars = str.toCharArray();
    boolean isNegative = chars[0] == '-';
    int ret = 0;
    for (int i = 0; i < chars.length; i++) {
        if (i == 0 && (chars[i] == '+' || chars[i] == '-')) continue;
        if (chars[i] < '0' || chars[i] > '9') return 0;
        ret = ret * 10 + (chars[i] - '0');
    }
    return isNegative ? -ret : ret;
}
```

##### ==68. 树中两个节点的最低公共祖先==

二叉查找树

```html
        _______6______
       /              \
   ___2__           ___8__
  /      \         /      \
 0        4       7        9
         / \
        3   5
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
    if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
    return root;
}
```

普通二叉树

```html
       _______3______
      /              \
  ___5__           ___1__
 /      \         /      \
 6       2       0        8
        / \
       7   4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
```

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}
```

##### 开发一个实时热搜的榜单。

```
输入
第一行一个正整数n，表示接下来有n条操作。（1<= n <= 100000）
接下来n行，每行是两种操作中的一种：
append x y ：其中x和y是两个正整数，表示接收到新闻x的热度提升了y。（新闻编号x的范围是[1,1000]，单次热度提升y的范围是[1,1000]）
query : 用户向你发来查询。
输出
对于每条用户查询，输出最高的十条新闻，以空格分隔。不足十条时，有几条输出几条。没有新闻时，输出null。每条查询的输出占一行。
样例输入
9
query
append 1 10
query
append 2 20
query
append 3 15
query
append 1 10
query
样例输出
null
1 
2 1 
2 3 1 
1 2 3
```

```java
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        HashMap<Integer,Integer> map=new HashMap<>();
        for (int i = 0; i < n; i++) {
            String s = sc.nextLine();
            String[] sa = s.split(" ");
            if (sa.length != 1) {
                int x = Integer.parseInt(sa[1]);
                int y = Integer.parseInt(sa[2]);
                if(map.containsKey(x)){
                    map.put(x,map.get(x)+y);
                }else {
                    map.put(x,y);
                }
            } else if (s.equals("query")) {
                ArrayList<Map.Entry<Integer, Integer>> entries = new ArrayList<>(map.entrySet());
                Collections.sort(entries, new Comparator<Map.Entry<Integer, Integer>>() {
                    @Override
                    public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
                        return o2.getValue().compareTo(o1.getValue());
                    }
                });
                //System.out.println(Arrays.toString(entries.toArray()));
                if(entries.size()==0){
                    System.out.println("null");
                }else{
                    if(entries.size()<=10){
                        for(Map.Entry<Integer, Integer> o1:entries){
                            System.out.print(o1.getKey()+" ");
                        }
                        System.out.println();
                    }else{
                        for(int j=0;j<10;j++){
                            if(entries.get(j)!=null){
                                System.out.print(entries.get(j).getKey()+" ");
                            }
                        }
                        System.out.println();
                    }
                }
            }
        }
    }
}
```

