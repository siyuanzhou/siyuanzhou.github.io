---
layout: post
title: "Spring基础知识"
date: 2018-07-06 10:36
toc: true
comments: true
categories: 技术学习
tags:
	- web 
---

#### Spring概述

pring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 SpringMVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。

<!--more-->

##### spring优势

```
##### 方便解耦，简化开发
通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。

##### AOP编程的支持
通过 Spring的 AOP 功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过 AOP 轻松应付。

##### 声明式事务的支持
可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。

##### 方便程序的测试
可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。

##### 方便集成各种优秀框架
Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。

##### 降低 JavaEE API 使用难度
Spring对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。
```

##### spring体系结构

![1566530239633](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1566530239633.png)

#### IoC概念和作用

##### 控制反转IOC(Inversion Of Control)

作用：把创建对象的权利交给框架，削减计算机程序的耦合(解除我们代码中的依赖关系)

工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。主要包括依赖注入和依赖查找

![1566531231569](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1566531231569.png)

##### 程序的耦合和解耦

- `耦合`: 程序间的依赖关系.在开发中,应该做到解决`编译期依赖`,即`编译期不依赖,运行时才依赖`.耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。
- 解耦的思路: 使用反射来创建对象,而避免使用new关键字,并通过读取配置文件来获取要创建的对象全限定类名.
- 耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。在开发中，有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。

```java
（1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。
（2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。
（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。
（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。
（5） 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。
（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。
（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。
总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。
```

##### 解耦实例1: JDBC驱动注册

JDBC操作中注册驱动时,我们不使用`DriverManager`的`register`方法,而采用`Class.forName("驱动类全类名")`的方式.

```java
public static void main(String[] args) throws SQLException, ClassNotFoundException {
	//注册驱动的两种方式
	// 1. 创建驱动类的实例 
	//DriverManager.registerDriver(new com.mysql.jdbc.Driver());
	// 2. 通过反射加载驱动类
	Class.forName("com.mysql.jdbc.Driver");		// 实际开发中此类名从properties文件中读取	
	//...后续操作
}
```

查看`com.mysql.jdbc.Driver`类的源码如下,在类加载和初始化时,会执行static代码块中的部分,也就是说加载类的时候就自动注册驱动了.

```java
public class Driver extends NonRegisteringDriver implements java.sql.Driver {
	static {
	    try {
	        java.sql.DriverManager.registerDriver(new Driver());	// 类初始化时执行注册动作
	    } catch (SQLException E) {
	        throw new RuntimeException("Can't register driver!");
	    }
	}
    public Driver() throws SQLException {
    // Required for Class.forName().newInstance()
    }
}
```

此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的）。

##### 解耦实例2: UI层,Service层,Dao层调用

在Web项目中,`UI层`,`Service层`,`Dao层`之间有着前后调用的关系.在实际开发中可以把三层的对象的全类名都使用配置文件保存起来,当启动服务器应用加载的时候,让一个类中的方法通过读取配置文件，创建这些对象的实例并保存在`容器`中. 这个读取配置文件，创建和获取三层对象的类就是工厂。在获取对象时,不使用new的方式,而是直接从`容器`中获取,这就是`工厂设计模式`，下面是一个简单的工厂模式代码

 * Bean：在计算机英语中，有可重用组件的含义。
 * JavaBean：用java语言编写的可重用组件。javabean >  实体类

```java
/**
 * 一个创建Bean对象的工厂，用来创建我们的service和dao对象的。
 *
 *   第一个：需要一个配置文件来配置我们的service和dao
 *           配置的内容：唯一标识=全限定类名（key=value)
 *   第二个：通过读取配置文件中配置的内容，反射创建对象
 *
 *   我的配置文件可以是xml也可以是properties
 */
public class BeanFactory {
    //定义一个Properties对象
    private static Properties props;
    //定义一个Map,用于存放我们要创建的对象。我们把它称之为容器
    private static Map<String,Object> beans;
    //使用静态代码块为Properties对象赋值
    static {
        try {
            //实例化对象
            props = new Properties();
            //获取properties文件的流对象
            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties");
            props.load(in);
            //实例化容器
            beans = new HashMap<String,Object>();
            //取出配置文件中所有的Key
            Enumeration keys = props.keys();
            //遍历枚举
            while (keys.hasMoreElements()){
                //取出每个Key
                String key = keys.nextElement().toString();
                //根据key获取value
                String beanPath = props.getProperty(key);
                //反射创建对象
                Object value = Class.forName(beanPath).newInstance();
                //把key和value存入容器中
                beans.put(key,value);
            }
        }catch(Exception e){
            throw new ExceptionInInitializerError("初始化properties失败！");
        }
    }
    //根据bean的名称获取对象
    public static Object getBean(String beanName){
        return beans.get(beanName);
    }
    /**根据Bean的名称获取bean对象,非单例，每次都会调用默认构造函数创建对象
    public static Object getBean(String beanName){
        Object bean = null;
        try {
            String beanPath = props.getProperty(beanName);
            System.out.println(beanPath);
            bean = Class.forName(beanPath).newInstance();//每次都会调用默认构造函数创建对象
        }catch (Exception e){
            e.printStackTrace();
        }
        return bean;
    }*/
}

//    private IAccountDao accountDao = new AccountDaoImpl();
//使用工厂模式得到AcountDao对象
private IAccountDao accountDao = (IAccountDao) MyBeanFactory.getBean("accountDao");
```

#### spring的IOC解决程序耦合

##### 简单实例

1.准备工作: 创建MAVEN项目,创建业务层接口和实现类

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.0.2.RELEASE</version>
    </dependency>
</dependencies>
```

```java
public class AccountServiceImpl implements IAccountService {
    IAccountDao accountDao=new AccountDaoImpl();
    @Override
    public void saveAccount() {
        accountDao.saveAccount();
    }
}

public class AccountDaoImpl implements IAccountDao {
    @Override
    public void saveAccount() {
        System.out.println("保存了账户");
    }
}
```

2.配置`bean`: 在类的根路径下的`resource`目录下创建`bean.xml`文件,把对象的创建交给spring来管理.
每个`<bean>`标签对应一个类,其`class`属性为该类的全类名,`id`属性为该类的id,在spring配置中,通过`id`获取类的对象.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中
        id 属性：对象的唯一标识。
        class 属性：指定要创建对象的全限定类名
    -->
    <bean id="accountService" class="site.newvalue.service.impl.AccountServiceImpl"></bean>
    <bean class="site.newvalue.dao.impl.AccountDaoImpl" id="accountDao"></bean>
</beans>
```

3.测试类通过`容器`创建对象.通过核心容器的`getBean()`方法获取具体对象

```java
@Test
public void testGetBean(){
    // 获取核心容器对象
    ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
    // 根据id获取Bean对象
    IAccountService as  = (IAccountService)ac.getBean("accountService");
    // 执行as的具体方法
    as.saveAccount();
}
```

##### ApplicationContext实现细节

![image-20200309141343267](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200309141343267.png)

```
 * ApplicationContext的三个常用实现类：
    ClassPathXmlApplicationContext：加载类路径下配置文件，要求文件必须在类路径下。不在的话，加载不了。(更常用)
    FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件(必须有访问权限）
    AnnotationConfigApplicationContext：用于读取注解创建容器

 * 核心容器的两个接口引发出的问题：
 *  ApplicationContext:     单例对象适用              采用此接口
 *      它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。
 *  BeanFactory:            多例对象使用
 *      它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。
```

##### IOC中bean标签

- 作用: 配置托管给spring的对象,默认情况下调用类的无参构造函数创建对象,若类没有无参构造函数则不能创建成功

```
属性:
id: 指定对象在容器中的标识,将其作为参数，传入getBean()方法，可以获取获取对应对象.
class: 指定类的全类名,默认情况下调用无参构造函数
scope: 指定对象的作用范围,可选值如下
    singleton: 单例对象,默认值
    prototype: 多例对象
    request: 将对象存入到web项目的request域中
    session: 将对象存入到web项目的session域中
	global session: 将对象存入到web项目集群session域中,若不存在集群则global session相当于session
init-method：指定类的初始化方法名称,在对象创建成功之后执行
destroy-method：指定类中销毁方法名称,对prototype多例对象没有作用,因为多利对象销毁时机不受容器控制
```

理解global session集群的Session如下图，实现了集群不同服务器见共享信息

![1566547327645](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1566547327645.png)

##### bean作用范围和生命周期

```
bean对象的生命周期
    单例对象 scope="singleton"
        出生：当容器创建时对象出生
        活着：只要容器还在，对象一直活着
        死亡：容器销毁，对象消亡
        总结：单例对象的生命周期和容器相同
    多例对象 scope="prototype"
        出生：当我们使用对象时spring框架为我们创建
        活着：对象只要是在使用过程中就一直活着。
        死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收
```

##### 实例化Bean的三种方式

```xml
<!-- 第一种方式：使用默认构造函数创建。
            在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。
            采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。    -->
<bean id="accountService" class="site.newvlaue.service.impl.AccountServiceImpl"></bean>

<!-- 第二种方式： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）
	//模拟一个实例工厂，创建业务层实现类; 此工厂创建对象，必须现有工厂实例对象，再调用方法
    public class InstanceFactory {
        public IAccountService createAccountService(){
            return new AccountServiceImpl();
        }
    }    -->
<bean id="instanceFactory" class="site.newvlaue.factory.InstanceFactory"></bean>
<bean id="accountService" factory-bean="instanceFactory" factory-method="createAccountService"></bean>


<!-- 第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)
    //模拟一个静态工厂，创建业务层实现类
    public class StaticFactory { 
        public static IAccountService createAccountService(){
            return new AccountServiceImpl();
        }
    }
    id 属性：指定 bean 的 id，用于从容器中获取
    class 属性：指定静态工厂的全限定类名
    factory-method 属性：指定生产对象的静态方法    -->
<bean id="accountService" class="site.newvlaue.factory.StaticFactory" factory-method="createAccountService"></bean>
```

#### Spring中的依赖注入

依赖注入(Dependency Injection)是spring框架核心ioc的具体实现.

```
通过控制反转,我们把创建对象托管给了spring,在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明。
但是代码中不可能消除所有依赖,例如:业务层仍然会调用持久层的方法,因此业务层类中应包含持久化层的实现类对象.
我们等待框架通过配置的方式将持久层对象传入业务层,而不是直接new对象,称为依赖注入.
因为是通过反射方式来创建属性对象,而非使用new,因此要指定创建出对象各字段取值，这是依赖注入重点。

能注入的数据：有三类
    基本类型和String
    其他bean类型（在配置文件中或者注解配置过的bean）
    复杂类型/集合类型
注入的方式：有三种
    第一种：使用构造函数提供
    第二种：使用set方法提供
    第三种：使用注解提供
```

##### 使用构造函数注入

顾名思义，就是使用类中构造函数，给成员变量赋值。注意，赋值操作不是我们自己做的，而是通过配置方式，让 spring框架来为我们注入。

在获取bean对象时，注入数据是必须操作，必须有相符合的构造函数，否则对象无法创建成功

```xml
寻找要赋值给的字段
    index: 指定参数在构造函数参数列表的索引位置，从0开始
    type: 指定参数在构造函数中的数据类型
    name: 指定参数在构造函数中的变量名,最常用的属性
指定赋给字段的值
    value: 给基本数据类型和String类型赋值
    ref: 给其它Bean类型的字段赋值,ref属性的值应为配置文件中配置的Bean的id
    
<bean id="accountService" class="site.newvalue.service.impl.AccountServiceImpl">
    <constructor-arg name="age" value="18"></constructor-arg>
    <constructor-arg index="0" value="zsy"></constructor-arg>
    <constructor-arg ref="now" type="java.util.Date"></constructor-arg>
</bean>
<bean id="now" class="java.util.Date"></bean>
```

##### 使用set方法注入(更常用)

在类中提供需要注入成员属性的set方法,创建对象只调用要赋值属性set方法，可以注入部分字段.

```xml
指定要调用set方法赋值的成员字段
	name：要调用set方法赋值的成员字段
指定赋给字段的值
    value: 给基本数据类型和String类型赋值
    ref: 给其它Bean类型的字段赋值,ref属性的值应为配置文件中配置的Bean的id
    
<bean id="accountService2" class="site.newvalue.service.impl.AccountServiceImpl">
    <property name="age" value="18"></property>
    <property name="birthday" value="2018/03/12"></property>
</bean>

通过在xml中导入p名称空间，使用p:propertyName来注入数据，本质仍然是调用类中的set方法实现注入功能
xmlns:p="http://www.springframework.org/schema/p"
<bean id="accountService"
    class="com.itheima.service.impl.AccountServiceImpl4"
    p:name="test" p:age="21" p:birthday-ref="now"/>
</beans>
```

##### 注入集合字段

就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。集合字段及其对应的标签按照**集合的结构**分为两类: 相同结构的集合标签之间可以互相替换.

```xml
只有键的结构:
    数组字段: <array>标签表示集合,<value>标签表示集合内的成员.
    List字段: <list>标签表示集合,<value>标签表示集合内的成员.
    Set字段: <set>标签表示集合,<value>标签表示集合内的成员.
    其中<array>,<list>,<set>标签之间可以互相替换使用.

键值对的结构:
    Map字段: <map>标签表示集合,<entry>标签表示集合内的键值对,其key属性表示键,value属性表示值.
    Properties字段: <props>标签表示集合,<prop>标签表示键值对,其key属性表示键,标签内的内容表示值.
    其中<map>,<props>标签之间,<entry>,<prop>标签之间可以互相替换使用.

<bean class="site.syzhou.service.impl.AccountServiceImpl3" id="accountService3">
    <property name="arrays">
        <array>
            <value>111</value>
            <value>222</value>
        </array>
    </property>
    <property name="lists">
        <array>
            <value>111</value>
        </array>
    </property>
    <property name="set">
        <set>
            <value>111</value>
            <value>222</value>
        </set>
    </property>
    <property name="map">
        <map>
            <entry key="123" value="123"></entry>
            <entry key="123"><value>123</value></entry>
        </map>
    </property>
    <property name="props">
        <props>
            <prop key="456">456</prop>
        </props>
    </property>
</bean>
```

#### 基于注解的IOC配置

bean.xml配置spring支持注解操作，使用注解实现IOC,要将注解写在类的定义中

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--告诉Spring需要扫描的包，配置不在beans约束中，在context约束中-->
    <context:component-scan base-package="site.newvalue"></context:component-scan>
    <!-- 配置 dbAssit -->
    <bean id="dbAssit" class="com.itheima.dbassit.DBAssit">
    	<property name="dataSource" ref="dataSource"></property>
    </bean>
    <!-- 配置数据源 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql:///spring_day02"></property>
        <property name="user" value="root"></property>
        <property name="password" value="1234"></property>
    </bean>
</beans>
```

##### 注解配置VSxml配置

注解的优势：配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。
XML  的优势：修改时，不用改源码。不涉及重新编译和部署。

![image-20200309151120491](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200309151120491.png)

##### 创建对象的注解

作用相当于bean.xml中的\<bean>标签\<bean id="" class="">

```java
@Component: 把当前类对象存入spring容器中,其属性如下:
	value: 用于指定当前类的id. 不写时默认值是当前类名,且首字母改小写
@Controller: 将当前表现层对象存入spring容器中
@Service: 将当前业务层对象存入spring容器中
@Repository: 将当前持久层对象存入spring容器中
@Controller,@Service,@Repository注解的作用和属性与@Component是一模一样的,可以相互替代,它们的作用是使三层对象的分别更加清晰
如果注解中有且只有一个属性 要赋值时是 ，且名称是 value ，value在赋值是可以不写

@Component("accountDao")
public class AccountDaoImpl implements IAccountDao {
	private DBAssit dbAssit;
}
```

##### 注入数据的注解

作用相当于`bean.xml`中的`<property>`标签，相当于：\<property name="" ref="">
\<property name="" value="">

@Autowired:注入过程如图：

![1566891253483](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1566891253483.png)

```java
@Autowired: 自动按照成员变量类型注入.
    注入过程
        当spring容器中有且只有一个对象的类型与要注入的类型相同时,注入该对象.
        当spring容器中有多个对象类型与要注入的类型相同时
        	使用要注入的变量名作为bean的id,在spring容器查找,找到则注入该对象.找不到则报错.
    出现位置: 既可以在变量上,也可以在方法上
    细节: 使用注解注入时,set方法可以省略
     @Autowired
     private IAccountDao accountDao;

@Qualifier: 在自动按照类型注入的基础之上,再按照bean的id注入.
    出现位置: 既可以在变量上,也可以在方法上
    	注入变量时不能独立使用,必须和@Autowire一起使用; 注入方法时可以独立使用.
    属性:value: 指定bean的id
    
@Resource: 直接按bean的id注入,可以独立使用.独立使用时相当于同时使用@Autowired和@Qualifier两个注解.
    属性:name: 指定bean的id
    
@Value: 注入基本数据类型和String类型数据
    属性:value: 用于指定数据的值,可以使用el表达式(${表达式})
```

##### 改变作用范围的注解

作用相当于bean.xml中的\<bean>标签的scope属性.\<bean id="" class="" scope="">

```java
@Scope: 指定bean的作用范围
属性:value: 用于指定作用范围的取值,"singleton","prototype","request","session","globalsession"
```

##### 生命周期相关注解

这些注解的作用相当于bean.xml中的\<bean>标签的init-method和destroy-method属性\<bean id="" class="" init-method="" destroy-method="" />

```java
@PostConstruct: 用于指定初始化方法
@PreDestroy: 用于指定销毁方法
```

#### 半注解配置和纯注解配置

spring的注解配置可以与xml配置并存,也可以只使用注解配置

##### 半注解配置

在`半注解配置`下,spring容器仍然使用`ClassPathXmlApplicationContext`类从xml文件中读取IOC配置,同时在xml文件中告知spring创建容器时要扫描的包.然后将spring注解加在类的定义中.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!--告知spring在创建容器时要扫描包,配置此项所需标签不在beans约束中,而在一个名为context名称空间和约束中-->
    <context:component-scan base-package="site.syzhou"></context:component-scan>
</beans>
```

##### 纯注解配置

在纯注解配置下,我们用配置类替代`bean.xml`,spring容器使用`AnnotationApplicationContext`类从spring配置类中读取IOC配置

```java
@Configuration: 用于指定当前类是一个spring配置类,当创建容器时会从该类上加载注解.获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class).

@ComponentScan: 指定spring在初始化容器时要扫描的包,作用和bean.xml 文件中<context:component-scan base-package="要扫描的包名"/>是一样的. 其属性如下:
	basePackages: 用于指定要扫描的包,是value属性的别名
	
@Bean: 该注解只能写在方法上,表明使用此方法创建一个对象,并放入spring容器,其属性如下:
	name: 指定此方法创建出的bean对象的id
	细节: 使用注解配置方法时,如果方法有参数,Spring框架会到容器中查找有没有可用的bean对象,查找的方式与@Autowired注解时一样的.
	
@PropertySource: 用于加载properties配置文件中的配置.例如配置数据源时,可以把连接数据库的信息写到properties配置文件中,就可以使用此注解指定properties配置文件的位置,其属性如下:
	value: 用于指定properties文件位置.如果是在类路径下,需要写上"classpath:"
	
@Import: 用于导入其他配置类.使用@Import注解之后,有@Import注解类就是父配置类,而导入都是子配置类. 
	其属性如下:value: 用于指定其他配置类的字节码
```

##### 纯注解配置实现CRUD

dao层实现类:

```java
@Repository("accountDao")
public class AccountDaoImpl implements IAccountDao {
    @Autowired	// 自动从spring容器中寻找QueryRunner类型对象注入给runner成员变量
    private QueryRunner runner;		// DBUtil对象,用来执行SQL语句

    public List<Account> findAllAccount() {
		// 功能实现...
    }
    public void saveAccount(Account account) {
        // 功能实现...
    }
    public void deleteAccount(Integer accountId) {
        // 功能实现...
    }
} 
```

service层实现类:

```java
@Service("accountService")
public class AccountServiceImpl implements IAccountService{
    @Autowired	// 自动从spring容器中寻找IAccountDao类型对象注入给accountDao成员变量
    private IAccountDao accountDao;	// dao层对象,用来执行数据持久化操作
    public List<Account> findAllAccount() {
		// 功能实现...
    }
    public void saveAccount(Account account) {
        // 功能实现...
    }
    public void deleteAccount(Integer accountId) {
        // 功能实现...
    }
}
```

包`config`存放配置类,其中`SpringConf`类为主配置类

```java
@Configuration					// 说明此类为配置类
@ComponentScan("site.syzhou")	// 指定初始化容器时要扫描的包
@Import(JdbcConfig.class)		// 引入JDBC配置类
public class SpringConfiguration {
}
```

其中JDBCConfig类为JDBC配置类

```java
@Configuration									// 说明此类为配置类
@PropertySource("classpath:jdbc.properties")	// 指定配置文件的路径,关键字classpath表示类路径
public class JdbcConfig {
    @Value("${jdbc.driver}")	// 为driver成员属性注入值,使用el表达式
    private String driver;
    @Value("${jdbc.url}")		// 为url成员属性注入值,使用el表达式
    private String url;
    @Value("${jdbc.username}")	// 为usernamer成员属性注入值,使用el表达式
    private String username;
    @Value("${jdbc.password}")	// 为password成员属性注入值,使用el表达式
    private String password;

    // 创建DBUtils对象
    @Bean(name="runner")	// 此将函数返回的bean对象存入spring容器中,其id为runner
    @Scope("prototype")		// 说明此bean对象的作用范围为多例模式,以便于多线程访问
    public QueryRunner createQueryRunner(@Qualifier("ds") DataSource dataSource){
		// 为函数参数datasource注入id为ds的bean对象
        return new QueryRunner(dataSource);
    }

    // 创建数据库连接池对象
    @Bean(name="ds")		// 此将函数返回的bean对象存入spring容器中,其id为ds
    public DataSource createDataSource(){
        try {
            ComboPooledDataSource ds = new ComboPooledDataSource();
            ds.setDriverClass(driver);
            ds.setJdbcUrl(url);
            ds.setUser(username);
            ds.setPassword(password);
            return ds;
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }
}

/*jdbc.properties文件：
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/day44_ee247_spring
jdbc.username=root
jdbc.password=1234*/

//通过注解获取容器
ApplicationContext ac =
        new AnnotationConfigApplicationContext(SpringConfiguration.class);
```

#### Spring整合Junit

```
为啥要整合
1、应用程序的入口
	main方法
2、junit单元测试中，没有main方法也能执行
	junit集成了一个main方法
	该方法就会判断当前测试类中哪些方法有 @Test注解
	junit就让有Test注解的方法执行
3、junit不会管我们是否采用spring框架
	在执行测试方法时，junit根本不知道我们是不是使用了spring框架
	所以也就不会为我们读取配置文件/配置类创建spring核心容器
4、由以上三点可知
	当测试方法执行时，没有Ioc容器，就算写了Autowired注解，也无法实现注入
```

整合思路

```xml
Spring整合junit的配置
    1、导入spring整合junit的jar(坐标)
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>5.0.2.RELEASE</version>
            <scope>test</scope>
        </dependency>
    2、使用Junit提供的一个注解把原有main方法替换了，替换成spring提供的
    	@Runwith
    3、告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置
        @ContextConfiguration
            locations：指定xml文件的位置，加上classpath关键字，表示在类路径下
            classes：指定注解类所在地位置
当我们使用spring 5.x版本的时候，要求junit的jar必须是4.12及以上
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = Springconfiguration.class)
//@ContextConfiguration(locations = "classpath:bean.xml")
public class AccountServiceTest {
    @Autowired
    private AccountServiceImpl accountService=null;
    @Test
    public void testFindALL(){
       System.out.println(accountService.findaAllAccount());
    }
}
```

#### 动态代理

##### 转账事务问题

下图会存在转出减钱而转入不加钱的情况，需要加上事务控制

![1566978000338](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1566978000338.png)

##### 代码冗余现象

Service层实现类中的每个方法都要加上事务控制,这样使得每个方法的前后都要加上重复的事务控制的代码,

```java
@Override
public void saveAccount(Account account) {
	try {
		TransactionManager.beginTransaction();
		accountDao.save(account);		// 唯一的一行业务代码
		TransactionManager.commit();
	} catch (Exception e) {
		TransactionManager.rollback();
		e.printStackTrace();
	}finally {
		TransactionManager.release();
	}
}
@Override
public void updateAccount(Account account) {
	try {
		TransactionManager.beginTransaction();
		accountDao.update(account);		// 唯一的一行业务代码
		TransactionManager.commit();
	} catch (Exception e) {
		TransactionManager.rollback();
		e.printStackTrace();
	}finally {
		TransactionManager.release();
	}
}
```

我们发现出现了两个问题:

```
业务层方法变得臃肿了,里面充斥着很多重复代码.
业务层方法和事务控制方法耦合了. 若提交,回滚,释放资源中任何一个方法名变更,都需要修改业务层的代码.
```

##### 动态代理

```java
/**
* 动态代理：
*  特点：字节码随用随创建，随用随加载
*  作用：不修改源码的基础上对方法增强
*  不同于静态代理：字节码一上来就创建好，并完成加载，如装饰者模式
*  分类：
*      基于接口的动态代理
*      基于子类的动态代理

*  基于接口的动态代理：
*      涉及的类：Proxy
*      提供者：JDK官方
*  如何创建代理对象：
*      使用Proxy类中的newProxyInstance方法
*  创建代理对象的要求：
*      被代理类最少实现一个接口，如果没有则不能使用
*  newProxyInstance方法的参数：
*      ClassLoader：类加载器
*          它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。
*      Class[]：字节码数组
*          它是用于让代理对象和被代理对象有相同方法。固定写法。
*      InvocationHandler：用于提供增强的代码
*          一般都是一个该接口实现类，通常情况下都是匿名内部类，但不是必须的。
*          此接口的实现类都是谁用谁写。

*  基于子类的动态代理：
*      涉及的类：Enhancer
*      提供者：第三方cglib
*  如何创建代理对象：
*      使用Enhancer类中的create方法
*  创建代理对象的要求：
*      被代理类不能是最终类
*  create方法的参数：
*      Class：字节码
*          它是用于指定被代理对象字节码的
*      callback：用于提供增强的代码
*          一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
*          此接口的实现类都是谁用谁写。
*          一般都写该接口的子接口实现类；MethodInterceptor
*/
```

![image-20200309155457605](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200309155457605.png)

**基于接口的动态代理**

```java
public class Client {
    public static void main(String[] args) {
        Producer producer=new Producer();
        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),
                producer.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * 作用：执行被代理对象的任何接口方法都会经过该方法
                     * 方法参数的含义
                     * @param proxy   代理对象的引用
                     * @param method  当前执行的方法
                     * @param args    当前执行方法所需的参数
                     * @return        和被代理对象方法有相同的返回值
                     * @throws Throwable
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        //提供增强的代码
                        Object returnValue = null;
                        //1.获取方法执行的参数
                        Float money = (Float)args[0];
                        //2.判断当前方法是不是销售
                        if("saleProduct".equals(method.getName())) {
                            returnValue = method.invoke(producer, money*0.8f);
                        }
                        if("afterService".equals(method.getName()))
                        {
                            returnValue = method.invoke(producer, money*0.8f);
                        }
                        return returnValue;
                    }
                });
        proxyProducer.saleProduct(10000f);
        proxyProducer.afterService(10000f);
    }
}
```

**基于子类的动态代理**

```java
public class Client {
    public static void main(String[] args) {
        final Producer producer=new Producer();
        Producer cglibProducer= (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() {
            @Override
            //个基于接口的类似
            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                //提供增强的代码
                Object returnValue = null;
                //1.获取方法执行的参数
                Float money = (Float)args[0];
                //2.判断当前方法是不是销售
                if("saleProduct".equals(method.getName())) {
                    returnValue = method.invoke(producer, money*0.8f);
                }
                return returnValue;
            }
        });
        cglibProducer.saleProduct(10000f);
        cglibProducer.afterService(10000f);
    }
}
```

##### 动态代理解决代码冗余

我们使用动态代理对上述Service进行改造,创建`BeanFactory`类作为service层对象工厂,通过其`getAccountService`方法得到业务层对象.需要在bean.xml中注入相关对象。

```java
// 用于创建Service的代理对象的工厂
public class BeanFactory {
	private IAccountService accountService;		// 被增强的service对象
	private TransactionManager txManager;		// 事务控制工具类
	// 成员变量的set方法,以便Spring容器注入
	public void setTxManager(TransactionManager txManager) {
		this.txManager = txManager;
	}
	public final void setAccountService(IAccountService accountService) {
		this.accountService = accountService;
	}

	// 获取增强后的Service对象
	public IAccountService getAccountService() {
		return (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),
			accountService.getClass().getInterfaces(),
			new InvocationHandler() {
				// 增强方法
				@Override
				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
					Object rtValue = null;
					try {
						//1.开启事务
						txManager.beginTransaction();
						//2.执行操作
						rtValue = method.invoke(accountService, args);
						//3.提交事务
						txManager.commit();
						//4.返回结果
						return rtValue;
					} catch (Exception e) {
						//5.回滚操作
						txManager.rollback();
						throw new RuntimeException(e);
					} finally {
						//6.释放连接
						txManager.release();
					}
				}
			});
	}
}
```

####  Spring的AOP细节

AOP概念：简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。

```
作用：在程序运行期间，不修改源码对已有方法进行增强。
优势：减少重复代码，提高开发效率，维护方便
```

我们学习spring的 aop，就是通过配置的方式，实现上一章节的功能。

##### AOP 相关术语

```java
Joinpoint( 连接点):
	被拦截到的方法.所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法
    因为 spring 只支持方法类型连接点。
Pointcut( 切入点):
	我们对其进行增强的方法.所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。
Advice( 通知/ 增强):
	对切入点进行的增强操作，所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。
	通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。
Introduction( 引介):
	引介是一种特殊的通知，在不修改类代码前提下,Introduction可以在运行期为类动态地添加方法或Field。
Target( 目标对象):
	代理的目标对象。
Weaving( 织入):
	是指把增强应用到目标对象来创建新代理对象的过程，spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。
Proxy （代理）:
	一个类被 AOP 织入增强后，就产生一个结果代理类。
Aspect( 切面):
	是切入点和通知（引介）的结合。
```

#####   AOP要明确

```
开发阶段（我们做的）
    编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。
    把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP编程人员来做。
    在配置文件中，声明切入点与通知间的关系，即切面。：AOP编程人员来做。
运行阶段（Spring框架完成的）
	Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。
```

#### 使用XML配置AOP

##### 通知类型和顺序

![1567670280656](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1567670280656.png)

##### bean.xml配置AOP

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!-- 配置srping的Ioc,把service对象配置进来-->
    <bean id="accountService" class="site.syzhou.service.impl.AccountServiceImpl"></bean>
    <!--通知类-->
    <bean id="logger" class="site.syzhou.utils.Logger"></bean>
    <!--spring中基于XML的AOP配置步骤
    1、把通知Bean也交给spring来管理
    2、使用aop:config标签表明开始AOP的配置
    3、使用aop:aspect标签表明配置切面
            id属性：是给切面提供一个唯一标识
            ref属性：是指定通知类bean的Id。
    4、在aop:aspect标签的内部使用对应标签来配置通知的类型
           我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知
           aop:before：表示配置前置通知
                method属性：用于指定Logger类中哪个方法是前置通知
                pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强

        切入点表达式的写法：
            关键字：execution(表达式)
            表达式：
                访问修饰符  返回值  包名.包名.包名...类名.方法名(参数列表)
            标准的表达式写法：
                public void com.itheima.service.impl.AccountServiceImpl.saveAccount()
            访问修饰符可以省略
                void com.itheima.service.impl.AccountServiceImpl.saveAccount()
            返回值可以使用通配符，表示任意返回值
                * com.itheima.service.impl.AccountServiceImpl.saveAccount()
            包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*.
                * *.*.*.*.AccountServiceImpl.saveAccount())
            包名可以使用..表示当前包及其子包
                * *..AccountServiceImpl.saveAccount()
            类名和方法名都可以使用*来实现通配
                * *..*.*()
            参数列表：
                可以直接写数据类型：
                    基本类型直接写名称           int
                    引用类型写包名.类名的方式   java.lang.String
                可以使用通配符表示任意类型，但是必须有参数
                可以使用..表示有无参数均可，有参数可以是任意类型
            全通配写法：
                * *..*.*(..)
            实际开发中切入点表达式的通常写法：
                切到业务层实现类下的所有方法
                    * com.itheima.service.impl.*.*(..)

    5.使用<aop:xxx>标签配置对应类型的通知方法
        其属性如下:
            method: 指定通知类中的增强方法名.
            ponitcut-ref: 指定切入点的表达式的id
            poinitcut: 指定切入点表达式
            其中pointcut-ref和pointref属性只能有其中一个
        具体的通知类型:
            <aop:before>: 配置前置通知,指定的增强方法在切入点方法之前执行.
            <aop:after-returning>: 配置后置通知,指定的增强方法在切入点方法正常执行之后执行.
            <aop:after-throwing>: 配置异常通知,指定的增强方法在切入点方法产生异常后执行.
            <aop:after>: 配置最终通知,无论切入点方法执行时是否发生异常,指定的增强方法都会最后执行.
            <aop:around>: 配置环绕通知,可以在代码中手动控制增强代码的执行时机.
    -->
    <!--配置AOP-->
    <aop:config>
        <!--配置切面-->
        <aop:aspect id="logAdvice" ref="logger">
            <!--配置通知类型，建立通知方法和切入点关联-->
            <aop:before method="beforePrintLog" pointcut="execution(* site.syzhou.service.impl.AccountServiceImpl.*(..))"></aop:before>
            <aop:after-returning method="afterReturningPrintLog" pointcut="execution(* site.syzhou.service.impl.AccountServiceImpl.*(..))"></aop:after-returning>
            <aop:after-throwing method="afterThrowingPrintLog" pointcut="execution(* site.syzhou.service.impl.AccountServiceImpl.*(..))"></aop:after-throwing>
            <aop:after method="afterPrintLog" pointcut-ref="pt1"></aop:after>
            <!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容
                  此标签写在aop:aspect标签内部只能当前切面使用。
                  它还可以写在aop:aspect外面，此时就变成了所有切面可用
              -->
            <aop:pointcut id="pt1" expression="execution(* site.syzhou.service.impl.AccountServiceImpl.*(..))"/>
        </aop:aspect>
    </aop:config>
</beans>
```

##### 环绕通知

```java
/**
* 环绕通知
* 问题：
*      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。
* 分析：
*      通过对比动态代理中环绕通知代码，发现动态代理环绕通知有明确的切入点方法调用，而我们代码中没有。
* 解决：
*      Spring框架为我们提供了一个接口：ProceedingJoinPoint。
            ProceedingJoinPoint对象的getArgs()方法返回被拦截的参数
            ProceedingJoinPoint对象的proceed()方法执行被拦截的方法
*      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。
*
* spring中的环绕通知：
*      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。
*/
public Object aroundPringLog(ProceedingJoinPoint pjp){
    Object rtValue = null;
    try{
        Object[] args = pjp.getArgs();//得到方法执行所需的参数
        System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。前置");
        rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）
        System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。后置");
        return rtValue;
    }catch (Throwable t){
        System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。异常");
        throw new RuntimeException(t);
    }finally {
        System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。最终");
    }
}
```

#### 使用注解配置AOP

半注解配置AOP,需要在`bean,xml`中加入下面语句开启对注解AOP的支持

```xml
<!--spring创建容器要扫描的包-->
<context:component-scan base-package="site.syzhou"></context:component-scan>
<!--spring开启注解AOP支持-->
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
```

##### Logger类中的相关配置

```java
@Component("logger")
@Aspect//声明当前类为通知类,该类定义了一个切面.相当于xml配置中的<aop:aspect>标签
public class Logger {
    @Pointcut("execution(* site.syzhou.service.impl.AccountServiceImpl.*(..))")
    public void pt1(){}
    //@Before("pt1()")
    public void beforePrintLog(){
        System.out.println("前置通知Logger中的beforePrintLog开始记录日志。。。");
    }
    //@AfterReturning("pt1()")
    public void afterReturningPrintLog(){
        System.out.println("后置通知Logger中的afterReturningPrintLog开始记录日志。。。");
    }
//    @AfterThrowing("pt1()")
    public void afterThrowingPrintLog(){
        System.out.println("异常通知Logger中的afterThrowingPrintLog开始记录日志。。。");
    }
//    @After("execution(* site.syzhou.service.impl.AccountServiceImpl.*(..))")
    public void afterPrintLog(){
        System.out.println("最终通知Logger中的afterPrintLog开始记录日志。。。");
    }
    @Around("pt1()")
    public Object aroundPringLog(ProceedingJoinPoint pjp){
        Object rtValue = null;
        try{
            Object[] args = pjp.getArgs();//得到方法执行所需的参数
            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。前置");
            rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）
            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。后置");
            return rtValue;
        }catch (Throwable t){
            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。异常");
            throw new RuntimeException(t);
        }finally {
            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。最终");
        }
    }
}
```

##### 纯注解配置AOP

在Spring配置类前添加`@EnableAspectJAutoProxy`注解,可以使用纯注解方式配置AOP

```java
@Configuration
@ComponentScan(basePackages="cn.maoritian")
@EnableAspectJAutoProxy			// 允许AOP
public class SpringConfiguration {
    // 具体配置
    //...
}
```

##### 使用注解配置AOP的bug

在使用注解配置AOP时,会出现一个bug. 四个通知的调用顺序依次是:`前置通知`,`最终通知`,`后置通知`. 这会导致一些资源在执行`最终通知`时提前被释放掉了,而执行`后置通知`时就会出错.而使用环绕通知就没问题。

#### JdbcTemplate概述

```
它是spring框架中提供一个对象,对原始Jdbc API对象简单封装。spring框架为我们提供了很多操作模板类。
    操作关系型数据的：
        JdbcTemplate
        HibernateTemplate
    操作 nosql 数据库的：
        RedisTemplate
    操作消息队列的：
        JmsTemplate
```

##### 导坐标

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-tx</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

##### 配置数据源

**配置C3P0数据源**

```xml
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
    <property name="jdbcUrl" value="jdbc:mysql:///spring_day02"></property>
    <property name="user" value="root"></property>
    <property name="password" value="1234"></property>
</bean
```

 **配置 DBCP 数据源**

```xml
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
    <property name="url" value="jdbc:mysql:// /spring_day02"></property>
    <property name="username" value="root"></property>
    <property name="password" value="1234"></property>
</bean>
```

  **配置spring 内置数据源**，导spring-jdbc

```xml
<bean  id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
    <property name="url" value="jdbc:mysql:///spring_day02"></property>
    <property name="username" value="root"></property>
    <property name="password" value="1234"></property>
</bean>
```

##### 引入jdbc.properties

```xml
【定义属性文件jdbc.properties】
jdbc.driverClass=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql:///spring_day02
jdbc.username=root
jdbc.password=123
【引入外部的属性文件】
一种方式:
<!-- 引入外部属性文件： -->
<bean
class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
<property name="location" value="classpath:jdbc.properties"/>
</bean>
另一种方式:
<context:property-placeholder location="classpath:jdbc.properties"/>
```

##### 配置JdbcTemplate

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="accountService" class="site.newvalue.service.impl.AccountServiceImpl"></bean>
    <bean class="site.newvalue.dao.impl.AccountDaoImpl" id="accountDao"></bean>
    <!-- 配置一个数据库的操作模板：JdbcTemplate -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
    <!-- 配置数据源 -->
    <bean  id="dataSource"
           class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql:///spring"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>
</beans>
```

##### 基本使用

```java
@Test
public void testJDBC(){
    //1.获取 Spring 容器
    ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
    //2.根据 id 获取 bean 对象
    JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate");
    //3.执行操作
    jt.execute("insert into account(name,money)values('eee',500)");
}
```

#### Spring中事务控制

```
org.springframework.jdbc.datasource.DataSourceTransactionManager使用 SpringJDBC或iBatis进行持久化数据时使用
org.springframework.orm.hibernate5.HibernateTransactionManager 使用Hibernate版本进行持久化数据时使用
```

第一步： 配置事务管理器

```xml
<!-- 配置一个事务管理器 -->
<bean  id="transactionManager"
class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <!-- 注入 DataSource -->
    <property name="dataSource" ref="dataSource"></property>
</bean>
```

第二步：配置事务的通知引用事务管理器

```xml
<!-- 事务的配置 -->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
</tx:advice>
```

第三步：配置事务的属性

```xml
<!--在tx:advice标签内部  配置事务的属性 -->
<tx:attributes>
<!-- 指定方法名称：是业务核心方法
read-only：是否是只读事务。默认 false，不只读。
isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。
propagation：指定事务的传播行为。
timeout：指定超时时间。默认值为：-1。永不超时。
rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。
没有默认值，任何异常都回滚。
no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回
滚。没有默认值，任何异常都回滚。
-->
<tx:method name="*" read-only="false" propagation="REQUIRED"/>
<tx:method name="find*" read-only="true" propagation="SUPPORTS"/>
</tx:attributes>
```

第四步：配置 AOP 切入点表达式

```xml
<!-- 配置 aop -->
<aop:config>
<!-- 配置切入点表达式 -->
<aop:pointcut  expression="execution(*  com.itheima.service.impl.*.*(..))"
id="pt1"/>
</aop:config>
```

第五步：配置切入点表达式和事务通知的对应关系

```xml
<!-- 在 aop:config  标签内部：建立事务的通知和切入点表达式的关系 -->
<aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/>
```

##### 基于注解的事务配置

在业务层使用@Transactional  注解

```java
@Service("accountService")
@Transactional(readOnly=true,propagation=Propagation.SUPPORTS)
public class AccountServiceImpl implements IAccountService {
    @Autowired
    private IAccountDao accountDao;
    @Override
    public Account findAccountById(Integer id) {
        return accountDao.findAccountById(id);
    }
    @Override
    @Transactional(readOnly=false,propagation=Propagation.REQUIRED)
    public void transfer(String sourceName, String targeName, Float money) {
		//1.根据名称查询两个账户
        Account source = accountDao.findAccountByName(sourceName);
        Account target = accountDao.findAccountByName(targeName);
		//2.修改两个账户的金额
        source.setMoney(source.getMoney()-money);//转出账户减钱
        target.setMoney(target.getMoney()+money);//转入账户加钱
		//3.更新两个账户
        accountDao.updateAccount(source);
		//int i=1/0;
        accountDao.updateAccount(target);
    }
}
该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。
    出现接口上，表示该接口的所有实现类都有事务支持。
    出现在类上，表示类中所有方法有事务支持
    出现在方法上，表示方法有事务支持。
    以上三个位置的优先级：方法>类>接口
```

配置事务支持

```xml
<!-- 配置事务管理器 -->
<bean  id="transactionManager"
class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
<property name="dataSource" ref="dataSource"></property>
</bean>
<!-- 开启 spring 对注解事务的支持 -->
<tx:annotation-driven transaction-manager="transactionManager"/>
```

##### 纯注解配置事务

```java
@Configuration
@EnableTransactionManagement
public class SpringTxConfiguration {
//里面配置数据源，配置 JdbcTemplate,配置事务管理器。在之前的步骤已经写过了。
}
```

#### Spring5新特性

##### 与JDK相关升级

```
spring5.0 在 2017 年 9 月发布了它的 GA（通用）版本。
该版本是基于 jdk8 编写的，所以 jdk8 以下版本将无法使用。同时，可以兼容 jdk9 版本。
tomcat 版本要求 8.5 及以上
```

第一：基于 JDK8 的反射增强

![image-20200309165532673](https://cdn.jsdelivr.net/gh/siyuanzhou/pic@master/pic/2018-07-06-Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200309165532673.png)

第二：@NonNull 注解和@Nullable 注解的使用
用 @Nullable 和 @NotNull 注解来显示表明可为空的参数和以及返回值。这样就够在编译的时候处理空值而不是在运行时抛出NullPointerExceptions。

第三：日志记录方面
Spring Framework 5.0 带来了 Commons Logging 桥接模块的封装, 它被叫做 spring-jcl 而不是标准的 Commons Logging。当然，无需任何额外的桥接，新版本也会对 Log4j 2.x, SLF4J, JUL( java.util.logging) 进行自动检测。

##### 核心容器的更新

```
Spring Framework 5.0 现在支持候选组件索引作为类路径扫描的替代方案。该功能已经在类路径扫描器中
添加，以简化添加候选组件标识的步骤。
应用程序构建任务可以定义当前项目自己的 META-INF/spring.components 文件。在编译时，源模型是
自包含的，JPA 实体和 Spring 组件是已被标记的。
从索引读取实体而不是扫描类路径对于小于 200 个类的小型项目是没有明显差异。但对大型项目影响较大。
加载组件索引开销更低。因此，随着类数的增加，索引读取的启动时间将保持不变。
加载组件索引的耗费是廉价的。因此当类的数量不断增长，加上构建索引的启动时间仍然可以维持一个常数,
不过对于组件扫描而言，启动时间则会有明显的增长。
这个对于我们处于大型 Spring 项目的开发者所意味着的，是应用程序的启动时间将被大大缩减。虽然 20
或者 30 秒钟看似没什么，但如果每天要这样登上好几百次，加起来就够你受的了。使用了组件索引的话，就能帮
助你每天过的更加高效
```

##### JetBrains Kotlin  语言支持

Kolin概述：是一种支持函数式编程编程风格的面向对象语言。Kotlin 运行在 JVM 之上，但运行环境并不
限于 JVM。

```java
Kolin 的示例代码：
{
    ("/movie" and accept(TEXT_HTML)).nest {
        GET("/", movieHandler::findAllView)
        GET("/{card}", movieHandler::findOneView)
	}
    ("/api/movie" and accept(APPLICATION_JSON)).nest {
        GET("/", movieApiHandler::findAll)
        GET("/{id}", movieApiHandler::findOne)
	}
}
Kolin 注册 bean 对象到 spring 容器：
val context = GenericApplicationContext {
registerBean()
registerBean { Cinema(it.getBean()) }
}
```

##### 响应式编程风格

##### Junit5  支持

##### 依赖类库的更新

```java
终止支持的类库
    Portlet.
    Velocity.
    JasperReports.
    XMLBeans.
    JDO.
    Guava.
支持的类库
    Jackson 2.6+
    EhCache 2.10+ / 3.0 GA
    Hibernate 5.0+
    JDBC 4.0+
    XmlUnit 2.x+
    OkHttp 3.x+
    Netty 4.1+
```

