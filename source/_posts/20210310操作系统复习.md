---
layout: post
title: "操作系统复习"
date: 2021-03-10 10:36
toc: true
comments: true
categories: 技术学习
tags:
	- 基础
	- 复习 
---

### 操作系统

<!--more-->

##### 大端和小端序

如果数据都是单字节，怎么存储无所谓，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。

Big-endian（大端序）：数据的高位字节存放在地址的低端 低位字节存放在地址高端

Little-endian（小端序）：数据的高位字节存放在地址的高端 低位字节存放在地址低端

if(((char*)&a)[3] ==1) 则为大端序，由于a是int，所以占四个字节，其值是00000001，存储方式如下。所以a[3]是0，不是大端序。一个更标准的写法是将a[3]替换为a[sizeof(int) - 1]。

#### CPU调度

![image-20210308095803977](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414114329.png)

#### 内存管理方式（页式、段式、段页式）

##### **页式**

为了便于在内存中找到进程的每个页面所对应的物理块，系统为**每个进程建立一张页表**，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见页表作用是实现从页号到物理块号的地址映射，这种是 页存储管理方式。

![image-20210308100029250](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414114330.png)

##### 段式

将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配，这种是 段存储管理方式。

![image-20210308100112242](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414114331.png)

##### 段页存储

作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位，这种是 段页存储管理方式。

![image-20210308100147792](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414114332.png)

#### 页面置换算法

缺页中断：缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。
页面置换算法：在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用**来选择淘汰哪一页**的规则叫做页面置换算法。



#### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为**孤儿进程**。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。



#### 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait () 或 waitpid () 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait () 或 waitpid ()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为**僵尸进程**。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

#### 原码，反码和补码

##### 原码

- 原码就是符号位加上所要表达值得绝对值，即用第一位表示符号，其他位表示值，比如在8位二进制中：

  [+1]~原~=0000 0001

  [-1]~原~=1000 0001

- 所以可以得到8位二进制得取值范围是[1111 1111] - [0111 1111]即-127到127

##### 反码

- 正数的反码是自己，负数的反码是在其原码基础上，符号位不变，其他位取反，例如：

  [0000 0001]=[+1]~原~=[+1]~反~

  [-1]~原~=1000 0001 ，[-1]~反~=1111 1110

##### 补码

- 正数的补码就是自己，负数的补码是反码加1

  [0000 0001]=[+1]~原~=[+1]~反~=[+1]~补~

  [-1]~原~=1000 0001 ，[-1]~反~=1111 1110 ，[-1]~补~= 1111 1111

##### 为什么使用原码，反码和补码

- 以原码为例，当涉及到减法时，计算机会将其转换为加法，以1-1为例

  1 - 1 = 1 + (-1) = [00000001]~原~ + [10000001]~原~ = [10000010]~原~ = -2

- 补码可以解决这个问题，统一加法和减法

  1-1 = 1 + (-1) =[0000 0001]~补~ + [1111 1111]~补~ = [0000 0000]~补~=[0000 0000]~原~