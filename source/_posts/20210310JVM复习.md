---
layout: post
title: "JVM复习"
date: 2021-03-10 10:36
toc: true
comments: true
categories: 技术学习
tags:
	- 基础
	- 复习 
---

### JVM

![image-20210308100929752](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105244.png)

<!--more-->

#### JMM 内存模型

JMM (Java Memory Model)是 Java 内存模型,JMM 定义了程序中各个**共享变量的访问规则**,即在虚拟机中将变量存储到内存和从内存读取变量这样的底层细节.并提供了内置解决方案（happen-before 原则）及其外部可使用的同步手段(synchronized/volatile 等)，确保了程序执行在多线程环境中的应有的 **原子性，可视性及其有序性**。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105245.png)

JMM 规定了所有的变量都存储在主内存 规定了所有的变量都存储在主内存（ （Main Memory） ） 中 。 每个线程还有自己的工作内存（ 己的工作内存（Working Memory ）,线程的工作内存中保存了该线程使用到的变量的 线程的工作内存中保存了该线程使用到的变量的**主内存的副本拷贝**，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行 ， 而不能直接读写主内存中的变量（ （volatile 变量仍然有工作内存的拷贝 变量仍然有工作内存的拷贝 ， 但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，**线程之间值的传递都需要通过主内存**来完成.

##### JMM 的 happens-before 原则

![image-20210307211631353](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105246.png)

##### 为什么要实现内存模型

![image-20210307211402249](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105247.png)

#### 内存分区

![image-20210307211804692](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105248.png)

![image-20210307211854961](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105249.png)

##### 什么是堆中的永久代

答： 永久代是用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类，永久代中一般包含：

```
类的方法(字节码...)
类名(Sring 对象)
.class 文件读到的常量信息
class 对象相关的对象列表和类型列表 (e.g., 方法对象的 array).
JVM 创建的内部对象
JIT 编译器优化用的信息
```

##### 对象初始化过程 newA()

Student s = new Student() 为例
1.首先查看类的符号引用，看是否已经在常量池中，在说明已经加载过了，不在的话需要进行类的加载，验证，准备，解析，初始化的过程。
2.上诉过程执行完毕以后，又将 Student 加载进内存，也就是存储 Student.class的字段信息和方法信息，存储到方法区中
字段信息：存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。
方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。
3。然后在自己的线程私有的虚拟机栈中，存储该引用，然后在每个线程的私有空间里面去分配空间存储 new Student(),如果空间不足在 eden 区域进行分配空间
4，对类中的成员变量进行默认初始化
5，对类中的成员变量进行显示初始化
6，有构造代码块就先执行构造代码块，如果没有，则省略(此步上文未体现)
7，执行构造方法，通过构造方法对对对象数据进行初始化
8，堆内存中的数据初始化完毕，把内存值复制给 s 变量

##### 并发下对象分配内存时线程安全

例如同时创建对象A和B，在给A分配内存时，指针还未来得及移动的情况下，B又在原来的基础上分配内存,两种解决方案：

1. 虚拟机采取**CAS操作**配上失败重试来保证更新操作的原子性
2. 每个线程在java堆中分配一小块区域，称为**本地线程分配缓冲**(TLAB)，哪个线程要分配内存时，就在自己的TLAB上分配。

##### 对象的内存布局

- 在HotSpot虚拟机中，对象的内存布局可以分为：**对象头**，**实例数据**，**对齐填充**
- **对象头**包括两部分的信息：
  1. 存储对象自身运行时数据，如哈希码，**GC分代年龄**，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等
  2. **类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例
- **实例数据**是对象真正存储的有效信息，也是在程序段中所定义的各种类型字段(包括父类的)。

##### 对象的访问定位

通过栈上的reference数据来操作堆上的对象有两种访问方式：

1. **句柄**。java堆中专门划分出一个句柄池，reference存储的是句柄的地址，而句柄包含了对象实例数据和类型数据各自的具体地址信息。

   优点：对象移动时，只需要修改句柄中的指针即可，reference不需要修改

   ![image-20200423105805390.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105250.png)

2. **直接指针**。reference直接存储对象地址

   优点：节省了一次地址定位的时间

   ![image-20200423105905341.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105251.png)

##### java堆内存溢出

```java
/**
     * VM:-verbose:gc
     * -Xms20M
     * -Xmx20M
     * -Xmn10M
     * -XX:+PrintGCDetails
     * -XX:SurvivorRatio=8
     */
static class OOMObject{

}
public static void main(String[] args) {
    List<OOMObject> list=new ArrayList<>();
    while (true){
        list.add(new OOMObject());
    }
}
```

通过设置参数：`-XX:+HeapDumpOnOutOfMemoryError`可以在虚拟机出现内存溢出时Dump出当前的内存堆转储快照。

然后用内存映像分析工具(VisualVM)对Dump出的堆转储快照进行分析，重点是确认内存中的对象是否有必要存在，即判断是发生了**内存泄漏**还是**内存溢出**。

- 如果是**内存泄漏**，可进一步查看泄漏对象到GC Roots的引用链，就可以找到泄漏对象是怎么和GC Roots相连的导致垃圾回收器无法自动回收它们。
- 如果**内存溢出**,那就应当检查虚拟机的堆参数，能不能调大一点。

##### 对象的强、软、弱和虚引用

强引用>软引用>弱引用>虚引用

- **强引用**。类似Object obj=new Object()这类的引用，只要强引用在，垃圾回收器就无法回收掉引用的对象。

- **软引用**。被软引用关联的对象只有在**内存不够**的情况下才会被回收，通常用在对内存敏感的程序中。

  ```
  SoftReference<Object> sf=new SoftReference<>(new Object());
  ```

- **弱引用**。被弱引用关联的对象只能活到**下次垃圾收集发生之前**。当垃圾收集器工作时，弱引用关联的对象总会被回收

  ```
  WeakReference<Object> wf=new WeakReference<>(new Object());
  ```

- **虚引用**。虚引用对对象的生存时间不会构成影响，也无法通过虚引用来获取对象实例。

  ```
  ReferenceQueue<Object> rq=new ReferenceQueue<>();   //引用队列
  PhantomReference<Object> pr=new PhantomReference<>(new Object(),rq);
  System.out.println(pr.get());  //null
  System.out.println(rq.poll()); //null
  ```

##### 如何减少 GC 的次数

```
1.对象不用时最好显示置为 NULL
一般而言，为 NULL 的对象都会被作为垃圾处理，所以将不用的对象置为NULL，有利于 GC 收集器判定垃圾，从而提高了 GC 的效率。
2.尽量少使用 System,gc()
此函数建议 JVM 进行主 GC，会增加主 GC 的频率，增加了间接性停顿的次数。
3.尽量少使用静态变量
静态变量属于全局变量，不会被 GC 回收，他们会一直占用内存
4.尽量使用 StringBuffer,而不使用 String 来累加字符串
5.分散对象创建或删除的时间
集中在短时间内大量创建新对象，特别是大对象，会导致突然需要大量内存，JVM 在这种情况下只能进行主 GC 以回收内存，从而增加主 GC 的频率。
6.尽量少用 finaliza 函数,会加大 GC 的工作量。
7.如果有需要使用经常用到的图片，可以使用软引用类型，将图片保存在内存中，而不引起 outofmemory
8.能用基本类型入 INT 就不用对象 Integer
9.增大-Xmx 的值
```

#### GC  算法（YGC and  FGC）

![image-20210308101949605](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105252.png)

##### 判断一个对象是否存活?(GC 对象判定方法)

引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）的情况
引用链法(可达性分析法）： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，如果有一条链能够到达 GC ROOT 就说明，不能到达 GC ROOT 就说明

![image-20210307212135054](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105253.png)

![image-20210307213754774](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105254.png)

##### Minor GC 和 Full GC

* Minor GC：回收新生代，复制算法，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
* Full GC / Major GC：回收老生代和新生代，标记清除整理算法，老生代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。出现了 Full GC，经常会伴随至少一次 Minor GC。

![image-20210308101949605](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105252.png)

堆里面分为新生代和老生代（java8 取消了永久代 Perm Space，采用了 Metaspace,字符串常量存放到堆内存中），新生代包含 **Eden+Survivor 区**，1 部分 Eden 区较大，1 部分 Survivor 比较小,survivor 区里面分为 from 和 to 区，**8:1:1**,内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后(年龄阈值15，可以通过-XX:MaxTenuringThreshold 来设置)，存活下来的对象会被移动到老年区，当 **JVM 内存不够**用的时候，会触发 Full GC，清理 JVM 老年区。
当**新生区满了**之后会触发 YGC,先把存活的对象放到其中一个 Survice区，然后进行垃圾清理。一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。

FGC 就是标记整理或者是标记清除算法来清除老年代。

##### 内存分配与回收策略

**对象优先在Eden区分配**

* 大多数情况下，对象在新生代的 Eden 区上分配，**当 Eden 空间不够时，发起 Minor GC**
* 若启动了本地线程分配缓冲，则将按线程优先在 TLAB （本地线程分配缓冲）上分配

**大对象直接进入老生代**

* 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组

* 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象

* -XX:PretenureSizeThreshold，大于此值的对象直接在老生代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

  该参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge收集器一般并不需要设置，若遇到必须使用该参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。

**长期存活的对象进入老年代**

* 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄（默认 15）则移动到老生代中。
* -XX:MaxTenuringThreshold 用来定义年龄的阈值。

**动态对象年龄判定**

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老生代，如果在 Survivor 中**相同年龄所有对象大小的总和大于 Survivor 空间的一半**，则年龄大于或等于该年龄的对象可以直接进入老生代，无需等到 MaxTenuringThreshold 中要求的年龄。

**空间分配担保**

在进行 Minorgc前，虚拟机会查看 Handle Promotion Failure设置值是否为True，那么说明允许担保失败（会检查虚拟机老年代剩余空间的大小与平均晋升到老年代空间的大小，如果大于说明“可能"是安全的），为True那么进行一次 Minora，如果此时刻发现进入到老年代的新对象的大小是大于老年代的剩余空间，说明担保失败了，只能进行一次Fu|GC清除老年代的剩余空间。

**JDK 6 Update 24 之后不再使用 HandlePromotionFailure  参数**，规则变为只要**老生代的连续空间大于新生代对象总大小或者历次晋升的平均大小**就会进行Minor GC，否则将进行Full GC。

**实例：**

1. 内存大小设定

```java
// 限制堆大小为 20M，不可扩展，10M 分配给新生代、10M 分配给老生代
-Xms20M -Xmx20M -Xmn10M
// 决定新生代中 Eden：Survivor = 8：1
-XX:SurvivorRatio=8
```

2. 内存分配

```java
byte[] allocation1，allocation2，allocation3，allocation4;
allocation1=new byte[2*_1MB];
allocation2=new byte[2*_1MB];
allocation3=new byte[2*_1MB];
allocation4=new byte[4*_1MB]; // 出现一次Minor GC
```

​	分配 allocation4 对象的语句时会发生一次 Minor GC，这次 GC 的结果是新生代 6651KB 变为 148KB，而总内存占用量则几乎没有减少（因为 allocation1、allocation2、allocation3 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。

​	这次 GC 发生的原因是给 allocation4 分配内存的时候，发现 Eden 已经被占用了 6MB，剩余空间已不足以分配 allocation4 所需的 4MB 内存，因此发生 Minor GC。GC 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 Survivor 空间（ Survivor 空间只有 1MB 大小），所以**只好通过分配担保机制提前转移到老生代去。**

3. 结果

​	Eden 占用 4 MB（被 allocation4 占用），Survivor 空闲，老生代被占用 6MB（被allocation1、 allocation2、allocation3 占用）。

##### Full GC 触发条件

对于 Minor GC，其触发条件非常简单，**当 Eden 空间满时，就将触发一次 Minor GC**。而 Full GC 则相对复杂，有以下条件：

**调用 System.gc()**

只是**建议虚拟机执行 Full GC**，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

**老生代空间不足**

老生代空间不足的常见场景为前文所讲的大对象直接进入老生代、长期存活的对象进入老生代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老生代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老生代的年龄，让对象在新生代多存活一段时间。

**空间分配担保失败**

使用复制算法的 Minor GC 需要老生代的内存空间作担保，如果担保失败会执行一次 Full GC。

**JDK 1.7 及以前的永久代空间不足**

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 信息、Meta 信息、常量、静态变量等数据。GC 不会在主程序运行期对永久代区域进行清理。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

**Concurrent Mode Failure**

执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

#### 垃圾收集器  

![1553654058045.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105255.png)

**串行、并行与并发**

* 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
* 串行：**串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；**
* 并行：多条垃圾收集线程并行工作，但**此时用户线程仍处于等待状态**；
* 并发：**用户线程与垃圾收集线程同时执行**（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上。
* 除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

##### Serial收集器

![image-20210307212331377](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105256.png)

##### ParNew收集器

- ParNew收集器是Serial收集器的多线程版本，使用多条线程进行垃圾收集，新生代使用**复制**算法。
- 默认开启线程数与 CPU 的数量相同
- 它是 **Server** 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

![image-20200424094451166.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105257.png)

##### Parallel Scavenge收集器

与 ParNew 一样是并行多线程收集器，使用**复制**算法，新生代使用。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是**达到一个可控制的吞吐量**，因此它被称为 “**吞吐量优先**” 收集器。这里的**吞吐量指 CPU 用于运行用户程序的时间占总时间的比值**。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，**适合在后台运算而不需要太多交互的任务**。

提供了精确控制吞吐量的参数：

```java
-XX:MaxGCPauseMills		// 控制最大垃圾收集停顿时间
-XX:GCTimeRatio			// 垃圾收集时间占总时间的比率，即吞吐量的倒数，例如19，则表示垃圾收集时间							   占比为1/(1+19)=5%
```

* 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打开 **GC 自适应的调节策略（GC Ergonomics）**，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老生代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

```java
-XX:+UseAdaptiveSizePolicy  // 开关参数
```

##### Serial Old 收集器

![1557456534404.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105258.png)

是 **Serial 收集器的老生代版本**，同样是一个**单线程**收集器（无法充分利用服务器多 CPU 的处理能力），使用 **”标记 - 整理“** 算法。该收集器主要是给 **Client** 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

* 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
* 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

##### Parallel Old收集器

![1557471744502.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105259.png)

JDK 1.6 中开始提供，是 Parallel Scavenge 收集器的老生代版本，使用**多线程**和 **”标记 - 整理“** 算法。

在JDK1.6之前，新生代使用 ParallelScavenge 收集器只能搭配老生代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了**在老生代同样提供吞吐量优先**的垃圾收集器，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

##### CMS收集器

![1557471755660.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105300.png)

CMS（Concurrent Mark Sweep）是一种以**获取最短回收停顿时间**为目标的收集器，Mark Sweep 指的是**标记 - 清除**算法。

分为以下四个流程：

* **初始标记：**仅仅只是**标记一下 GC Roots 能直接关联到的对象**，速度很快，**需要停顿**。

* **并发标记：**进行 **GC Roots Tracing** 的过程，它在整个回收过程中耗时最长，**不需要停顿**。

* **重新标记：**为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，**需要停顿**，时间长于初始标记、短于并发标记。

* **并发清除：****不需要停顿**。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

**缺点：**

* **吞吐量低**：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。

* **无法处理浮动垃圾，可能出现 Concurrent Mode Failure。**浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老生代快满的时候再回收。**如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure**，这时虚拟机将临时启用 **Serial Old** 来替代 CMS。

* **标记 - 清除**算法导致的空间碎片，往往出现老生代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

  可使用 ` -XX：+UseCMSCompactAtFullCollection` 参数（默认开启）在需要进行 Full GC 时开启内存碎片合并整理过程，该过程无法并发，导致停顿时间变长。

  可使用 `-XX：CMSFullGCsBeforeCompaction` 参数设置执行多少次不压缩的 Full GC 后进行带压缩的 Full GC（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。

##### G1收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

* 适用于**追求低停顿情况**，不适用于追求吞吐量的情况

1. G1收集器的特点：

   1. 并行与并发
   2. 分代收集
   3. 空间整合
   4. 可预测的停顿
2. G1收集器化整为零的思路，每个region都有一个Remembered Set区域
3. 一共有四个步骤：

   1. 初始标记（停止用户线程）
   2. 并发标记（时间较长，但是可以可用户并发进行）
   3. 最终标记（停止用户线程）
   4. 筛选回收（停止用户线程）

堆被分为新生代和老生代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和老生代一起回收。

![4cf711a8-7ab2-4152-b85c-d5c226733807.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105301.png)

**G1 把堆划分成多个大小相等的独立区域**（Region），区大小为 2 的幂，范围为 1M 到 32M，目标是根据最小的 Java 堆大小划分出约 2048 个区域。

新生代和老生代不再物理隔离，仅保留逻辑上的分代概念，每个分区都可能随着 G1 的运行在不同代之间前后切换。

![9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105302.png)

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收，**避免全内存扫描**。这种划分方法带来了很大的灵活性，使得**可预测的停顿时间模型**（软目标）成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个**优先列表**，每次根据允许的收集时间，**优先回收价值最大的 Region**，有计划地避免在整个 Java 堆中进行全区域的垃圾收集，确保在有限时间内获得最高的垃圾收集效率。

每个 Region 都有一个 **Remembered Set**，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![1557474325452.png](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105303.png)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

* 初始标记：

  标记 GC Roots 能直接关联到的对象并修改 TAMS（Next Top at Mark Set）的值，使下一阶段用户程序并发运行时能在正确可用的 Region 中创建新对象。需要停顿，但耗时很短。

* 并发标记：

  从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象。耗时较长，但可以与用户程序并发执行。

* 最终标记：

  为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要**停顿线程**，但是可并行执行。

* 筛选回收：

  首先，对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

**特点：**

* **并行与并发**：利用多个 CPU 缩短停顿时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作， G1 收集器仍然可以通过并发的方式使 Java 程序继续执行。
* **分代收集**：分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。
* **空间整合**：整体来看是基于 **“标记 - 整理”** 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 **“复制”** 算法实现的，这意味着运行期间不会产生内存空间碎片。
* **可预测的停顿**：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

##### CMS 与 G1 整体区别

- 两者都追求最短停顿时间，无法兼顾吞吐量

- **CMS 使用标记清除算法**实现，会导致空间碎片，提前触发 GC 

  **G1 使用标记整理算法**，不会导致空间碎片

- G1 中分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。

  **CMS 针对理整个老年代进行处理。G1可以回收新生代和老年代**

##### **总结**

|      收集器       |                      定义                      |                             特点                             |             垃圾算法              |                          应用场景                          |                   备注                   |
| :---------------: | :--------------------------------------------: | :----------------------------------------------------------: | :-------------------------------: | :--------------------------------------------------------: | :--------------------------------------: |
|      Serial       |        最基本、发展历史最长的垃圾收集器        |                      并发、单线程、高效                      |               复制                |              客户端模式下，虚拟机的新生代区域              |                                          |
|    Serial Old     |      Serial 收集器应用在老年代区域的版本       |                      并发、单线程、高效                      |            标记 - 整理            |              客户端模式下，虚拟机的老生代区域              |        CMS 的后备预案，失败时使用        |
|      ParNew       |           Serial 收集器的多线程版本            |                并发、多线程、性能低于 Serial                 |               复制                |              客户端模式下，虚拟机的新生代区域              |       唯一可配合 CMS 工作的收集器        |
| Parallel Scavenge |             ParNew 收集器的升级版              |      并发、多线程、自适应调节，以达到可控制吞吐量为目标      |               复制                |              服务器模式下，虚拟机的新生代区域              |                                          |
|   Parallel Old    | Parallel Scavenge 收集器应用在老年代区域的版本 |      并发、多线程、自适应调节，以达到可控制吞吐量为目标      |            标记 - 整理            |              服务器模式下，虚拟机的老生代区域              |                                          |
|        CMS        |        基于**标记 - 清除**算法的收集器         | 并行、单线程、垃圾收集停顿时间短，总吞吐量低，无法处理浮动垃圾，产生空间碎片 |            标记 - 清除            | 重视应用的响应速度、希望系统停顿时间最短的场景（如老年代） | 初始标记、并发标记、重新标记、并发清除、 |
|        G1         |            最新、技术最前沿的收集器            | 并行、多线程、垃圾回收效率高（可预测的停顿时间模型），分代收集、无空间碎片 | 新生代：复制、老生代：标记 - 整理 |        服务器端虚拟机的内存区域（含新生代与老生代）        | 初始标记、并发标记、最终标记、筛选回收、 |

##### 组合选择

* **单 CPU 或小内存，单机程序：**

  **-XX:+UseSerialGC：**新生代 Serial + 复制，老生代 SerialOld + 标记整理

* **多 CPU，需要最大吞吐量，如后台计算型应用：**

  **-XX:+UseParallelGC：**新生代 Parallel + 复制，老生代 ParallelOld + 标记整理

  **-XX:+UseParallelOldGC：**同上

* **多 CPU，追求低停顿时间，需要快速响应如互联网应用**

  **-XX:+UseConcMarkSweepGC：**新生代 ParNew + 复制，老生代 CMS +SerialOld 的收集器组合 + 标记清除

  **-XX:+UseG1GC：**整体采用标记整理，局部使用复制，不会产生碎片

####  Java 类加载机制 

##### Class文件字节码结构组织示意图

```
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类会可以有个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

![类文件字节码结构组织示意图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105304.png)

##### 类加载过程

![image-20210307214358957](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105305.png)

```
加载
    1. 通过一个类的全限名来获取定义此类的二进制节流。（实现这个代码模块就是类加载器）
    2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    3. 在内存中生成一个代表这个类的 java.lang.Class 对象,作为方法区这个类的各种数据的访问入口。
验证
    文件格式验证
    – [x] 是否以魔数 0xCAFEBABE 开头
    – [x] 主次版本号是否在当前虚拟机处理范围之内
    – [x] 常量池中的常量是否有不被支持的常量类型
    – [x] 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
    – [x] CONSTANTUtf8info 型的常量中是否有不符合 UTF8 编码的数据
    – [x] Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息
    – [x] 等等
    元数据验证
    – [x] 这个类是否有父类
    – [x] 这个类的父类是否继承了不准许被继承的类
    – [x] 如果这个类不是抽象类,是否实现了其父类或者接口之中要求实现的所有方法
    – [x] 类中的字段方法是否与父类产生矛盾
    –
    字节码验证
    – [x] 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
    – [x] 保证跳转指令不会跳转到方法体以外的字节码指令上
    – [x] 保证方法体重的类型转换是有效的
    符号引用验证
    – [x] 符号引用中通过字符串描述的全限定名是否找到相应的类
    – [x] 在指定的类中是否存在符合方法的字段描述符以及简单名称说描述的方法和字段
    – [x] 符号引用中的类、字段、方法的访问性是否被当前类访问
准备
    准备阶段是正式为类变量分配内存并设置类变量初始值(被static修饰的变量)的阶段,这些变
    量所使用的内存都将在方法区中进行分配
解析
	解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程
初始化
	初始化就是执行类构造器方法的过程
```

##### 双亲委派机制

**避免重复加载 + 避免核心类篡改**

![image-20210307214738509](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105306.png)

![image-20210307214648663](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105307.png)

#### 内存泄漏

![image-20210307214840464](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105308.png)

##### jstat jmap jps jinfo jconsole查看内存

![image-20210308100816201](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105309.png)

![image-20210307215245377](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105310.png)

##### 参数设置

```
-Xmx3550m：设置 JVM 最大堆内存为 3550M。
-Xms3550m：设置 JVM 初始堆内存为 3550M。此值可以设置与-Xmx 相同，以避免每次垃
圾回收完成后 JVM 重新分配内存。
-Xss128k：设置每个线程的栈大小。JDK5.0 以后每个线程栈大小为 1M，之前每个线程栈
大小为 256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个
值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，
经验值在 3000~5000 左右。需要注意的是：当这个值被设置的较大（例如>2MB）时将会
在很大程度上降低系统的性能。
-Xmn2g：设置年轻代大小为 2G。在整个堆内存大小确定的情况下，增大年轻代将会减小
年老代，反之亦然。此值关系到 JVM 垃圾回收，对系统性能影响较大，官方推荐配置为整
个堆大小的 3/8。
-XX:NewSize=1024m：设置年轻代初始值为 1024M。
-XX:MaxNewSize=1024m：设置年轻代最大值为 1024M。
-XX:PermSize=256m：设置持久代初始值为 256M。
-XX:MaxPermSize=256m：设置持久代最大值为 256M。
-XX:NewRatio=4：设置年轻代（包括 1 个 Eden 和 2 个 Survivor 区）与年老代的比值。表
示年轻代比年老代为 1:4。
-XX:SurvivorRatio=4：设置年轻代中 Eden 区与 Survivor 区的比值。表示 2 个 Survivor 区
（JVM 堆内存年轻代中默认有 2 个大小相等的 Survivor 区）与 1 个 Eden 区的比值为 2:4，
即 1 个 Survivor 区占整个年轻代大小的 1/6。
-XX:MaxTenuringThreshold=7：表示一个对象如果在 Survivor 区（救助空间）移动了 7 次
还没有被垃圾回收就进入年老代。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，
直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为
一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象在年轻代存
活时间，增加对象在年轻代被垃圾回收的概率，减少 Full GC 的频率，这样做可以在某种程
度上提高服务稳定性。
-XX:PretenureSizeThreshold 直接晋升到老年代的对象大小，设置这个参数后，大于这个参
数的对象将直接在老年代分配。
-XX：MaxTenuringThreshold 每次 minorGC 就增加一次，超过这个值，在 from 中的对象直
接进入到老年代
```

![image-20210307215333634](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105311.png)

![image-20210307215341119](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105312.png)

