---
layout: post
title: "秋招知识点汇总"
date: 2021-03-16 10:36
toc: true
comments: true
categories: 技术学习
tags:
	- 基础
	- 复习 
---

# [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

**题目描述：**

给定一个二叉树，检查它是否是镜像对称的。



**示例：**

```
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
```

<!--more-->



## 算法一：递归

**算法思想：**

- 判断一颗树是否为镜像对称的，可以判断对称位置节点的值是否相等，对称位置也就是从根节点开始所走的路劲完全相反，例如 `root.left.right与root.right.left`就是对称节点



- 如果同时满足下面的条件，两个树互为镜像：

1. 它们的两个根结点具有相同的值。
2. 每个树的右子树都与另一个树的左子树镜像对称。

![Push an element in stack](https://pic.leetcode-cn.com/2c9a13df75821ba472de5267470481e48386ffa658b3f91a8acca5abfa43625d-file_1555698500306)



**算法实现：**

```
public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        return isSame(root.left,root.right);
    }
    //判断分别以left，right为根的子树是否镜像对称
    public boolean isSame(TreeNode left,TreeNode right){
         if(left==null&&right==null) return true;
         //如果left与right中有且只有一个为null，返回false
         if(left==null||right==null) return false;
         //两个根节点的值不相等
         if(left.val!=right.val) return false;
         //递归判断left的左子树与right的右子树是否镜像对称，下面类似
         if(!isSame(left.left,right.right)) return false;
         if(!isSame(left.right,right.left)) return false;
         return true;
    }
```



**复杂度分析**

- **时间复杂度：**O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)，其中 n 是树中结点的总数。
- **空间复杂度：**递归调用的次数受树的高度限制。在最糟糕情况下，树是线性的，其高度为 O(n)。因此，在最糟糕的情况下，由栈上的递归调用造成的空间复杂度为 O(n)。





## 算法二：迭代

**算法思想：**

- 上面算法的迭代解法，由于上面的递归函数有两个参数left与right，所以想到用两个栈分别来存储这两个参数
- 用深度优先的方式分别遍历两个子树



**算法实现：**

```
public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        //用两个栈分别存储需要去比较的两个子树
        Stack<TreeNode> leftNodes=new Stack<>(),rightNodes=new Stack<>();
        //初始为root的左子树与右子树
        leftNodes.push(root.left);
        rightNodes.push(root.right);
        TreeNode left,right;
        while(!leftNodes.isEmpty()&&!rightNodes.isEmpty()){
            left=leftNodes.pop();
            right=rightNodes.pop();
            if(left==null&&right==null) continue;
            if(!isSame(left,right)) return false;
            //按顺序将left，right的左右子树存储到栈中
            leftNodes.push(left.left);
            rightNodes.push(right.right);
            leftNodes.push(left.right);
            rightNodes.push(right.left);
        }
        //最后如果有一个栈没有遍历完，肯定不是镜像对称的，返回false(这一步是多余的，因为上面已			  经将这种情况考虑进去了)
        if(!leftNodes.isEmpty()||!rightNodes.isEmpty()){
            return false;
        }
        return true;
    }
    //返回left与right的值是否相同
    public boolean isSame(TreeNode left,TreeNode right){
         if(left==null&&right==null) return true;
         if(left==null||right==null) return false;
         if(left.val!=right.val) return false;
         return true;
    }
```



**复杂度分析：**

- **时间复杂度：**O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)，其中 n 是树中结点的总数。
- **空间复杂度：**搜索栈需要额外的空间。在最糟糕情况下，我们不得不向队列中插入 O(n) 个结点。因此，空间复杂度为 O(n)。

---
title: 1013.将数组分成和相等的三个部分
date: 2020-07-10 16:30:05
tags: leetcode
categories: leetcode
---

# [1013. 将数组分成和相等的三个部分](https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/)

**题目描述：**

给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。

形式上，如果可以找出索引 i+1 < j 且满足 A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1] 就可以将数组三等分。

```
示例 1：

输入：[0,2,1,-6,6,-7,9,1,2,0,1]
输出：true
解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1

示例 2：

输入：[0,2,1,-6,6,7,9,-1,2,0,1]
输出：false

示例 3：

输入：[3,3,6,5,-2,2,5,1,-9,4]
输出：true
解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
```





**算法思想：**

- 思路很清晰，就是有些错误容易犯，先计算整个数组的和，然后/3，从0开始向后去找到第一个和为sum/3的索引，再从后面去找第二个....

```
	public boolean canThreePartsEqualSum(int[] A) {
        int sum=0;
        for(int num:A){
            sum+=num;
        }
        if(sum%3!=0) return false;
        int i=0,sum1=0,sum2=0;
        while(i<A.length){
            sum1+=A[i++];
            if(sum1==sum/3)
                break;
        }
        while(i<A.length){
            sum2+=A[i++];
            if(sum2==sum/3)
                break;
        }
        //最后返回i是否<A.length
        return i<A.length;
    }
```

---
title: 102. 二叉树的层次遍历
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [102. 二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

**题目描述：**

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。



**示例：**

```
例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```



## 算法一：迭代

**算法思想：**

- 层次遍历可以用队列来实现，由于要将同一层的节点存储在一个list中，所以想到用lastNode指向本层中的最后一个节点
- 当访问到lastNode时就表明访问到了本层最后一个节点，需要更新结果result，以及初始化list，同时更新lastNode的值，此时队尾元素即为更新后的lastNode的值



**算法实现：**

```
public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result=new ArrayList<>();
        if(root==null) return result;
        LinkedList<TreeNode> queue=new LinkedList<>();
        //lastNode指向本层的最后一个节点
        TreeNode node=root,lastNode=root;
        queue.add(node);
        List<Integer> list=new ArrayList<>();
        //当队列不为空时
        while(!queue.isEmpty()){
            node=queue.poll();
            list.add(node.val);
            //如果左子树不为空，则将左子树添加到队列中
            if(node.left!=null){
                queue.add(node.left);
            }
            //右子树同理
            if(node.right!=null){
                queue.add(node.right);
            }
            //如果当前访问的节点为本层的最后一个节点
            if(node==lastNode){
            	//将list加入到result中
                result.add(new ArrayList<>(list));
                //此时更新lastNode的值为队列中的队尾元素
                lastNode=queue.peekLast();
                //初始化list
                list=new ArrayList<>();
            }
        }
        return result;
    }
```



**复杂度分析**

- **时间复杂度：**O*(*N)，因为每个节点恰好会被运算一次。
- **空间复杂度：**O(N)，保存输出结果的数组包含 N 个节点的值。



**说明：**

- 本来想用Queue，但是由于要访问队列中的队尾元素，Queue好像没有对应的方法，所以用LinkedList

- 首先用的是LinkedList中的方法getLast()，但是当队列中没有元素时会报错NoSuchElementException，在jdk1.6后出现了替代方法peekLast()，在队列没有元素时返回null

  

## 算法二：迭代改

**算法思想：**

- 上面的迭代算法中是用lastNode记录每一层的最后一个节点
- 这里用第二种算法，用level记录每一层的层数，每一次循环遍历完一层的节点后再将层数加一，然后遍历下一层



**算法实现：**

```
public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result=new ArrayList<>();
        if(root==null) return result;
        LinkedList<TreeNode> queue=new LinkedList<>();
        TreeNode node=root;
        //level记录当前遍历的层数，从0开始
        int level=0;
        queue.add(node);
        List<Integer> list=new ArrayList<>();
        while(!queue.isEmpty()){
            result.add(new ArrayList<>());
            //外层循环中，每一循环遍历一层的节点并将下一层的节点全部入队，所以每一次循环开始时队				 列长度即为这一层总的节点个数
            int level_size=queue.size();
            //循环遍历这一层的所有节点，并出队，然后将下一层节点入队
            for(int i=0;i<level_size;i++){
                node=queue.poll();
                result.get(level).add(node.val);
                if(node.left!=null){
                    queue.add(node.left);
                }
                if(node.right!=null){
                    queue.add(node.right);
                }
            }
            //层数加一
            level++;
        }
        return result;
    }
```



## 算法三：递归

**算法思想：**

- 将上面的迭代算法改为递归算法，层次遍历按层数递归
- 注意在遍历新的一层时要将result集合的大小更新



**算法实现：**

```
List<List<Integer>> result=new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return result;
        helper(root,0);
        return result;
    }
	//此方法将level层的root节点添加到对应的result的子集合中，并且递归将计算其左孩子与右孩子
    private void helper(TreeNode root,int level){
    	//如果result的大小等于当前level，表示在递归计算新的一层，需要更新result的大小
        if(result.size()==level){
            result.add(new ArrayList<>());
        }
        result.get(level).add(root.val);
        if(root.left!=null){
            helper(root.left,level+1);
        }
        if(root.right!=null){
            helper(root.right,level+1);
        }
    }
```



**复杂度分析**

- **时间复杂度：**O(N)，因为每个节点恰好会被运算一次。
- **空间复杂度**：O(N)，保存输出结果的数组包含 `N` 个节点的值。

---
title: 103. 二叉树的锯齿形层次遍历
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

**题目描述：**

给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。



**示例：**

```
例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层次遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
```



## 算法一：额外使用栈来实现偶数层的反转

**算法思想：**

- 同102题大致相同，不同的 是需要在偶数层实现翻转，所以想到用栈来实现，其他部分一样



**算法实现：**

```
List<List<Integer>> result=new ArrayList<>();
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if(root==null) return result;
        int level=0;
        LinkedList<TreeNode> queue=new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
        	//栈来实现翻转
            Stack<TreeNode> stack=new Stack<>();
            if(level==result.size()){
                result.add(new ArrayList<>());
            }
            int level_size=queue.size();
            //由于level从0开始，所以偶数层的level为奇数
            if(level%2==1) {
                for (int i = 0; i < level_size; i++) {
                	//依次将出队的元素入栈
                    TreeNode node = queue.poll();
                    stack.add(node);
                    if (node.left != null) {
                        queue.add(node.left);
                    }
                    if (node.right != null) {
                        queue.add(node.right);
                    }
                }
                //然后再依次出栈即可实现翻转
                while(!stack.isEmpty()){
                    result.get(level).add(stack.pop().val);
                }
                level++;
            }else {
            	//奇数层的处理不变
                for (int i = 0; i < level_size; i++) {
                    TreeNode node = queue.poll();
                    if (node.left != null) {
                        queue.add(node.left);
                    }
                    if (node.right != null) {
                        queue.add(node.right);
                    }
                    result.get(level).add(node.val);
                }
                level++;
            }
        }
         return result;
     }
```



**说明：**

- 在思考过程中一直想到一种错误的算法，即通过LinkedList能够在队头和队尾操作的特性来实现双端队列
- 如果是在奇数层则不需要额外操作，直接队尾进，队头出即可
- 如果是在偶数层，我想的是从队头进，队头出模拟栈的作用来实现翻转，但是问题在于这样操作后先入队的是最右边节点的孩子，会导致在下一层的遍历中，还是从右边开始



## 算法二：递归算法

**算法思路：**

- 将上面的算法改为递归算法
- **学到一个新的方法，List的add()方法有一个带两个参数的方法list.add(int index,E element)，在特定的索引处添加element，所以可以通过list.add(0,element)来实现翻转**



**算法实现：**

```
List<List<Integer>> result=new ArrayList<>();
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if(root==null) return result;
        helper(root,0);
         return result;
     }
     private void helper(TreeNode root,int level){
         if(level==result.size()){
             result.add(new ArrayList<>());
         }
         if(level%2==0) {
             result.get(level).add(root.val);
         }else {
             result.get(level).add(0,root.val);
         }
         if(root.left!=null) {
             helper(root.left, level + 1);
         }
         if(root.right!=null) {
             helper(root.right, level + 1);
         }
     }
```

---
title: 104. 二叉树的最大深度
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**题目描述：**

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。



## 算法一：递归

**算法实现：**

```
public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        int leftDepth=maxDepth(root.left);
        int rightDepth=maxDepth(root.right);
        return Math.max(leftDepth,rightDepth)+1;
    }
```



**复杂度分析:**

- 时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，
  其中 N 是结点的数量。
- **空间复杂度：**在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。



## 算法二：层次遍历

**算法思想：**

- 层次遍历，没遍历一层，高度加一



**算法实现：**

```
public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        Queue<TreeNode> queue=new LinkedList<>();
        queue.add(root);
        //depth记录高度
        int depth=0;
        while(!queue.isEmpty()){
            int level_size=queue.size();
            for(int i=0;i<level_size;i++){
                TreeNode node = queue.poll();
                if(node.left!=null){
                    queue.add(node.left);
                }
                if(node.right!=null){
                    queue.add(node.right);
                }
            }
            depth++;
        }
        return depth;
    }
```

---
title: 105. 从前序与中序遍历序列构造二叉树
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

**题目描述：**

根据一棵树的前序遍历与中序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。



**示例：**

```
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```



## 算法一：递归

**算法思想：**

- 通过先序遍历可以首先确认出根节点，然后再在中序遍历中寻找根节点的值，其左边和右边就分别是左子树与右子树
- 通过更新左子树与右子树的先序遍历和中序遍历数组，可以递归计算左子树与右子树



**算法实现：**

```
public TreeNode buildTree(int[] preorder, int[] inorder) {
		//将两个情况单独拉出来讨论
        if(preorder.length==0&&inorder.length==0) return null;
        if(preorder.length==1&&inorder.length==1) return new TreeNode(preorder[0]);
        //通过先序遍历确定根节点的值
        TreeNode root=new TreeNode(preorder[0]);
        //index记录根节点在中序遍历中的索引
        int index=0;
        while(inorder[index]!=preorder[0]){
            index++;
        }
        //分别表示左子树长度和右子树长度
        int leftTreeSize=index,rightTreeSize=inorder.length-index-1;
        int[] leftPreorder=new int[leftTreeSize],rightPreorder=new int[rightTreeSize],
                leftInorder=new int[leftTreeSize],rightInorder=new int[rightTreeSize];
        //分别更新左子树先序遍历，右子树先序遍历，左子树中序遍历，右子树中序遍历数组
        System.arraycopy(preorder,1,leftPreorder,0,leftTreeSize);
        System.arraycopy(preorder,leftTreeSize+1,rightPreorder,0,rightTreeSize);
        System.arraycopy(inorder,0,leftInorder,0,leftTreeSize);
        System.arraycopy(inorder,leftTreeSize+1,rightInorder,0,rightTreeSize);
        //递归计算左子树与右子树
        root.left=buildTree(leftPreorder,leftInorder);
        root.right=buildTree(rightPreorder,rightInorder);
        return root;
    }
```



**改进：**

- 上面的算法是通过复制数组的方式来实现的，会耗费更多时间，可以通过更改数组初始索引的方式来实现

  ---
title: 108. 将有序数组转换为二叉搜索树
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

**题目描述：**

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。



**示例：**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \

   -3   9
   /   /
 -10  5
```





## 算法：递归

**算法思想：**

- 首先题中的树并不唯一，主要是因为在只有两个节点时，哪个节点作为根节点并不唯一
- 给出在两个节点时，选择后一个节点作为根节点的算法





**算法实现：**

```
	private int[] nums;
    public TreeNode sortedArrayToBST(int[] nums) {
    	//先给nums数组赋值
        this.nums=nums;
        return sortedArrayToBST(0,nums.length-1);
    }
	
	//start和end分别指向数组的起始索引和结束索引
    private TreeNode sortedArrayToBST(int start,int end){
    	//如果只有一个元素
        if(start==end){
            return new TreeNode(nums[start]);
        }
        //如果索引不合格
        if(start>end){
            return null;
        }
        //在有两个元素时单独拉出来，确定后面一个元素为根节点
        if(end-start==1){
            TreeNode root=new TreeNode(nums[end]);
            root.left=new TreeNode(nums[start]);
            return root;
        }
        //每次选取中间的节点作为根节点
        int mid=(start+end)/2;
        TreeNode root=new TreeNode(nums[mid]);
        //递归确定左子树与右子树
        root.left=sortedArrayToBST(start,mid-1);
        root.right=sortedArrayToBST(mid+1,end);
        return root;
    }
```



**复杂度分析：**

- 时间复杂度：O(N)，每个元素只访问一次。
- 空间复杂度：O(N)，二叉搜索树空间 O(N)，递归栈深度O(logN)。

---
title: 11.盛最多水的容器
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# 11.盛最多水的容器

**题目描述：**

给定 n 个非负整数 a<sub>1</sub>，a<sub>2</sub>，...，a<sub>n</sub>，每个数代表坐标中的一个点 (i, a<sub>i</sub>) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, a~i~) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

---

**说明：**

 你不能倾斜容器，且 *n* 的值至少为 2。 

----

 ![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg) 

> 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 



**示例：**

```
输入: [1,8,6,2,5,4,8,3,7]
输出: 49
```



----

**方法一：**

- 暴力法

  对每一个矩形计算其面积，取其中最大的那一个

  ```
  public class Solution1 {
      //暴力法，对每一个矩形计算其面积，取其中最大的那一个
      public int maxArea(int[] height){
          int len=height.length;
          int max=0;
          for(int i=0;i<len-1;i++){
              for(int j=i+1;j<len;j++){
                  int maxRef=(j-i)*Math.min(height[i],height[j]);
                  if(maxRef>max){
                      max=maxRef;
                  }
              }
          }
          return max;
      }
  }
  ```

---

**方法2：**

- 双指针法

  分别用两个指针first和last指向最左边和最右边，max记录最大的矩阵面积，若first的高度小于last的高度，则first右移，否则last左移。

  >1.大致证明一下，若移动较长的边，则之后的矩阵高度最大为较短边的高度，而长度又比移动前少一，所以面积一定比移动之前要小，所以移动较长的边没有意义。
  >
  >2.比较麻烦的是证明两条边的长度相同时随便移动任意一条边都可以，需要注意到当两边相同时，若要移动后的矩阵面积比之前要大，则新的边必须要比这两条等边的高度都要大，所以无论移动哪条边，这种情况都不会错过。

---



```
public class Solution2 {
    //双指针法
    public int maxArea(int[] height){
        int len=height.length;
        int max=0;
        int first=0;
        int last=len-1;
        while(first<last){
            int maxRef=(last-first)*Math.min(height[first],height[last]);
            max=Math.max(max,maxRef);
            if(height[first]>height[last]){
                last--;
            }else{
                first++;
            }
        }
        return max;
    }
}
```





 



---
title: 1117.H2O生成
date: 2020-06-18 20:58:59
tags: leetcode
categories: leetcode
---

# [1117. H2O 生成](https://leetcode-cn.com/problems/building-h2o/)

**题目描述：**

现在有两种线程，氧 oxygen 和氢 hydrogen，你的目标是组织这两种线程来产生水分子。

存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。

氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。

这些线程应该三三成组突破屏障并能立即组合产生一个水分子。

你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。

换句话说:

如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。
如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。
书写满足这些限制条件的氢、氧线程同步代码。

```
示例 1:

输入: "HOH"
输出: "HHO"
解释: "HOH" 和 "OHH" 依然都是有效解。

示例 2:

输入: "OOHHHH"
输出: "HHOHHO"
解释: "HOHHHO", "OHHHHO", "HHOHOH", "HOHHOH", "OHHHOH", "HHOOHH", "HOHOHH" 和 "OHHOHH" 依然都是有效解。
```





## 信号量

**算法思想：**

- 假设两个H必须在O之前打印，所以有关系H->O，而在打印一个O之后又可以打印2个H，所以有O->H。

```
class H2O {

    Semaphore h;
    Semaphore o;

    public H2O() {
        h=new Semaphore(2);
        o=new Semaphore(0);
    }

    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {
		h.acquire();
        // releaseHydrogen.run() outputs "H". Do not change or remove this line.
        releaseHydrogen.run();
        o.release();
    }

    public void oxygen(Runnable releaseOxygen) throws InterruptedException {
    	//这里每次获取两个，然后释放两个
        o.acquire(2);
        // releaseOxygen.run() outputs "O". Do not change or remove this line.
		releaseOxygen.run();
        h.release(2);
    }
}
```

---
title: 1143.最长公共子序列
date: 2020-06-06 16:18:40
tags: leetcode
categories: leetcode
---

# [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

```
示例 1:

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。


示例 2:

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。


示例 3:

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
```





## 动态规划

**算法思想：**

- 用memo\[i][j]表示text1的前i个字符和text2的前j个字符的最长公共子序列，则有当text1.charAt(i)==text2.charAt(j)时有memo\[i][j]=memo\[i-1][j-1]+1;
- 否则，memo\[i][j]=max(memo\[i-1][j],memo\[i][j-1])

```
public int longestCommonSubsequence(String text1, String text2) {
        if(text1==null||text2==null) return 0;
        int[][] memo=new int[text1.length()+1][text2.length()+1];
        int M=memo.length;
        int N=memo[0].length;
        //memo长度都扩展了1，避免了将i=0，j=0的情况单独考虑
        for(int i=1;i<M;i++){
            for(int j=1;j<N;j++){
                if(text1.charAt(i-1)==text2.charAt(j-1)){
                    memo[i][j]=memo[i-1][j-1]+1;
                }else{
                    memo[i][j]=Math.max(memo[i-1][j],memo[i][j-1]);
                }
            }
        }
        return memo[M-1][N-1];
    }
```



---
title: 116. 填充每个节点的下一个右侧节点指针
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

**题目描述：**

给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。



**示例：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png)





## 算法一：层次遍历

**算法思想：**

- 由于是满二叉树 ，每一层的节点数量是确定的，依次遍历每一层，将前一个节点的next指向后一个节点，最后一个节点的next指向null



**算法实现：**

```
public Node connect(Node root) {
        if(root==null) return null;
        LinkedList<Node> queue=new LinkedList<>();
        int level=0;
        queue.add(root);
        while(!queue.isEmpty()){
        	//满二叉树，每层数量是满的
            for(int i=0;i<Math.pow(2,level);i++){
                Node node=queue.poll();
                //如果是最后一个节点，next置为null
                if(i==Math.pow(2,level)-1){
                    node.next=null;
                }else {
                	//否则，指向下一个节点
                    node.next = queue.peek();
                }
                if(node.left!=null){
                    queue.add(node.left);
                }
                if(node.right!=null){
                    queue.add(node.right);
                }
            }
            level++;
        }
        return root;
    }
```



**复杂度分析:**

- **时间复杂度：**O(N)。每个节点被访问一次，即从队列中弹出，并建立 next 指针。

- **空间复杂度：**O(N)。这是一棵完美二叉树，它的最后一个层级包含 N/2个节点。广度优先遍历的复杂度取决于**一个层级上的最大元素数量**。这种情况下空间复杂度为 O(N)。

  



**说明：**

- 树和图的两种基本遍历方法。一种是深度优先方法，例如：每次只遍历一个分支；另外一种是广度优先方法，例如：先遍历完这一层再进入下一层。树的深度优先遍历又可以分为先序遍历 preorder、中序遍历 inorder 和后序遍历 postorder。树的广度优先遍历基于节点的层级 level 概念。一个节点的层级取决于该节点的深度或者到根节点的距离。需要先遍历完同一层级的所有节点，才能进入下一层级。






## 算法二：利用已经建立的next指针

**算法思想：**

- 一颗树中存在两种情况的next指针：

  1. 第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。
     `node.left.next = node.right`

     ![img](https://pic.leetcode-cn.com/Figures/116/img6.png)

  2. 第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。

     ![img](https://pic.leetcode-cn.com/Figures/116/img7.png)

  如果每个节点有指向父节点的指针，可以通过该指针找到 next 节点。如果不存在该指针，则按照下面思路建立连接：

  > 第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。可以通过 next 指针访问同一层的所有节点，因此可以使用第 N 层的 next 指针，为第 N+1 层节点建立 next 指针。

- 首先最上面一层的节点只有一个根节点，不需要操作，所以可以从第一层开始去更新下一层的节点，直到用倒数第二层的节点更新最后的叶节点。



**算法实现：**

```
public Node connect(Node root) {
        helper(root);
        return root;
    }
	//方法将node的左孩子的next置为其右孩子，右孩子的next置为node.next的左孩子
    private void helper(Node node){
    	//如果node为空，或者node为最后一层的节点，不用操作
        if(node==null||node.left==null) return;
        node.left.next=node.right;
        if(node.next!=null){
            node.right.next=node.next.left;
        }
        //递归计算其左孩子与右孩子
        helper(node.left);
        helper(node.right);
    }
```





## 算法三：

**算法思想：**

- 与上面思路相同，依次计算一层



**算法实现：**

```
public Node connect(Node root) {
        if(root==null) return root;
		//leftMost记录每一层的最左边节点
        Node leftMost=root;
        //因为是通过上一层计算下一层，所以最后一层叶子节点已经通过倒数第二层计算了，只需遍历到倒数第			 二层
        while(leftMost.left!=null){
            Node node=leftMost;
            //每一层内从左向右
            while(node.next!=null){
                node.left.next=node.right;
                node.right.next=node.next.left;
                node=node.next;
            }
            //到最右边一个节点，其next域为null，但需要更新其左孩子的next域
            node.left.next=node.right;
            //再进入下一层
            leftMost=leftMost.left;
        }
        return root;
    }
```



**复杂度分析**

- **时间复杂度：**O(N)，每个节点只访问一次。
- **空间复杂度：**O(1)，不需要存储额外的节点。---
title: 118. 杨辉三角
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

**题目描述：**

给定一个非负整数 *numRows，*生成杨辉三角的前 *numRows* 行。

![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。



**示例：**

```
示例:

输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```



**算法：**

**算法描述：**

- 动态规划，通过上一层的数字来递推下一层的，当numRows不为0时，选取第一层作为递推起点



**算法实现：**

```
public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res=new ArrayList<>();
        //0的情况单独拿出来
        if(numRows==0){
            return res;
        }
        //第一行作为递推起点
        res.add(new ArrayList<>());
        res.get(0).add(1);
        for(int i=1;i<numRows;i++){
        	//扩容
            if(i==res.size()){
                res.add(new ArrayList<>());
            }
            //首尾的1单独加进去
            res.get(i).add(1);
            for(int j=1;j<i;j++){
                res.get(i).add(res.get(i-1).get(j-1)+res.get(i-1).get(j));
            }
            res.get(i).add(1);
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(numRows^2^)
- **空间复杂度：**O(numRows^2^)---
title: 12.整数转罗马数字
date: 2020-07-16 15:12:54
tags: leetcode
categories: leetcode
---

# [12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)

**题目描述：**

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。

- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 

- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

  给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。

```
示例 1:

输入: 3
输出: "III"

示例 2:

输入: 4
输出: "IV"

示例 3:

输入: 9
输出: "IX"

示例 4:

输入: 58
输出: "LVIII"
解释: L = 50, V = 5, III = 3.

示例 5:

输入: 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```



## 递归

**算法思想：**

- 从最大的1000开始判断，如果比其大，则加上对应的字符并减去对应的数。

```
public String intToRoman(int num) {
        StringBuilder res=new StringBuilder();
        helper(num,res);
        return res.toString();
    }

    private void helper(int num,StringBuilder res){
        if(num==0) return;
        if(num/1000!=0){
            res.append('M');
            num-=1000;
        }else if(num/900!=0){
            res.append("CM");
            num-=900;
        }else if(num/500!=0){
            res.append("D");
            num-=500;
        }else if(num/400!=0){
            res.append("CD");
            num-=400;
        }else if(num/100!=0){
            res.append("C");
            num-=100;
        }else if(num/90!=0){
            res.append("XC");
            num-=90;
        }else if(num/50!=0){
            res.append("L");
            num-=50;
        }else if(num/40!=0){
            res.append("XL");
            num-=40;
        }else if(num/10!=0){
            res.append('X');
            num-=10;
        }else if(num/9!=0){
            res.append("IX");
            num-=9;
        }else if(num/5!=0){
            res.append('V');
            num-=5;
        }else if(num/4!=0){
            res.append("IV");
            num-=4;
        }else{
            res.append('I');
            num-=1;
        }
        helper(num,res);
    }
```

上面的算法存在太多的if  else判断，这样代码简洁性太差了。



## 改进

**算法思想：**

- 可以用两个数组分别存储数组和对应的字符串，这样来记录对应关系

```
public String intToRoman(int num) {
        int[] nums={1000,900,500,400,100,90,50,40,10,9,5,4,1};
        String[] dict={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
        StringBuilder res=new StringBuilder();
        //用i来记录当前需要比较哪个数字
        int i=0;
        while(i<nums.length){
            if(num>=nums[i]){
                res.append(dict[i]);
                num-=nums[i];
            }else i++;
        }
        return res.toString();
    }
```



---
title: 120.三角形最小路径和
date: 2020-07-16 10:15:47
tags: leetcode
categories: leetcode
---

# [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

**题目描述：**

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

 

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。



## 回溯

**算法思想：**

- 依次去计算每一种路径可能的结果，然后取最小

```
	private int res=Integer.MAX_VALUE;

    public int minimumTotal(List<List<Integer>> triangle) {
        if(triangle==null||triangle.size()==0) return 0;
        helper(triangle,0,0,0,triangle.size());
        return res;
    }

    private void helper(List<List<Integer>> triangle,int i,int j,int sum,int size){
        if(i==size) {
            res=Math.min(res,sum);
            return;
        }
        int num=triangle.get(i).get(j);
        sum+=num;
        helper(triangle,i+1,j,sum,size);
        helper(triangle,i+1,j+1,sum,size);
    }
```

超时

**时间复杂度：**O(2^n^)，从最上面向下看，每次都有两个分支，所以就不停乘以2，最后得出2^n^

**空间复杂度：**O(n)，递归调用的空间复杂度



## 动态规划

**算法思想：**

- 用dp\[i][j]来记录从最上面到第i行第j个的最小路径和，则有如下的递推关系式：

  `dp[i][j]=Math.min(dp[i-1][j-1],dp[i-1][j])+nums[i][j]`

```
public int minimumTotal(List<List<Integer>> triangle) {
        if(triangle==null||triangle.size()==0) return 0;
        int n=triangle.size();
        int[][] dp=new int[n][n];
        dp[0][0]=triangle.get(0).get(0);
        for(int i=1;i<n;i++){
            List<Integer> list=triangle.get(i);
            int size=list.size();
            //0和size-1要单独出来算，避免越界
            dp[i][0]=dp[i-1][0]+list.get(0);
            for(int j=1;j<size-1;j++){
                dp[i][j]=Math.min(dp[i-1][j-1],dp[i-1][j])+list.get(j);
            }
            dp[i][size-1]=dp[i-1][size-2]+list.get(size-1);
        }
        int res=Integer.MAX_VALUE;
        for(int i=0;i<n;i++){
            res=Math.min(res,dp[n-1][i]);
        }
        return res;
    }
```

**时间复杂度：**O(n^2^)

**空间复杂度：**O(n^2^)

## 空间优化

**算法思想：**

- 从上面的递推关系式`dp[i][j]=Math.min(dp[i-1][j-1],dp[i-1][j])+nums[i][j]`可以发现dp\[i][j]的计算只和i-1行的状态有关，所以不需要去存储前面i-1行之前的数据，所以可以用一个二维矩阵来存储dp\[2][n]，其中一行存储上一行的，一行存储这一行的，然后交替使用。
- 更好的改进是只使用dp[n]的数组，由于计算dp[n]需要用到dp[n]与dp[n-1]，所以如果正着从1开始算，那么就会因为dp[n-1]已经被更新了，而无法得到正确的结果，所以可以倒着算，计算dp[n]时只更新了dp[n+1]以及其向后的，dp[n]和dp[n-1]还存储着上一行的数据。

```
public int minimumTotal(List<List<Integer>> triangle) {
        if(triangle==null||triangle.size()==0) return 0;
        int n=triangle.size();
        int[] dp=new int[n];
        dp[0]=triangle.get(0).get(0);
        for(int i=1;i<n;i++){
            List<Integer> list=triangle.get(i);
            int size=list.size();
            //从后向前算
            dp[size-1]=dp[size-2]+list.get(size-1);
            for(int j=size-2;j>0;j--){
                dp[j]=Math.min(dp[j],dp[j-1])+list.get(j);
            }
            dp[0]=dp[0]+list.get(0);
        }
        int res=Integer.MAX_VALUE;
        for(int i=0;i<n;i++){
            res=Math.min(res,dp[i]);
        }
        return res;
    }
```

**时间复杂度：**O(n^2^)

**空间复杂度：**O(n)---
title: 121. 买卖股票的最佳时机
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**题目描述：**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。



**示例：**

```
示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
     
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```



## 算法：一次遍历

**算法思想：**

- 简化题目，即为在数组中寻找两个数，使得右边的数减左边的数最大
- 一次遍历，分别用两个指针指向最大利润maxProfit，和买入时机buy，遍历到第i个数时计算当前利润，若利润小于0，则更新买入时机为i，若当前利润大于最大利润，则更新最大利润



**算法实现：**

```
public int maxProfit(int[] prices) {
		//i指向卖出时间，从1开始，buy指向买入时间
        int i=1,buy=0;
        //maxProfit表示最大利润，默认为0
        int maxProfit=0;
        while(i<prices.length){
        	//profit表示当前利润
            int profit=prices[i]-prices[buy];
            //如果当前利润小于0，表示当前股票价格小于之前的买入价格，所以在此处买入的价格更低
            if(profit<0){
                buy=i;
            }else if(profit>maxProfit){
            	//更新最大利润
                maxProfit=profit;
            }
            i++;
        }
        return maxProfit;
    }
```



**算法分析：**

- **时间复杂度：**O(n),一次遍历
- **空间复杂度：**O(1)---
title: 122. 买卖股票的最佳时机 II
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

**题目描述：**

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



**示例：**

```
示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
     
     
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
     
     
示例 3:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```



## 算法一

**算法思想：**

- 在基于上一题的基础上，增加了多次交易条件，因此用maxProfit表示当前交易的最大利润，sumProfit表示多次交易的最大利润之和。
- 由于两个交易之间不允许有交集，所以问题关键在于如何确定上一个交易的结束，此时选取的是尽量大的利润，假设两次交易的买入点和卖出点分别为i~1~,j~1~;i~2~,j~2~,必然满足j~1~<i~2~,利润之和等于prices[j~2~]-prices[i~2~]+prices[j~1~]-prices[i~1~]=prices[j~2~]-prices[i~1~]+prices[j~1~]-prices[i~2~],可以看成在i~1~买入在j~2~卖出的利润再加上prices[j~1~]-prices[i~2~]，但是之所以将交易拆分成两次，可以得出这样的利润更大，所以有prices[j~1~]-prices[i~2~]>0,即prices[j~1~]>prices[i~2~]
- 所以得出在交易的卖出点时如果后一天的价格小于等于卖出点的价格，那么就要结束上一次交易，进入下一层交易;第一次写的代码是没有等于的，只有小于的情况会结束上一次交易，这样会导致若存在两天的股票价格相同的情况时后一天因为利润与最大利润相同而无法结束交易(因为前一天已经更新了最大利润)，开始下一次交易



**算法实现：**

```
public int maxProfit(int[] prices) {
        if(prices.length==0) return 0;
        //buy表示买入点，i表示卖出点，maxProfit表示当前最大利润，sumProfit表示最大利润之和
        int buy=0,i=1,maxProfit=0,sumProfit=0;
        while(i<prices.length){
        	//profit表示当前利润
            int profit=prices[i]-prices[buy];
            if(profit<0){
                buy=i;
            //在得到最大利润的同时要考虑是否终止本次交易，卖出股票开始下一次交易
            }else if(profit>maxProfit){
                maxProfit=profit;
                //如果卖出点的价格大于等于第二天的价格，完成当前交易
                if(i+1<prices.length&&prices[i]>=prices[i+1]){
                	//更新sumProfit，maxProfit置为0，买入点置为第二天的位置，i也从第二天开始
                    sumProfit+=maxProfit;
                    maxProfit=0;
                    buy=i+1;
                    i++;
                }
            }
            i++;
        }
        //由于最后一次交易可能并没有终止条件，导致maxProfit没有置为0，也要加上去
        if(maxProfit>0){
            sumProfit+=maxProfit;
        }
        return sumProfit;
    }
```



**算法分析：**

- **时间复杂度：**O(n)，一次遍历即可完成
- **空间复杂度：**O(1)





## 算法二：峰谷法

**算法思想：**

- 从上面的算法思路中可以提炼一下思路，找买入点的过程其实就是找谷的过程，找卖出点的过程就是找其后面的峰的过程

- 假设给定的数组为：

  [7, 1, 5, 3, 6, 4]

  如果我们在图表上绘制给定数组中的数字，我们将会得到：

  ![Profit Graph](https://pic.leetcode-cn.com/d447f96d20d1cfded20a5d08993b3658ed08e295ecc9aea300ad5e3f4466e0fe-file_1555699515174)



**算法实现：**

```
public int maxProfit(int[] prices) {
        if(prices.length==0) return 0;
        int maxProfit=0,i=0;
        //取i<prices.length会导致可能无法跳出循环，只取到i=prices.length-2就可以了，因为里面			  的判断有prices[i+1],所以最后一个元素也参加了判断
        while (i<prices.length-1){
        	//寻找谷的过程，一定要取到大于等号，不能漏掉等号，下同
            while(i<prices.length-1&&prices[i]>=prices[i+1]) i++;
            int vally=prices[i];
            while(i<prices.length-1&&prices[i]<=prices[i+1]) i++;
            int peak=prices[i];
            maxProfit+=peak-vally;
        }
        return maxProfit;
    }
```





## 算法三

**算法思想：**

- 是上一个算法的改进，只要连续的两个数字有后一个数字大于前一个数字，则将两数之差添加到最大利润中

- 这个例子可以更清楚地展现上述情况：

  [1, 7, 2, 3, 6, 7, 6, 7]

  与此数组对应的图形是：

  ![Profit Graph](https://pic.leetcode-cn.com/6eaf01901108809ca5dfeaef75c9417d6b287c841065525083d1e2aac0ea1de4-file_1555699697692)



**算法实现：**

```
public int maxProfit(int[] prices) {
        int maxProfit=0;
        for(int i=0;i<prices.length-1;i++){
            if(prices[i]<prices[i+1]){
                maxProfit+=prices[i+1]-prices[i];
            }
        }
        return maxProfit;
    }
```

---
title: 123.买卖股票的最佳时机III
date: 2020-06-15 22:17:56
tags: leetcode
categories: leetcode
---

# [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

**题目描述：**

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



```
示例 1:

输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
     
     
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
     
     
示例 3:

输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
```





## 动态规划

**算法思想：**

- 三维dp，其中第三个维度表示已经完成了几次交易，最大为2

```
public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int[][][] dp=new int[prices.length][2][3];
        //处理初始值
        dp[0][0][0]=0;
        dp[0][0][1]=0;
        dp[0][0][2]=0;
        dp[0][1][0]=-prices[0];
        dp[0][1][1]=-prices[0];
        dp[0][1][2]=-prices[0];
        for(int i=1;i<prices.length;i++){
            dp[i][0][0]=dp[i-1][0][0];
            dp[i][0][1]=Math.max(dp[i-1][1][0]+prices[i],dp[i-1][0][1]);
            dp[i][0][2]=Math.max(dp[i-1][1][1]+prices[i],dp[i-1][0][2]);
            dp[i][1][0]=Math.max(dp[i-1][0][0]-prices[i],dp[i-1][1][0]);
            dp[i][1][1]=Math.max(dp[i-1][0][1]-prices[i],dp[i-1][1][1]);
            dp[i][1][2]=Math.max(dp[i-1][0][2]-prices[i],dp[i-1][1][2]);
        }
        return Math.max(0,Math.max(dp[dp.length-1][0][1],dp[dp.length-1][0][2]));
    }
```



**改进：最多完成k笔交易**

```
public int maxProfit(int k, int[] prices) {
        if(prices==null||prices.length==0||k==0) return 0;
        int[][][] dp=new int[prices.length][2][k+1];
        for(int i=0;i<=k;i++){
            dp[0][0][i]=0;
            dp[0][1][i]=-prices[0];
        }
        for(int i=1;i<prices.length;i++){
            dp[i][0][0]=dp[i-1][0][0];
            dp[i][1][0]=Math.max(dp[i-1][1][0],dp[i-1][0][0]-prices[i]);
            for(int j=1;j<=k;j++){
                dp[i][0][j]=Math.max(dp[i-1][1][j-1]+prices[i],dp[i-1][0][j]);
                dp[i][1][j]=Math.max(dp[i-1][1][j],dp[i-1][0][j]-prices[i]);
            }
        }
        int max=0;
        int len=prices.length;
        for(int i=0;i<=k;i++){
            if(dp[len-1][0][i]>max)
                max=dp[len-1][0][i];
        }
        return max;
    }
```

**leetcode上超出内存限制。**---
title: 124.二叉树中的最大路径和
date: 2020-06-30 21:33:26
tags: leetcode
categories: leetcode
---

# [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

**题目描述：**

给定一个**非空**二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点。

```
示例 1:

输入: [1,2,3]

       1
      / \
     2   3

输出: 6
示例 2:

输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```



## 递归

**算法思想：**

- 最大路径和虽然不一定经过根节点，但是其一定是某一个子节点，把它看作根节点的子树中，并且经过该子树的根节点，所以递归去计算以每一个节点作为根节点时，经过其的最大路径和。
- 问题就可以转换成经过根节点的最大路径，那么这个问题就要去求左子树和右子树的最长单向路径。

```
	private int res=Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        if(root==null) return 0;
        //计算以当前节点为根节点的最长路径和
        int left=helper(root.left);
        int right=helper(root.right);
        res=Math.max(res,left+right+root.val);
        //递归计算左子树和右子树
        maxPathSum(root.left);
        maxPathSum(root.right);
        return res;
    }
	
	//计算左子树的最长单向路径
    private int helper(TreeNode root){
        if(root==null) return 0;
        int left=helper(root.left);
        int right=helper(root.right);
        //返回两者中较长的，但是如果小于0时，返回0表示不通过下面的节点。
        int num=Math.max(left,right)+root.val;
        return num>0?num:0;
    }
```





## 改进

**算法思想：**

- 上面递归次数太多了，其实下面的maxPath()方法就计算了每个节点的左子树和右子树的最长路径。

```
private int res=Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        if(root==null) return 0;
        maxPath(root);
        return res;
    }

    private int maxPath(TreeNode root){
        if(root==null) return 0;
        int left=maxPath(root.left);
        int right=maxPath(root.right);
        int num=Math.max(left,right)+root.val;
        res=Math.max(res,left+right+root.val);
        return num>0?num:0;
    }
```

---
title: 125. 验证回文串
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

**题目描述：**

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。



**示例：**

```
示例 1:

输入: "A man, a plan, a canal: Panama"
输出: true


示例 2:

输入: "race a car"
输出: false
```





## 算法一：双指针法

**算法思想：**

- 使用两个指针分别从左边开始和从右边开始



**算法实现：**

```
public boolean isPalindrome(String s) {
		//根据题意空串返回true
        if(s==null||s.length()==0) return true;
        int len=s.length();
        int left=0,right=len-1;
        while(left<right){
        	//如果当前字符不是字母或数字，就考虑下一个字符
            while (!isVaild(s,left)) left++;
            while (!isVaild(s,right)) right--;
            //如果有left>right，那么就不需要再进行下面的判断了，返回true
            if(left>right) return true;
            //在两个字符不等时，还需要除去大小写不等的情况
            if(s.charAt(left)!=s.charAt(right)) {
                boolean flag=false;
                if (isCapital(s, left) && s.charAt(left) + 32 == s.charAt(right)){flag=true;}
                if(isCapital(s,right)&&s.charAt(right)+32==s.charAt(left)){flag=true;}
                if(!flag) {
                    return false;
                }
            }
            left++;
            right--;
        }
        return true;
    }
    //方法中判断字符串在指定索引处是否为数字或字母
    private boolean isVaild(String s,int index){
    	//如果index越界，返回true
        if(index>=s.length()||index<0) return true;
        if(s.charAt(index)>='0'&&s.charAt(index)<='9') return true;
        if(s.charAt(index)>='a'&&s.charAt(index)<='z') return true;
        if(s.charAt(index)>='A'&&s.charAt(index)<='Z') return true;
        return false;
    }
	
	//方法判断是否为大写字母
    private boolean isCapital(String s,int index){
        if(s.charAt(index)>='A'&&s.charAt(index)<='Z') return true;
        return false;
    }
```





## 算法二：调用库函数

**算法实现：**

```
public boolean isPalindrome(String s) {
        if(s==null||s.length()==0) return true;
        int len=s.length();
        int left=0,right=len-1;
        while(left<right){
            while (left<right&&!Character.isLetterOrDigit(s.charAt(left))) left++;
            while (left<right&&!Character.isLetterOrDigit(s.charAt(right))) right--;
          if(Character.toLowerCase(s.charAt(left))!=Character.toLowerCase(s.charAt(right))) return false;
            left++;
            right--;
        }
        return true;
    }
```



**说明：**

- ```
  Character.isLetter()可以判断字符是否为字母;Character.isDigit()可以判断字符是否为数字;
  ```

- ```
  Character.toLowerCase()可以将大写字母转换为小写字母
  ```---
  title: 127. 单词接龙
  date: 2020-04-11 17:51:24
  tags: leetcode
  categories: leetcode
---

# [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。

2. 转换过程中的中间单词必须是字典中的单词。

   

说明:

- 如果不存在这样的转换序列，返回 0。
- 所有单词具有相同的长度。
- 所有单词只由小写字母组成。
- 字典中不存在重复的单词。
- 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。



## 动态规划

**算法思想：**

- 用memo表来存储其索引对应的字符串转换到endword所需要的次数
- 按照广度优先搜索的顺序，依次搜索离endword转换近的字符串，并更新其memo值



**算法实现：**

```
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
            if(!wordList.contains(endWord)){
                return 0;
            }
            Integer[] memo=new Integer[wordList.size()];
            //递推起点为endword所在的位置的值为1
            memo[wordList.indexOf(endWord)]=1;
            Queue<String> queue = new LinkedList<>();
            //广度优先遍历
            queue.add(endWord);
            while (!queue.isEmpty()) {
                String compare = queue.poll();
                for (String s : wordList) {
                    if (onlyOneDiff(compare, s) && memo[wordList.indexOf(s)] == null) {
                        memo[wordList.indexOf(s)] = memo[wordList.indexOf(compare)] + 1;
                        queue.add(s);
                    }
                }
            }
            //然后寻找memo中可以转换为beginword的最小元素
            int min=Integer.MAX_VALUE;
            for(int i=0;i<memo.length;i++){
                if(onlyOneDiff(beginWord,wordList.get(i))&&memo[i]!=null){
                    min=Math.min(min,memo[i]);
                }
            }
            //如果min没有变化表示没有可以转换的，返回0，否则返回min+1
            return min==Integer.MAX_VALUE?0:min+1;
        }

		
		//如果s1与s2只有一个字符不同，返回true
        private boolean onlyOneDiff(String s1,String s2){
            int diff=0;
            for(int i=0;i<s1.length();i++){
                if(s1.charAt(i)!=s2.charAt(i)) diff++;
            }
            if(diff==1) return true;
            return false;
        }
```

---
title: 128.最长连续序列
date: 2020-06-14 10:32:46
tags: leetcode
categories: leetcode
---

# [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

**题目描述：**

给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 *O(n)*。

```
示例:

输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```



## 排序

**算法思想：**

- 先排序后一次遍历即可

**第二次做时出现的错误：**

1. 没有考虑元素相等的情况
2. 没有考虑数组为空的情况
3. 当出现不连续的时候，curr从1开始

```
public int longestConsecutive(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        Arrays.sort(nums);
        int max=0,curr=1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]-nums[i-1]==1){
                curr++;
            }else if(nums[i]-nums[i-1]==0){
                continue;
            }else{
                max=Math.max(max,curr);
                curr=1;
            }
        }
        max=Math.max(max,curr);
        return max;
    }
```



## 哈希表

**算法思想：**

- 将所有元素存在哈希表中，同时可以去重，然后对于每一个元素num，只要num-1不在set中，则去判断以其作为起点的最长连续序列；反之若在，则跳过该元素，因为以num-1未开始的最长连续序列一定比他长。

```
public int longestConsecutive(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        Set<Integer> set=new HashSet<>();
        int max=0;
        for(int num:nums)
            set.add(num);
        for(int num:set){
            if(!set.contains(num-1)){
                int curr=1;
                int next=num+1;
                while (set.contains(next)){
                    curr++;
                    next++;
                }
                max=Math.max(max,curr);
            }
        }
        return max;
    }
```

---
title: 13. 罗马数字转整数
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)



**算法描述:**

- 唯一需要注意的一点就是当左边的数字比右边要小时，计算结果是右边-左边
  - 为了达到这个目的，我的设计是始终用一个整数 `prev`记录前一个数字的大小，用当前数字 `rev`与前一个数字相比，若`rev>prev`，则 `result+=rev-2*prev;`





**算法实现：**

```
public int romanToInt(String s) {
        //记录最终结果
        int result=0;
        //记录前一个结果
        int prev=10000;
        //map对应映射关系
        Map<Character,Integer> map=new HashMap<>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        for(int i=0;i<s.length();i++){
            //rev记录当前数字
            int rev=map.get(s.charAt(i));
            //如果右边数字比左边大
            if(rev>prev){
                result+=rev-2*prev;
            }else{
                result+=rev;
            }
            prev=rev;
        }
        return result;
    }
```



---
title: 130. 被围绕的区域
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

**题目描述：**

给定一个二维的矩阵，包含 `'X'` 和 `'O'`（**字母 O**）。

找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。



**示例：**

```
示例:

X X X X
X O O X
X X O X
X O X X
运行你的函数后，矩阵变为：

X X X X
X X X X
X X X X
X O X X
```



**解释：**

被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。



## 算法一：DFS递归

**算法思想：**

- 首先类似于图中找联通区域，可以将与边界上的'O'相连的'O'看成一个连通区域，找到所有的连通区域，并将其值从'O'改变为一个特殊的值'#'，那么剩下来的'O'就是不与边界上的'O'相连的，直接将其令为‘X’即可，然后再将之前的'#'还原为‘O’即可
- 寻找连通域的可以通过DFS和BFS实现，首先给出DFS的递归算法





**算法实现：**

```
public void solve(char[][] board) {
            if(board==null) return;
            int m = board.length;
            if (m == 0) return;
            int n = board[0].length;
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++){
                    boolean isEdge=i==0||i==m-1||j==0||j==n-1;
                    //寻找边界上的'O'的连通区域
                    if(isEdge&&board[i][j]=='O'){
                        dfs(board,i,j);
                    }
                }
            }
            //后面再还原
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++) {
                    if(board[i][j]=='O'){
                        board[i][j]='X';
                    }
                    if(board[i][j]=='#'){
                        board[i][j]='O';
                    }
                }
            }
        }

        private void dfs(char[][] board,int i,int j){
        	//索引越界和值为'X'的情况不需要处理，board[i][j]=='#'表示已经处理过了，				防止再往回递归
            if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]=='X'||board[i][j]=='#'){
                return;
            }
            //先处理i,j处的值，然后再分别向四个方向递归
            board[i][j]='#';
            dfs(board,i-1,j);
            dfs(board,i+1,j);
            dfs(board,i,j-1);
            dfs(board,i,j+1);
        }
```





## 算法二：DFS非递归

**算法思想：**

- DFS非递归是通过栈来实现的
- 在每次查看stack顶时，只是查看，而不出元素，因为DFS是先向一个方向往深处遍历，然后再回溯回来遍历其他方向，所以值访问过一个方向的元素还需要保存在stack中



**算法实现：**

```
//定义一个内部类来存储横纵坐标
public class Pos{
        int i;
        int j;
        public Pos(int i,int j){
            this.i=i;
            this.j=j;
        }
    }
        public void solve(char[][] board) {
            if(board==null) return;
            int m = board.length;
            if (m == 0) return;
            int n = board[0].length;
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++){
                    boolean isEdge=i==0||i==m-1||j==0||j==n-1;
                    if(isEdge&&board[i][j]=='O'){
                        dfs(board,i,j);
                    }
                }
            }
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++) {
                    if(board[i][j]=='O'){
                        board[i][j]='X';
                    }
                    if(board[i][j]=='#'){
                        board[i][j]='O';
                    }
                }
            }
        }

        private void dfs(char[][] board,int i,int j){
            Stack<Pos> stack=new Stack<>();
            stack.push(new Pos(i,j));
            board[i][j]='#';
            while(!stack.isEmpty()){
            	//只是访问，不出元素
                Pos current=stack.peek();
                //如果向上走是可以的，将上面的节点入栈，然后访问，continue表示下面几					 个方向的遍历先不进行，先去进行上面那个节点的遍历
                if(current.i-1>=0&&board[current.i-1][current.j]=='O'){
                    stack.push(new Pos(current.i-1,current.j));
                    board[current.i-1][current.j]='#';
                    continue;
                }
                //下
                if (current.i + 1 <= board.length - 1
                        && board[current.i + 1][current.j] == 'O') {
                    stack.push(new Pos(current.i + 1, current.j));
                    board[current.i + 1][current.j] = '#';
                    continue;
                }
                // 左
                if (current.j - 1 >= 0
                        && board[current.i][current.j - 1] == 'O') {
                    stack.push(new Pos(current.i, current.j - 1));
                    board[current.i][current.j - 1] = '#';
                    continue;
                }
                // 右
                if (current.j + 1 <= board[0].length - 1
                        && board[current.i][current.j + 1] == 'O') {
                    stack.push(new Pos(current.i, current.j + 1));
                    board[current.i][current.j + 1] = '#';
                    continue;
                }
                // 如果上下左右都搜索不到,本次搜索结束，弹出stack
                stack.pop();
            }
        }
```





## 算法三：BFS非递归

**算法思想：**

- 通过队列来实现，类似于树的层次遍历



**算法实现：**

```
public class Pos{
        int i;
        int j;
        public Pos(int i,int j){
            this.i=i;
            this.j=j;
        }
    }
        public void solve(char[][] board) {
            if(board==null) return;
            int m = board.length;
            if (m == 0) return;
            int n = board[0].length;
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++){
                    boolean isEdge=i==0||i==m-1||j==0||j==n-1;
                    if(isEdge&&board[i][j]=='O'){
                        dfs(board,i,j);
                    }
                }
            }
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++) {
                    if(board[i][j]=='O'){
                        board[i][j]='X';
                    }
                    if(board[i][j]=='#'){
                        board[i][j]='O';
                    }
                }
            }
        }

        private void dfs(char[][] board,int i,int j){
            Queue<Pos> queue=new LinkedList<>();
            queue.add(new Pos(i,j));
            board[i][j]='#';
            while(!queue.isEmpty()){
            	//每次要出队，然后将每个方向访问完后再去访问临近节点
                Pos current=queue.poll();
                //上
                if(current.i-1>=0&&board[current.i-1][current.j]=='O'){
                    queue.add(new Pos(current.i-1,current.j));
                    board[current.i-1][current.j]='#';
                }
                //下
                if (current.i + 1 <= board.length - 1
                        && board[current.i + 1][current.j] == 'O') {
                    queue.add(new Pos(current.i + 1, current.j));
                    board[current.i + 1][current.j] = '#';
                }
                // 左
                if (current.j - 1 >= 0
                        && board[current.i][current.j - 1] == 'O') {
                    queue.add(new Pos(current.i, current.j - 1));
                    board[current.i][current.j - 1] = '#';
                }
                // 右
                if (current.j + 1 <= board[0].length - 1
                        && board[current.i][current.j + 1] == 'O') {
                    queue.add(new Pos(current.i, current.j + 1));
                    board[current.i][current.j + 1] = '#';
                }
                // 如果上下左右都搜索不到,本次搜索结束，弹出stack
            }
        }
```

---
title: 131. 分割回文串
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

**题目描述：**

给定一个字符串 *s*，将 *s* 分割成一些子串，使每个子串都是回文串。

返回 *s* 所有可能的分割方案。



**示例：**

```
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```





## 算法一：回溯法

- 一般这种方法返回值为List<List<Object>>类型的情况，在写递归函数时有两种解决方法：
  1. 递归函数中一个参数为List类型，在一次递归结束时将List添加到结果中
  2. 递归函数的一个参数为int类型的num，用来指向当前的产生的结果List要添加到结果的第几个索引处
- 本次是用的第一种方法



**算法实现：**

```
	List<List<String>> res=new ArrayList<>();
    public List<List<String>> partition(String s) {
        if(s==null) return res;
        helper(s,new ArrayList<>());
        return res;
    }

    private void helper(String s,List<String> list){
    	//如果s长度为0，表示已经分割到末尾了，直接将list加到结果中
        if(s.length()==0){
            res.add(new ArrayList<>(list));
            return;
        }
        //长度为1的情况单独拿出来，先加到list中再将list添加到res中，回溯法需要将list			  在回溯到添加s的之前的情况
        if(s.length()==1){
            list.add(s);
            res.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            return;
        }
		
		//i从1到s.length，因为subString函数返回的子串左闭右开
        for(int i=1;i<=s.length();i++){
        	//如果子串回文，就将其添加到list中，递归对后面的子串计算，然后再回溯到之前			  的状态
            if(isSymmetric(s.substring(0,i))){
                list.add(s.substring(0,i));
                helper(s.substring(i),list);
                list.remove(list.size()-1);
            }
        }

    }
	
	//判断字符串是否是回文串
    private boolean isSymmetric(String s){
        if(s.length()==1) return true;
        for(int i=0;i<s.length()/2;i++){
            if(s.charAt(i)!=s.charAt(s.length()-i-1)) return false;
        }
        return true;
    }
```

---
title: 1332.删除回文序列
date: 2020-07-08 19:33:14
tags: leetcode
categories: leetcode
---

# [1332. 删除回文子序列](https://leetcode-cn.com/problems/remove-palindromic-subsequences/)

**题目描述：**

给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。

返回删除给定字符串中所有字符（字符串为空）的最小删除次数。

「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。

「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。



```
示例 1：

输入：s = "ababa"
输出：1
解释：字符串本身就是回文序列，只需要删除一次。


示例 2：

输入：s = "abb"
输出：2
解释："abb" -> "bb" -> "". 
先删除回文子序列 "a"，然后再删除 "bb"。


示例 3：

输入：s = "baabb"
输出：2
解释："baabb" -> "b" -> "". 
先删除回文子序列 "baab"，然后再删除 "b"。


示例 4：

输入：s = ""
输出：0
```





**算法思想：**

- 这题有点抖机灵，最后结果只有三种情况：
  1. 如果为空串，则结果为0；
  2. 如果字符串本身回文，则为1；
  3. 否则，结果为2.(因为字符串种只包含'a'和'b'，所以先删除a，再删除b即可)

```
public int removePalindromeSub(String s) {
        if(s==null||s.length()==0) return 0;
        int l=0,r=s.length()-1;
        while(l<r){
            if(s.charAt(l)!=s.charAt(r))
                return 2;
            l++;
            r--;
        }
        return 1;
    }
```

---
title: 134. 加油站
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

**题目描述：**

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。



**说明:** 

- 如果题目有解，该答案即为唯一答案。
- 输入数组均为非空数组，且长度相同。
- 输入数组中的元素均为非负数。



**示例：**

```
示例 1:

输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。


示例 2:

输入: 
gas  = [2,3,4]
cost = [3,4,3]

输出: -1

解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```





## 算法一：递归

**算法思想：**

- 依次以每一个加油站作为起点判断其是否能绕环路一周



**算法实现：**

```
public int canCompleteCircuit(int[] gas, int[] cost) {
        if(gas==null||gas.length==0) return 0;
        //依次判断每一个加油站
        for(int i=0;i<gas.length;i++){
        	//oil从0开始
            if(canCompleteCircuit(gas,cost,i,i,0)) return i;
        }
        return -1;
    }
	
	//方法返回能否从起点start到终点end，oil表示在当前加油站加油前当前剩余的油量
    private boolean canCompleteCircuit(int[] gas,int[] cost,int start,int end,int oil){
    	//不能到达下一站
        if(oil+gas[start]<cost[start]) return false;
        //否则，能到达下一站，首先判断下一站是否是重点作为递归出口
        if((start+1)%gas.length==end) return true;
        //然后递归判断下一站能否到终点
        if(canCompleteCircuit(gas,cost,(start+1)%gas.length,end,oil+gas[start]-cost[start])) return true;
        return false;
    }
```



**算法分析：**

- **时间复杂度：**O(n^2^)，外层循环要判断n个加油站，内层递归会访问所有加油站
- **空间复杂度：**O(n)，递归栈深度为n



## 算法二：非递归

**算法思想：**

- 将上面的算法改为非递归形式



**算法实现：**

```
public int canCompleteCircuit(int[] gas, int[] cost) {
        if(gas==null||gas.length==0) return 0;
        for(int i=0;i<gas.length;i++){
            if(canCompleteCircuit(gas,cost,i,i,0)) return i;
        }
        return -1;
    }

    private boolean canCompleteCircuit(int[] gas,int[] cost,int start,int end,int oil){
    	//当下一个加油站不是终点时
        while((start+1)%gas.length!=end){
        	//current记录到达下一个加油站时剩余的油量
            int current=oil+gas[start]-cost[start];
            if(current<0) return false;
            //否则，进入下一个加油站
            start=(start+1)%gas.length;
            //更新剩余油量
            oil=current;
        }
        //上面的循环出口为终点的前一个加油站，所以还要判断能否到达终点
        if(oil+gas[start]-cost[start]<0) return false;
        return true;
    }
```



**算法分析：**

- **时间复杂度：**O(n^2^)
- **空间复杂度：**O(1)



## 算法三：一次遍历

**算法思想：**

- 上面的算法都是依次判断每一个加油站能否作为起点，这里会给出只需要一次遍历即可得出结果的算法
- 可以用这个式子计算环行过程中邮箱里剩下的油：total_tank = sum(gas) - sum(cost) ，如果 total_tank < 0 则返回 -1 。
- 同时引入变量 `curr_tank` ，记录当前油箱里剩余的总油量。如果在某一个加油站 `curr_tank`比 `0` 小，意味着我们无法到达这个加油站。下一步我们把这个加油站当做新的起点，并将 curr_tank 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， curr_tank 也一定会比 0 小）
- 从0号加油站开始循环，如果在计算中在某个加油站i有`curr_tank<0`，表示从0号加油站到不了加油站i，显然以0到i之间的任何一个加油站作为起点都不能到达i(这是因为假如以0到i之间的加油站j作为新的起点，之前以0作为起点时，到达j的剩余油量一定大于等于0，而此时从j开始初始油量为0，比从0开始情况更少，所以更不可能)，所以只能以i作为新的起点

> 具体证明看leetcode上吧



**算法实现：**

```
public int canCompleteCircuit(int[] gas, int[] cost) {
		//total_tank记录整个环形过程中的油量，curr_tank记录以当前加油站为起点时的环形		   过程剩余油量
        int total_tank=0;
        int curr_tank=0;
        int starting_station=0;
        for(int i=0;i<gas.length;i++){
            total_tank+=gas[i]-cost[i];
            curr_tank+=gas[i]-cost[i];
            //如果curr_tank<0表示以当前起点到不了加油站i+1，所以只能以i+1为新的起点
            if(curr_tank<0){
                starting_station=i+1;
                curr_tank=0;
            }
        }
        //最后如果total_tank>=0，那么就可以以当前起点环形一周，证明见leetcode
        return total_tank>=0?starting_station:-1;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 136. 只出现一次的数字
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

**题目描述：**

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。



**示例：**

```
示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
```





## 算法一：哈希表

**算法思想：**

- 一次遍历，如果哈希表中没有对应的元素，则将其值作为键，1作为次数存储进去；否则如果已经有了对应元素，将次数改为2即可



**算法实现：**

```
public int singleNumber(int[] nums) {
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(nums[i])) {
                map.put(nums[i],2);
            }
            else {
                map.put(nums[i], 1);
            }
        }
        //然后遍历map找到其中值为1所对应的键
        Set<Integer> set = map.keySet();
        for(Integer key:set){
            if(map.get(key)==1){
                return key;
            }
        }
        return -1;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



## 算法二：列表操作

**算法思想：**

- 同样可以用列表来存储，如果列表中没有对应元素，则将元素加入到列表中，否则则将元素从列表中移除，最后剩下来的一个 元素就是所求



**算法实现：**

```
public int singleNumber(int[] nums) {
        List<Integer> list=new ArrayList<>();
        for (int num:nums){
            if(!list.contains(num)) list.add(num);
            else list.remove(num);
        }
        return list.get(0);
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



## 算法三：位运算

**算法思想：**

- 概念

  如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位
  a⊕0=a
  如果我们对相同的二进制位做 XOR 运算，返回的结果是 0
  a⊕a=0
  XOR 满足交换律和结合律
  a⊕b⊕a=(a⊕a)⊕b=0⊕b=b
  所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。

  

- 在java中， `|表示按位或，&表示按位与,^表示按位异或`



**算法实现：**

```
public int singleNumber(int[] nums) {
        int result=0;
        for (int num:nums){
            result=result^num;
        }
        return result;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 138. 复制带随机指针的链表
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

**题目描述：**

给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。

要求返回这个链表的 深拷贝。 

我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

val：一个表示 Node.val 的整数。
random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。



## 算法一：递归

**算法思想：**

- 方法中需要确定三个域的内容，其中val域可以直接复制，next域和random域则通过递归去完成，由于有random域的存在，所以链表中直接递归可能会重复访问一个节点多次，所以需要用到一个map去 存储已经复制过的链表节点，防止多次访问



**算法实现：**

```
Map<Node,Node> map=new HashMap<>();
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        //如果节点已经复制过了，直接返回哈希表中的结果
        if(map.containsKey(head)) return map.get(head);
        //否则，复制节点
        Node node=new Node(head.val);
        //并将节点存入到map中
        map.put(head,node);
        //递归复制节点的next和random
        node.next=copyRandomList(head.next);
        node.random=copyRandomList(head.random);    
        return node;
    }
```



**算法分析：**

- **时间复杂度：**O(n),其实递归的调用过程是先按着next域递归，并将节点复制后存入map内，然后在递归random域时，所有的节点已经复制了，只需要从map中取出来然后对应上即可
- **空间复杂度：**O(n)，map的复杂度为n，并且递归栈的深度为n



## 算法二：迭代

**算法思想：**

- 将上面的算法改为迭代





**算法实现：**

```
Map<Node,Node> map=new HashMap<>();
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        Node node=new Node(head.val);
        map.put(head,node);
        Node curr=node,from=head;
        //先按着next域遍历
        while (from.next!=null){
            curr.next=new Node(from.next.val);
            curr=curr.next;
            from=from.next;
            //由于存储的是地址，所以需要单独赋值后再存储
            Node c=curr,h=from;
            map.put(h,c);
        }
        curr=node;
        //然后在完善random域
        while(curr!=null){
        	//直接从map中取值即可
            curr.random=map.get(head.random);
            curr=curr.next;
            head=head.next;
        }
        return node;
    }
```



**算法分析：**

- **时间复杂度：**O(n),两次遍历
- **空间复杂度：**O(n)---
title: 139. 单词拆分
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

**题目描述：**

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。



**说明：**

- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。



**示例：**

```
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。


示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
     
     
示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```





## 算法一：回溯

**算法思想：**

- 依次判断每一种前缀的可能性



**算法实现：**

```
public boolean wordBreak(String s, List<String> wordDict) {
        return helper(s,wordDict);
    }
    private boolean helper(String s,List<String> wordDict){
    	//递归出口
        if(s.length()==0) return true;
        //依次判断wordDict中的每一个单词是否可以为其前缀
        for (String str : wordDict) {
        //如果是前缀，则递归判断其剩下的子串能否被划分完毕，若不能则再用其他前缀去判断
            if(s.indexOf(str)==0){
                if(helper(s.substring(str.length()),wordDict)) return true;
            }
        }
        //如果没有前缀符合，直接返回false
        return false;
    }
```



**算法分析：**

- **时间复杂度：**O(n^n^)，考虑最坏情况 s = aaaaaaa 。每一个前缀都在字典中，此时回溯树的复杂度会达到 n^n^ 。
- **空间复杂度：**O(n)，回溯树的最大深度达n



## 算法二：带记忆表的优化

**算法思想：**

- 使用记忆表去优化可以防止多次调用回溯函数，回溯树得到剪枝



**算法实现：**

```
	//memo作为记忆表，存储的类型是Boolean类型，这个技巧可以学习
	Boolean[] memo;
    public boolean wordBreak(String s, List<String> wordDict) {
        memo=new Boolean[s.length()];
        return helper(s,wordDict,0);
    }
    private boolean helper(String s,List<String> wordDict,int start){
        if(start==s.length()) return true;
        //如果已经计算过，直接返回即可
        if(memo[start]!=null) return memo[start];
        for (String str : wordDict) {
            if(s.substring(start).indexOf(str)==0){
                if(helper(s,wordDict,start+str.length())) {
                	//返回的同时更新数组的值
                    memo[start]=true;
                    return true;
                }
            }
        }
        //返回的同时更新数组的值
        memo[start]=false;
        return false;
    }
```



**算法分析：**

- **时间复杂度：**O(n^2^)
- **空间复杂度：**O(n)





## 算法三：动态规划

**算法思想：**

- 数组res记录以当前索引开头的字符串能否被划分，则最后结果为res[0]



**算法实现：**

```
public boolean wordBreak(String s, List<String> wordDict) {
        if(s.length()==0) return true;
        //res长度比s大1，因为要加上一个递归起点res[len-1]=true;
        boolean[] res=new boolean[s.length()+1];
        int len=res.length;
        res[len-1]=true;
        //index记录在i之后离i最近的一个res为true值处的索引
        int index=len-1;
        for(int i=len-2;i>=0;i--){
        	//从index向后判断是否存在划分
            for(int j=index;j<len;j++) {
                if (res[j]&&wordDict.contains(s.substring(i, j))) {
                    res[i] = true;
                    //更新index的值
                    index = i;
                    break;
                }
            }
        }
        return res[0];
    }
```



**算法分析：**

- **时间复杂度：**O(n^2^)
- **空间复杂度：**O(n)---
title: 14. 最长公共前缀
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

**题目描述：**

>编写一个函数来查找字符串数组中的最长公共前缀。
>
>如果不存在公共前缀，返回空字符串 `""`。



**示例：**

```
示例 1:

输入: ["flower","flow","flight"]
输出: "fl"


示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```



## **方法一：**

- 对于每一个字符串，依次比较其从地位到高位的字符是否相同，直到存在不同的字符，则返回



**算法实现1(自己的)：**

```
public String longestCommonPrefix(String[] strs) {
		//如果数组为空或者长度为0则返回空串
        if(strs==null||strs.length==0){
            return "";
        }
        String s1=strs[0];
        flag记录是否存在不同的字符，当有不同的字符时，则赋值为false
        boolean flag=true;
        int i=0;
        //对于每一个字符位，从低位到高位
        for(i=0;i<s1.length();i++){
            char c=s1.charAt(i);
            //对于每一个字符串
            for(int j=1;j<strs.length;j++){
            	//如果当前比较的字符索引大于等于某个字符串的长度，则需要跳出循环了，最后一个相等的					字符索引为i-1
                if (i>=strs[j].length()){
                    flag=false;
                    break;
                }
                //如果对应的字符不同，则跳出循环
                if(strs[j].charAt(i)!=c){
                    flag=false;
                    break;
                }
            }
            //flag==false跳出循环
            if(flag==false) break;
        }
        //i==0表示没有任何一个字符位相同，返回空串
        if(i==0) {
            return "";
        }else {
            return s1.substring(0,i);
        }
    }
```



**改进思路：**

- 我是通过判断不同的字符来跳出循环，可以直接让存在不同字符则返回结果



**算法实现2(改)：**

```
public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        for(int i=0;i<strs[0].length();i++){
            char c=strs[0].charAt(i);
            for(int j=1;j<strs.length;j++){
            	//如果存在不同的字符位，则直接返回结果
                if(i==strs[j].length()||strs[j].charAt(i)!=c){
                    return strs[0].substring(0,i);
                }
            }
        }
        //若没有在循环中返回结果，则表示str[0]的所有字符都可以作为公共字符，所以直接返回strs[0]
        return strs[0];
    }
```





## 方法二:

- 首先找到前两的字符串的公共前缀，然后将这个公共前缀与第三个字符串相比，依次往后，得到结果，若在某一步得到的公共前缀已经是空串了，则可以直接返回空串了。



**算法实现：**

```
public String longestCommonPrefix(String[] strs){
        if(strs.length==0) return "";
        ///prefix记录最长公共前缀
        String prefix=strs[0];
        for(int i=1;i<strs.length;i++){
        	//当prefix在strs[i]中第一次出现的索引不是0时，将prefix的最后一位去掉
            while(strs[i].indexOf(prefix)!=0){
                prefix=prefix.substring(0,prefix.length()-1);
               //若当前的prefix为空串，则返回空串
            }if(prefix.length()==0){
                return "";
            }
        }
        return prefix;
    }
```







## 方法三：

- **分治法：**
  
  ![t14_1.PNG](https://i.loli.net/2020/05/04/sx4cjb2Bu3mAK9F.png)

**算法实现：**

```
public String longestCommonPrefix(String[] strs){
        if(strs==null||strs.length==0){
            return "";
        }
        return longestCommonPrefix(strs,0,strs.length-1);
    }

    private String longestCommonPrefix(String[] strs,int l,int r){
    	//如果左右边界相等，则表示只有一个字符串，显然公共前缀为自己
        if(l==r){
            return strs[l];
        }else{
        	//需要注意mid=（l+r）/2，不能是减
            int mid=(l+r)/2;
            //分成左右两个部分计算
            String leftLongest=longestCommonPrefix(strs,l,mid);
            String rightLongest=longestCommonPrefix(strs,mid+1,r);
            //再合起来
            return CommonePrefix(leftLongest,rightLongest);
        }
    }
	
	
	//计算两个字符串的公共前缀
    private String CommonePrefix(String s1,String s2){
        int index=0;
   	while(index<s1.length()&&index<s2.length()&&s1.charAt(index)==s2.charAt(index)){
            index++;
        }
        return s1.substring(0,index);
    }
```







## 二分查找法：

![t14_2.png](https://i.loli.net/2020/05/04/x6OkaRQTEXVlvJg.png)

![t14_3.png](https://i.loli.net/2020/05/04/ljVLJuIBK71W6tZ.png)





**算法实现：**

```
 public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0)
            return "";
        int minLen = Integer.MAX_VALUE;
        for (String str : strs)
            minLen = Math.min(minLen, str.length());
        int low = 1;
        int high = minLen;
        while (low <= high) {
            int middle = (low + high) / 2;
            if (isCommonPrefix(strs, middle))
                low = middle + 1;
            else
                high = middle - 1;
        }
        return strs[0].substring(0, (low + high) / 2);
    }

    private boolean isCommonPrefix(String[] strs, int len){
        String str1 = strs[0].substring(0,len);
        for (int i = 1; i < strs.length; i++)
            if (!strs[i].startsWith(str1))
                return false;
        return true;
    }
```

---
title: 141. 环形链表
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**题目描述：**

给定一个链表，判断链表中是否有环。



## 算法一：双指针法

**算法思想：**

- 使用两个指针快慢指针，若不存在环，则快指针会先达到终点，否则快指针最终会追上慢指针



**算法实现：**

```
 public boolean hasCycle(ListNode head) {
          if(head==null||head.next==null) return false;
          //p为慢指针，q为快指针
          ListNode p=head,q=head.next;
          while (q!=null){
              if(q.next==null) return false;
              //q追上了p
              if(p==q) return true;
              //快指针每次移动两个
              q=q.next.next;
              p=p.next;
          }
          return false;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)



## 算法二：哈希表

**算法思想：**

- 依次访问节点，用Set集合去存储访问的节点，如果存在有的节点已经访问过，那很明显有环；否则无环



**算法实现：**

```
public boolean hasCycle(ListNode head) {
        if(head==null) return false;
        Set<ListNode> set=new HashSet<>();
        ListNode node=head;
        while(node!=null){
            if(set.contains(node)) return true;
            set.add(node);
            node=node.next;
        }
        return false;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



**说明：**

- 对于引用类型，集合中存储的是元素的值，不是元素的集合，所以改变元素不会改变其在集合中存储的值---
title: 143.重排链表
date: 2020-07-08 21:35:16
tags: leetcode
categories: leetcode
---

# [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

**算法思想：**

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```
示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.


示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.
```





## 哈希表

**算法思想：**

- 使用哈希表强制给每个节点安排一个下标，这样来实现随机获取，然后双指针即可。

```
public void reorderList(ListNode head) {
        if(head==null) return;
        Map<Integer,ListNode> map=new HashMap<>();
        ListNode p=head;
        int i=0;
        while(p!=null){
            map.put(i++,p);
            p=p.next;
        }
        int l=0,r=i-1;
        ListNode Head=new ListNode(0),tail=Head;
        while(l<r){
            tail.next=map.get(l);
            tail=tail.next;
            tail.next=map.get(r);
            tail=tail.next;
            l++;
            r--;
        }
        //最后如果是奇数个节点的情况，最中间那个还需要加进去
        if(l==r){
            tail.next=map.get(l);
            tail=tail.next;
        }
        tail.next=null;
    }
```





## 逆转链表

**算法思想：**

- 从中间将后一半的链表逆转，然后再依次拼接即可

```
public void reorderList(ListNode head) {
        if(head==null) return;
        ListNode p=head,q=head,prev=head;
        while(p!=null&&p.next!=null){
            p=p.next.next;
            prev=q;
            q=q.next;
        }
        prev.next=null;
        ListNode Head=reverse(q);
        p=head;
        q=Head;
        ListNode memo=new ListNode(0),tail=memo;
        while(p!=null&&q!=null){
            tail.next=p;
            tail=tail.next;
            p=p.next;
            tail.next=q;
            tail=tail.next;
            q=q.next;
        }
        //最后如果q不为null，则右半边多了一个节点，也要拼接上
        if(q!=null){
            tail.next=q;
            tail=tail.next;
        }
        //最后tail.next=null不能丢，防止链表出现环
        tail.next=null;
    }

    private ListNode reverse(ListNode head){
        if(head==null||head.next==null) return head;
        ListNode p=head,q=head.next;
        p.next=null;
        ListNode Head=reverse(q);
        q.next=p;
        return Head;
    }
```



**错误1：**将17行的`p=p.next`写到了19行，导致p取到的值是刚插进去的q

---
title: 148. 排序链表
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

**题目描述：**

在 *O*(*n* log *n*) 时间复杂度和常数级空间复杂度下，对链表进行排序。



## 归并排序（递归）

**算法思想：**

- 归并排序将数组不停的二分直到只有一个元素，然后再合并，所以归并排序涉及分与和的过程
- 对于链表的二分，可以通过快慢指针来实现，注意fast的初值为fast=head.next，这是因为考虑只有两个节点的情况，如果fast初值取为head，则在fast到达终点时slow也到达终点，二分失败



**算法实现：**

```
public ListNode sortList(ListNode head) {
        if(head==null||head.next==null) return head;
        //fast初值为head.next
        ListNode fast=head.next,slow=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        //去rhead为右半边链表的起始节点
        ListNode rhead=slow.next;
        //将两个链表断开
        slow.next=null;
        //递归对两个链表排序
        ListNode left = sortList(head);
        ListNode right = sortList(rhead);
        //下面将两个有序链表合并起来
        ListNode res=new ListNode(0);
        ListNode p=res;
        while (left!=null&&right!=null){
            if(left.val<right.val){
                p.next=left;
                p=p.next;
                left=left.next;
            } else {
                p.next=right;
                p=p.next;
                right=right.next;
            }
        }
        while(left!=null){
            p.next=left;
            p=p.next;
            left=left.next;
        }
        while(right!=null){
            p.next=right;
            p=p.next;
            right=right.next;
        }
        return res.next;
    }
```



**算法分析：**

- **时间复杂度：**O(nlogn)
- **空间复杂度：**O(logn)



---
title: 15.三数之和
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# 15.三数之和

**题目描述：**

给定一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且**不重复**的三元组。



**注意：** 答案中不可以包含重复的三元组。 

~~~
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
~~~



---

**算法思路：** 

1. 对数组进行排序
2. 设i指向当前元素，则令L和R分别指向其后面所有元素的最左侧和最右侧元素
3. 如果 `nums[i]>0`，则结束循环
4. 如果 `nums[i]==nums[i-1]` ，则会导致重复，跳过下面步骤直接开始下一轮循环
5. 如果满足条件 `nums[i]+nums[L]+nums[R]==0` ，则将其添加到目标集合中 `添加方法为： list.add(Arrays.asList(nums[i], nums[L], nums[R]));` ，**同时让L和R分别左移和右移**（不能忘了这一步）
6. 同时，如果有 `nums[L]==nums[L+1]` ,则会重复，应该跳过， `L++`
7. 同时，如果有 `nums[R]==nums[R-1]` ,则会重复，应该跳过， `R--`



---

**具体算法实现：**

```
public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> list=new ArrayList<>();
        Arrays.sort(nums); //排序
        int len=nums.length;
        if(nums==null||len<3) return list;
        for(int i=0;i<len;i++){
            if(nums[i]>0) break;
            //需要加上i>0这个条件，防止数组越界，
            //使用continue，表示直接进入下次循环
            if(i>0&&nums[i]==nums[i-1]) continue;
            int L=i+1;
            int R=len-1;
            while(L<R){
                int result=nums[i]+nums[L]+nums[R];
                if(result==0){
                     list.add(Arrays.asList(nums[i], nums[L], nums[R]));
                     while(L<R&&nums[L]==nums[L+1]) L++;
                     while(L<R&&nums[R]==nums[R-1]) R--;
                     L++;
                     R--;
                }else if(result<0) L++;
                else R--;
            }
        }
        return list;
    }
```

---
title: 150. 逆波兰表达式求值
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

**题目描述：**

根据逆波兰表示法，求表达式的值。

有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。



**示例：**

```
示例 1：

输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: ((2 + 1) * 3) = 9

示例 2：

输入: ["4", "13", "5", "/", "+"]
输出: 6
解释: (4 + (13 / 5)) = 6

示例 3：

输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
输出: 22
解释: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```





## 后缀表达式

**算法思想：**

- 用一个栈来存储数字



**算法实现：**

```
public int evalRPN(String[] tokens) {
        Stack<Integer> stack=new Stack<>();
        for(int i=0;i<tokens.length;i++){
            if(tokens[i].equals("+")){
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a+b);
            }
            else if(tokens[i].equals("-")){
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a-b);
            }
            else if(tokens[i].equals("*")){
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a*b);
            }
            else if(tokens[i].equals("/")){
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a/b);
            }else {
                stack.push(Integer.valueOf(tokens[i]));
            }
        }
        return stack.pop();
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



---
title: 151.翻转字符串里的单词
date: 2020-07-10 20:56:51
tags: leetcode
categories: leetcode
---

# [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

**题目描述：**

给定一个字符串，逐个翻转字符串中的每个单词。



```
示例 1：

输入: "the sky is blue"
输出: "blue is sky the"


示例 2：

输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。


示例 3：

输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
```





**算法思想：**

- 用StringBuilder开始从后向前拼接，需要解决一下几点：
  1. 字符串前面和后面的多余空格需要消除
  2. 单词中间多余的空格需要消除
- 从末尾向前遍历，每次拼接一个单词，然后拼上一个空格

```
public String reverseWords(String s) {
        if(s==null||s.length()==0) return s;
        StringBuilder res=new StringBuilder();
        int i=s.length()-1;
        while(i>=0&&s.charAt(i)==' ') i--;
        //全是空格的情况，返回空串
        if(i==-1) return "";
        while(i>=0){
            int r=i;
            //找到单词的左边界
            while(i>=0&&s.charAt(i)!=' ') i--;
            res.append(s.substring(i+1,r+1));
            res.append(' ');
            //寻找下一个单词的右边界
            while(i>=0&&s.charAt(i)==' ') i--;
        }
        //最后一个单词多加了一个空格，需要删掉
        res.deleteCharAt(res.length()-1);
        return res.toString();
    }
```

---
title: 152. 乘积最大子序列
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [152. 乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/)

**题目描述：**

给定一个整数数组 `nums` ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。



**示例：**

```
示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。


示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```





## 动态规划

**算法思想：**

- 用一个数组res，其中res[i]表示在nums数组中从nums[i]开始并且必须包括该元素的连续子序列最大乘积(约定只能向后延申)
- 以数组{-4,-3,-2}为例，res[2]=-2，res[1]=-3×-2=6，res[0]=-4×-3=12，则最后的 结果必定为数组中的最大元素
- 第一次想的递归关系是只依靠于res数组，从后向前递推有res[i]=Math.max(nums[i],nums[i]×res[i+1])，但是问题在于如果nums[i]为负，那么会得出错误的结果，还是以上面的例子为例，根据res[1]=6会得出，res[0]=-4错误，因此想到引入一个数组min来记录以对应元素开头并且必须包括该元素的最小乘积
- 对于字符串a~0~,a~1~,...,a~i~,a~i+1~,....，若记a~i+1~,....，为字符串s，则字符串a~i~,a~i+1~,....，的最大子序列和的取值只有三种可能：
  1. nums[i]
  2. nums[i]*res[i+1]
  3. nums[i]*min[i+1]



**算法实现：**

```
public int maxProduct(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        int len=nums.length;
        int[] res=new int[len];
        int[] min=new int[len];
        //递推起点
        res[len-1]=nums[len-1];
        min[len-1]=nums[len-1];
        for(int i=len-2;i>=0;i--){
//更新res和min的值            res[i]=Math.max(Math.max(nums[i],nums[i]*res[i+1]),nums[i]*min[i+1]);
            min[i]=Math.min(Math.min(nums[i],nums[i]*res[i+1]),nums[i]*min[i+1]);
        }
        //下面寻找res数组中的最大元素即为所求
        int max=Integer.MIN_VALUE;
        for(int i=0;i<res.length;i++){
            if(res[i]>max) max=res[i];
        }
        return max;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



---
title: 155. 最小栈
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

**题目描述：**

设计一个支持 push，pop，top 操作，并能在**常数时间**内检索到最小元素的栈。

- push(x) -- 将元素 x 推入栈中。
- pop() -- 删除栈顶的元素。
- top() -- 获取栈顶元素。
- getMin() -- 检索栈中的最小元素。



## 算法一：辅助栈与数据栈同步

**算法思想：**

- 因为要在常数时间内完成返回最小元素的操作，所以想到用一个栈来记录最小元素，辅助栈与数据栈同步，在插入元素时，同时在辅助栈中插入此时的最小元素，由于在插入之前，辅助栈顶的元素为插入之前的最小元素，所以只需要将其和新插入的元素相比，谁更小来确定谁是最小元素
- 在出栈时，两个栈要同步出栈



**算法实现：**

```
	Stack<Integer> stack;
	//min为辅助栈
    Stack<Integer> min;
    public MinStack() {
        stack=new Stack<>();
        min=new Stack<>();
    }

    public void push(int x) {
        stack.push(x);
        //插入两者中较小的
        if(min.isEmpty()||min.peek()>x){
            min.push(x);
        }else {
            min.push(min.peek());
        }
    }

    public void pop() {
    //同步出栈
        if(!stack.isEmpty()) {
            stack.pop();
            min.pop();
        }else {
            throw new RuntimeException("栈为空，非法操作");
        }
    }

    public int top() {
        if(!stack.isEmpty()) {
            return stack.peek();
        }else {
            throw new RuntimeException("栈为空，非法操作");
        }
    }

    public int getMin() {
        if(!min.isEmpty()) {
            return min.peek();
        }
        else {
            throw new RuntimeException("栈为空，非法操作");
        }
    }
```





## 算法二：数据栈与辅助栈不同步

**算法思想：**

- 在插入元素时有区别，辅助栈并不总是直接插入元素，而是在当前需要插入的元素小于等于辅助栈顶元素时才将该元素插入辅助栈中
- 在出栈时，需要比较从数据栈中出的元素是否等于辅助栈顶元素，等于时辅助栈顶元素才出栈



**算法实现：**

```
Stack<Integer> stack;
    Stack<Integer> min;
    public MinStack2() {
        stack=new Stack<>();
        min=new Stack<>();
    }

    public void push(int x) {
        stack.push(x);
        //插入的元素小于等于栈顶元素时才插入
        if(min.isEmpty()||min.peek()>=x){
            min.push(x);
        }
    }

    public void pop() {
        if(!stack.isEmpty()) {
            int pop=stack.pop();
            //出栈的元素等于辅助栈顶元素时才出辅助栈
            if(pop==min.peek()) {
                min.pop();
            }
        }else {
            throw new RuntimeException("栈为空，非法操作");
        }
    }

    public int top() {
        if(!stack.isEmpty()) {
            return stack.peek();
        }else {
            throw new RuntimeException("栈为空，非法操作");
        }
    }

    public int getMin() {
        if(!min.isEmpty()) {
            return min.peek();
        }
        else {
            throw new RuntimeException("栈为空，非法操作");
        }
    }
```

---
title: 160. 相交链表
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

**题目描述：**

编写一个程序，找到两个单链表相交的起始节点。



如下面的两个链表**：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。





## 算法一：用集合存储

**算法思想：**

- 对A链先遍历一遍，然后将其中的节点都存储在一个集合中，然后再遍历第二个链表B，寻找其中在集合中出现的第一个节点即为所求



**算法实现：**

```
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        List<ListNode> listA=new LinkedList<>();
        ListNode p=headA;
        //首先将A链中的节点存储到集合中
        while (p!=null){
            listA.add(p);
            p=p.next;
        }
        p=headB;
        while (p!=null){
            if(listA.contains(p)) return p;
            p=p.next;
        }
        return null;
    }
```



**算法分析：**

- **时间复杂度：**O(m+n)，其中m，n分别为A链和B链的长度
- **空间复杂度：**O(m)





## 算法二：双指针法

**算法思想：**

- 首先提供一个寻找一对**长短链之间长度差**的方法，用两个指针分别指向两链的头部，然后同时向后移动，当一个指针到达尾部时，另一个指针距离尾部的距离就是长度差
- 然后通过拼接链表的方法，使得在短链走到末尾时进入长链，长链到末尾时进入短链，如下图：

![Picture1.png](https://pic.leetcode-cn.com/5651993ddb76ae6a42f0b338aec9382206f567041113f49d6ca670832ac75791-Picture1.png)

图中的相交点即为p==q时的点，若无相交点则会最终走完两个链，返回null



**算法实现：**

```
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p=headA,q=headB;
        while (p!=q){
            p=p==null?headB:p.next;
            q=q==null?headA:q.next;
        }
        return p;
    }
```



**算法分析：**

- **时间复杂度：**O(m+n)，其中m，n分别为A链和B链的长度
- **空间复杂度：**O(1)

---
title: 162. 寻找峰值
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

**题目描述：**

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞。



**示例：**

```
示例 1:

输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。

示例 2:

输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```





## 算法一：一次遍历

**算法思想：**

- 从左向右遍历，若数组一直时递增的，则向后寻找，否则返回第一个下降处的前一个索引即为所求，因为此索引前面的元素为递增，所以显然大于前一个元素，同时后面又是下降的，所以是峰值





**算法实现：**

```
public int findPeakElement(int[] nums) {
        int len=nums.length;
        for(int i=0;i<len-1;i++){
        	//如果递增，就向后寻找，否则返回第一个下降处的索引
            if(nums[i]>nums[i+1]){
                return i;
            }
        }
        //最后如果数组是递增的，则返回最后一个元素
        return len-1;
    }
```





**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)





## 算法二：折半查找

**算法思想：**

- 可以将数组的元素变化画成折线图来看，峰值就是图像中的峰值
- 折半查找就是一次排除一半的元素，通过比较中间点处的变化趋势是增还是减来排除另一半元素
  - 若是增，表示其右半边一定有峰值，所以排除左半边
  - 若是减，表示其左半边一定有峰值，所以排除右半边



**算法实现：**

```
public int findPeakElement(int[] nums) {
        int len=nums.length;
        int start=0,end=len-1;
        while (start<end){
            int mid=(start+end)/2;
            //增，排除左半边
            if(nums[mid]<nums[mid+1]) start=mid+1;
            //减，排除右半边，但此时是令end=mid而不是mid-1,因为此时是		  		               nums[mid]>nums[mid+1],只能排除mid+1右边的
            else end=mid;
        }
        return start;
    }
```



**算法分析：**

- **时间复杂度：**O(logn)
- **空间复杂度：**O(1)

---
title: 166. 分数到小数
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)

**题目描述：**

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。

如果小数部分为循环小数，则将循环的部分括在括号内。



**示例：**

```
示例 1:

输入: numerator = 1, denominator = 2
输出: "0.5"

示例 2:

输入: numerator = 2, denominator = 1
输出: "2"

示例 3:

输入: numerator = 2, denominator = 3
输出: "0.(6)"
```





## 长除法

**算法思想：**

- 对于循环小数，其核心思想是**当商出现循环时，余数也会循环**，所以只要记录下余数出现循环的位置即可
- 用一个哈希表存储余数是哪一位商对应的



**算法实现：**

```
public String fractionToDecimal(int numerator, int denominator) {
        if(numerator==0) return "0";
        if(denominator==0) throw new RuntimeException("操作非法");
        StringBuilder res=new StringBuilder();
        //异或，表示只有一个为负的情况
        if(numerator<0^denominator<0) res.append('-');
        Long dividend=Math.abs(Long.valueOf(numerator));
        Long divisor=Math.abs(Long.valueOf(denominator));
        res.append(dividend/divisor);
        long remainder=dividend%divisor;
        //余数为0直接返回
        if(remainder==0) return res.toString();
        //否则表示余数不为0，则肯定有小数部分
        res.append('.');
        Map<Long,Integer> map=new HashMap<>();
        //当余数不为0时循环，若是有限小数，则会最终因为余数为0，跳出循环；无限循环小数则因			  为下面的break跳出
        while (remainder!=0){
        	//判断余数是否出现循环
            if(map.containsKey(remainder)){
                res.insert(map.get(remainder),"(");
                res.append(')');
                break;
            }
            map.put(remainder,res.length());
            remainder*=10;
            res.append(String.valueOf(remainder/divisor));
            remainder%=divisor;
        }
        return res.toString();
    }
```

---
title: 169. 多数元素
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

**题目描述**

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。



**示例：**

```
示例 1:

输入: [3,2,3]
输出: 3


示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2
```





## 算法一：哈希表

**算法思想：**

- 用一个哈希表来存储数组中每一个元素的出现次数，然后再寻找其中出现大于n/2的元素



**算法实现：**

```
public int majorityElement(int[] nums) {
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(nums[i])) map.put(nums[i],map.get(nums[i])+1);
            else map.put(nums[i],1);
        }
        for(Integer key:map.keySet()){
            if(map.get(key)>nums.length/2) return key;
        }
        return 0;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



## 算法二：计数比较法

**算法思想：**

- 首先如果有一个元素其个数大于n/2，那么可以得出其个数比其他所有元素的个数加起来都要多
- 所以可以设置一个数num来记录当前元素compare的个数，如果相同，则num+1，否则不同，num-1，同时当num等于0时，则换其下一个元素为compare来记录，则最后得出的使num大于0的元素即为所求



**算法实现：**

```
public int majorityElement(int[] nums) {
        int num=0,compare=nums[0];
        for(int i=0;i<nums.length;i++){
        	//如果相同，num++；否则num--；
            if(nums[i]==compare) num++;
            else num--;
            //当num为0时，换下一个元素统计，因为题中表示一定有多数元素存在，所以没有考虑数	   			组越界情况
            if(num==0) compare=nums[i+1];
        }
        return compare;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 17. 电话号码的字母组合
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

**题目描述：**

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

 ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png) 

---

**示例：**

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```



---



**算法描述：**

> **回溯法**（其实本算法并不是传统意义上的回溯法，没有回溯与剪枝）

1. 如果输入的字符串长度为0或者为`null`，则返回一个空的列表
2. 否则，调用方法`backtrack(String combination, String next_digits),combination表示当前已经拼接后的字符串（还没有拼完）,next_digits表示还未参与拼接的字符串`
   - 在方法中，首先要判断`next_digits`的长度是否为0，如果为0则表示全部的字符都已经拼接完了，直接将`combination`加到list中
   - 否则，表示没拼接完，则在`combination`后加上符合条件的字符，然后将`next_digits`去掉第一个字符后再递归调用`backtrack`方法



**算法实现：**

```
public class Solution1 {
    //phone集合封装数字和字母的对应关系
    Map<String, String> phone = new HashMap<String, String>() {
        put("2", "abc");
        put("3", "def");
        put("4", "ghi");
        put("5", "jkl");
        put("6", "mno");
        put("7", "pqrs");
        put("8", "tuv");
        put("9", "wxyz");
    };
    //最终结果
    List<String> output = new ArrayList<String>();

    public void backtrack(String combination, String next_digits) {
        //表示没有字符要拼接了，直接把结果加入到集合中
        if (next_digits.length() == 0) {
            output.add(combination);
        }
        else {
            
            String digit = next_digits.substring(0, 1);
            String letters = phone.get(digit);
            for (int i = 0; i < letters.length(); i++) {
                String letter = phone.get(digit).substring(i, i + 1);
                backtrack(combination + letter, next_digits.substring(1));
            }
        }
    }

    public List<String> letterCombinations(String digits) {
        //如果digits长度不为0，则调用递归函数
        if (digits.length() != 0)
            backtrack("", digits);
        return output;
    }
}
```



----

**注意：** 由于字符串的不可变性，所以 `next_digits.substring(1)`不会改变 ``next_digits`的值，而是创建了一个字符串来接受了新的值。并传入到了新的递归中。

---
title: 171. Excel表列序号
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [171. Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)

**题目描述：**
给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

```
 	A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```



**示例：**

```
示例 1:

输入: "A"
输出: 1

示例 2:

输入: "AB"
输出: 28

示例 3:

输入: "ZY"
输出: 701
```



## 算法

**算法思想：**

- 类似于二进制与十进制之间的转换



**算法实现：**

```
public int titleToNumber(String s) {
        int len=s.length();
        int res=0;
        //从后向前加，相当于从各位开始加
        for(int i=len-1;i>=0;i--){
            int num=s.charAt(i)-'A'+1;
            res+=num*Math.pow(26,len-i-1);
        }
        return res;
    }
```

------

---
title: 172. 阶乘后的零
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

**题目描述：**

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。



**示例：**

```
示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。

示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```



## 算法

**算法思想：**

- 尾数上有0，首先想到是乘了一个10，但是5！=120有一个0，这是因为5*2=10，所以后面多了一个0，因此想到可以去统计其中5的个数
- 但需要注意的是，5，10，15，20，25，...，中25可以分解为5*5，所以其中是有两个5的，会给尾数带来两个0而不是一个0；同理125=5×5×5，所以有三个5
- 所以最后的结果可以表示为n/5+n/25+n/125+.....(注意n/25前面没有乘2，因为再算n/5时已经算了一遍，所以补上一遍就可以了，后面一样)



**算法实现：**

```
public int trailingZeroes(int n) {
        int res=0;
        while (n>0){
            res+=n/5;
            n=n/5;
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(logn),底数为5
- **空间复杂度：**O(1)---
title: 179. 最大数
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [179. 最大数](https://leetcode-cn.com/problems/largest-number/)

**题目描述：**

给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。



**示例：**

```
示例 1:

输入: [10,2]
输出: 210


示例 2:

输入: [3,30,34,5,9]
输出: 9534330
```





## 算法：自定义排序

**算法思想：**

- 通过自定义的顺序使得数组降序排列，然后再一个一个拼接起来就可以得到结果，需要特别注意的是排序后，第一个元素为"0"的情况，表明其中所有元素都是"0"，所以直接返回0即可



**算法实现：**

```
	//实现comparator接口
	private class LargerNumberComparator implements Comparator<String>{
        @Override
        public int compare(String t1, String t2) {
        	//字符串拼接
            String a=t1+t2,b=t2+t1;
            //当b>a即a<b时返回正数，即a>b时返回负，所以时按照拼接后降序排列的
            return b.compareTo(a);
        }
    }
    public String largestNumber(int[] nums) {
    	//转换为字符串数组
        String[] strs=new String[nums.length];
        for(int i=0;i<nums.length;i++){
            strs[i]=String.valueOf(nums[i]);
        }
        //排序
        Arrays.sort(strs,new LargerNumberComparator());
        //如果第一个为"0"，直接返回"0"
        if("0".equals(strs[0])) return "0";
        StringBuilder res=new StringBuilder();
        for(int i=0;i<strs.length;i++){
            res.append(strs[i]);
        }
        return res.toString();
    }
```



**算法分析：**

- **时间复杂度：**O(nlogn)，sort的时间复杂度
- **空间复杂度：**O(n)



**说明：**

- 字符串的compare方法，比较的是字符的ASCII值差值，从第一个字符开始比较，若第一个字符相同，则比较下一个字符，详情见博客：

  > [https://blog.csdn.net/qq_40922845/article/details/100087613?ops_request_misc=%7B%22request%5Fid%22%3A%22158296628819725247623672%22%2C%22scm%22%3A%2220140713.130056874..%22%7D&request_id=158296628819725247623672&biz_id=0&utm_source=distribute.pc_search_result.none-task](https://blog.csdn.net/qq_40922845/article/details/100087613?ops_request_misc={"request_id"%3A"158296628819725247623672"%2C"scm"%3A"20140713.130056874.."}&request_id=158296628819725247623672&biz_id=0&utm_source=distribute.pc_search_result.none-task)

- 另一个思考comparator接口中的方法compare的返回值的方法：若返回值大于0，表示两个元素不交换；若小于0则交换，但是两个比较的元素时逆序的

  > 例如，对数组[2,1,3]，若compare方法中返回的是return a-b，即a>b时不交换；但是比较的两个元素是2和1时，a=1，b=2(逆序，通过debug发现的),所以有a<b要交换成1，3---
title: 189. 旋转数组
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

**题目描述：**

给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。



**示例：**

```
示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]


示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```



## 算法：反转

**算法思想：**

- 以[1,2,3,4,5,6,7]为例，右移3个位置，可以先将[5,6,7]和[1,2,3,4]分别翻转得到[4,3,2,1,7,6,5]，然后再整体反转得到[5,6,7,1,2,3,4]即为最终结果



**算法实现：**

```
public void rotate(int[] nums, int k) {
        int len=nums.length;
        //k先取模
        k=k%len;
        //分别反转
        reverse(nums,0,len-k-1);
        reverse(nums,len-k,len-1);
        reverse(nums,0,len-1);
    }
    //反转函数
    private void reverse(int[] nums,int start,int end){
        while (start<end){
            int temp=nums[start];
            nums[start]=nums[end];
            nums[end]=temp;
            start++;
            end--;
        }
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 19.删除链表的倒数第N个节点
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# 19.删除链表的倒数第N个节点

**描述：**

​		给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。 



**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```



**说明：**

 		给定的 *n* 保证是有效的。 

---



**算法思路：**

1. 若只有一个节点，则直接删除，返回null

2. 否则，令p和q指向第一个节点，`prevq`也指向第一个节点，但其表示的是q的前一个节点
3. 首先让p独自向后移动n步
   - 若移动到了末尾，则表明n达到最大为链表长度，表示删除第一个节点
   - 否则让q和`prevq`与p同步向后移动(`prevq`指向q的前一个节点，方便删除)，直到p移动到末尾





---

**算法实现如下：**

```
public ListNode removeNthFromEnd(ListNode head, int n){
        //若只有一个节点，则直接删除，返回null
        if(head.next==null) return null;
        ListNode p=head;
        ListNode q=head;
        ListNode prevq=head;
        int rev=0;
        //首先让p独自后移n位
        for(int i=0;i<n;i++){
            p=p.next;
        }
        //若p移动到了末尾，即p为null时，删除头节点
        if(p==null){
            head=head.next;
        }
        //若没移动到末尾，则三个指针同步移动
        while(p!=null){
            p=p.next;
            //让prevq指向q的前一个节点
            prevq=q;
            q=q.next;
        }
        //删除节点q
        prevq.next=q.next;
        return head;
    }
```



**算法改进：**

> 在上面的算法中，单独将删除头节点的情况拿出来了，而通过在头节点前再田间一个哑节点的方式，可以将这种情况归到普通情况中。





**算法实现：**

```
public ListNode removeNthFromEnd(ListNode head, int n){
        ListNode dummy=new ListNode(0);
        dummy.next=head;
        ListNode p=head;
        for(int i=0;i<n;i++){
            p=p.next;
        }
        ListNode q=head;
        ListNode prev=dummy;
        while (p!=null){
            p=p.next;
            prev=q;
            q=q.next;
        }
        prev.next=q.next;
        //注意最后要返回dummy.next,而不能返回head
        return dummy.next;
    }
```



---
title: 190. 颠倒二进制位
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

**题目描述：**

颠倒给定的 32 位无符号整数的二进制位。



**示例：**

```
示例 1：

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
      
示例 2：

输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。
```





## 位运算

**算法思想：**

- 颠倒32位无符号整数的二进制可以通过将从低位开始之后的每一位插入在其低位的后面，以1010为例，先插入0，然后在0后面插入1，接着是0和1，得到0101
- **需要注意的是位运算是以补码作为运算的**



**算法实现：**

```
public int reverseBits(int n) {
        int count=0;
        int res=0;
        //因为是以补码作为运算，所以要循环32位
        while (count<32){
        	//为插入下一位做好准备，留下一个空位
            res=res<<1;
            //得到n的最后一位，并将其插入res的末位
            res|=n&1;
            //n右移一位
            n=n>>1;
            count++;
        }
        return res;
    }
```

---
title: 191. 位1的个数
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

**题目描述：**

编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。



**示例：**

```
示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。


示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。


示例 3：

输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```





## 算法一：位运算

**算法思想：**

- 依次将n与1按位求与，得到最后一位，如果是1结果++，然后将n左移一位再判断下一位



**算法实现：**

```
public int hammingWeight(int n) {
        int count=0;
        int res=0;
        while (count<32){
        	//最后一位是1，结果++
            if((n&1)==1) res++;
            //n右移一位
            n>>=1;
            count++;
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(1)，上面的循环执行32次，常数次幂
- **空间复杂度：**O(1)





## 算法二：位掩码

**算法思想：**

- 采用掩码的方式，例如001，010，100，与掩码按位与可以得到对应位的数字，如果最终结果不为0，则结果++



**算法实现：**

```
// you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        //mask为掩码
        int mask=1;
        int res=0;
        while (count<32){
            if((n&mask)!=0) res++;
            //mask每次左移一位得到下一位的掩码
            mask<<=1;
            count++;
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(1)，上面的循环执行32次，常数次幂
- **空间复杂度：**O(1)





## 算法三：n与n-1的按位与

**算法思想：**

- n与n-1的按位与有如下图的规律：

  ![image.png](https://pic.leetcode-cn.com/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png)

- 可以发现n&(n-1)后与原结果相比，只是少了最低位的一个1，因此可以不停的将取n&(n-1)，直到n为0，表示已经没有1了





**算法实现：**

```
public int hammingWeight(int n) {
        int res=0;
        while (n!=0){
            res++;
            n=n&(n-1);
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(1)，上面的循环的次数为n中1的个数，所以最大为32次，也是常数次幂
- **空间复杂度：**O(1)---
title: 198. 打家劫舍
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

**题目描述：**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。



**示例：**

```
示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
     
示例 2:

输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```



## 算法一：动态规划

**算法思想：**

- 用数组memo来表示以对应索引的元素为开头的数组的最大盗窃金额，则递归起点`memo[memo.length-1]=0;memo[memo.length-2]=nums[nums.length-1];`，然后依次向前递推，递推关系为：例如以nums[i]元素为开头的数组的最大盗窃金额只有两种情况：
  1. 最大盗窃金额包括盗窃nums[i]，则等于nums[i]+memo[i+2]；
  2. 最大盗窃金额不包括nums[i]，则等于memo[i+1];



**算法实现：**

```
private int[] memo;
    public int rob(int[] nums) {
        if(nums.length==0) return 0;
        memo=new int[nums.length+1];
        //递推起点
        memo[memo.length-1]=0;
        memo[memo.length-2]=nums[nums.length-1];
        for(int i=memo.length-3;i>=0;i--){
            memo[i]=Math.max(nums[i]+memo[i+2],memo[i+1]);
        }
        //memo[0]即为所求
        return memo[0];
    }
```



**算法分析：**

- **时间复杂度：**O(n)，一次遍历即可
- **空间复杂度：**O(n)





## 算法二：动态规划改进

**算法思想：**

- 从上面的递推过程中发现，一直用到的是其后面一个元素开头的数组的最大盗窃金额和后面第二个元素的最大盗窃金额，所以可以单独将两个值记录下来，然后不停更新来代替数组



**算法实现：**

```
public int rob(int[] nums) {
        if(nums.length==0) return 0;
        //currMax表示其后一个元素开头数组的最大盗窃金额；prev表示其后第二个元素开头数组的最大盗			窃金额
        int currMax=0,prevMax=0;
        //这里是从前向后递推的
        for(int i=0;i<nums.length;i++){
        	//更新prevMax和currMax的值
            int temp=currMax;
            currMax=Math.max(currMax,prevMax+nums[i]);
            prevMax=temp;
        }
        return currMax;
    }
```



**算法分析：**

- **时间复杂度：**O(n)，一次遍历即可

- **空间复杂度：**O(1)

  

  ---
title: 200. 岛屿数量
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

**题目描述：**

给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。



**示例：**

```
示例 1:

输入:
11110
11010
11000
00000

输出: 1


示例 2:

输入:
11000
11000
00100
00011

输出: 3
```





## 算法一：深度优先递归形式

**算法思路：**

- 可以将题目转换为图，将相邻或者竖直的两个1之间看作有边，图中的连通分量个数即为所求



**算法实现：**

```
public int numIslands(char[][] grid) {
        int m=grid.length;
        if(m==0) return 0;
        int n=grid[0].length;
        //res为结果
        int res=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
            	//每一次dfs结束即访问完了所有的连通分量，res++
                if(grid[i][j]=='1'){
                    dfs(grid,i,j);
                    res++;
                }
            }
        }
        return res;
    }

    private void dfs(char[][] grid,int x,int y){
        int m=grid.length;
        int n=grid[0].length;
        //索引不合法
        if(x<0||y<0||x>m-1||y>n-1) return;
        if(grid[x][y]=='1'){
        	//首先要将值改为'0'，其实是来标记本次dfs已经访问过这个元素
            grid[x][y]='0';
            //然后向四个方向访问
            dfs(grid,x-1,y);
            dfs(grid,x+1,y);
            dfs(grid,x,y-1);
            dfs(grid,x,y+1);
        }
    }
```



**算法分析：**

- **时间复杂度：**O(m*n)，按深度优先的方式依次访问了值为'1'的元素，所以最坏情况下时间复杂度为m×n
- **空间复杂度：**O(m*n)，最坏情况下，都是1，递归栈深度为m×n





## 算法二：深度优先迭代形式

**算法实现：**

```
	//自定义类存放坐标
	private class Coordinate{
        public int x;
        public int y;
        public Coordinate(int x,int y){
            this.x=x;
            this.y=y;
        }
    }
    public int numIslands(char[][] grid) {
        int m=grid.length;
        if(m==0) return 0;
        int n=grid[0].length;
        int i=0,j=0;
        int res=0;
        while (i<m&&j<n){
        	//用栈来模拟递归的效果
            Stack<Coordinate> stack=new Stack<>();
            if(grid[i][j]=='1'){
                grid[i][j]='0';
                stack.push(new Coordinate(i,j));
                while (!stack.isEmpty()){
                	//此时是访问栈顶元素，而不是出栈
                    Coordinate curr=stack.peek();
                    //然后依次访问四个方向的元素
                    if(curr.x-1>=0&&grid[curr.x-1][curr.y]=='1'){
                        grid[curr.x-1][curr.y]='0';
                        stack.push(new Coordinate(curr.x-1,curr.y));
                        //这里要加上continue，因为是深度优先，要以新加入这个节点作为初始节点再						  去遍历
                        continue;
                    }
                    if(curr.x+1<m&&grid[curr.x+1][curr.y]=='1'){
                        grid[curr.x+1][curr.y]='0';
                        stack.push(new Coordinate(curr.x+1,curr.y));
                        continue;
                    }
                    if(curr.y-1>=0&&grid[curr.x][curr.y-1]=='1'){
                        grid[curr.x][curr.y-1]='0';
                        stack.push(new Coordinate(curr.x,curr.y-1));
                        continue;
                    }
                    if(curr.y+1<n&&grid[curr.x][curr.y+1]=='1'){
                        grid[curr.x][curr.y+1]='0';
                        stack.push(new Coordinate(curr.x,curr.y+1));
                        continue;
                    }
                    //最后周围都是0或者都被访问之后再出栈
                    stack.pop();
                }
                //访问完了一个连通分量
                res++;
            }
            //判断下一个元素
            if(j<n-1) j++;
                else{
                    i++;
                    j=0;
                }
        }
        return res;
    }
```





**算法分析：**

- **时间复杂度：**O(m*n)，按深度优先的方式依次访问了值为'1'的元素，所以最坏情况下时间复杂度为m×n
- **空间复杂度：**O(m*n)，最坏情况下，都是1，栈的长度为m×n





## 算法三：广度优先遍历

**算法思想：**

- 注意体会广度优先和深度优先的差别



**算法实现：**

```
private class Coordinate{
        public int x;
        public int y;
        public Coordinate(int x,int y){
            this.x=x;
            this.y=y;
        }
    }
    public int numIslands(char[][] grid) {
        int m=grid.length;
        if(m==0) return 0;
        int n=grid[0].length;
        int i=0,j=0;
        int res=0;
        while (i<m&&j<n){
        	//使用的是队列
            Queue<Coordinate> queue=new LinkedList<>();
            if(grid[i][j]=='1'){
                grid[i][j]='0';
                queue.add(new Coordinate(i,j));
                while (!queue.isEmpty()){
                	//每次队列直接出队
                    Coordinate curr=queue.poll();
                    if(curr.x-1>=0&&grid[curr.x-1][curr.y]=='1'){
                        grid[curr.x-1][curr.y]='0';
                        queue.add(new Coordinate(curr.x-1,curr.y));
                       	//添加新的节点后，继续进行下main的判断，不跳出去
                    }
                    if(curr.x+1<m&&grid[curr.x+1][curr.y]=='1'){
                        grid[curr.x+1][curr.y]='0';
                        queue.add(new Coordinate(curr.x+1,curr.y));
                    }
                    if(curr.y-1>=0&&grid[curr.x][curr.y-1]=='1'){
                        grid[curr.x][curr.y-1]='0';
                        queue.add(new Coordinate(curr.x,curr.y-1));
                    }
                    if(curr.y+1<n&&grid[curr.x][curr.y+1]=='1'){
                        grid[curr.x][curr.y+1]='0';
                        queue.add(new Coordinate(curr.x,curr.y+1));
                    }
                }
                res++;
            }
            if(j<n-1) j++;
                else{
                    i++;
                    j=0;
                }
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(m*n)，按广度优先的方式依次访问了值为'1'的元素，所以最坏情况下时间复杂度为m×n
- **空间复杂度：**O(min(m,n))---
title: 202. 快乐数
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

**题目描述：**

编写一个算法来判断一个数是不是“快乐数”。

一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。



**示例：**

```
输入: 19
输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```



## 快慢指针

**算法思想：**

- 判断是快乐数很简单，只需要判断平方和在有限循环内最后为1即可，而判断不是则很困难，因为在无限循环下不能到达1不能模拟
- 这里说明如果不是快乐数 最终会出现4 16 37 58 89 145 42 20 4循环
- 所以只要判断其是否进入了循环就可以得到其是否为快乐数，通过快慢指针的方法，如果快指针追上慢指针就开始循环了



**算法实现：**

```
public boolean isHappy(int n) {
        int fast=n,slow=n;
        do {
        	//fast每次走两步，slow每次走一步
            fast=squareSum(fast);
            fast=squareSum(fast);
            slow=squareSum(slow);
            if(slow==1) return true;
        }while (fast!=slow);
        return false;
    }
	
	//求平方和的方法
    private int squareSum(int n){
        int res=0;
        while (n!=0){
            res+=(n%10)*(n%10);
            n=n/10;
        }
        return res;
    }
```



---
title: 204. 计数质数
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

**题目描述：**

统计所有小于非负整数 *n* 的质数的数量。



**示例：**

```
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```





## 厄拉多塞筛法

**算法思想：**

- 首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8... 都不可能是素数了。

  然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12... 也都不可能是素数了。



**算法实现：**

```
public int countPrimes(int n) {
        boolean[] isPrim=new boolean[n];
        Arrays.fill(isPrim,true);
        //i从2开始，如果i是素数那么他的整数倍的数都不是素数
        for(int i=2;i<n;i++){
            if(isPrim[i]){
                for(int j=2*i;j<n;j+=i) isPrim[j]=false;
            }
        }
        int count=0;
        for(int i=2;i<n;i++){
            if(isPrim[i]) count++;
        }
        return count;
    }
```

---
title: 206. 反转链表
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

**题目描述：**反转一个单链表。



**示例：**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```



## 算法一：递归

**算法思想：**

- 递归函数可以这样设计：以反转链表1->2->3->4->5为例，先将头节点单独拿出来，然后递归反转剩下的2->3->4->5，然后将后面链表的头节点2指向原头节点1可以得到最终结果



**算法实现：**

```
public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        return helper(head);
    }
    private ListNode helper(ListNode head){
        if(head==null||head.next==null) return head;
        //用node记录头节点之后的一个节点，然后将两个链断开
        ListNode node=head.next;
        head.next=null;
        //递归反转后一条链，此时返回的节点作为新的链表头节点返回
        ListNode newHead = helper(node);
        //node节点指向原链表头节点的后一个节点，反转后变成后面链表的最后一个节点，令其指向原头节点
        node.next=head;
        return newHead;
    }
```



**说明：**

- 以反转链表1->2->3->4->5为例，首先：
  - head指向1，node指向2，断链得到两个链1和2->3->4->5，然后递归反转2->3->4->5；
  - 在递归反转2->3->4->5中，head指向2，node指向3，断链得到两个链2和3->4->5，然后递归反转3->4->5；
  - 在递归反转3->4->5中，head指向3，node指向4，断链得到两个链3和4->5，然后递归反转4->5；
  - 在递归反转4->5中，head指向4，node指向5，断链得到两个链4和5，然后递归反转5；
  - 由于5的next为空，所以直接返回到上一步递归反转4->5过程中，node.next=head，就可以得到5->4，然后5作为新的头节点返回上一步递归反转3->4->5，得到5->4->3.........
  - **分析上面的递归调用过程对理解递归很有帮助**



**算法分析：**

- **时间复杂度：**O(n)，时间复杂度递推关系式T(n)=T(n-1)+1，后面的+1是因为在一次递归中其他的步骤都是常数次
- **空间复杂度：**O(n)，递归栈深度就是链表的长度



## 算法二：迭代

**算法思想：**

- 将上面的递归过程改为迭代过程



**算法实现：**

```
public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        //newHead指向新的头节点
        ListNode newHead=null;
        boolean flag=true;
        Stack<ListNode> stack=new Stack<>();
        stack.push(head);
        while (!stack.isEmpty()){
        	//注意是peek，不是pop
            ListNode node = stack.peek();
            if(node.next==null){
                node=stack.pop();
                //尾节点即为新的头节点，所以第一次node,next为空时的节点即为newHead
                if(flag){
                    newHead=node;
                    flag=false;
                }
                if(stack.isEmpty()){
                    node.next=null;
                }else {
                    node.next = stack.peek();
                }
            }else {
                ListNode next=node.next;
                node.next=null;
                stack.push(next);
            }
        }
        return newHead;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



## 算法三：头插法

**算法思想：**

- 头插法是每次在插入节点时插在链表的头部，所以结果产生的链表是反的，可以用来反转链表



**算法实现：**

```
public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        //Hhead为一个新的哨兵
        ListNode Hhead=new ListNode(0);
        ListNode p=head,q=head;
        //头插法需要记住在插入前的头节点，用next来记录
        ListNode next=null;
        while (p!=null){
            q=q.next;
            p.next=next;
            Hhead.next=p;
            //更新next
            next=p;
            p=q;
        }
        return Hhead.next;
    }
```





**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)





## 算法四：顺序遍历

**算法思想：**

- 顺序遍历，将每一个节点的next域逆置即可，但要注意防止断链



**算法实现：**

```
public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode node=head.next,prev=head,next=head.next.next;
        head.next=null;
        while (node!=null){
            node.next=prev;
            if(next==null) break;
            prev=node;
            node=next;
            next=next.next;
        }
        return node;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 207. 课程表
date: 2020-05-29 17:51:24
tags: leetcode
categories: leetcode
---

# [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

**题目描述：**

现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？



**示例：**

```
示例 1:

输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。


示例 2:

输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```





## 算法一：拓扑排序

**算法思想：**

- 题目中的条件可以转换为有向图，能完成全部课程就是图中没有环，判断是否有环可以用拓扑排序，每次找到入度为0的点，然后删除以它为起点的边，之后接着去寻找入度为0的点直到所有的点都变成入度为0则表示没有环，或者最后找不到入度为0的点则表示有环



**算法实现：**

```
	//memo记录哪些节点已经因为入度为0而删除了其相邻的边
	private List<Integer> memo;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if(prerequisites==null||prerequisites.length==0) return true;
        memo=new ArrayList<>();
        for(int i=0;i<numCourses;i++){
            Integer res=searchStarting(numCourses,prerequisites);
            if (res==null) return false;
            int startPoint=res;
            deleteSide(startPoint,prerequisites);
        }
        return true;
    }
	
	//寻找入度为0的点
    private Integer searchStarting(int numCourses,int[][] prerequisities){
        boolean flag=true;
        int i=0;
        for(i=0;i<numCourses;i++){
            flag=true;
            //如果该点已经被删除了，则不能重复
            if(memo.contains(i)) {
                flag=false;
                continue;
            }
            for(int j=0;j<prerequisities.length;j++){
                if(prerequisities[j][1]==i) {
                    flag=false;
                    break;
                }
            }
            if (flag) break;
        }
        //更新memo
        if(flag) memo.add(i);
        return flag?i:null;
    }
	
	//此方法是将以startPoint为起点的边删除，其实是将以startPoint开头的边的终点也设为startPoint
    private void deleteSide(int startPoint,int[][] prerequisities){
        for(int i=0;i<prerequisities.length;i++){
            if(prerequisities[i][0]==startPoint) prerequisities[i][1]=startPoint;
        }
    }
```



**结果显示超时**



## 算法二：入度表

**算法思想：**

- 用一个入读表indegrees来记录每个顶点的入度，将入度为0的节点存储到一个队列中去、
- 删除入度为0的顶点，并不是真的删除，而是将与其相连的后继节点删除



**算法实现：**

```
public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegrees=new int[numCourses];
        //更新入读表的值
        for(int[] nums:prerequisites){
            indegrees[nums[1]]++;
        }
        Queue<Integer> queue=new LinkedList<>();
        for(int i=0;i<numCourses;i++){
            if(indegrees[i]==0) queue.add(i);
        }
        while (!queue.isEmpty()){
            Integer curr = queue.poll();
            numCourses--;
            for(int[] nums:prerequisites){
                if(nums[0]==curr){
                    indegrees[nums[1]]--;
                    if(indegrees[nums[1]]==0) queue.add(nums[1]);
                }
            }
        }
        //最后判断是否所有的节点都可以变成入度为0
        return numCourses==0;
    }
```



**算法分析：**

- **时间复杂度：**O(N+M)，遍历一个图需要访问所有节点和所有临边，N*N* 和 M*M* 分别为节点数量和临边数量；
- **空间复杂度：**O(N)，入度表的大小为N---
title: 208. 实现 Trie (前缀树)
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

**题目描述：**

实现一个 Trie (前缀树)，包含 `insert`, `search`, 和 `startsWith` 这三个操作



**示例：**

```
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```



## Trie树

**算法思想：**

- 构造一个新的树型数据结构，其输入多叉树，假设所有输入都是小写字母，最后是26叉树，每一个节点由两个字段构成：
  1. 26个指向字节的链接组成的数组
  2. 标记当前节点是否为节点的布尔值

![无效的图片地址](https://pic.leetcode-cn.com/3463d9e7cb323911aa67cbd94910a34d88c9402a1ab41bbea10852cd0a74f2af-file_1562596867185)

​                                                  leet在该数据结构中的显示



- `TrieNode`的实现如下：

````
class TrieNode{
        private TrieNode[] links;
        private final int R=26;
        private boolean isEnd;

        public TrieNode(){
            links=new TrieNode[R];
        }

        public boolean containKey(char ch){
            return links[ch-'a']!=null;
        }

        public TrieNode get(char ch){
            return links[ch-'a'];
        }

        public void put(char ch,TrieNode node){
            links[ch-'a']=node;
        }
        public void setEnd(){
            isEnd=true;
        }

        public boolean isEnd(){
            return isEnd;
        }
    }
````



最后的实现如下：

```
private TrieNode root;
    public Trie() {
        root=new TrieNode();
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode node=root;
        for(int i=0;i<word.length();i++){
        	//依次插入一个字母
            if(node==null||!node.containKey(word.charAt(i))){
                node.put(word.charAt(i),new TrieNode());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode node=root;
        for(int i=0;i<word.length();i++){
            if(!node.containKey(word.charAt(i))) return false;
            node=node.get(word.charAt(i));
        }
        //最后返回当前node是否是最后一位
        return node.isEnd();
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.containKey(prefix.charAt(i))) return false;
            node=node.get(prefix.charAt(i));
        }
        //判断前缀直接返回true就可
        return true;
    }
```

---
title: 209.长度最小的子数组
date: 2020-07-05 21:53:06
tags: leetcode
categories: leetcode
---

# [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

**题目描述：**

给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的子数组，并返回其长度**。**如果不存在符合条件的子数组，返回 0。

```
示例：

输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```





## 滑动窗口

**算法思想：**

- 用l，r分别记录滑动窗口的左边界和右边界，sum记录当前从窗口数组和，如果sum<s，则窗口需要右移；否则当sum>=s时，则窗口需要左移直到sum<s.

```
public int minSubArrayLen(int s, int[] nums) {
        if(nums==null||nums.length==0) return 0;
        int l=0,r=0,sum=0,res=Integer.MAX_VALUE;
        while(r<nums.length){
            sum+=nums[r];
            while(sum>=s){
                res=Math.min(res,r-l+1);
                sum-=nums[l];
                l++;
            }
            r++;
        }
        return res==Integer.MAX_VALUE?0:res;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 210. 课程表 II
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

**题目描述：**

现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。



**示例：**

```
示例 1:

输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2:

输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```



## 入读表

**算法思想：**

- 思路同207题，再用一个数据来存储每次出队的元素即可





**算法实现：**

```
public int[] findOrder(int numCourses, int[][] prerequisites) {
        int[] res=new int[numCourses];
        int[] indegrees=new int[numCourses];
        for(int[] nums:prerequisites){
            indegrees[nums[0]]++;
        }
        Queue<Integer> queue=new LinkedList<>();
        for(int i=0;i<numCourses;i++){
            if(indegrees[i]==0) queue.add(i);
        }
        int i=0;
        while (!queue.isEmpty()){
            Integer num = queue.poll();
            res[i++]=num;
            for(int[] nums:prerequisites){
                if(nums[1]==num){
                    if(--indegrees[nums[0]]==0) queue.add(nums[0]);
                }
            }
            numCourses--;
        }
        return numCourses==0?res:new int[0];
    }
```

---
title: 214.最短回文串
date: 2020-06-21 21:45:58
tags: leetcode
categories: leetcode
---

# [214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)

**题目描述：**

给定一个字符串 ***s***，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

```
示例 1:

输入: "aacecaaa"
输出: "aaacecaaa"


示例 2:

输入: "abcd"
输出: "dcbabcd"
```





## 暴力法

**算法思想：**

- 由于只能在左边添加字符使得其称为回文串，所以找到从左边第一个字符开始的最长回文字符串即可。

```
public String shortestPalindrome(String s) {
        if(s==null||s.length()==0) return s;
        char[] chars=s.toCharArray();
        int i=s.length()-1;
        while(i>=0){
            if(isMirror(chars,i))
                break;
            i--;
        }
        StringBuilder res=new StringBuilder();
        for(int j=s.length()-1;j>i;j--){
            res.append(s.charAt(j));
        }
        res.append(s);
        return res.toString();
    }

    private boolean isMirror(char[] chars,int i){
        int l=0;
        while(l<i){
            if(chars[l]!=chars[i])
                return false;
            l++;
            i--;
        }
        return true;
    }
```

---
title: 215. 数组中的第K个最大元素
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

**题目描述：**

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。



**示例：**

```
示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5

示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```



## 算法一：排序

**算法思想：**

- 直接排序，然后再返回第k大的



**算法实现：**

```
public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length-k];
    }
```



**算法分析：**

- **时间复杂度：**O(nlogn)
- **空间复杂度：**O(1)



## 算法二：快速选择

**算法思想：**

- 基于快速排序中的快速选择算法，每次将数组划分成两部分，每次可以确定两部分中间的哪个数是第几大的数，如果满足条件直接返回，否则可以按照大小淘汰掉一部分，在另一部分中寻找



**算法实现：**

```
public int findKthLargest(int[] nums, int k) {
        int start=0,end=nums.length-1;
        while (start<end){
            int low=start,high=end;
            int compare=nums[low];
            while (low<high){
            	//下面一定要有等号(nums[high]>=compare)
                while (low<high&&nums[high]>=compare) high--;
                nums[low]=nums[high];
                while (low<high&&nums[low]<=compare) low++;
                nums[high]=nums[low];
            }
            nums[high]=compare;
            //如果找到的是第k大的元素，直接返回
            if(high-start==end-start-k+1) return compare;
            //否则，如果在左边，更新end的值，同时也要用k减去右边部分元素个数
            else if(high-start>end-start-k+1){
                k=k-(end-high+1);
                end=high-1;
                //如果在右边，直接更新start
            } else {
                start=high+1;
            }
        }
        return nums[end];
    }
```



**算法分析：**

- **时间复杂度：**最好情况下，一次划分一半，时间复杂度为n+n/2+n/4+......=2n，所以为O(n)，最坏情况下时间复杂度为O(n^2^)，平均下时间复杂度为O(n)
- **空间复杂度：**O(1)



## 算法三：小根堆

**算法思想：**

- 维护一个小根堆，依次将数组中的元素加入堆中，堆顶为最小元素，当堆中元素个数大于k时，最小元素出堆，最后堆中只剩下k个元素，堆中剩下的元素一定大于之前出堆的元素，堆中的k个元素就是最大的k个元素，堆顶元素就是第k大的元素



**算法实现：**

```
public int findKthLargest(int[] nums, int k) {
        //PriorityQueue<Integer> heap=new PriorityQueue<>(o1,o2 -> o1-o2);
        PriorityQueue<Integer> heap=new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1-o2;
            }
        });
        for(int n:nums){
            heap.add(n);
            if(heap.size()>k) heap.poll();
        }
        return heap.poll();
    }
```



**说明：**

- java中用PriorityQueue来实现堆，其默认为小根堆，可以传入自定义的Comparator变成大根堆：`PriorityQueue<Integer> heap=new PriorityQueue<>(o1,o2 -> o2-o1);`



**算法分析：**

- **时间复杂度：**O(nlogk)，像大小为 k 的堆中添加元素的时间复杂度为 O(logk)，我们将重复该操作 N 次，故总时间复杂度为 O(Nlogk)。

- **空间复杂度：**O(k)

  ---
title: 217. 存在重复元素
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

**题目描述：**

给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。



**示例：**

```
示例 1:

输入: [1,2,3,1]
输出: true

示例 2:

输入: [1,2,3,4]
输出: false

示例 3:

输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```





## 哈希表

**算法思想：**

- 用一个哈希表存储已经访问过的元素若有重复直接返回true
- 对于哈希表（Java 中的 HashSet 或 HashMap），`search` 和 `insert` 的平均时间复杂度为 *O*(1)



**算法实现：**

```
public boolean containsDuplicate(int[] nums) {
        Set<Integer> set=new HashSet<>();
        for(int num:nums){
            if(set.contains(num)) return true;
            set.add(num);
        }
        return false;
    }
```



**算法分析：**

- **时间复杂度：**O(n),`search` 和 `insert` 的平均时间复杂度为 *O*(1)
- **空间复杂度：**O(n)---
title: 227. 基本计算器 II
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

**题目描述：**实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式仅包含非负整数，`+`， `-` ，`*`，`/` 四种运算符和**空格** ` `。 整数除法仅保留整数部分。



**示例：**

```
示例 1:

输入: "3+2*2"
输出: 7


示例 2:

输入: " 3/2 "
输出: 1


示例 3:

输入: " 3+5 / 2 "
输出: 5
```



## 二刷

实现的没有下面简洁，学习一下，注意四点：

1. 第一遍只计算乘除，第二遍再计算加减
2. 减可以转换为加相反数
3. 数字可能是多位的比如43这种，遇到数字需要要一直向后直到不是数字
4. i多++了一次，后面要i--；

## 栈

**算法思想：**

- 用一个栈来存储操作数，以计算32+2*2为例，首先lastOp为'+'，计算出tempNum为32，所以将32入栈，然后下一次循环将lastOp改为'+'，再计算出tempNum为2，所以2入栈，下一次循环lastOp改为`'×'`,计算出tempNum为2，所以计算res(×，2，2)，将结果4入栈，最后所有结果相加即可。



**算法实现：**

```
public int calculate(String s) {
        Stack<Integer> numStack=new Stack<>();
        //lastOp记录操作符，初始为'+'
        char lastOp='+';
        char[] arr = s.toCharArray();
        for(int i=0;i<arr.length;i++){
        	//空格直接进入下次循环
            if(arr[i]==' ') continue;
            //如果是数字首先要把连续的数字变成十进制储存起来
            if(Character.isDigit(arr[i])){
                int tempNum=arr[i]-'0';
                while (++i<arr.length&&Character.isDigit(arr[i])){
                    tempNum=10*tempNum+arr[i]-'0';
                }i--;  //此处i要--，因为刚跳出上面循环的i指向的不是数字，要么是空格，					要么是操作符，要在下次循环时处理，而下次循环开始i要再++，所以先--
                if(lastOp == '+') numStack.push(tempNum);
                //如果是'-'，则存入相反数
                else if(lastOp == '-') numStack.push(-tempNum);
                //否则乘除就需要先计算
                else numStack.push(res(lastOp, numStack.pop(), tempNum));
                //最后如果不是数字，则要更新操作符
            } else lastOp = arr[i];
        }
		//所有结果相加
        int ans = 0;
        for(int num : numStack) ans += num;
        return ans;
    }
    private int res(char op, int a, int b) {
        if (op == '*') return a * b;
        else if (op == '/') return a / b;
        return 0;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)---
title: 230. 二叉搜索树中第K小的元素
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

**题目描述：**

给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。



**示例：**

```
示例 1:

输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1


示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
```



## 算法一：中序遍历递归

**算法思想：**

- 二叉排序树中第k小的元素就是中序遍历中第k次访问的元素，用一个全局变量来记录当前访问的元素是第几个元素，如果访问的是第k个元素直接返回即可



**算法实现：**

```
	//全局变量k
	private int k;
    public int kthSmallest(TreeNode root, int k) {
        this.k=k;
        Integer res=helper(root);
        if(res==null){
            return 0;
        }else return res;
    }

    private Integer helper(TreeNode root){
        if(root!=null) {
        	//先访问左子树，如果结果不为null，则直接返回
            Integer left=helper(root.left);
            if(left!=null) return left;
            //然后访问自己
            k--;
            if (k == 0) return root.val;
            //右子树
            Integer right=helper(root.right);
            if(right!=null) return right;
        }
        //如果没有找到返回null
        return null;
    }
```



**算法分析：**

- **时间复杂度：**O(n),n为中节点个数
- **空间复杂度：**O(logn)，递归栈的深度为树的高度





## 算法二：中序遍历迭代

**算法思想：**

- **中序遍历的迭代形式**



**算法实现：**

```
public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack=new Stack<>();
        TreeNode curr=root;
        while (curr!=null||!stack.isEmpty()){
            while (curr!=null){
                stack.push(curr);
                curr=curr.left;
            }
            curr=stack.pop();
            if(--k==0) return curr.val;
            curr=curr.right;
        }
        return 0;
    }
```



---
title: 234. 回文链表
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

**题目描述：**

请判断一个链表是否为回文链表。



**示例：**

```
示例 1:

输入: 1->2
输出: false

示例 2:

输入: 1->2->2->1
输出: true
```



## 快慢指针

**算法思想：**

- 使用一对快慢指针，当快指针走到结尾时，慢指针刚好走到链表的中间，在慢指针slow走的同时，将前半部分链表反转
- 需要注意的是当链表长度为奇数时，比较时要跳过中间的元素



**算法实现：**

```
public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null) return true;
        ListNode fast=head.next,slow=head;
        //要反转链表，所以要记录slow的前一个节点和后一个节点
        ListNode prev=null,next=head.next;
        int len=0;
        ListNode node=head;
        //首先的到链表的长度
        while (node!=null) {
            len++;
            node=node.next;
        }
        //开始反转前半部分链表
        head.next=null;
        while (fast!=null&&fast.next!=null){
            fast=fast.next.next;
            //slow向后走的同时反转前半部分链表
            prev=slow;
            slow=next;
            next=next.next;
            slow.next=prev;
        }
        //如果链表的长度为奇数，那么最中间的元素要调过比较
        if(len%2==1) slow=slow.next;
        while (slow!=null&&next!=null){
            if(slow.val!=next.val) return false;
            slow=slow.next;
            next=next.next;
        }
        //最后返回两边是否同时到结尾(此步是多余的，可以直接返回true)
        return slow==null&&next==null;
    }
```



**算法分析：**

- **时间复杂度：**O(n)，总的时间消耗为n+n/2+n/2=2n
- **空间复杂度：**O(1)

---
title: 236.二叉树的最近公共祖先
date: 2020-06-01 14:58:54
tags: leetcode
categories: leetcode
---

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)



# 递归

**算法思想：**

- `lowestCommonAncestor(root,p,q)`中有三种情况，如果全部在左子树，则返回 `lowestCommonAncestor(root.left,p,q)`，如果全部在右子树则返回 `lowestCommonAncestor(root.right,p,q)`，否则左边一个，右边一个，则返回root

```
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
		//如果已经有root==p或root==q，则不用去找它的子树了，只要看它的兄弟节点中是否有另		一个即可
        if(root==null||root==p||root==q) return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        //左子树没有，返回右边
        if(left==null) return right;
        if(right==null) return left;
        //左子树，右子树都不为null，表示一边一个。
        return root;
    }
```

---
title: 238. 除自身以外数组的乘积
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

**题目描述：**

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。



**示例：**

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```



## 算法一：动态规划

**算法思想：**

- 分别计算两个数组left和right的值，其中left[i]表示在原数组中索引在i之前(不包括i)的所有元素的乘积，right[i]表示在原数组中索引在以后(不包括i)的所有元素的乘积，则最终结果output[i]=left[i]×right[i]



**算法实现：**

```
public int[] productExceptSelf(int[] nums) {
        int len=nums.length;
        int[] res=new int[len];
        if(len==0) return res;
        int[] left=new int[len];
        int[] right=new int[len];
        //left[0]和right[len-1]初始值为1
        left[0]=1;
        right[len-1]=1;
        //计算left的值和right的值
        for(int i=1;i<len;i++){
            left[i]=left[i-1]*nums[i-1];
        }
        for(int i=len-2;i>=0;i--){
            right[i]=right[i+1]*nums[i+1];
        }
        for(int i=0;i<len;i++){
            res[i]=left[i]*right[i];
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)





## 算法二：动态规划改进

**算法思想：**

- 上面使用了两个数组来存储对应的值，可以只用两个值来代替，left和right，在计算left的值时将其值赋给结果数组，然后计算right再将其与结果数组相乘即可



**算法实现：**

```
public int[] productExceptSelf(int[] nums) {
        int len=nums.length;
        int[] res=new int[len];
        if(len==0) return res;
        res[0]=1;
        int left=1,right=1;
        //计算left的值时将其值赋给res
        for(int i=1;i<len;i++){
            left*=nums[i-1];
            res[i]=left;
        }
        //计算right时将其与res相乘
        for(int i=len-2;i>=0;i--){
            right*=nums[i+1];
            res[i]*=right;
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 239. 滑动窗口最大值
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

**题目描述：**

给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。



**示例：**

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```



## 双端队列

算法思想：

- 使用一个双端队列来存储元素的索引，其中队头元素保持为最大元素
- 每次元素入队时，如果队列为空，则直接入队；否则需要将其与队尾元素相比较，如果小于队尾元素，直接入队，否则令队列出队直到队尾元素大于当前元素或者队列为空
- 每次插入元素时，需要先将队列中不在滑动窗口范围的元素出队



**算法实现：**

```
public int[] maxSlidingWindow(int[] nums,int k){
        int len=nums.length;
        int[] res=new int[len-k+1];
        //双向队列
        LinkedList<Integer> queue=new LinkedList<>();
        int count=0,index=0;
        for(int i=0;i<len;i++){
        	//将不在滑动窗口范围的队头元素出队
            if(!queue.isEmpty()&&queue.peekFirst()==i-k) queue.removeFirst();
            if(queue.isEmpty()||nums[queue.peekLast()]>nums[i]) queue.addLast(i);
            else {
                while (!queue.isEmpty()&&nums[queue.peekLast()]<nums[i]) queue.removeLast();
                queue.addLast(i);
            }
            count++;
            if(count==k){
                res[index++]=nums[queue.peekFirst()];
                count--;
            }
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(N)
- **空间复杂度：**O(N)，队列复杂度为O(k)---
title: 240. 搜索二维矩阵 II
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

**题目描述：**

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。



**示例：**

```
现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

给定 target = 5，返回 true。
给定 target = 20，返回 false。
```





## 算法一：二分查找（在每一行中分别查找）

**算法思想：**

- 由于数组中每一行是有序的，所以可以依次在每一行中用二分查找是否有目标元素存在



**算法实现：**

```
public boolean searchMatrix(int[][] matrix, int target) {
        int m=matrix.length;
        if(m==0) return false;
        int n=matrix[0].length;
        for(int i=0;i<m;i++){
            int left=0,right=n-1;
            //二分查找要有等号
            while (left<=right){
                int mid=(left+right)/2;
                if(matrix[i][mid]==target) return true;
                else if(matrix[i][mid]<target){
                    left=mid+1;
                }else right=mid-1;
            }
        }
        return false;
    }
```



**算法分析：**

- **时间复杂度：**O(mlogn)，其中m,n分别为二维数组的行数和列数
- **空间复杂度：**O(1)





## 算法二：二分查找(数组分成四块)

**算法思想：**

- 将数组分成四块，left和right分别表示当前检查的数组的列的开头和结尾；up和down表示当前检查的数组的行的开头和结尾
- 每次在中间一列中寻找是否有目标元素，如果有则返回true，否则寻找第一个比目标元素大的元素，则可以排除掉以其划分的左上元素和右下元素，所以可以排除两个区域，在剩下两个区域中寻找



**算法实现：**

```
	private int[][] matrix;
    private int target;
    private boolean searchHelper(int left,int right,int up,int down){
    	//列或则行范围不合法
        if(left>right||up>down) return false;
        //如果目标元素小于最左上元素，或者大于最右下元素，则不会有元素匹配
        if(target<matrix[up][left]||target>matrix[down][right]) return false;
        //中间列
        int mid=(left+right)/2;
        int row=up;
        //找到在中间列中第一个大于目标元素的行数
        while (row<=down&&matrix[row][mid]<=target){
            if(matrix[row][mid]==target) return true;
            row++;
        }
        //只用递归查找右上和左下即可
        return searchHelper(left,mid-1,row,down)||searchHelper(mid+1,right,up,row-1);
    }
    public boolean searchMatrix(int[][] matrix, int target) {
        this.matrix=matrix;
        this.target=target;
        int m=matrix.length;
        if(m==0) return false;
        int n=matrix[0].length;
        return searchHelper(0,n-1,0,m-1);
    }
```



**算法分析：**

- **时间复杂度：**O(nlogn)，为了将问题简单化假设m=n，则有时间复杂度

  T(n^2^)=2T(n^2^/4)+n

  ​		 =4T(n^2^/16)+2n

  ​		 =.......=2^k^T(n^2^/4^k^)+kn，假设n^2^/4^k^=1，可以得到2^k^=n，k=logn，所以T(n^2^)=nlogn

- **空间复杂度：**O(logn)





## 算法四

**算法思想：**

- 初始化一个指向数组坐下元素的指针(row,col)，每次将其与目标元素相比，如果大于目标元素，则row--，如果小于目标元素，则col++，相当于每次排除一行或者一列



**算法实现：**

```
public boolean searchMatrix(int[][] matrix, int target) {
        int m=matrix.length;
        if(m==0) return false;
        int n=matrix[0].length;
        int row=m-1,col=0;
        while (row>=0&&col<n){
            if(matrix[row][col]==target) return true;
            else if(matrix[row][col]<target) col++;
            else row--;
        }
        return false;
    }
```



**算法分析：**

- **时间复杂度：**O(m+n)，最坏情况下需要从左下角判断到右上角，由于每次只能向上走一行或者向右走一列，所以时间为m+n
- **空间复杂度：**O(1)---
title: 242. 有效的字母异位词
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

**题目描述：**

给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。



**示例：**

```
示例 1:

输入: s = "anagram", t = "nagaram"
输出: true

示例 2:

输入: s = "rat", t = "car"
输出: false
```



## 算法一：哈希表

**算法思想：**

- 用哈希表来存储字符串s中每个字符出现的次数，然后在带入字符串t中去比较



**算法实现：**

```
public boolean isAnagram(String s, String t) {
		//长度不同直接返回false
        if(s.length()!=t.length()) return false;
        Map<Character,Integer> map=new HashMap<>();
        //记录字符串s中的每个字符出现的个数
        for(int i=0;i<s.length();i++){
            if(!map.containsKey(s.charAt(i))){
                map.put(s.charAt(i),1);
            }else map.put(s.charAt(i),map.get(s.charAt(i))+1);
        }
        //然后在t中比较
        for(int i=0;i<t.length();i++){
            if(!map.containsKey(t.charAt(i))||map.get(t.charAt(i))==0) return false;
            map.put(t.charAt(i),map.get(t.charAt(i))-1);
        }
        return true;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



## 算法二：改进

**算法思想：**

- 用数组来代替哈希表，其索引就可以代表相应字符，例如索引0对应字符'a'，向后递推
- 在一次遍历中，如果遇到s中的字符，则对应数组元素++，若遇到t中的元三年，则对应数组元素--，最后判断数组中是否所有元素都是0



**算法实现：**

```
public boolean isAnagram(String s, String t) {
        if(s.length()!=t.length()) return false;
        int[] count=new int[26];
        for(int i=0;i<s.length();i++){
            count[s.charAt(i)-'a']++;
            count[t.charAt(i)-'a']--;
        }
        for(int num:count){
            if(num!=0) return false;
        }
        return true;
    }
```





**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)，只申请了常数个长度的数组---
title: 26. 删除排序数组中的重复项
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

**题目描述：**

- 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后**数组的新长度**。

- 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

  

---

**示例：**

```
示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。


示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```



**说明：**

- 为什么返回数值是整数，但输出的答案是数组呢?

  请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。





## 算法一：

**算法思路：**

- 若存在相同的字符，则将其后的元素全部前移，并且同时对有效长度进行修改



**算法实现：**

```
public int removeDuplicates(int[] nums) {
        if(nums==null){
            return 0;
        }
        //用len记录数组的有效长度
        int len=nums.length;
        for(int i=0;i<len;i++){
            int j=i+1;
            //当重复时，向后移动直到不重复为止
            while(j<len&&nums[j]==nums[i]){
                j++;
            }
            //然后将后面的元素全部前移j-i-1位
            for(int k=i+1;k+j-i-1<len;k++){
                nums[k]=nums[k+j-i-1];
            }
            //同时更新有效长度
            len-=j-i-1;
        }
        return len;
    }
```



**算法分析：**

+ 算法的时间复杂度位O(n^2^)，需要改进





## 算法二：双指针法

**算法思路：**

1. 两个指针：慢指针i和快指针j，当`nums[j]==nums[i]`时，j++；
2. 若不等时，则将i先++，然后将`nums[j]的值赋值到nums[i]`，直到j到达数组的末尾，此时返回的数组长度为i+1；





**算法实现：**

```
public int removeDuplicates(int[] nums) {
		if (nums.length == 0) return 0;
		//慢指针i和快指针j
        int i=0;
        for(int j=1;j<nums.length;j++){
        	//若不等则i++后再赋值，否则j++
            if(nums[i]!=nums[j]){
                i++;
                nums[i]=nums[j];
            }
        }
        //返回有效数组长度为i+1
        return i+1;
    }
```



---
title: 268. 缺失数字
date: 2020-04-11 17:51:24
tags: leetcode
categories: 
	- leetcode
---

# [268. 缺失数字](https://leetcode-cn.com/problems/missing-number/)

**题目描述：**

给定一个包含 `0, 1, 2, ..., n` 中 *n* 个数的序列，找出 0 .. *n* 中没有出现在序列中的那个数。



**示例：**

```
示例 1:

输入: [3,0,1]
输出: 2

示例 2:

输入: [9,6,4,2,3,5,7,0,1]
输出: 8
```



## 算法一：求和

**算法思想：**

- 等差数列的和减去数组的和即为缺少的元素



**算法实现：**

```
public int missingNumber(int[] nums) {
        int len=nums.length;
        int res=0;
        for(int num:nums){
            res+=num;
        }
        return len*(len+1)/2-res;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)





## 算法二：位运算

**算法思想：**

- 使用异或运算，异或运算满足结合律，将数组中的元素与0,......,n分别做异或运算，得到的结果就是最终结果，以[3,0,1]为例：
  - `3^0^1^0^1^2^3=(0^0)^(1^1)^2^(3^3)=0^0^2^0=2`
- 在数组中可以将元素与其索引(0,1,2)作异或，最后再异或上一个数组长度(3)即可



**算法实现：**

```
public int missingNumber(int[] nums) {
        int len=nums.length;
        int res=len;
        for(int i=0;i<len;i++){
            res^=i^nums[i];
        }
        return res;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 279. 完全平方数
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

**题目描述：**

给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。



**示例：**

```
示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.

示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```



## 动态规划

**算法思想：**

- 用一个长度为n+1的数组来维护对应索引能化成的最少完全平方数之和，每次更新前先将每次位置的值初始化为其索引，即res[i]=i，即完全平方数之和的上界(1+1+....+1)
- 递推关系式为res[i]=min(res(i-j*j)+1)



**算法实现：**

```
public int numSquares(int n) {
        int[] res=new int[n+1];
        for(int i=1;i<=n;i++){
            res[i]=i;
            for(int j=1;i-j*j>=0;j++){
                res[i]=Math.min(res[i],res[i-j*j]+1);
            }
        }
        return res[n];
    }
```



**算法分析：**

- **时间复杂度：**O(n×sqrt(n))

- **空间复杂度：**O(n)

  ---
title: 28. 实现 strStr()
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

**题目描述：**

> 实现 strStr() 函数。

> 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。



**示例：**

```
示例 1:

输入: haystack = "hello", needle = "ll"
输出: 2

示例 2:

输入: haystack = "aaaaa", needle = "bba"
输出: -1
```



----

**算法思路：**

- 可以直接使用java中String类的库函数indexOf，只需要改变一下边界条件的判断即可
- 首先当needle字符串为空时，返回0
- 否则当haystack字符串为空时，返回-1
- 否则就直接调用indexOf函数



**算法实现：**

```
public int strStr(String haystack, String needle) {
        if(needle==null||needle.length()==0){
            return 0;
        }else if(haystack==null||haystack.length()==0){
            return -1;
        } else{
            return haystack.indexOf(needle);
        }
    }
```

---
title: 283. 移动零
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

**题目描述：**

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。



**示例：**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```



## 算法一：双指针

**算法思想：**

- 分别用两个指针index和i指向非0数字所需要插入的索引和当前元素索引，index只在当前元素非0时才向后缩进



**算法实现：**

```
public void moveZeroes(int[] nums) {
        int index=0;
        for(int i=0;i<nums.length;i++){
        	//非0元素才赋值，否则直接i++
            if(nums[i]!=0){
                nums[index++]=nums[i];
            }
        }
        //最后将index之后的元素赋值为0
        while (index<nums.length){
            nums[index++]=0;
        }
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)



## 算法二：统计0的个数

**算法思想：**

- count统计到当前索引处之前的0元素个数，则当count大于0时，当前的非0元素应该左移count位才到达其最终位置，并且将此处的值赋值位0



**算法实现：**

```
public void moveZeroes(int[] nums) {
        int count=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==0) count++;
            else if (count>0){
                nums[i-count]=nums[i];
                nums[i]=0;
            }
        }
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 287. 寻找重复数
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

**题目描述：**

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。



**示例：**

```
示例 1:

输入: [1,3,4,2,2]
输出: 2

示例 2:

输入: [3,1,3,4,2]
输出: 3
```



## 二分查找

**算法思想：**

- 不同与一般的二分查找去划分区间，此题是首先猜结果为数组元素的中位数1,2,.....,len-1的中位数mid，然后统计小于等于mid的元素个数，如果个数大于mid，则表示目标元素一定在中位数左边，否则在其右边



**算法实现：**

```
public int findDuplicate(int[] nums) {
        int len=nums.length;
        //数组元素取值范围为1,2,...,len-1
        int left=1,right=len-1;
        while (left<right){
            int mid=(left+right)/2;
            int count=0;
            for(int num:nums){
                if(num<=mid) count++;
                if(count>mid) right=mid;
                else left=mid+1;
            }
        }
        return left;
    }
```



**算法分析：**

- **时间复杂度：**O(nlogn)，在二分法的内部有一个遍历数组的操作，所以为nlogn

- **空间复杂度：**O(1)

  

  ---
title: 29. 两数相除
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [29. 两数相除](https://leetcode-cn.com/problems/divide-two-integers/)

**题目描述：**

>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
>
>返回被除数 dividend 除以除数 divisor 得到的商。
>



**示例：**

```
示例 1:

输入: dividend = 10, divisor = 3
输出: 3


示例 2:

输入: dividend = 7, divisor = -3
输出: -2
```



**说明：**

- 被除数和除数均为 32 位有符号整数。
- 除数不为 0。
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31^,  2^31^ − 1]。本题中，如果除法结果溢出，则返回 2^31^ − 1。

****

----

**算法思路：**

- 由于正数操作的话，考虑越界情况比较复杂，所以全部转换成为负数处理



**算法实现：**

```
public int divide(int dividend, int divisor){
		//^为异或符号，即dividend和divisor同号时，sign为false
        boolean sign = (dividend > 0) ^ (divisor > 0);
        int result = 0;
        //全部转换为负数操作
        if(dividend>0) {
            dividend = -dividend;
        }
        if(divisor>0) divisor = -divisor;
        while(dividend <= divisor) {
            int temp_result = -1;
            int temp_divisor = divisor;
            //左移一位即表示乘以2
            while(dividend <= (temp_divisor << 1)) {
                if(temp_divisor <= (Integer.MIN_VALUE >> 1))break;
                temp_result = temp_result << 1;
                temp_divisor = temp_divisor << 1;
            }
            dividend = dividend - temp_divisor;
            result += temp_result;
        }
        //如果最后结果为整数时
        if(!sign) {
        	//越界了
            if(result <= Integer.MIN_VALUE) return Integer.MAX_VALUE;
            result = - result;
        }
        return result;
    }
```

---
title: 3.无重复字符的最长子串
date: 2020-05-29 23:39:16
tags: leetcode
categories: leetcode
---

```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。


示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

```



# 滑动窗口

**算法思想：**

- 从第一个字符开始向后滑动，如果没有重复字符则长度++；否则如果有重复字符了，则需要从重复字符处的后一个位置开始遍历。

```
public static int lengthOfLongestSubstring(String s) {
        if(s==null||s.length()==0) return 0;
        //start记录当前序列的开始索引，用于判断哈希表中的元素是否是之前的
        int max=0,curr=0,start=0;
        Map<Character,Integer> map=new HashMap<>();
        char[] chars = s.toCharArray();
        for(int i=0;i<chars.length;i++){
        	//或者元素在之前就加进去了
            if(!map.containsKey(chars[i])||map.get(chars[i])<start){
                map.put(chars[i],i);
                curr++;
            }else {
            	//否则，有重复，则要更新curr，start
                max=Math.max(max,curr);
                int index=map.get(chars[i]);
                curr-=index-start+1;
                start=index+1;
                map.put(chars[i],i);
                //这里不要忘了curr++
                curr++;
            }
        }
        //此处还要比较一次，对于那种整个字符串没有重复的情况，不会进入下面的else
        max=Math.max(curr,max);
        return max;
    }
```

---
title: 309.最佳买卖股票时机含冷冻期
date: 2020-06-14 17:03:51
tags: leetcode
categories: leetcode
---

# [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

**题目描述：**

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。



```
示例:

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```



## 动态规划

**算法思想：**

- 二维dp，其中dp\[i][0]表示第i天不持有股票的最大收益，dp\[i][1]表示第i天持有股票的最大收益，则dp\[i][0]根据第i天是否售卖股票进一步可分为：
  1. 如果第i天出售股票，则dp\[i][0]=dp\[i-1][1]+prices[i]
  2. 如果第i天没有出售股票，则dp\[i][0]=dp\[i-1][0]

- 同样dp\[i][1]也可分为：
  1. 如果第i天购买股票，则dp\[i][1]=dp\[i-2][0]-prices[i]
  2. 如果第i天没有购入股票，则dp\[i][1]=dp\[i-1][1]

- 则最终结果为dp\[n][0]

```
public int maxProfit(int[] prices) {
        if(prices==null||prices.length<=1) return 0;
        int len=prices.length;
        int[][] dp=new int[len][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        dp[1][0]=Math.max(prices[1]-prices[0],0);
        dp[1][1]=Math.max(-prices[0],-prices[1]);
        for(int i=2;i<len;i++){
            dp[i][1]=Math.max(dp[i-2][0]-prices[i],dp[i-1][1]);
            dp[i][0]=Math.max(dp[i-1][1]+prices[i],dp[i-1][0]);
        }
        return dp[len-1][0];
    }
```

---
title: 31.下一个排列
date: 2020-07-09 21:31:00
tags: leetcode
categories: leetcode
---

# [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

**题目描述：**

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1





**算法思想：**

- 假如数组是整体降序的，则其即为最大的排列了，将其逆转就可以得到下一个排列；否则的话从尾部开始找到第一个不满足降序的数，然后在其后面找到与其最接近但是又大于其的数，两者互换后，再将后面的逆转即可

```
	public void nextPermutation(int[] nums) {
        if(nums==null||nums.length==0) return;
        int r=nums.length-2;
        while(r>=0&&nums[r]>=nums[r+1])  r--;
        //如果r==-1则表示全局降序
        if(r==-1){
            reverse(nums,0);
            return;
        }
        int i=nums.length-1;
        while(i>r&&nums[i]<=nums[r]) i--;
        swap(nums,r,i);
        reverse(nums,r+1);
    }

    private void reverse(int[] nums,int l){
        int r=nums.length-1;
        while(l<r){
            swap(nums,l,r);
            l++;
            r--;
        }
    }

    private void swap(int[] nums,int l,int r){
        int temp=nums[l];
        nums[l]=nums[r];
        nums[r]=temp;
    }
```

---
title: 33. 搜索旋转排序数组
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

**题目描述：**

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 **[4,5,6,7,0,1,2]** )。
>
> 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
>
> 你可以假设数组中不存在重复的元素。
>
> 你的算法时间复杂度必须是 O(log n) 级别。
>



---

**示例：**

```
示例 1:

输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

示例 2:

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```





**算法思路：**

1. 找到旋转点的下标，也就是数组中最小元素的索引
   - 用二分法查找，如果有 `nums[left]<nums[right]，则原数组并没有旋转，即依然是整体单增的`
   - 由于数组的左右两个部分都是单增的，所以若存在一点使得 `nums[pivot]>nums[pivot+1](即违反了单增)，则可以得到pivot+1为最小元素的索引`
   - 否则，若 `nums[pivot] < nums[left]`，则表示pivot在右边的有序数组中，显然旋转点在其左边，所以令 `right = pivot - 1;`
   - 否则，令 `left = pivot + 1;`
2. 若 `nums为空或者长度为0，则返回-1；若nums长度为1，则直接将nums[0]与target相比`
   + 首先得到整个数组的旋转点索引，若其为0，则表示没有旋转，则整个数组有序，直接对整个数组进行二分查找；
   + 否则，将`target与nums[0]进行比较，如果target<nums[0]，则表示target在右边的有序数组中`
   + 否则，target在左边的有序数组中。





---

**算法实现：**

```
//寻找旋转点的索引
private int find_rotate_index(int left,int right,int[] nums){
		//表示整个数组单增，返回0
        if(nums[left]<nums[right]){
            return 0;
        }
        //二分查找
        while(left<=right){
            int pivot=(left+right)/2;
            if(nums[pivot]>nums[pivot+1]){
                return pivot+1;
            }else if (nums[pivot]<nums[left]){
                right=pivot-1;
            }else {
                left=pivot+1;
            }
        }
        return 0;
    }
    //二分查找算法
    private int search(int left,int right,int[] nums,int target){
        while(left<=right){
            int mid=(left+right)/2;
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                right=mid-1;
            }else {
                left=mid+1;
            }
        }
        //没有找到，返回-1
        return -1;
    }
    public int search ( int[] nums, int target){
        int n = nums.length;
		//特殊情况单独考虑
        if (nums==null||n == 0)
            return -1;
        if (n == 1)
            return nums[0] == target ? 0 : -1;
        //得到旋转点坐标
        int rotate_index = find_rotate_index(0, n - 1, nums);
        //旋转点坐标为0，表示没有旋转，对整个数组二分查找
        if(rotate_index==0){
            return search(0,n-1,nums,target);
        }else {
            if(target==nums[rotate_index]){
                return rotate_index;
            }else if (target<nums[0]){
                return search(rotate_index,n-1,nums,target);
            }else {
                return search(0,rotate_index-1,nums,target);
            }
        }
    }
```







**注意：**

- **对于二分查找需要注意的是，初始时，left的值为0，right的值为`nums.length-1`**

  ---
title: 337.打家劫舍
date: 2020-06-02 15:27:03
tags: leetcode
categories: leetcode
---

# [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

**题目描述：**

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

```
示例 1:

输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.


示例 2:

输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```



## 递归

**算法思想：**

- 方法`robWithRoot`表示偷root节点情况下偷取的最大金额，方法`robWithoutRoot`表示不偷取root节点情况下的最大金额，需要注意的是这种情况下root.left和root.right并不一定会被选择，所以需要比较取最大。

```
public int rob(TreeNode root) {
        if(root==null) return 0;
        return Math.max(robWithRoot(root),robWithoutRoot(root));
    }
	
	//不偷root节点
    private int robWithoutRoot(TreeNode root){
        if(root==null) return 0;
        //要比较偷取左孩子和不偷左孩子的情况比最大值
        int left=Math.max(robWithRoot(root.left),robWithoutRoot(root.left));
        //右孩子相同
        int right=Math.max(robWithRoot(root.right),robWithoutRoot(root.right));
        return left+right;
    }
	
	//偷root节点
    private int robWithRoot(TreeNode root){
        if(root==null) return 0;
        return root.val+robWithoutRoot(root.left)+robWithoutRoot(root.right);
    }
```

**最后执行实践1400ms，由于递归存在大量的重复调用，所以用map去存储结果来改进**



## map改进

```
	//额外用map存储中间结果
	Map<TreeNode,Integer> withRoot=new HashMap<>();
    Map<TreeNode,Integer> withoutRoot=new HashMap<>();
    public int rob(TreeNode root) {
        if(root==null) return 0;
        return Math.max(robWithRoot(root),robWithoutRoot(root));
    }

    private int robWithoutRoot(TreeNode root){
        if(root==null) return 0;
        if(withoutRoot.containsKey(root)) return withoutRoot.get(root);
        int left=Math.max(robWithRoot(root.left),robWithoutRoot(root.left));
        int right=Math.max(robWithRoot(root.right),robWithoutRoot(root.right));
        withoutRoot.put(root,left+right);
        return left+right;
    }

    private int robWithRoot(TreeNode root){
        if(root==null) return 0;
        if(withRoot.containsKey(root)) return withRoot.get(root);
        int res=root.val+robWithoutRoot(root.left)+robWithoutRoot(root.right);
        withRoot.put(root,res);
        return res;
    }
```

**最后结果4ms，还可以**---
title: 34. 在排序数组中查找元素的第一个和最后一个位置
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

**题目描述：**

> 给定一个按照升序排列的整数数组 `nums`，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 你的算法时间复杂度必须是 O(log n) 级别。
>
> 如果数组中不存在目标值，返回 [-1, -1]。





**示例：**

```
示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]

示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```



---

## 算法1：

**算法思路：**

- 方法 `searchMin`和 `searchMax`分别用二分法来计算开始位置和结束位置



****

**算法实现：**

```
public int[] searchRange(int[] nums, int target) {
        int len=nums.length;
        //数组长度为0
        if(len==0){
            return new int[]{-1,-1};
        }
        //没有找到terget元素
        if(searchMin(nums,target,0,len-1)==Integer.MAX_VALUE){
            return new int[]{-1,-1};
        }else {
            return new int[]{searchMin(nums,target,0,len-1),searchMax(nums,target,0,len-1)};
        }
    }
    //计算开始位置
    private int searchMin(int[] nums,int target,int left,int right){
    	//注意用的是if，而不是while，因为在里面用的是递归
        if(left<=right){
            int mid=(left+right)/2;
            //左半边的开始位置
            int leftMin=searchMin(nums,target,left,mid-1);
            //右半边的开始位置，之所以要把右边加进去，是因为target可能不在左边，而在右边
            int rightMin=searchMin(nums,target,mid+1,right);
            int min=Math.min(leftMin,rightMin);
            if(nums[mid]==target){
               return Math.min(min,mid);
            }
            return min;
        }
        //若没有找到，则返回一个最大的数
        return Integer.MAX_VALUE;
    }
    //计算结束位置
    private int searchMax(int[] nums,int target,int left,int right){
        if(left<=right){
            int mid=(left+right)/2;
            //左半边的结束位置
            int leftMax=searchMax(nums,target,left,mid-1);
            //右半边的结束位置
            int rightMax=searchMax(nums,target,mid+1,right);
            int max=Math.max(leftMax,rightMax);
            if(nums[mid]==target){
                return Math.max(max,mid);
            }
            return max;
        }
        //若没有找到，则返回一个最小的数
        return Integer.MIN_VALUE;
    }
```



**算法效率很差，但是时间复杂度依然是`O(logn)`**







## 算法2：

**算法思想：**

- 基于二分查找的改进，只不过当 `nums[mid]==target时还不能立即停止`,还需要继续搜索直到 `lo==hi`为止
- `left` 参数的引入，它是一个 boolean 类型的变量，指示我们在遇到 `target == nums[mid]` 时应该做什么。如果 `left` 为 `true` ，那么我们递归查询左区间，否则递归右区间。考虑如果我们在下标为 i 处遇到了 `target` ，最左边的 `target` 一定不会出现在下标大于 i 的位置，所以我们永远不需要考虑右子区间。当求最右下标时，道理同样适用。



---

**算法实现：**

```
//left的真假代表了当nums[mid]==target时不同的处理策略
private int extremeInsertionIndex(int[] nums, int target, boolean left) {
        int lo=0,hi=nums.length;
        while(lo<hi){
            int mid=(lo+hi)/2;
            //当left为true时，表示相等时仍要去左边寻找
            //left为false时，表示相等时去右边寻找
            if(nums[mid]>target||left&&nums[mid]==target){
                hi=mid;
            }else {
                lo=mid+1;
            }
        }
        //当lo==hi时结束循环，返回lo
        return lo;
    }
    public int[] searchRange(int[] nums, int target) {
        int[] result=new int[]{-1,-1};
        int leftIdx=extremeInsertionIndex(nums,target,true);
        //leftIdx==nums.length表示每次nums[mid]与target进行比较时，都是target更大，所以             //lo=mid+1，nums[lefttIdx]!=target如nums={1,3,3,3,5},而target=2这种情况
        if(leftIdx==nums.length||nums[leftIdx]!=target){
            return result;
        }
        result[0]=leftIdx;
        //下面结果需要减一
        result[1]=extremeInsertionIndex(nums,target,false)-1;
        return result;
    }
```

---
title: 347.前K个高频元素
date: 2020-05-13 22:31:34
tags: leetcode
categories: leetcode
---

# [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]


提示：

你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
你可以按任意顺序返回答案。



## 优先队列

**算法思想：**

- 求前k个最大或最小都可以用优先队列，但是本题需要注意的是进行比较的是词出现的频数，所以需要重写一个比较器，出现频数大的元素更大，所以要把map传进去。



```
public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map=new HashMap<>();
        for(int num:nums){
            if(!map.containsKey(num)) map.put(num,1);
            else map.put(num,map.get(num)+1);
        }
        PriorityQueue<Integer> queue=new PriorityQueue<>(k, new MyComparator(map));
        for(int num:map.keySet()){
            if(queue.size()<k) queue.add(num);
            else {
                if(map.get(queue.peek())<map.get(num)){
                    queue.remove();
                    queue.add(num);
                }
            }
        }
        int[] res=new int[k];
        for(int i=0;i<k;i++){
            res[i]=queue.remove();
        }
        return res;
    }

	//比较器，词频大的元素更大。
    static class MyComparator implements Comparator<Integer>{
        private Map<Integer,Integer> map;

        public MyComparator(Map map){
            this.map=map;
        }

        @Override
        public int compare(Integer o1, Integer o2) {
            return map.get(o1)-map.get(o2);
        }
    }
```







---
title: 376.摆动序列
date: 2020-06-06 15:53:04
tags: leetcode
categories: leetcode
---

# [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

```
示例 1:

输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。


示例 2:

输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。


示例 3:

输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```





## 动态规划

**算法思想：**

- 用memo[i]来表示以nums[i]结尾并且必须包含nums[i] 的最长摆动序列，则memo[i]=max(memo[j]+1|j<i&&i与前面的序列构成摆动序列)
- 因此需要用一个数组del来记录当使用这个元素作为摆动序列结尾元素时与前面元素的差值，这个值要记得更新

```
public int wiggleMaxLength(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        int[] del=new int[nums.length];
        //给del赋初值
        for(int i=1;i<nums.length;i++){
            del[i]=nums[i]-nums[i-1];
        }
        int[] memo=new int[nums.length];
        memo[0]=1;
        for(int i=1;i<memo.length;i++){
            for(int j=i-1;j>=0;j--){
                int less=nums[i]-nums[j];
                if(less==0) continue;
                //加上等于0是把memo[0]考虑进来，因为del[0]=0
                if(less*del[j]<=0){
                    if(memo[j]+1>memo[i]){
                        memo[i]=memo[j]+1;
                        //这里更新del的值
                        del[i]=nums[i]-nums[j];
                    }       
                }
            }
        }
        int max=0;
        for(int i=0;i<memo.length;i++){
            if(memo[i]>max) max=memo[i];
        }
        return max;
    }
```

---
title: 377.组合总和IV
date: 2020-06-16 22:22:30
tags: leetcode
categories: leetcode
---

# [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

**算法思想：**
给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

```
示例:

nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。
```





## 动态规划

**算法思想：**

- 数组中的元素**可以多次使用**，因此可以看作一个完全背包问题，dp[i]表示数组中和为i的组合个数，则对于数组中每一个元素num，dp[i]+=dp[i-num]；
- 数组中的元素如果不能多次使用，就是01背包问题。

```
public int combinationSum4(int[] nums, int target) {
        if(nums==null||nums.length==0) return 0;
        int len=nums.length;
        int[] dp=new int[target+1];
        dp[0]=1;
        for(int i=1;i<dp.length;i++){
            for(int num:nums){
                if(i>=num){
                    dp[i]+=dp[i-num];
                }
            }
        }
        return dp[target];
    }
```

---
title: 38. 报数
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [38. 报数](https://leetcode-cn.com/problems/count-and-say/)

**题目描述：**

>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
>
>1.     1
>2.     11
>3.     21
>4.     1211
>5.     111221
>
>
>
>1 被读作  "one 1"  ("一个一") , 即 11。
>11 被读作 "two 1s" ("两个一"）, 即 21。
>21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。
>
>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。
>
>注意：整数顺序将表示为一个字符串。
>



---

**示例：**

```
示例 1:

输入: 1
输出: "1"


示例 2:

输入: 4
输出: "1211"
```





## 算法一：

**算法思想：**

- 很显然存在递推关系，所以很明显要用动态规划，虽然递推关系不太能直接用公式来描述
- 递推关系： `strs[n]中的字符确定方法为：strs[n-1]中的连续字符个数+这个字符`
- 递推起点为 `strs[0]和strs[1]`



1. 确定递推起点 `strs[0]和strs[1]`
2. 逐个向后推，递推关系如上表示
3. 最后返回 `strs[n-1]，因为编号从0开始`





**算法实现：**

```
public String countAndSay(int n) {
        if(n==1) return "1";
        if(n==2) return "11";
        //用数组去存放递推的结果
        String[] strs=new String[n];
        //递推起点
        strs[0]="1";
        strs[1]="11";
        //依次递推从2到n-1的每一个字符串
        for(int i=2;i<n;i++){
        	//k记录strs[i-1]中正在被计算个数的字符索引，从0开始
            int k=0;
            //必须初始化为空字符串，否则会出现空指针异常
            strs[i]="";
            //用j来跟随相同的字符，若相同则++
            int j=0;
            while(j<strs[i-1].length()) {
            	//num记录相同字符的个数
                int num=0;
                //当字符相同时，num++，j++
                while (j<strs[i-1].length()&&strs[i - 1].charAt(j) == strs[i - 1].charAt(k)) {
                    num++;
                    j++;
                }
                //当字符不同后跳出上面的循环，此时需要更新strs[i]的值
                strs[i] = strs[i].concat("" + num + strs[i - 1].charAt(k));
                //将j的值赋给为k，以记录下一次循环所要计算的字符的重复个数
                k = j;
            }
        }
        //最后返回结果
        return strs[n-1];
    }
```





**分析：**

> 虽然看似在算法中有三个循环的嵌套，但其实最里面两层循环加起来只会执行n~i~次，n~i~为`strs[i-1].length`,所以总时间复杂度为O(n~i~*n)





---
title: 394.字符串解码
date: 2020-08-11 16:14:25
tags: leetcode
categories: leetcode
---

# [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

**题目描述：**

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。



**示例：**

```
示例 1：

输入：s = "3[a]2[bc]"
输出："aaabcbc"

示例 2：

输入：s = "3[a2[c]]"
输出："accaccacc"

示例 3：

输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"

示例 4：

输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```



## 递归

**算法思想：**

- 递归方法helper(chars,l,r)解析chars数组从l到r的字符，则解析过程如下：
  - 如果不是数字，则直接拼接上去；
  - 如果遇到数字了，则将其后面跟随的所有数字转换为整数，然后解析其后跟随的一对[]中的字符，并拼接上去；
  - 对于之后的数字递归调取方法即可。



```
public String decodeString(String s) {
        return helper(s.toCharArray(),0,s.length()-1);
    }

    private String helper(char[] chars,int l,int r){
        if(l>r) return "";
        if(l==r) return ""+chars[l];
        StringBuilder res=new StringBuilder();
        while(l<=r&&(chars[l]>'9'||chars[l]<'0')){
            res.append(chars[l]);
            l++;
        }
        if(l>r) return new String(res);
        //将数字找出
        int num=0;
        while(chars[l]!='['){
            num=10*num+chars[l]-'0';
            l++;
        }
        l++;
        //找到其后的一对[]，由于里面可能嵌套多层[]，所以用flag来记录嵌套情况
        int index=l,flag=0;
        while(index<=r){
            if(flag==0&&chars[index]==']') break;
            if(chars[index]==']') flag--;
            if(chars[index]=='[') flag++;
            index++;
        }
        //递归转换括号之间的字符
        String str=helper(chars,l,index-1);
        for(int k=0;k<num;k++){
            res.append(str);
        }
        //拼接上括号之后的
        return res+helper(chars,index+1,r);
    }
```

**时间复杂度：**O(n)，每个字符只遍历了一次

**空间复杂度：**O(n)，StringBuilder占用空间为n，递归深度为最大括号嵌套数。---
title: 405.数字转换为十六进制数
date: 2020-07-09 16:06:12
tags: leetcode
categories: leetcode
---

# [405. 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)

**题目描述：**

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

1. 十六进制中所有字母(a-f)都必须是小写。
2. 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
3. 给定的数确保在32位有符号整数范围内。
4. 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。

```
示例 1：

输入:
26

输出:
"1a"


示例 2：

输入:
-1

输出:
"ffffffff"
```





## 位运算

**算法思想：**

- 由于题目涉及负数转换为16进制数，所以不能通过十进制的取模和除来解决，应该通过二进制来解决
- 从二进制最高位开始每4位对应一个十六进制位

```
public String toHex(int number) {
        StringBuilder res=new StringBuilder();
        //flag用来表示前面是否不要这个前导0
        boolean flag=true;
        int mask=Integer.MIN_VALUE;
        for(int i=0;i<8;i++){
            int num=0;
            for(int j=0;j<4;j++){
                num=2*num;
                if((mask&number)==mask)
                    num+=1;
                mask>>>=1;
            }
            //如果flag为true表示前面都是0，则不要把这个0加进去
            if(num==0){
                if(flag)
                    continue;
            }
            flag=false;
            if(num>=10) {
                char c= (char) ('a'+num-10);
                res.append(c);
            }
            else res.append(num);
        }
        //最后如果全是0，则res为空串，需要手动加上0
        if(res.length()==0) res.append(0);
        return res.toString();
    }
```



**错误点：**

1. 12行的位移运算应该为无符号右移>>>
2. 21行需要强制转换为char类型---
title: 406.根据身高重建队列
date: 2020-06-23 22:14:32
tags: leetcode
categories: leetcode
---

# [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

**题目描述：**

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：
总人数少于1100人。



```
示例

输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```



## 贪心算法

**算法思路：**

- 拿[4,4]来看，因为其是最小的，所以他在数组中的位置就是4，将这个位置擦去之后，再去比较其他的元素
- 需要注意的是例如[5,0]和[5,2]需要先去确定[5,2]的位置，因为如果先确定[5,0]，那么再到剩余的元素中去确定[5,2]时，其中间就会相隔两个元素，最终导致大于等于[5,2]的有3个
- 由于需要将剩余的位置存储起来，并且需要其于顺序索引0，1，2的对应关系，所以想到用一个list去存储，当使用了一个元素之后，就将其索引删去即可。

```
public int[][] reconstructQueue(int[][] people) {
        if(people==null||people.length==0) return new int[0][2];
        int N=people.length;
        //index去记录剩余的索引
        List<Integer> index=new ArrayList<>();
        for(int i=0;i<N;i++){
            index.add(i);
        }
        //排序
        Arrays.sort(people,new Comparator<int[]>(){
            public int compare(int[] i1,int[] i2){
                if(i1[0]==i2[0])
                    return i2[1]-i1[1];
                return i1[0]-i2[0];
            }
        });
        int[][] res=new int[N][2];
        for(int[] nums:people){
            res[index.get(nums[1])]=nums;
            //将索引删除掉
            index.remove(nums[1]);
        }
        return res;
    }
```



**时间复杂度：**O(n^2^)

---
title: 416.分割等和子集
date: 2020-06-07 10:45:36
tags: leetcode
categories: leetcode
---

# [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

**题目描述：**

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:

1. 每个数组中的元素不会超过 100
2. 数组的大小不会超过 200

```
示例 1:

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
 

示例 2:

输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.
```





## 回溯

**算法思想：**

- 就是求数组中是否有一个子序列使得其和为总和数的一半，用回溯法去考虑，每个元素都有选和不选两种情况。

```
public boolean canPartition(int[] nums) {
        if(nums==null||nums.length==0) return false;
        int sum=0;
        for(int num:nums){
            sum+=num;
        }
        //和为奇书，直接返回false
        if(sum%2==1) return false;
        return existHalf(nums,0,0,sum);
    }

    private boolean existHalf(int[] nums,int i,int curr,int sum){
        if(i==nums.length){
            if(curr==sum/2)
                return true;
            else return false;
        }
        if(curr>sum/2) return false;
        return existHalf(nums,i+1,curr+nums[i],sum)||existHalf(nums,i+1,curr,sum);
    }
```





## 动态规划

先补充一下01背包问题：

有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。

定义一个二维数组 dp 存储最大价值，其中 dp\[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：

- 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp\[i][j] = dp\[i-1][j]。
- 第 i 件物品添加到背包中，dp\[i][j] = dp\[i-1][j-w] + v。

第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8cb2be66-3d47-41ba-b55b-319fc68940d4.png)



```java
// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```





本题就是和为sum/2的01背包问题，用memo\[i][j]表示前i个元素是否存在子序列使得和为j，则根据第i个元素是否放入序列有：`memo[i][j]=memo[i-1][j]||memo[i-1][j-wi]`

```
public boolean canPartition(int[] nums) {
        if(nums==null||nums.length==0) return false;
        int sum=0;
        for(int num:nums){
            sum+=num;
        }
        if(sum%2==1) return false;
        return find(nums,sum/2);
    }

    private boolean find(int[] nums,int sum){
        int M=nums.length;
        boolean[][] memo=new boolean[M+1][sum+1];
        memo[0][0]=true;
        for(int i=1;i<=M;i++){
            for(int j=1;j<=sum;j++){
                int w=nums[i-1];
                if(j>=w)
                    memo[i][j]=memo[i-1][j]||memo[i-1][j-w];
                else 
                    memo[i][j]=memo[i-1][j];
            }
        }
        return memo[M][sum];
    }
```

---
title: 42.接雨水
date: 2020-07-10 11:14:19
tags: leetcode
categories: leetcode
---

# [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

**题目描述：**

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

```
示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```





## 按列计算

**算法思想：**

- 依次计算每一列可能的积水高度，可以通过分别计算左边最大高度和右边的最大高度，然后取较小者即为这一列水的高度

```
public int trap(int[] height) {
        int res=0;
        //依次计算每一列
        for(int i=0;i<height.length;i++){
            int maxLeft=0,maxRight=0;
            //计算左边的最大高度
            for(int j=i-1;j>=0;j--){
                maxLeft=Math.max(maxLeft,height[j]);
            }
            //计算右边的最大高度
            for(int j=i+1;j<height.length;j++){
                maxRight=Math.max(maxRight,height[j]);
            }
            int num=Math.min(maxLeft,maxRight)-height[i];
            //如果有积水才加上去
            if(num>0) res+=num;
        }
        return res;
    }
```

**时间复杂度：**O(n^2^)

**空间复杂度：**O(1)



## 动态规划

**算法思想：**

- 上面对于每一列都需要去计算其左右最大高度，可以用数组将其存放起来，用leftMax存放左边最大，rightMax存放右边最大

```
public int trap(int[] height) {
        int res=0;
        int[] leftMax=new int[height.length],rightMax=new int[height.length];
        for(int i=1;i<leftMax.length;i++){
            leftMax[i]=Math.max(leftMax[i-1],height[i-1]);
        }
        for(int i=rightMax.length-2;i>=0;i--){
            rightMax[i]=Math.max(rightMax[i+1],height[i+1]);
        }
        for(int i=0;i<height.length;i++){
            int num=Math.min(leftMax[i],rightMax[i])-height[i];
            if(num>0) res+=num;
        }
        return res;
    }
```

**时间复杂度：**O(n)

**空间复杂度：**O(n)---
title: 435.无重叠区间
date: 2020-06-03 10:55:41
tags: leetcode
categories: leetcode
---

# [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

示例 1:

输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。

示例 2:

输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

示例 3:

输入: [ [1,2], [2,3] ]

输出: 0



## 贪心算法

**算法思想：**

- 要删除最少的区间使得无重叠，也就是求出最多的无重叠区间的值，然后总区间数减上这个值就可以得到结果。
- 需要求出最多的无重叠区间就要用贪心的思想，当两个区间放在这里去选择时，优先选择区间结尾处小的区间，因为这样可以给其他区间留下更多的空间，所以根据区间结尾排序后再去选择。

```
public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals==null||intervals.length==0) return 0;
        int M=intervals.length;
        //将数组按照区间区间结尾排序
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] i1,int[] i2){
                return i1[1]-i2[1];
            }
        });
        int pre=intervals[0][1];
        int curr=1;
        for(int i=1;i<M;i++){
            if(intervals[i][0]<pre){
                continue;
            }else{
                curr++;
                pre=intervals[i][1];
            }
        }
        return M-curr;
    }
```

---
title: 437.路径总和III
date: 2020-06-24 15:56:30
tags: leetcode
categories: leetcode
---

# [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

**题目描述：**

给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

```
示例：

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```



## 递归

**算法思路：**

- 问题在于路径的起点可以是任何一个节点，然后向下走，所以方法helper()计算以当前root为根节点(起点)的路径个数，然后分别计算以每一个节点作为起点的情况即可。

```
private int res=0;

    public int pathSum(TreeNode root, int sum) {
        if(root==null) return 0;
        //计算以当前节点为根
        helper(root,sum);
        //计算以其左孩子为根
        pathSum(root.left,sum);
        //计算以其右孩子为根
        pathSum(root.right,sum);
        return res;
    }

    private void helper(TreeNode root,int sum){
        if(root==null) return;
        //注意这里的判断要用root.val==sum而不能用sum===0
        if(root.val==sum)
            res++;
        helper(root.left,sum-root.val);
        helper(root.right,sum-root.val);
    }
```

---
title: 474.一和零
date: 2020-06-27 15:12:39
tags: leetcode
categories: leetcode
---

# [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

**题目描述：**

在计算机界中，我们总是追求用有限的资源获取最大的收益。

现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。

你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。

注意:

- 给定 0 和 1 的数量都不会超过 100。
- 给定字符串数组的长度不会超过 600。

```
示例 1:

输入: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
输出: 4

解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。


示例 2:

输入: Array = {"10", "0", "1"}, m = 1, n = 1
输出: 2
```



## 动态规划

**算法思路：**

- dp\[i]\[j][k]表示的是前i个元素正好用j个0和k个1表示所能表示的最多字符串。
- 则有dp\[i][j]\[k]=Math.max(dp\[i-1][j]\[k],dp\[i-1]\[j-zero\[i]][k-one[i]])，分别对应表示和表示第i个字符
- 最终的结果是dp[i]\[?]\[?]中的最大值

```
public int findMaxForm(String[] strs, int m, int n) {
        int[][][] dp=new int[strs.length+1][m+1][n+1];
        int[] one=new int[strs.length];
        for(int i=0;i<one.length;i++){
            one[i]=numberOfOne(strs[i]);
        }
        int res=0;
        for(int i=1;i<=strs.length;i++){
            for(int j=0;j<=m;j++){
                for(int k=0;k<=n;k++){
                    dp[i][j][k]=dp[i-1][j][k];
                    int oneNum=one[i-1];
                    int zeroNum=strs[i-1].length()-oneNum;
                    if(j-zeroNum>=0&&k-oneNum>=0){
                        dp[i][j][k]=Math.max(dp[i][j][k],dp[i-1][j-zeroNum][k-oneNum]+1);
                    }
                    res=Math.max(res,dp[i][j][k]);
                }
            }
        }
        return res;
    }

	//统计字符串中1的个数
    private int numberOfOne(String str){
        int res=0;
        for(int i=0;i<str.length();i++){
            if(str.charAt(i)=='1')
                res++;
        }
        return res;
    }
```

---
title: 48. 旋转图像
date: 2019-12-24 17:51:24
tags: leetcode
categories: leetcode
---



# [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

**题目描述：**

> 给定一个 n × n 的二维矩阵表示一个图像。
>
> 将图像顺时针旋转 90 度。
>
> 说明：
>
> 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
>





**示例：**

```
示例 1:

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


示例 2:

给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```





## 算法一：

- 顺时针旋转90^0^可以等价为先将矩阵转置。然后再按列互换

> 不知道怎么去证明，我就是试了几个矩阵就想到了这个解法

**注意：**在`java`中对二维矩阵调用`length()`方法时，默认返回的是行数，即第一个中括号中的数



---

**算法实现：**

```
public void rotate(int[][] matrix) {
		//数组为null或长度为0，直接结束
        if(matrix==null||matrix.length==0) return;
        //n阶方阵
        int n=matrix.length;
        //矩阵的转置操作
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                int temp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=temp;
            }
        }
        //矩阵互换两列的操作
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                int temp=matrix[j][i];
                matrix[j][i]=matrix[j][n-i-1];
                matrix[j][n-i-1]=temp;
            }
        }
    }
```

---
title: 49. 字母异位词分组
date: 2020-05-31 17:51:24
tags: leetcode
categories: leetcode
---



# [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

**题目描述：**

> 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

---

**示例：**

```
示例:

输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```



---

**说明：**

- 所有输入均为小写字母。
- 不考虑答案输出的顺序。



## 算法一：按排序数组分类

**算法思想：**

- 维护一个map集合，其中键的值为排序后的字符串，则同一个list集合中的字符串显然键值也相同。



**算法实现：**

```
public List<List<String>> groupAnagrams(String[] strs) {
        if(strs==null||strs.length==0) return new ArrayList<>();
        //map集合维护映射关系
        Map<String,List<String>> map=new HashMap<>();
        for(String s:strs){
        	//因为Arrays.sort()方法只能对数组排序，所以先转换位字符数组
            char[] chars=s.toCharArray();
            //按字母升序排序
            Arrays.sort(chars);
            //再将字符数组转换为字符串
            String key=String.valueOf(chars);
            //如果再map中没有对应key，则将key和一个空的集合添加进去
            if(!map.containsKey(key)) map.put(key,new ArrayList<>());
            相对应的key的集合中添加字符串
            map.get(key).add(s);
        }
        map.values()方法返回的是一个collection类型，需要将其转换为List类型
        return new ArrayList<>(map.values());
    }
```



**注意：**将`map.values()转换为list时，不能使用强制类型转换，会报错`





# 算法二：按计数分类

**算法思想：**

- 维护一个数组，其长度为26，相应索引处的值表示对应的字符的个数，例如： `counts[0]表示的是字符'a'的个数`



**算法实现：**

```
 public List<List<String>> groupAnagrams(String[] strs) {
        if(strs==null||strs.length==0) return new ArrayList<>();
        Map<String,List<String>> map=new HashMap<>();
        //counts数组记录对应字符个数，对应同一个key的字符串有着同样的counts数组
        int[] counts=new int[26];
        for(String s:strs){
        	//将counts的元素覆盖为0，初始化
            Arrays.fill(counts,0);
            for(int i=0;i<s.length();i++){
                counts[s.charAt(i)-'a']++;
            }
            StringBuilder sb=new StringBuilder();
            for(int i=0;i<26;i++){
                sb.append(counts[i]);
            }
            String key=sb.toString();
            if(!map.containsKey(key)) map.put(key,new ArrayList<>());
            map.get(key).add(s);
        }
        return new ArrayList<>(map.values());
    }
```



**注意：**  `Arrays.fill(counts,0)表示的是将counts中的元素用0覆盖，用来每次循环给数组初始化`---
title: 5.最长回文子串
date: 2019-12-23 13:02:24
tags: leetcode
categories: leetcode
---

# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)



**题目描述：**

>  给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。 



**示例：**

```
示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。


示例 2：

输入: "cbbd"
输出: "bb"
```





---



## **方法一：中心扩展算法**

- 回文字符串的两侧互为镜像，因此可以找到这个回文字符串的中心，这样的中心一共有`2n—1`个，因为，中心可以在字符上也可以在两个字符的中间

1. 方法 `expandAroundCenter(String s, int left, int right)`可以找到以left和right的中心的中心的最长字符串，并且返回它的长度。
2. 若字符串为null或则为空串则返回空串，否则对于每一个可能的回文串中心，依次找到其最长的回文字符串长度，如果比之前记录的字符串要长，则记录新的长度和新的字符串起点和终点





**具体实现：**

```
public String longestPalindrome(String s) {
		//若字符串为null或则为空串则返回空串
        if(s==null||s.length()==0){
            return "";
        }
        //start和end记录最长回文子串的起点和终点
        int start=0,end=0;
        //对于每一个可能的回文串中心
        for(int i=0;i<s.length();i++){
        	//以点i为中心的最长回文子串的长度
            int len1=expandAroundCenter(s,i,i);
            //以点i和点i+1的中心为中心的最长回文子串中心
            int len2=expandAroundCenter(s,i,i+1);
            //取其中最大的
            int len=Math.max(len1,len2);
            //如果新的回文串的长度大于之前记录的最长回文串，则更新起点和终点
            if(len>end-start+1){
            	<备注1>更新start和end的值
                start=i-(len-1)/2;
                end=i+len/2;
            }
        }
        return s.substring(start,end+1);
    }
    private int expandAroundCenter(String s, int left, int right) {
    	//用L和R的值分别接受left和right，放在改变i的值
        int L=left,R=right;
        //找到最长的回文串
        while(L>=0&&R<s.length()&&s.charAt(L)==s.charAt(R)){
            L--;
            R++;
        }
        //注意返回的长度是R-L-1，因为上面的循环的到的L和R是回文串的左边一个字符和右边一个		   字符
        return R-L-1;
    }
```



**备注1：**
关于start和end的值的更新的简单证明：

1. 首先需要注意的是，`len1`一定是奇数， `len2`一定是偶数，分别对 `len=len1和len=len2`的情况单独讨论，可以得到上面的结果是可行的。





## 方法二：动态规划

- 首先定义 `P(i，j）` ：

  ​                              ![t5_1.png](https://i.loli.net/2020/05/04/RhNSGYX8se6fEP7.png)

  接下来

  ​								` P(i,j)=(P(i+1,j-1)&&s[i]==s[j]) `

  但是需要注意的是求长度为1和2的字符串不能用上面的递推式，因为会导致左边界大于有边界，所以长度为1和2的情况需要单独拿出来作为初始条件

  

  **算法实现：**

  ```
  public String longestPalindrome(String s){
          int length=s.length();
          //P记录子字符串是否为回文字符串
          boolean[][] P=new boolean[length][length];
          //最长回文字符串长度
          int maxLen=0;
          //最长回文字符串
          String maxPal="";
          //对于所有可能的长度
          for(int len=1;len<=length;len++){
          	//对于每一个起点
              for(int start=0;start<length;start++){
                  int end=start+len-1;
                  //end越界
                  if(end>=length) break;
                  //对P数组进行赋值
                  P[start][end]=(len==1||(len==2||P[start+1][end-1])&&s.charAt(start)==s.charAt(end));
                  //如果当前字符串为回文字符串且长度大于记录的最长回文字符串
                  if(P[start][end]&&len>maxLen){
                      maxPal=s.substring(start,end+1);
                  }
              }
          }
          return maxPal;
      }
  
  ```

  

  

---
title: 50. Pow(x, n)
date: 2020-01-08 17:51:24
tags: leetcode
categories: leetcode
---

# [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

**示例：**

```
示例 1:

输入: 2.00000, 10
输出: 1024.00000


示例 2:

输入: 2.10000, 3
输出: 9.26100


示例 3:

输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```



**说明：**

```
-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
```



## 算法一：暴力法

**算法描述：**

- 暴力循环，每循环一次就乘以x
- 比较好的统一正负的方式是当n为负时，则令N=-n，并且x=1/x来统一运算

**算法实现：**

```
public double myPow(double x, int n) {
        int N=n;
        //当n小于0时，进行处理方便统一运算
        if(N<0){
            x=1/x;
            N=-N;
        }
        double result=1;
        for(int i=0;i<N;i++){
            result*=x;
        }
        return result;
    }
```





## 算法二：递归算法

**算法思想：**

- x^n^可以表示为(x^n/2^)^2^，当n为奇数时，由于四舍五入的存在，所以还需要再乘以一个x

**算法实现：**

```
public double myPow(double x, int n) {
        int N = n;
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }
        return fastPow(x, N);
    }
    
    private double fastPow(double x,int n){
    	//递归出口
        if(n==0) return 1;
        //递归调用fastPow(x,n/2)
        double fast=fastPow(x,n/2);
        //偶数时，直接平方
        if(n%2==0){
            return fast*fast;
        }else{
            //奇数时，还要乘一个x
            return fast*fast*x;
        }
    }
```





## 算法三：循环快速幂运算

**算法思想：**

- 若n可以表示为 n=n~1~+n~2~+.......，则x^n^=x^n~1~^*x^n~2~^*....

- 因此想到可以用n的二进制表示，若n可以表示为b~1~b~2~...b~k~（从低位到高位），则x^n^=x^b~1~*2的0次方^*x^b~2~*2的一次方^*......x^b~k~*2的k次方^

- 总结起来就是，使 n 的二进制从最低位 (LSB) 到最高位 (MSB) 表示为b~1~, b~2~, ..., b~k~。对于第 i 位为，如果 b~i~ =  ，意味着我们需要将结果累乘上  x^2的i次方^。

- 

- **算法实现：**

  ```
   public double myPow(double x, int n) {
          int N=n;
          if(N<0){
              x=1/x;
              N=-N;
          }
          double ans=1;
          //current_x记录当前所要乘的倍数
          double current_x=x;
          for(int index=N;index>0;index/=2){
          	//若当前位数为1，则乘以current_x
              if(index%2==1){
                  ans*=current_x;
              }
              //每当计算下一位时，x都要取平方
              current_x=current_x*current_x;
          }
          return ans;
      }
  ```

  

  ---
title: 503.下一个更大的元素II
date: 2020-06-27 15:58:57
tags: leetcode
categories: leetcode
---

# [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

**题目描述：**

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

```
示例 1:

输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```



## 栈

**算法思路：**

- 要求得循环数组中下一个更大的元素，需要两次遍历数组，用栈来存储结果
- 如果栈为空或者后面的元素小于等于栈顶元素，则入栈，否则表示后面有元素更大了，则从栈顶向下的小于这个元素的位置都找到了结果，最后可以保证栈中元素是降序的
- 由于是循环数组，则需要二次遍历数组，如果有元素比栈顶元素大，则找到了结果

```
 public int[] nextGreaterElements(int[] nums) {
        if(nums==null||nums.length==0) return new int[0];
        int len=nums.length;
        int[] res=new int[len];
        //首先全部用-1填充
        Arrays.fill(res,-1);
        Stack<Integer> stack=new Stack<>();
        for(int i=0;i<len;i++){
        	//如果栈为空，或者后面的元素更小则入栈
            if(stack.isEmpty()||nums[i]<=nums[stack.peek()])
                stack.push(i);
            else{
            	//否则一直出栈到栈顶元素比后面的元素大或者为空
                while(!stack.isEmpty()&&nums[stack.peek()]<nums[i])
                    res[stack.pop()]=nums[i];
                //最后还要把i push进去
                stack.push(i);
            }
        }
        //第二次遍历数组
        for(int i=0;i<len;i++){
            if(stack.isEmpty()) break;
            if(nums[i]>nums[stack.peek()]){
                while(!stack.isEmpty()&&nums[stack.peek()]<nums[i])
                    res[stack.pop()]=nums[i];
            }
        }
        return res;
    }
```

---
title: 524. 通过删除字母匹配到字典里最长单词
date: 2020-05-09 22:07:53
tags:	
		- leetcode
categories:
		- leetcode
---

# [524. 通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)

给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。

```
示例 1:

输入:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

输出: 
"apple"

示例 2:

输入:
s = "abpcplea", d = ["a","b","c"]

输出: 
"a"

```


说明:

- 所有输入的字符串只包含小写字母。
- 字典的大小不会超过 1000。
- 所有输入的字符串长度不会超过 1000。



## 双指针法

**算法思想：**

- 通过双指针法可以判断一个字符串是否为另一个字符串的子串
- 而由于都是小写字母，所以判断字段序可以直接用string类的compareTo()方法。



**算法实现：**

```
public String findLongestWord(String s, List<String> d) {
        String res="";
        for(String str:d){
            if(isSub(s,str)){
                if((str.length()>res.length())||str.length()==res.length()&&str.compareTo(res)<0) res=str;
            }
        }
        return res;
    }
	
	//判断是否为子串的方法
    private boolean isSub(String s,String sub){
        int i=0,j=0;
        while (i<s.length()&&j<sub.length()){
            if(s.charAt(i)==sub.charAt(j))  j++;
            i++;
        }
        return j==sub.length();
    }
```

---
title: 53. 最大子序和
date: 2020-01-08 17:51:24
tags: leetcode
categories: leetcode
---

# [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

**题目描述：**
给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。



**示例：**

```
示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```



## 算法一：暴力法（分别计算以数组中每一个元素为开头的连续子数组的最大和，然后取最大）

**算法实现：**

```
public int maxSubArray(int[] nums) {
		//max记录最终结果，temp记录以当前元素为开头的最大连续子数组和
        int max=Integer.MIN_VALUE,temp=0;
        //对于以每一个元素为开头分别计算最大和
        for(int i=0;i<nums.length;i++){
            temp=nums[i];
            //首先判断当前最大连续子序列和是否比最终结果大
            if(temp>max){
                max=temp;
            }
            for(int j=i+1;j<nums.length;j++){
            	//如果当前子序列和小于0，则跳出循环
                if(temp<0){
                    break;
                }
                temp+=nums[j];
                //此处判断两次并不多余，上面的判断是防止当j从i+1开始取值时没有进行一次循环，就会丢				  失掉此时的最大子序列和，而后面的是因为最大子序列和可能出现在求和的过程中，而不一					定是结尾
                if(temp>max){
                    max=temp;
                }
            }
        }
        return max;
    }
```





## 算法二：分治法

**算法思想：**

- 分治法需要合并结果时，需要处理当最大和即不再左半边的数组，也不再右边边数组，而是横跨两个数组时的情况
- 将数组分为两部分，索引为(left+right)/2的元素归到左边数组



**算法实现：**

```
public int maxSubArray(int[] nums) {
		//将数组为空的情况单独拿出
        if(nums.length==0){
            return 0;
        }
        return maxArray(nums,0,nums.length-1);
    }
    private int maxArray(int[] nums,int left,int right){
    	//递归出口，当数组只有一个元素时，直接返回
        if(left==right){
            return nums[left];
        }
        //左边数组的最大值
        int leftMax=maxArray(nums,left,(left+right)/2);
        //右边数组的最大值
        int rightMax=maxArray(nums,(left+right)/2+1,right);
        //lmax记录在左边元素中，包含其最右边元素时的最大和
        int lmax=Integer.MIN_VALUE;
        //ltemp则记录暂时的最大和
        int ltemp=0;
        for(int i=(left+right)/2;i>=left;i--){
            ltemp+=nums[i];
            if(ltemp>lmax){
                lmax=ltemp;
            }
        }
        //rmax与rtemp同上
        int rmax=Integer.MIN_VALUE;
        int rtemp=0;
        for(int i=(left+right)/2+1;i<=right;i++){
            rtemp+=nums[i];
            if(rtemp>rmax){
                rmax=rtemp;
            }
        }
        //middleMax表示横跨两边数组的最大值
        int middleMax=lmax+rmax;
        //返回三者中最大的元素即为最大和
        return Math.max(Math.max(leftMax,rightMax),middleMax);
    }
```







## 算法三：贪心算法：

**算法思想：**

- 我自我感觉不太像是贪心算法，这样解释有点牵强，更像是换一种方法计算，第一种方法是分别计算以每一个元素为开头时的最大子序列和，则可以通过计算以每一个元素为结尾时的最大子序列和，以`nums[0]`为结尾的最大子序列和显然为自己，更一般的，以 `nums[i]`为结尾的最大子序列和有两种情况：
  1. 第一种是，以 `nums[i-1]`结尾的最大子序列和再加上`nums[i]`
  2. 第二种是，`nums[i]`
- 任何其他情况都比这两种情况要小，有递推的关系在其中，更像是动态规划





**算法实现：**

```
public int maxSubArray(int[] nums) {
        int n=nums.length;
        //可以看出动态规划的初值，currSum记录以当前元素结尾的最大子序列和，maxSum则记录最终结果
        int currSum=nums[0],maxSum=nums[0];
        //分别计算以每一个元素结尾时的最大子序列和
        for(int i=1;i<n;i++){
        	//两种情况中的一种
            currSum=Math.max(currSum+nums[i],nums[i]);
            //更新maxSum的值
            maxSum=Math.max(maxSum,currSum);
        }
        return maxSum;
    }
```



## 算法四：动态规划

**算法思想：**

- 其实和上面大致思路是一样，也是记录以当前元素结尾时的最大子序列和，但不同的是，将当前的最大子序列和记录在 `nums[i]`上



**算法实现：**

```
public int maxSubArray(int[] nums) {
        int n=nums.length;
        //动态规划的初值
        int maxSum=nums[0];
        for(int i=1;i<n;i++){
        	//直接将以nums[i]结尾的最大子序列和存在nums[i]中
            nums[i]=Math.max(nums[i],nums[i-1]+nums[i]);
            maxSum=Math.max(nums[i],maxSum);
        }
        return maxSum;
    }
```

---
title: 530.二叉搜索树的最小绝对差
date: 2020-06-27 17:31:07
tags: leetcode
categories: leetcode
---

# [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

**题目描述：**

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

```
示例：

输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```



## 中序遍历(用一个节点来表示前一个节点)

**算法思想：**

- 用一个last来表示前一个节点即可

```
	private int res=Integer.MAX_VALUE;

    private TreeNode last=null;

    public int getMinimumDifference(TreeNode root) {
        if(root==null) return 0;
        inOrder(root);
        return res;
    }

    private void inOrder(TreeNode root){
        if(root==null) return;
        inOrder(root.left);
        if(last!=null){
            res=Math.min(res,root.val-last.val);
        }
        last=root;
        inOrder(root.right);
    }
```



## 中序遍历(用list存储起来)---
title: 54. 螺旋矩阵
date: 2020-01-08 17:51:24
tags: leetcode
categories: leetcode
---

# [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

**题目描述：**
给定一个包含 *m* x *n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。



**示例：**

```
示例 1:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]


示例 2:

输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]
```





## 二刷

**算法思想：**

- 类似与dfs的思想，用到一个方向矩阵，同样需要一个矩阵表示当前元素是否被访问。

```
public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res=new ArrayList<>();
        if(matrix==null||matrix.length==0) return res;
        int m=matrix.length;
        int n=matrix[0].length;
        boolean[][] visited=new boolean[m][n];
        int[][] direction={{0,1},{1,0},{0,-1},{-1,0}};
        int total=m*n,row=0,col=0;
        int dir=0;
        for(int i=0;i<total;i++){
            res.add(matrix[row][col]);
            visited[row][col]=true;
            int newRow=row+direction[dir][0],newCol=col+direction[dir][1];
            if(newRow<0||newRow>=m||newCol<0||newCol>=n||visited[newRow][newCol]){
                dir=(dir+1)%4;
                newRow=row+direction[dir][0];
                newCol=col+direction[dir][1];
            }
            row=newRow;
            col=newCol;
        }
        return res;
    }
```





## 算法一：从外到内每层循环

**算法描述：**

- 从外到内每一次循环顺时针访问每一个元素，本意上看是不需要设置一个seen数组来存储每一个节点被访问的情况的，但是由于一些边界条件我没有处理好，所以加上了这个数组
- 每一层分为四个方向的访问，每一次访问都留下这一行或者这一列的最后一个元素，这样每一层的四个方向的访问所访问的元素就是相同的数量。



**算法实现：**

```
public List<Integer> spiralOrder(int[][] matrix) {
        if(matrix==null){
            return null;
        }
        List<Integer> list=new ArrayList<>();
        //对于二维数组，m表示行数，n表示列数
        int m=matrix.length;
        //如果二维数组长度为0，返回空集合
        if(m==0){
            return list;
        }
        int n=matrix[0].length;
        //seen数组记录每个元素被访问了没，默认为false表示为被访问
        boolean[][] seen=new boolean[m][n];
        int seg=Math.min(m,n);
        //index记录当前循环遍历的是哪一层
        int index=0;
        for(;index<=seg/2;index++) {
            for (int i = index; i < n - index - 1; i++) {
            	//表示未被访问
                if(seen[index][i]==false) {
                    list.add(matrix[index][i]);
                }
                //将其置为访问
                seen[index][i]=true;
            }
            for (int j = index; j < m - index - 1; j++) {
                if(seen[j][n - index - 1]==false) {
                    list.add(matrix[j][n - index - 1]);
                }
                seen[j][n - index - 1]=true;
            }
            for (int i = n - index - 1; i > index; i--) {
                if(seen[m - index - 1][i]==false) {
                    list.add(matrix[m - index - 1][i]);
                }
                seen[m - index - 1][i]=true;
            }
            for (int j = m - index - 1; j > index; j--) {
                if(seen[j][index]==false) {
                    list.add(matrix[j][index]);
                }
                seen[j][index]=true;
            }
        }
        //最后要判断最中心的元素是否被访问
        index--;
        if(seen[index][index]==false){
            list.add(matrix[index][index]);
        }
        return list;
    }
```





## 算法二：用方向数来表示顺时针方向

**算法描述：**

- 用两个数组来表示顺时针方向，同时用mr和nc分别来表示下一个要被访问元素的行和列，如果其已经被访问过，则表示要顺时针访问下一个元素了





**算法实现：**

```
public List<Integer> spiralOrder(int[][] matrix) {
        if(matrix==null){
            return null;
        }
        List<Integer> list=new ArrayList<>();
        int m=matrix.length;
        if(m==0){
            return list;
        }
        int n=matrix[0].length;
        boolean[][] seen=new boolean[m][n];
        //dm和dn表示顺时针方向数组
        int[] dm=new int[]{0,1,0,-1};
        int[] dn=new int[]{1,0,-1,0};
        //r和c分别表示当前元素的行和列，di表示当前进行到了顺时针数组中的哪一个方向
        int r=0,c=0,di=0;
        for(int i=0;i<m*n;i++){
            list.add(matrix[r][c]);
            seen[r][c]=true;
            //mr和nc表示下一个要被访问的元素的行和列
            int mr=r+dm[di];
            int nc=c+dn[di];
            //如果mr和nc没有越界并且未被访问过，则将其置为下一个要被访问的元素，否则取下一个方向的				元素为下一个要被访问的。
            if(mr>=0&&mr<m&&nc>=0&&nc<n&&!seen[mr][nc]){
                r=mr;
                c=nc;
            }else{
            	//取模来表示方向变化
                di=(di+1)%4;
                r+=dm[di];
                c+=dn[di];
            }
        }
        return list;
    }
```

---
title: 55. 跳跃游戏
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

**题目描述：**给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。



**示例：**

```
示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。


示例 2:

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```



## 动态规划思路整理：

通常解决并理解一个动态规划问题需要以下 4 个步骤：

1. 利用递归回溯解决问题
2. 利用记忆表优化（[自顶向下](https://baike.baidu.com/item/自顶向下)的动态规划）
3. 移除递归的部分（自底向上的动态规划）
4. 使用技巧减少时间和空间复杂度



## 算法一：回溯

**算法实现：**

```
public boolean canJump(int[] nums) {
		//判断第一个位置能否跳到最后一个位置
        return jumpTrace(nums,0);
    }
    
    //参数index表示当前判断的是哪个索引处的数据能否跳到最后的位置，称这样的点为“好位置”
    private boolean jumpTrace(int[] nums,int index){
        int n=nums.length;
        //递归出口，表示可以跳到最后一个位置
        if(index==n-1){
            return true;
        }else if(index>=n){
            return false;
        }else{
            int num=nums[index];
            //i从大到小循环，类似贪心的算法，可以节省时间
            for(int i=num;i>0;i--){
            	//如果index+i为好位置，并且index可以向前跳i到index+i，所以index也为					 好位置
                if(jumpTrace(nums,index+i)){
                    return true;
                }
            }
        }
        //否则，index向前的任何一种跳步策略到的都不是一个好节点，那么index就是一个坏节点
        return false;
    }
```





## 算法二：自顶向下的动态规划，使用记忆表优化

**算法思路：**

- 在回溯的过程中，一旦发现一个位置是坏节点，那么下面的回溯过程中都可以避开这个节点，因此想到可以用记忆表来存储已经判断过的节点。
- 步骤如下：
  1. 初始化 `memo` 的所有元素为 *UNKNOWN*，除了最后一个显然是 *GOOD* （自己一定可以跳到自己）
  2. 在递归前首先判断这个节点是否被判断过，如果已经被判断过，则返回之前判断的结果，如果没有被判断过，再进入下面的判断。
  3. 每次判断后，将结果存入`memo`数组中



**算法实现：**

```
//定义一个枚举类Index
enum Index{
    GOOD, BAD, UNKNOWN
}
public class Solution2 {
    public boolean canJump(int[] nums) {
    	//memo作为记忆数组，通过参数传递
        Index[] memo=new Index[nums.length];
        //初始化为UNKNOWN,最后一个数为GOOD
        for(int i=0;i<memo.length;i++){
            memo[i]=Index.UNKNOWN;
        }
        memo[memo.length - 1] = Index.GOOD;
        return jumpTrace(nums,0,memo);
    }
    private boolean jumpTrace(int[] nums,int index,Index[] memo){
        int n=nums.length;
        if(index>=n){
            return false;
        }
        //判断如果当前index处的点已经被判断过，则直接返回之前的判断结果
        if(memo[index]!=Index.UNKNOWN){
            return memo[index]==Index.GOOD?true:false;
        }
        if(index==n-1){
            return true;
        }else{
            int num=nums[index];
            for(int i=num;i>0;i--){
                if(jumpTrace(nums,index+i,memo)){
                	//判断当前节点为好节点的同时修改memo数组的值
                    memo[index]=Index.GOOD;
                    return true;
                }
            }
        }
        //判断当前节点不是好节点的同时，修改memo数组的值为false
        memo[index]=Index.BAD;
        return false;
    }
```

**时间复杂度为**：O(n^2^)，数组中的每个元素，假设为 i，需要搜索右边相邻的 nums[i] 个元素查找是否有 GOOD 的坐标。 nums[i] 最多为 n，n 是 nums 数组的大小。

**空间复杂度为**：O(2n)=O(n)，第一个 n 是栈空间的开销，第二个 n 是记忆表的开销。



- 注意在修改记忆数组的值时，在一次函数调用中，只需要判断当前节点即index处的`memo[index]`的值，不需要去判断其他节点，例如`memo[index+i]`的值，因为在递归调用中，这些点的函数调用会在判断index之前，所以其值可以在index处的值之前确定。



## 算法三：自底向上的动态规划，消除递归

**算法思路：**

- 由于有memo数组的存在，所以想到可以用纯动态规划的方法，因为最后一个节点已经肯定时“好节点”，所以，可以从右向左开始动态规划。



**算法实现：**

```
public boolean canJump(int[] nums) {
        Index[] memo=new Index[nums.length];
        for(int i=0;i<memo.length;i++){
            memo[i]=Index.UNKNOWN;
        }
        memo[memo.length - 1] = Index.GOOD;
        int n=nums.length;
        //从右向左递推
        for(int i=n-2;i>=0;i--){
        	//num记录i所能跳到的最远位置
            int num=Math.min(i+nums[i],n-1);
            //对于i所有可能跳到的位置，判断其是否为“好节点”
            for(int j=num;j>i;j--){
                if(memo[j]==Index.GOOD){
                    memo[i]=Index.GOOD;
                }
            }
            //最后如果未在上面的循环中判断其为好节点，则其值为默认的UNKNOWN，则赋值为			   BAD
            if(memo[i]==Index.UNKNOWN) {
                memo[i] = Index.BAD;
            }
        }
        //最够返回memo[0]是否为好节点
        return memo[0]==Index.GOOD;
    }
```



**时间复杂度：**O(n^2^)

**空间复杂度：**O(n)





## 算法四：贪心

**算法思想：**

- 用一个`lastPosition`来记录最左边的GOOD位置的坐标，如果最后有`lastPosition==0`，则表示第一个位置的数是好位置



**算法实现：**

```
public boolean canJump(int[] nums) {
        int n=nums.length;
        //lastPosition记录最左边的GOOD位置的坐标，初始为n-1
        int lastPosition=n-1;
        for(int i=n-2;i>=0;i--){
        	//如果i+nums[i]>=lastPosition，那么i一定可以跳到lastPosition，也就是一				个好位置，则需要更新lastPosition的值
            if(i+nums[i]>=lastPosition){
                lastPosition=i;
            }
        }
        //最后返回lastPosition是否为0
        return lastPosition==0;
    }
```



**时间复杂度：**O(n)

**空间复杂度：**O(1)---
title: 56. 合并区间
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

**题目描述：**给出一个区间的集合，请合并所有重叠的区间。

**示例：**

```
示例 1:

输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].


示例 2:

输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```



## 二刷

**注意是根据左区间排序，而不是右区间**

```
public int[][] merge(int[][] intervals) {
        if(intervals==null||intervals.length<=1) return intervals;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] i1,int[] i2){
                return i1[0]-i2[0];
            }
        });
        int left=intervals[0][0],right=intervals[0][1];
        List<int[]> res=new ArrayList<>();
        for(int i=1;i<intervals.length;i++){
            if(intervals[i][0]<=right){
                right=Math.max(right,intervals[i][1]);
            }else{
                res.add(new int[]{left,right});
                left=intervals[i][0];
                right=intervals[i][1];
            }
        }
         res.add(new int[]{left,right});
        int[][] ress=new int[res.size()][2];
        int i=0;
        for(int[] nums:res){
            ress[i++]=nums;
        }
        return ress;
    }
```



## 算法一：排序

**算法思想**：

- 将每个区间按照start升序排列，那么每次就只需要比较相邻的两个区间是否有重叠的部分
- 用LinkedList去存储合并后的区间，这是因为LinkedList有 `getLast()方法`可以返回最后的一个节点进行比较，如果



**算法实现：**

```
public class Solution1 {
	//定义一个Interval的类，start存储的是区间起点，end是区间终点
    private class Interval{
        int start;
        int end;
        //提供一个构造函数，传入一个数组，将其的两个元素分别赋给start和end
        public Interval(int[] ints){
            start=ints[0];
            end=ints[1];
        }
    }
    //定义一个Comparator接口来实现对Interval排序，注意要在下面加上具体的泛型
    private class IntervalComparator implements Comparator<Interval>{
        @Override
        public int compare(Interval t1, Interval t2) {
        	//按start位升序排列
            return t1.start>t2.start?1:t1.start==t2.start?0:-1;
        }
    }
    public int[][] merge(int[][] intervals) {
    	//将二维数组转换为Interval一维数组
        Interval[] ints=new Interval[inervals.length];
        //对数组ints使用构造函数赋值
        for(int i=0;i<intervals.length;i++){
            ints[i]=new Interval(intervals[i]);
        }
        //对ints数组排序
        Arrays.sort(ints,new IntervalComparator());
        //使用LinkedList存储区间
        LinkedList<Interval> list=new LinkedList<>();
        for(int i=0;i<ints.length;i++){
        	//如果list.getLast().end<ints[i].start，表明区间没有重叠
            if(list.isEmpty()||list.getLast().end<ints[i].start){
                list.add(ints[i]);
            }else{
            	//否则，则需要合并区间
                list.getLast().end=Math.max(ints[i].end,list.getLast().end);
            }
        }
        //初始化需要返回的二维数组
        int[][] result=new int[list.size()][2];
        for(int i=0;i<result.length;i++){
        	//对于每一个result[i]初始化为包含区间起点和终点的数组
            result[i]=new int[]{list.get(i).start,list.get(i).end};
        }
        return result;
    }
}
```



**注意：**

1. Comparator接口的compare方法的返回值解释：
   - 1表示两数需要互换位置
   - 0表示不处理
   - -1表示不互换位置



**时间复杂度：**O(nlogn),排序的时间复杂度为O(nlogn)，除去排序仅仅需要一遍扫描

**空间复杂度：**O(n)，申请的LinkedList的消耗为O(n)，而排序的时间复杂度为O(1)或O(n)





**算法二：**图，找连通区域

**算法思想：**

- 将每一个区间看成端点，如果两个区间之间有重叠的部分，则看作着两个端点之间有边，则最后问题可以转化为求图的连通图

- 用邻接表去存储图，可以用map来实现

**算法实现：**

```
public class Solution2 {
	//graph存储图的邻接表
    private Map<Interval, List<Interval>> graph;
    //nodeIncomp存储在同一个连通区域中的Interval，键表示第几个连通区域，从0开始
    private Map<Integer,List<Interval>> nodesInComp;
    //由于下面要用到图的遍历DFS，所以用一个visited集合来表示Interval是否被访问
    private Set<Interval> visited;
    private class Interval{
        int start;
        int end;
        public Interval(int start,int end){
            this.start=start;
            this.end=end;
        }
    }
	//判断两个Interval是否重叠
    private boolean overlap(Interval a,Interval b){
        return a.end>=b.start&&a.start<=b.end;
    }
    //建图
    private void buildGraph(List<Interval> intervals){
        graph=new HashMap<>();
        //首先初始化graph后，需要将每一个interval存入其中，值对应一个空的LinkedList
        for(Interval interval:intervals){
            graph.put(interval,new LinkedList<>());
        }
        //循环判断两个interval间是否有边，即是否重叠，若重叠则将其加入到对应的				  LinkedList中
        for(Interval interval1:intervals){
            for(Interval interval2:intervals){
                if(overlap(interval1,interval2)){
                    graph.get(interval1).add(interval2);
                    //下面这一行我觉得不需要，因为会重复添加
                    //graph.get(interval2).add(interval1);

                }
            }
        }
    }
	
	//将重叠的区间合并成一个区间
    private Interval mergeNodes(List<Interval> nodes){
    	//分别找到区间的最小start和最大的end
        int minstart=nodes.get(0).start;
        for(Interval interval:nodes){
            if(interval.start<minstart){
                minstart=interval.start;
            }
        }
        int maxend=nodes.get(0).end;
        for(Interval interval:nodes){
            if(interval.end>maxend){
                maxend=interval.end;
            }
        }
        return new Interval(minstart,maxend);
    }
	
   //compNumber表示第几个连通区域，此方法表示从start开始DFS遍历第compNumber个连通区域
    private void markComponetDFS(Interval start,int compNumber){
        Stack<Interval> stack=new Stack();
        stack.add(start);
        while(!stack.isEmpty()){
            Interval node=stack.pop();
            if(!visited.contains(node)) {
                visited.add(node);
                if (!nodesInComp.containsKey(compNumber)) {
                    nodesInComp.put(compNumber, new LinkedList<>());
                }
                nodesInComp.get(compNumber).add(node);
                for (Interval child : graph.get(node)) {
                    stack.add(child);
                }
            }
        }
    }
	
	//构建连通区域图
    private void buildComponets(List<Interval> intervals){
        nodesInComp=new HashMap<>();
        visited=new HashSet<>();
        int compNumber=0;
        //对于每一个连通区域分别调用DFS遍历，并且compNumber记录这是第几个连通区域
        for(Interval interval:intervals){
            if(!visited.contains(interval)){
                markComponetDFS(interval,compNumber);
                compNumber++;
            }
        }
    }
    public int[][] merge(int[][] intervals) {
        Interval[] ints=new Interval[intervals.length];
        for(int i=0;i<intervals.length;i++){
            ints[i]=new Interval(intervals[i][0],intervals[i][1]);
        }
        List<Interval> list = Arrays.asList(ints);
        List<Interval> merged=new LinkedList<>();
        buildGraph(list);
        buildComponets(list);
        for (int comp = 0; comp < nodesInComp.size(); comp++) {
            merged.add(mergeNodes(nodesInComp.get(comp)));
        }
        int[][] result=new int[merged.size()][2];
        for(int i=0;i<result.length;i++){
            result[i]=new int[]{merged.get(i).start,merged.get(i).end};
        }
        return result;
    }
}
```



**时间复杂度：**O(n^2^),建图的时间复杂度为O(V+E)=O(n)+O(n^2^),`buildComponets(list);`的时间复杂度也是O(n^2^)，`mergeNodes()`的时间复杂度为O(n)

**空间复杂度**：O(n^2^)



**注意**：上面中的将二维数组 `int[][] intervals`转换为对应的 `List<Interval>`的过程：

1. 首先转换为 `Interval[] ints`，通过Interval的构造函数对其赋值
2. 然后将ints转换为List，调用的是`Arrays.asList(ints)`



同样，将 `List<Interval>`转换为 `int[][] result`的过程：

1. 第一种方法，对于result的每一行，分别初始化
2. 第二种方法，先将list转化为Interval数组，使用 `Interval[] results = merged.toArray(new Interval[0])`;,然后将一维数组转换为二维数组

---
title: 583.两个字符串的删除操作
date: 2020-06-11 14:42:20
tags: leetcode
categories: leetcode
---

# [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。



```
示例：

输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```



## 动态规划

- memo\[i][j]表示使word1的前i个字符和word2的前j个字符相同所需要删除的最少字符
- 则如果有`word1.charAt(i-1)==word2.charAt(j-1)`，则memo\[i][j]=memo\[i-1][j-1]，否则 `memo[i][j]=Math.min(memo[i-1][j],memo[i][j-1])+1`

```
 public int minDistance(String word1, String word2) {
        int len1=word1.length();
        int len2=word2.length();
        int[][] memo=new int[len1+1][len2+1];
        for(int i=0;i<=len1;i++){
            for(int j=0;j<=len2;j++){
            	//处理一下特殊情况
                if(i==0&&j==0) memo[i][j]=0;
                else if(i==0||j==0) memo[i][j]=i+j;
                else{
                    if(word1.charAt(i-1)==word2.charAt(j-1))
                        memo[i][j]=memo[i-1][j-1];
                    else{
                        memo[i][j]=Math.min(memo[i-1][j],memo[i][j-1])+1;
                    }
                }
            }
        }
        return memo[len1][len2];
    }
```

---
title: 594.最长和谐子序列
date: 2020-06-27 20:44:43
tags: leetcode
categories: leetcode
---

# [594. 最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/)

**题目描述：**

和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。

现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。

```
示例 1:

输入: [1,3,2,2,5,2,3,7]
输出: 5
原因: 最长的和谐数组是：[3,2,2,2,3].
```



## 哈希表

**算法思想：**

- 用哈希表去存储每个元素出现的次数，然后依次统计以每个元素作为下界的和谐子序列长度，取最大即可

```
public int findLHS(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        Map<Integer,Integer> map=new HashMap<>();
        for(int num:nums){
            if(!map.containsKey(num)){
                map.put(num,1);
            }else{
                map.put(num,map.get(num)+1);
            }
        }
        int res=0;
        for(int num:map.keySet()){
            if(map.containsKey(num+1)){
                res=Math.max(res,map.get(num)+map.get(num+1));
            }
        }
        return res;
    }
```

---
title: 6.Z字形变换
date: 2020-07-10 16:04:48
tags: leetcode
categories: leetcode
---

# [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

**题目描述：**

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：

L   C   I   R
E T O E S I I G
E   D   H   N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。

请你实现这个将字符串进行指定行数变换的函数：

`string convert(string s, int numRows);`



```
示例 1:

输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"

示例 2:

输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
```





**算法思想：**

- 用一个list来记录每一行有哪些字符，那么在整个字符串从左向右遍历时，只需要确定当前字符是哪一行即可，所以要搞明白行数的变化；
- 行数是从0到numRows-1，然后再从numRows-1到0，后面再依次

```
public String convert(String s, int numRows) {
        if(numRows==1) return s;
        List<List<Character>> res=new ArrayList<>();
        //先给每一行加一个空的list
        for(int i=0;i<numRows;i++){
            res.add(new ArrayList<>());
        }
        char[] chars=s.toCharArray();
        int index=0,row=0;
        //falg来记录当前row是要增还是要减
        boolean flag=true;
        while(index<chars.length){
            res.get(row).add(chars[index++]);
            if(row==0){
                flag=true;
                row++;
                continue;
            }
            if(row==numRows-1){
                flag=false;
                row--;
                continue;
            }
            if(flag) row++;
            else row--;
        }
        char[] str=new char[s.length()];
        index=0;
        for(List<Character> list:res){
            for(Character c:list){
                str[index++]=c;
            }
        }
        return new String(str);
    }
```

**时间复杂度：**O(n)

**空间复杂度：**O(n)---
title: 62. 不同路径
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

**题目描述：**

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![image-20200119191050814](/images/leetcode/t14_2.png)

**示例：**

```
示例 1:

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右


示例 2:

输入: m = 7, n = 3
输出: 28
```



# 算法一：回溯法

**算法思想：**

- 以(i,j)表示机器人当前的位置，(m,n)表示终点的位置
- 当i==m且j==n时表示机器人已经走到终点了，则计数num++
- 若i<m，则机器人可以向下走
- 若j<n，则机器人可以向右走

**算法实现：**

```
//全局变量num表示到终点的路径
private int num;
    public int uniquePaths(int m, int n) {
    	//初始位置为(1,1)
        PTrace(1,1,m,n);
        return num;
    }
    //(i,j)表示当前机器人的位置
    private void PTrace(int i,int j,int m,int n){
    	//表示到达终点，num++
        if(i==m&&j==n){
            num++;
        }
        //如果i<m，则机器人向下走
        if(i<m){
            PTrace(i+1,j,m,n);
        }
        如果j<n，则机器人向右走
        if(j<n){
            PTrace(i,j+1,m,n);
        }
    }
```







# 算法二：动态规划

**算法思想：**

- 用一个二维数组去存储索引处位置到终点的不同路径条数，则显然`paths[m-1][n-1]=1`,需要注意的是数组的索引是从0开始的，而机器人位置坐标是从1开始的，所以要统一坐标
- 动态规划递推公式为
  - 若i<m-1且j<n-1， `paths[i][j]=paths[i][j+1]+paths[i+1][j]`
  - 若i==m-1，则 `paths[i][j]=paths[i][j+1]`
  - 若j==n-1,则 `paths[i][j]=paths[i+1][j]`
- 最后输出的 `paths[0][0]即为所求`



**算法实现：**

```
public int uniquePaths(int m, int n) {
		//paths数组存放每一个索引代表的位置到终点的不同路径条数
        int[][] paths=new int[m][n];
        //此处默认为1
        paths[m-1][n-1]=1;
        //对所有点从后向前递推赋值
        for(int i=m-1;i>=0;i--){
            for(int j=n-1;j>=0;j--){
            	//i==m-1且j==n-1时不需要进行赋值，因为之前已经赋过值了
                if(i==m-1&&j==n-1) continue;
                //如果i==m-1，则机器人只能向右走
                if(i==m-1){
                    paths[i][j]=paths[i][j+1];
                    //j==n-1时，机器人只能向下走
                }else if(j==n-1){
                    paths[i][j]=paths[i+1][j];
                }else{
                	//否则机器人既能向下走，又能向右走
                    paths[i][j]=paths[i][j+1]+paths[i+1][j];
                }
            }
        }
        //最后paths[0][0]即为所求
        return paths[0][0];
    }
```



**时间复杂度：**O(m*n),两层循环处的时间复杂度

**空间复杂度：**O(m*n)，paths数组的空间消耗---
title: 63.不同路径II
date: 2020-07-10 17:52:18
tags: leetcode
categories: leetcode
---

# [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

**题目描述:**

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？



网格中的障碍物和空位置分别用 1 和 0 来表示。

说明：m 和 n 的值均不超过 100。



```
示例 1:

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```





## 动态规划

**算法思想：**

- 需要去处理障碍物时的情况，用0来表示某个位置不可到达，则其余递推关系是不变的

```
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m=obstacleGrid.length,n=obstacleGrid[0].length;
        int[][] dp=new int[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0&&j==0){
                    dp[i][j]=obstacleGrid[0][0]==1?0:1;
                    continue;
                }
                //如果当前有障碍物，则dp为0
                if(obstacleGrid[i][j]==1)
                    dp[i][j]=0;
                else{
                    if(i-1>=0&&j-1>=0){
                        dp[i][j]=dp[i-1][j]+dp[i][j-1];
                    }else if(i==0){
                        dp[i][j]=dp[i][j-1];
                    }else dp[i][j]=dp[i-1][j];
                }
            }
        }
        return dp[m-1][n-1];
    }
```

---
title: 650.只有两个键的键盘
date: 2020-06-14 15:42:32
tags: leetcode
categories: leetcode
---

# [650. 只有两个键的键盘](https://leetcode-cn.com/problems/2-keys-keyboard/)

**题目描述：**

最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：

Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
Paste (粘贴) : 你可以粘贴你上一次复制的字符。
给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。



```
示例 1:

输入: 3
输出: 3
解释:
最初, 我们只有一个字符 'A'。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 'AA'。
第 3 步, 我们使用 Paste 操作来获得 'AAA'。
```



## 动态规划

**算法思想：**

- 题目等价于素数分解，首先对于一个素数，其dp[i]=i，因为素数没有因子，所以只能由1粘贴得来，而对于25=5*5，首先可以先得到5需要5次，然后5复制之后，粘贴4次就可以得到25
- 更一般的如果i可以分解为m*n，则有dp[i]=dp[m]+dp[n];其中dp[m]就是先得到m所需要的次数，对dp[n]的理解举一个例子：24=2\*12，后面的dp[12]可以理解初始记事本中有2个A，要得到24个A需要多少次，完全等价于初始笔记本只有1个A，得到12个A需要的次数也就是dp[12]
- 而对于存在多个分解的情况，也只用计算一次，因为最终都是分解成了素数的乘积

```
public int minSteps(int n) {
          if(n==1) return 0;
          int[] dp=new int[n+1];
          dp[1]=0;
          //初始化每一个dp[i]=i
          for(int i=2;i<=n;i++){
              dp[i]=i;
          }
          for(int i=2;i<=n;i++){
              for(int j=2;j<=Math.sqrt(i);j++){
                  if(i%j==0){
                      dp[i]=dp[j]+dp[i/j];
                      break;
                  }
              }
          }
          return dp[n];
    }
```

---
title: 66. 加一
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [66. 加一](https://leetcode-cn.com/problems/plus-one/)

**题目描述：**

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。



**示例：**

```
示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。


示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```



## 数学解法

**算法思想：**

- 依次从后向前遍历数字，若当前数字小于9，则直接加一跳出循环即可；否则当前数字为9，需要进位，将当前数字改为0，然后再去判断前面的数字
- 需要特别注意的是所有数字都是9的情况，此时需要重新申请一个数组，将首位赋为1



**算法实现：**

```
public int[] plusOne(int[] digits) {
        int len=digits.length;
        int i=0;
        //从最后一位向前循环判断
        for(i=len-1;i>=0;i--){
        	//若当前位数小于9
            if(digits[i]<9){
                digits[i]+=1;
                break;
            }else{
                digits[i]=0;
            }
        }
        //i<0则表示，上面的循环没有因为digits[i]<9而跳出，因此所有位数都是9
        if(i<0){
            int[] result=new int[len+1];
            result[0]=1;
            return result;
        }
        return digits;
    }
```



**算法分析：**

- **时间复杂度：**
  1. 最坏情况下，时间复杂度为O(n)
  2. 一般情况下，时间复杂度为O(1)
- **空间复杂度：**
  1. 最坏情况下，空间复杂度为O(n),因为需要申请一个新的数组
  2. 一般情况下，空间复杂度为O(1)

---
title: 669.修建二叉搜索树
date: 2020-06-02 21:17:05
tags: leetcode
categories: leetcode
---

# [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

**题目描述：**

给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。



```
示例 1:

输入: 
    1
   / \
  0   2

  L = 1
  R = 2

输出: 
    1
      \
       2


示例 2:

输入: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

输出: 
      3
     / 
   2   
  /
 1
```





**算法思想：**

- 如果root处的值val已经小于L，则其左子树肯定已经小于L了，所以只需要递归在右子树进行操作返回即可
- 如果root处的值val已经大于R，则其右子树肯定已经大于R了，所以只需要递归在左子树进行操作返回即可
- 否则在范围内，则递归对左右子树操作，返回值作为新的左孩子和右孩子

```
public TreeNode trimBST(TreeNode root, int L, int R) {
        return del(root,L,R);
    }

    private TreeNode del(TreeNode root,int L,int R){
        if(root==null) return null;
        //整个左子树可以删除了
        if(root.val<L){
            return del(root.right,L,R);
        }
        if(root.val>R){
            return del(root.left,L,R);
        }
        root.left=del(root.left,L,R);
        root.right=del(root.right,L,R);
        return root;
    }
```

---
title: 671.二叉树中第二小的节点
date: 2020-06-28 15:04:31
tags: leetcode
categories: leetcode
---

# [671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

**题目描述：**

给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。



```
示例 1:

输入: 
    2
   / \
  2   5
     / \
    5   7

输出: 5
说明: 最小的值是 2 ，第二小的值是 5 。


示例 2:

输入: 
    2
   / \
  2   2

输出: -1
说明: 最小的值是 2, 但是不存在第二小的值。
```





## 递归

**算法思想：**

- 首先最小的值一定是根节点的值，那么第二小的值就有以下几种情况：
  1. 左孩子的值等于根节点，并且右孩子的值也等于根节点，则结果为分别在两个子树中寻找得到的较小者；
  2. 左孩子等于根节点，右孩子大于根节点，则结果为左子树中第二小的和右孩子的值中的较小者；
  3. 左孩子大于根节点，右孩子等于根节点，则结果为右子树中第二小的和左孩子的值中的较小者。

```
public int findSecondMinimumValue(TreeNode root) {
        if(root==null||(root.left==null&&root.right==null))
            return -1;
        int l=root.left.val,r=root.right.val;
        //去左子树中寻找第二大的
        if(root.val==root.left.val)
            l=findSecondMinimumValue(root.left);
        //去右子树中寻找第二大的
        if(root.val==root.right.val)
            r=findSecondMinimumValue(root.right);
        if(l!=-1&&r!=-1)
            return Math.min(l,r);
        if(l!=-1)
            return l;
        return r;
    }
```

---
title: 684.冗余连接
date: 2020-06-01 15:12:15
tags: leetcode
categories: leetcode
---

在本问题中, 树指的是一个连通且无环的无向图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。



**算法思想：**

- 使用并查集，并查集可以迅速检验两个节点是否在一个连通区域里面。

并查集定义如下：

```
private class UF{
        private int[] id;

        UF(int N){
            id=new int[N+1];
            for(int i=0;i<id.length;i++){
                id[i]=i;
            }
        }

        public int find(int p){
            return id[p];
        }

        public void union(int p,int q){
            int uID=find(p);
            int vID=find(q);
            if(uID==vID) return;
            for(int i=0;i<id.length;i++){
                if(id[i]==uID){
                    id[i]=vID;
                }
            }
        }

        public boolean connected(int p,int q){
            return id[p]==id[q];
        }

    }
```



```
public int[] findRedundantConnection(int[][] edges) {
        int N=edges.length;
        UF uf=new UF(N);
        for(int[] e:edges){
            int u=e[0],v=e[1];
            if(uf.connected(u,v))
                return new int[]{u,v};
            uf.union(u,v);
        }
        return new int[]{-1,-1};
    }
```

---
title: 687.最长同值路径
date: 2020-06-28 21:00:25
tags: leetcode
categories: leetcode
---

# [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

**题目描述：**

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

**注意**：两个节点之间的路径长度由它们之间的边数表示。

```
示例 1:

输入:

              5
             / \
            4   5
           / \   \
          1   1   5
输出:

2


示例 2:

输入:

              1
             / \
            4   5
           / \   \
          4   4   5
输出:

2
```



**算法思想：**

- 结果可能以每一个节点作为根节点，所以依次计算以每一个节点作为根节点的最长 同值路径。

```
	private int res=0;

    public int longestUnivaluePath(TreeNode root) {
        if(root==null) return 0;
        int left=helper(root.left,root.val);
        int right=helper(root.right,root.val);
        //计算以当前节点作为根节点的同值路径长度
        res=Math.max(res,left+right);
        //然后递归计算左子树和右子树
        longestUnivaluePath(root.left);
        longestUnivaluePath(root.right);
        return res;
    }

	//计算与num相等的最长长度
    private int helper(TreeNode root,int num){
        if(root==null||root.val!=num) return 0;
        int left=helper(root.left,num);
        int right=helper(root.right,num);
        return Math.max(left,right)+1;
    }
```

---
title: 69. x 的平方根
date: 2020-05-29 17:51:24
tags: leetcode
categories: leetcode
---

# [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

**题目描述：**

实现 `int sqrt(int x)` 函数。

计算并返回 *x* 的平方根，其中 *x* 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去



**示例：**

```
示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```



## 二分法

**算法思想：**

- 二分查找法应用于搜索平方根的思想很简单，其实就是“猜”，但是是有策略的“猜”，用“排除法”在有限的区间里，一次排除一半的区间元素，最后只剩下一个数，这个数就是题目要求的向下取整的平方根整数。

- 需要注意的是输出的是整数，所以在mid*mid<x时需要额外判断一下是否有(mid+1)\*(mid+1)>x，如果有则表示mid是平方小于x并且最接近的，即为答案。

**算法实现：**

```
public int mySqrt(int x) {
		long left=0,right=x;
        while(left<=right){
            long mid=(left+right)/2;
            if(mid*mid==x) return (int)mid;
            else if(mid*mid<x){
                if((mid+1)*(mid+1)>x) return (int)mid;
                left=mid+1;
            }else right=mid-1;
        }
        return 0;
    }
```

**算法分析：**

- **时间复杂度：**O(logn)，二分法的时间复杂度都是对数形式的
- **空间复杂度：**O(1)



**题目改：求平方根，但需要保证三位小数精度**

在Math.abs(mid*mid-x)<0.001时返回即可，并且注意此时步长为0.001

```
public double mySqrt(int x){
        double left=0.0,right=x;
        while(true){
            double mid=(left+right)/2;
            if(Math.abs(mid*mid-x)<0.001){
                return mid;
            }else if(mid*mid>x) right=mid-0.001;
            else left=mid+0.001;
        }
    }
```





## 牛顿迭代法

推导过程见leetcode题解。

最后得出对于f(x)=x^2^-C=0，递推公式为x~i+1~=1/2(x~i~+C/x~i~)，选取递推起点为C

```
public int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }

        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0);
            if (Math.abs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return (int)x0;
    }
```

---
title: 70. 爬楼梯
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

**题目描述：**

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。



**示例：**

```
示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶


示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```



## 算法一：暴力法（递归）

**算法思路：**

- `stairsBTrace(begin,n)=stairsBTrace(begin+1,n)+stairsBTrace(begin+2,n)`

- 设置三个递归出口：
  1. 若begin==n-1，返回1
  2. 若begin==n-2，返回2
  3. 若begin>n，返回0

**算法实现：**

```
public int climbStairs(int n) {
		//调用递归函数，设置begin为0
        return stairsBTrace(0,n);
    }

    private int stairsBTrace(int begin,int n){
    	//三个递归出口
    	if(begin>n) return 0;
        if(begin==n-2) return 2;
        if(begin==n-1) return 1;
        int pathsForword_1=stairsBTrace(begin+1,n);
        int pathsForword_2=stairsBTrace(begin+2,n);
        return pathsForword_1+pathsForword_2;
    }
```



**算法分析：**

1. **时间复杂度：O(2^n^)，当考虑一个算法的时间复杂度时，可以先如下列出一个情况来考虑**

   例如：当n=5时的情况如下：

![Climbing_Stairs](/images/leetcode/t70_1.jfif)

2. **空间复杂度：O(n)，递归树的深度为n**



## 算法二：带有记忆表的优化

**算法思路：**

- 使用一个数组memo来记忆已经递归计算过的路径数



**算法实现：**

```
	//memo充当记忆表
	private int[] memo;
        public int climbStairs(int n) {
        	//memeo初始化
            memo=new int[n];
            return stairsBTrace(0,n);
        }
    
        private int stairsBTrace(int begin,int n){
            if(begin>n) return 0;
            if(begin==n-2) return 2;
            if(begin==n-1) return 1;
            //如果memo[begin]已经计算过值，则直接返回
            if(memo[begin]>0){
                return memo[begin];
            }
            //否则，同样递推计算其值，并更新在memo数组中
            int pathsForword_1=stairsBTrace(begin+1,n);
            int pathsForword_2=stairsBTrace(begin+2,n);
            memo[begin]=pathsForword_1+pathsForword_2;
            return pathsForword_1+pathsForword_2;
        }
```



**算法分析：**

1. **时间复杂度：O(n)**，也可以通过n=5的情况来归纳
2. **空间复杂度：O(n)**





## 算法三：动态规划

**算法思想：**

- 递推关系可以描述为：`paths[i]=paths[i-1]+paths[i-2]`
- 数组错位表示，paths[n-1]表示到达n阶台阶的不同走法
- 设置两个初值path[0]表示到达1阶台阶有1种不同走法，paths[1]表示到达2阶台阶有2种不同走法



**算法实现：**

```
public int climbStairs(int n) {
		//n==1或2时单独拿出来，防止下面的paths数组越界
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int[] paths=new int[n];
        //两个递归初值
        paths[0]=1;
        paths[1]=2;
        //递推关系
        for(int i=2;i<n;i++){
            paths[i]=paths[i-1]+paths[i-2];
        }
        //paths[n-1]表示到n阶台阶的不同走法
        return paths[n-1];
    }
```



**算法分析：**

1. **时间复杂度：O(n)**

2. **空间复杂度：O(n)**---
title: 714.买卖股票的最佳时机
date: 2020-06-15 21:39:01
tags: leetcode
categories: leetcode
---

# [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

**题目描述：**

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。



```
示例 1:

输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
注意:

0 < prices.length <= 50000.
0 < prices[i] < 50000.
0 <= fee < 50000.
```





## 动态规划

**算法思想：**

- 还是用二维数组dp\[i][0],dp\[i][1]来表示下标为i处持有(不持有)股票的最大收益。

```
public int maxProfit(int[] prices, int fee) {
        if(prices==null||prices.length==0) return 0;
        int[][] dp=new int[prices.length][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<dp.length;i++){
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]-fee);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[dp.length-1][0];
    }
```

---
title: 725.分隔链表
date: 2020-06-03 21:53:28
tags: leetcode
categories: leetcode
---

**题目描述：**

给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。

每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。

这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。

返回一个符合上述规则的链表的列表。

举例： 1->2->3->4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]



```
示例 1：

输入: 
root = [1, 2, 3], k = 5
输出: [[1],[2],[3],[],[]]
解释:
输入输出各部分都应该是链表，而不是数组。
例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。
第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。
最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。

示例 2：

输入: 
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
解释:
输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。
```





**算法思想：**

- 只需要计算每一段的长度即可，然后注意前面取长一点即可。**注意代码的简洁性。**

```
public ListNode[] splitListToParts(ListNode root, int k) {
        if(root==null) return new ListNode[k];
        int len=0;
        ListNode p=root;
        while(p!=null){
            len++;
            p=p.next;
        }
        //每一段长度
        int size=len/k;
        //前面有多少段长度加一
        int more=len%k;
        ListNode[] res=new ListNode[k];
        p=root;
        ListNode pre=root;
        int index=0;
        while(p!=null){
            res[index++]=p;
            //这一步注意代码的整洁性
            int currsize=more>0?size+1:size;
            for(int i=0;i<currsize;i++){
                pre=p;
                p=p.next;
                if(p==null) break;
            }
            pre.next=null;
            more--;
        }
        return res;
    }
```

---
title: 73. 矩阵置零
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)

**题目描述：**

给定一个 *m* x *n* 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**[原地](http://baike.baidu.com/item/原地算法)**算法**。**



**示例：**

```
示例 1:

输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
示例 2:

输入: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```





## 算法一：用两个数组分别记录要置为0的行 和列

**算法实现：**

```
public void setZeroes(int[][] matrix) {
        int m=matrix.length;
        int n=matrix[0].length;
        //zeros_rows记录要置为0的行
        int[] zero_rows=new int[m];
        //zeros_cols记录要置为0的列
        int[] zero_cols=new int[n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
            	//如果存在0元素，则将对应数组的值赋为1
                if(matrix[i][j]==0){
                    zero_rows[i]=1;
                    zero_cols[j]=1;
                }
            }
        }
        //将zeros_rows中为1的元素对应的行全部赋值为0
        for(int i=0;i<m;i++){
            if(zero_rows[i]==1){
                for(int j=0;j<n;j++){
                    matrix[i][j]=0;
                }
            }
        }
        //将zeros_cols中为1的元素对应的列全部赋值为0
        for(int j=0;j<n;j++){
            if(zero_cols[j]==1){
                for(int i=0;i<m;i++){
                    matrix[i][j]=0;
                }
            }
        }
    }
```



**算法分析：**

- **时间复杂度：**O(m*n)，m为二维数组的行数，n为二维数组的列数
- **空间复杂度：**O(m+n)





## 算法二：O(1)空间的暴力法

**算法思路：**

1. 遍历原始矩阵，如果发现如果某个元素 `cell[i][j]` 为 0，我们将第 i 行和第 j 列的所有非零元素设成很大的负虚拟值（比如说 -1000000）。注意，正确的虚拟值取值依赖于问题的约束，任何允许值范围外的数字都可以作为虚拟之。
2. 最后，我们便利整个矩阵将所有等于虚拟值（常量在代码中初始化为 `MODIFIED`）的元素设为 0。



**算法实现：**

```
	//MODIFIED的值表示虚拟值，具体值随具体情况而变
	private int MODIFIED=-10000000;
    public void setZeroes(int[][] matrix) {
        int m=matrix.length;
        int n=matrix[0].length;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
            	//若当前元素为0，则将其所在行与所在列的所有元素赋为MODIFIED，要除去值本身为0				的情况，因为如果其值之前就为0，赋值后会缺少此处为0的信息
                if(matrix[i][j]==0){
                    for(int k=0;k<n;k++){
                        if(matrix[i][k]!=0) {
                            matrix[i][k] = MODIFIED;
                        }
                    }
                    for(int k=0;k<m;k++){
                        if(matrix[k][j]!=0) {
                            matrix[k][j] = MODIFIED;
                        }
                    }
                }
            }
        }
        //最后将数组中所有值为MODIFIED的元素赋值为0即可
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(matrix[i][j]==MODIFIED){
                    matrix[i][j]=0;
                }
            }
        }
    }
```



**算法分析：**

- **时间复杂度：**O(n^2^)
- **空间复杂度：**O(1)---
title: 739.每日温度
date: 2020-06-03 16:52:28
tags: leetcode
categories: leetcode
---

# [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

**题目描述：**

根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。



## 栈

**算法思想：**

- 用栈去存储对应元素的下标值，如果：
  1. 栈为空或者元素小于栈顶元素则直接入队
  2. 否则，栈中小于要入栈元素的下标全部出栈，并且赋值

```
public int[] dailyTemperatures(int[] T) {
        if(T==null||T.length==0) return new int[0];
        int[] res=new int[T.length];
        Stack<Integer> stack=new Stack<>();
        for(int i=0;i<T.length;i++){
            if(stack.isEmpty()||T[i]<=T[stack.peek()])
                stack.push(i);
            else{
                while(!stack.isEmpty()&&T[stack.peek()]<T[i]){
                    int index=stack.pop();
                    res[index]=i-index;
                }
                stack.push(i);
            }
        }
        return res;
    }
```



**若对题目进行改进，将数组改成循环数组，则需要两次遍历数组，在第二次遍历时只需要判断大于的情况即可**---
title: 75. 颜色分类
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

**题目描述：**

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。



**示例：**

~~~
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
~~~



**进阶：**

- 一个直观的解决方案是使用计数排序的两趟扫描算法。
  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
- 你能想出一个仅使用常数空间的一趟扫描算法吗？



## 算法一：直接排序（冒泡）

**算法实现：**

```
public void sortColors(int[] nums) {
        int len=nums.length;
        //冒泡排序即可
        for(int i=0;i<len;i++){
            for(int j=i+1;j<len;j++){
                if(nums[j]<nums[i]){
                    int temp=nums[i];
                    nums[i]=nums[j];
                    nums[j]=temp;
                }
            }
        }
    }
```



**算法分析：**

- **时间复杂度：**O(n^2^)
- **空间复杂度:**O(1)



## 算法二：两次遍历，第一次确定每个元素的个数，第二次重排数组即可

**算法实现：**

```
public void sortColors(int[] nums) {
        int len=nums.length;
        //sum数组记录0，1，2元素的个数
        int[] sum=new int[3];
        //第一次循环确定各个元素个数
        for(int i=0;i<len;i++){
            sum[nums[i]]++;
        }
        int i=0;
        //第二次循环重排数组
        for(i=0;i<sum[0];i++){
            nums[i]=0;
        }
        for(;i<sum[0]+sum[1];i++){
            nums[i]=1;
        }
        for(;i<len;i++){
            nums[i]=2;
        }
    }
```



**算法分析：**

- **时间复杂度：**O(n)，两次遍历
- **空间复杂度：**O(1)，只是用了一个长度为3的数组，常数阶



## 算法三：一次遍历

**算法思路：**

1. 用三个指针p0，curr，p2分别指向元素0的右边界，当前元素，元素2的左边界，以p0为例，此处0的右边界表示的是最右边的0的右边一位的元素
2. curr从0开始沿着数组遍历，若当前元素
   - nums[curr]==0，则将其与nums[p0]互换，并且curr++,p0++;
   - nums[curr]==2,则将其与nums[p2]互换，并且p2--;
   - nums[curr]==1,则curr++即可
3. 因为当nums[curr]==2,则将nums[curr]与nums[p2]互换后，nums[curr]处的值可能为0，还需要再判断，来更新p0的值，所以此时curr不能++；nums[curr]==0，则将nums[curr]与nums[p0]互换后，nums[curr]处的值不会0或者2，只有一种情况可能是0，就是当p0与curr指向同一个元素0时，此时互换后也需要curr++，而其他情况只能是1，所以curr可以直接++



**算法实现：**

```
public void sortColors(int[] nums) {
		//p0,curr从0开始，p2从nums.length-1开始
        int p0=0,curr=0;
        int p2=nums.length-1;
        int tmp;
        //当curr<=p2时循环
        while(curr<=p2){
            if(nums[curr]==0){
                tmp=nums[curr];
                nums[curr++]=nums[p0];
                nums[p0++]=tmp;
            }else if(nums[curr]==2){
                tmp=nums[curr];
                nums[curr]=nums[p2];
                nums[p2--]=tmp;
            }else{
                curr++;
            }
        }
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(1)---
title: 79. 单词搜索
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

**题目描述：**

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。



**示例：**

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true.
给定 word = "SEE", 返回 true.
给定 word = "ABCB", 返回 false.
```



## 算法一：回溯法

**算法思路：**

- 相邻的单元格也就是上下左右四个方向的单元格，因此可以分别向四个方向回溯，只要有一个方向成功，则返回成功
- 由于同一单元格的字母不允许使用多次，所以使用一个visited数组来记录当前单元格是否被访问



**算法实现：**

```
//枚举类型，用来表示当前单元格是否被访问
private enum Visited{
        YES,NO;
    }
    public boolean exist(char[][] board, String word) {
        int m=board.length;
        int n=board[0].length;
        boolean flag=false;
        //visited数组记录目标元素是否被访问
        Visited[][] visited=new Visited[m][n];
        //对于数组中的每一个元素开始
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
            	//若首字母相同，则进入下面的判断
                if(board[i][j]==word.charAt(0)) {
                	//首先要对visited数组初始化
                    for (int i2 = 0; i2 < m; i2++) {
                        for (int j2 = 0; j2 < n; j2++) {
                            visited[i2][j2] = Visited.NO;
                        }
                    }
                    //然后调用BTrace函数，若结果为真，则直接返回即可
                    if (BTrace(board, word, i, j, visited)) {
                        flag = true;
                        break;
                    }
                }
            }
        }
        return flag;
    }
    public boolean BTrace(char[][] board,String word,int i,int j,Visited[][] visited){
        int m=board.length;
        int n=board[0].length;
        //首先要置visited[i][j]为已访问，但是过当前元素的字符串可能并不匹配目标字符串，即当返			回false时，要将visited[i][j]再令为NO，不能在return true时再置visited[i][j]为		  已访问，因为此时可能会存在元素的重复使用
        visited[i][j]=Visited.YES;
        //如果i,j不满足边界条件或者第一个字母不等时，则直接返回false
        if(i<0||j<0||i>=m||j>=n||board[i][j]!=word.charAt(0)){
            visited[i][j]=Visited.NO;
            return false;
        }else {
        	//否则，当word长度为1时，表示已经匹配，返回true
            if(word.length()==1){
                return true;
            }
            //flag_d表示字符串向下延申，其他同理
            boolean flag_d=false;
            boolean flag_u=false;
            boolean flag_l=false;
            boolean flag_r=false;
            //如果下面一位元素位置不越界并且未被访问时，向下回溯，下面同理
            if(i+1<m&&visited[i+1][j]==Visited.NO) {
                flag_d = BTrace(board, word.substring(1), i + 1, j, visited);
            }
            if(j+1<n&&visited[i][j+1]==Visited.NO) {
                flag_r = BTrace(board, word.substring(1), i, j + 1, visited);
            }
            if(i-1>=0&&visited[i-1][j]==Visited.NO) {
                flag_u = BTrace(board, word.substring(1), i - 1, j, visited);
            }
            if(j-1>=0&&visited[i][j-1]==Visited.NO) {
                flag_l = BTrace(board, word.substring(1), i, j - 1, visited);
            }
			//如果四个方向都不能延申，则返回false
            if(flag_l==false&&flag_d==false&&flag_r==false&&flag_u==false){
                visited[i][j]=Visited.NO;
                return false;
            }else {
            	//否则只要存在一个方向可以延申，则返回true
                return true;
            }
        }
    }
```



**算法分析：**

- **时间复杂度：**O(n^4^)
- **空间复杂度：**O(n^2^)



## 算法二：DFS

**算法描述：**

- 其实是基于上面算法的改进，首先针对上面的时间复杂度问题，由于每次循环时我都重置了数组记录为未访问，所以增加了新的时间负担，这里引入了一个新的方法叫 **状态重置**，因为每次换一个起始点开始判断时，marked数组都需要重置,而且可以用boolean类型代替上面的类型即可
- 第二就是方向，可以用方向数组代替，使代码更加简洁



**算法实现：**

```
	//marked数组记录是否被访问
	private boolean[][] marked;
	//direction为方向数组
    private int[][] direction={{-1,0},{0,-1},{1,0},{0,1}};
    private int m;
    private int n;
    private char[][] board;
    private String word;
    public boolean exist(char[][] board, String word) {
        this.m=board.length;
        this.n=board[0].length;
        this.board=board;
        this.word=word;
        marked=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(DFS(i,j,0)){
                    return true;
                }
            }
        }
        return false;
    }
    //x,y表示数组的起始坐标，start表示字符串的当前检验索引，从0开始
    private boolean DFS(int x,int y,int start){
    	//如果检验的是最后一个字母直接返回是否相等即可
        if(start==word.length()-1){
            return word.charAt(start)==board[x][y];
        }
        //否则，不是最后一个字母，若不等直接返回false，若相等则进入下面
        if(board[x][y]==word.charAt(start)){
        	//首先标记为已访问
            marked[x][y]=true;
            //从四个方向开始回溯递归
            for(int k=0;k<4;k++){
                int newX=x+direction[k][0];
                int newY=y+direction[k][1];
                //如果newX和newY还在范围内，并且未被访问过
                if(inArea(newX,newY)&&!marked[newX][newY]&&DFS(newX,newY,start+1)){
                    return true;
                }
            }
            //最后没有返回true，则状态重置为false
            marked[x][y]=false;
        }
        return false;
    }
    private boolean inArea(int x,int y){
        return x>=0&&y>=0&&x<m&&y<n;
    }
```



**说明：**此处说一下 **状态重置**，由于要保证每次循环时将marked数组重置，首先每次先将marked数组置为true，即已访问，然后在返回false时再将marked数组置为false---
title: 88. 合并两个有序数组
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

**题目描述：**

给定两个有序整数数组 *nums1* 和 *nums2*，将 *nums2* 合并到 *nums1* 中*，*使得 *num1* 成为一个有序数组。

**说明：**

- 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
- 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。



**示例：**

```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```



## 算法一：从前向后

**算法思想：**

- 从前到后依次比较两个数组中的元素，但需要额外申请一个数组存放



**算法实现：**

```
public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i=0,j=0,k=0;
        //nums临时存放复制过来的元素
        int[] nums=new int[m+n];
        //当两个数组都还没有遍历到最后时
        while(i<m&&j<n){
            if(nums1[i]>nums2[j]){
                nums[k]=nums2[j];
                j++;
            }else {
                nums[k]=nums1[i];
                i++;
            }
            k++;
        }
        //若第一个数组还有多的元素
        while(i<m){
            nums[k]=nums1[i];
            k++;
            i++;
        }
        //若第二个数组还有多的元素
        while(j<n){
            nums[k]=nums2[j];
            k++;
            j++;
        }
        //最后将nums数组中的元素逐个复制到nums1中
        for(int l=0;l<m+n;l++){
            nums1[l]=nums[l];
        }
    }
```



**算法分析：**

- **时间复杂度：**O(m+n)
- **空间复杂度：**O(m+n)



## 算法二：从后向前

**算法思想：**

- 由于从前向后需要额外申请空间，所以想到从后向前
- 因为在合并前的元素索引位置i~1~一定小等于合并后的位置i~2~，所以不会导致之前的元素因覆盖而丢失



**算法实现：**

```
public void merge(int[] nums1, int m, int[] nums2, int n) {
		//从后向前
        int i=m-1,j=n-1,k=m+n-1;
        while(i>=0&&j>=0){
            if(nums1[i]>nums2[j]){
                nums1[k]=nums1[i];
                i--;
            }else {
                nums1[k]=nums2[j];
                j--;
            }
            k--;
        }
        while(i>=0){
            nums1[k]=nums1[i];
            i--;
            k--;
        }
        while(j>=0){
            nums1[k]=nums2[j];
            j--;
            k--;
        }
    }
```



**算法分析：**

- **时间复杂度：**O(m+n)
- **空间复杂度：**O(1)---
title: 8.字符串转换整数
date: 2019-12-23 13:02:24
tags: leetcode
categories: leetcode
---

# 8.字符串转换整数

**题目描述：**

请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

----



**说明：**

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

----



**示例1：**

```
输入: "42"
输出: 42
```

---

示例2：

```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

----

示例3：

```
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

---

示例4：

```
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```

---

示例5：

```
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
```

----

**算法思路：**

1. 首先找到第一个非空格的字符`判断空格字符的方法： chars[i]==' '或者(int)chars[i]==32`

- 若没有非空格字符，则直接返回0
- 有空格字符，则首先判断此字符是否为数字或者正号或者负号
  - 若都不是，则返回0
  - 若为正号或者负号，则用一个boolean值记录正负，然后向右移一位

2. 之后对连续的数字字符进行转换，转换为整数`转换方法为： pop的值令为指向的字符转换过来的数字，最终结果rev=rev*10+pop`

3. 同时需要对rev进行判断防止溢出    

   ```
   判断方法为：if (rev > Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) {
                       return Integer.MAX_VALUE;
                   }
             if (rev < Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) {
                       return Integer.MIN_VALUE;
                   }
   ```

----



**具体代码：**

```java
public int myAtoi(String str){
        char[] chars = str.toCharArray();
        int len=chars.length;
        //空字符串，直接返回0
        if(len==0){
            return 0;
        }
        int i=0;
        //找到第一个不为空格的字符,注意判断条件中把i<len放在前面，可以防止数组越界（短路算法）
        while(i<len&&chars[i]==' '){
            i++;
        }
        //全是空格字符，返回0
        if(i==len){
            return 0;
        }
        //第一个非空格字符不是数字或正负号，返回0
        if(chars[i]!='+'&&chars[i]!='-'&&(chars[i]>'9'||chars[i]<'0')){
            return 0;
        }
        //flag记录正负号，默认为正号，即第一个非空格字符是数字的时候为正号
        boolean flag=true;
        //正号和负号都需要向后移动一位
        if(chars[i]=='-'){
            flag=false;
            i++;
        }else if (chars[i]=='+'){     //这里必须要使用else if的结构，如果使用两个										if并列，会出现数组越界的情况。
            i++;
        }
        int rev=0;
        while(i<len&&chars[i]>='0'&&chars[i]<='9'){
            int pop=Integer.valueOf(String.valueOf(chars[i]));
            //如果是负号，则加上负号x
            if(flag==false){
                pop=-pop;
            }
            if(rev>Integer.MAX_VALUE/10||(rev==Integer.MAX_VALUE/10&&pop>7)){return Integer.MAX_VALUE;}
            if(rev<Integer.MIN_VALUE/10||(rev==Integer.MIN_VALUE/10&&pop<-8)){return Integer.MIN_VALUE;}
            rev=rev*10+pop;
            i++;
        }
        return rev;
    }
```





注意：

1. 将字符转换为字符串的方法： `String s=String.valueOf(chars[i])`

   将字符串转换为int类型的方法： `int i=Integer.valueOf(s)`

   所以将字符转换为int类型可以用： `int i=Integer.valueOf(String.valueOf(chars[i]))`

2. 注意数组越界的情况，在判断条件时将`i<len`放在前面可以避免这个情况
3. 通过一个整数的每位上的数字求整数的方法：从低位向高位遍历，pop记每位上的数字，rev记最终结果，rev=rev*10+pop;

---
title: 91. 解码方法
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

**题目描述：**

一条包含字母 A-Z 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的非空字符串，请计算解码方法的总数。



**示例：**

```
示例 1:

输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2:

输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```



## 算法一：递归

**算法思想：**

- 比如 232232323232。对于第一个字母我们有两种划分方式。2|32232323232 和 23|2232323232

- 所以，如果我们分别知道了上边划分的右半部分 32232323232 的解码方式是 ans1 种，2232323232 的解码方式是 ans2 种，那么整体 232232323232 的解码方式就是 ans1 + ans2 种。
- 因此想到可以用递归的方式解决



**算法实现：**

```
public int numDecodings(String s) {
        return numTrace(s,0);
    }
    //方法返回值为字符串s从索引start开始的子串的编码个数
    private int numTrace(String s,int start){
    	//如果start超过s.length()，返回0
        if(start>s.length()) return 0;
        //如果start等于s.length()需要特殊注意，此时要返回1
        if(start==s.length()) return 1;
        //如果当前索引处的字符为'0'，则以当前索引开头的子串没有合格的编码，返回0
        if(s.charAt(start)=='0') return 0;
        if(start==s.length()-1) return 1;
        //如果s在srart处满足函数要求
        if(isVaild(s,start)){
            return numTrace(s,start+1)+numTrace(s,start+2);
        }else {
            return numTrace(s,start+1);
        }
    }
    private boolean isVaild(String s,int start){
        return s.charAt(start)=='1'||(s.charAt(start)=='2'&&s.charAt(start+1)<='6');
    }
```





## 算法二：基于记忆表的改进

**算法思想：**

- 由于递归会重复计算，所以使用记忆表来存储已经计算的结果



**算法实现：**

```
	//memo为记忆表
	private int[] memo;
    public int numDecodings(String s) {
        memo=new int[s.length()];
        return numTrace(s,0);
    }
    private int numTrace(String s,int start){
        if(start>s.length()) return 0;
        if(start==s.length()) return 1;
        if(s.charAt(start)=='0') return 0;
        if(start==s.length()-1) return 1;
        //如果已经计算过值，直接返回
        if(memo[start]!=0){
            return memo[start];
        }
        if(isVaild(s,start)){
        	//将计算后的值更新到数组中
            memo[start]=numTrace(s,start+1)+numTrace(s,start+2);
            return memo[start];
        }else {
            memo[start]=numTrace(s,start+1);
            return memo[start];
        }
    }
    private boolean isVaild(String s,int start){
        return s.charAt(start)=='1'||(s.charAt(start)=='2'&&s.charAt(start+1)<='6');
    }
```





## 算法三：动态规划

**算法思想：**

- 从右向左递推



**算法实现：**

```
	private int[] memo;
    public int numDecodings(String s) {
        int len=s.length();
        memo=new int[len+1];
        //递推初始值
        memo[len]=1;
        if(s.charAt(len-1)=='0') memo[len-1]=0;
        else {
            memo[len-1]=1;
        }
        //从右向左递推
        for(int i=len-2;i>=0;i--){
            if(s.charAt(i)=='0') memo[i]=0;
            else {
                if (isVaild(s, i)) {
                    memo[i] = memo[i + 1] + memo[i + 2];
                } else {
                    memo[i] = memo[i + 1];
                }
            }
        }
        return memo[0];
    }

    private boolean isVaild(String s,int start){
        return s.charAt(start)=='1'||(s.charAt(start)=='2'&&s.charAt(start+1)<='6');
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)

---
title: 94. 二叉树的中序遍历
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**题目描述：**给定一个二叉树，返回它的*中序* 遍历。

**示例：**

```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```



## 算法一：递归

**算法思想：**

- 中序遍历的递归形式



**算法实现：**

```
public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode(int x) { val = x; }
  }
  List<Integer> list=new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root!=null){
            inorderTraversal(root.left);
            list.add(root.val);
            inorderTraversal(root.right);
        }
        return list;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(logn)





## 算法二：迭代形式

**算法思想：**

- 用迭代来消除递归
- 首先，若node不为空，则令node入栈，然后node=node.left，当node为空时，表示没有左孩子即为最左边节点了，则直接访问即可，然后令node=node.right，若右孩子为空，则直接出栈访问即可，否则重复在右子树中遍历



**算法实现：**

```
public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode(int x) { val = x; }
  }
  List<Integer> list=new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
    	//用栈来消除递归
        Stack<TreeNode> stack=new Stack<>();
        TreeNode node=root;
        while(node!=null||!stack.isEmpty()){
           while(node!=null){
               stack.push(node);
               node=node.left;
           }
           node=stack.pop();
           list.add(node.val);
           node=node.right;
        }
        return list;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)---
title: 98. 验证二叉搜索树
date: 2020-04-11 17:51:24
tags: leetcode
categories: leetcode
---

# [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

**题目描述：**

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。



**示例：**

```
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```



## 算法一：中序遍历

**算法思想：**

- 用lastNode指向前一个被访问的节点，node指向当前被访问的节点
- 在中序遍历的顺序下，二叉排序树一定是升序排列的，所以可以检查是否有逆序存在即可



**算法实现：**

```
public boolean isValidBST(TreeNode root) {
		//lastNode指向上一个被访问节点的val域，初始为一个很小的数
        double lastNode=-Double.MAX_VALUE;
        Stack<TreeNode> stack=new Stack<>();
        //node指向当前被访问的节点
        TreeNode node=root;
        while(node!=null||!stack.isEmpty()){
            while(node!=null){
                stack.push(node);
                node=node.left;
            }
            node=stack.pop();
            //如果当前节点val小于等于前一个节点，即逆序则返回false
            if(node.val<=lastNode){
                return false;
            }
            //更新lastNode的值
            lastNode=node.val;
            node=node.right;
        }
        //最后若没有逆序存在则返回会true
        return true;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



## 算法二：递归

**算法思想：**

- 要判断以root为根的树为二叉排序树，只要root大于左子树上最大的节点，小于右子树上最小的节点
- 然后递归判断左子树和右子树



**算法实现：**

```
public boolean isValidBST(TreeNode root) {
		//flag记录以root为根的树是否是二叉排序树，默认是true
        boolean flag=true;
        //left记录以root的左子树为根的树是否为二叉排序树
        boolean left=true;
        //right记录以root的右子树为根的树是否为二叉排序树
        boolean right=true;
        if(root!=null){
        	//递归判断是左子树
            left=isValidBST(root.left);
            //如果左子树为空或者root大于左边最大的，并且右子树为空或者root小于右边最小
            if((getMax(root.left)==null||root.val>getMax(root.left).val)&&(getMin(root.right)==null||root.val<getMin(root.right).val)){
                flag=true;
            }else {
                flag=false;
            }
            //递归判断右子树
            right=isValidBST(root.right);
        }
        return flag&&left&&right;
    }
	
	//getMax返回以root为根的子树的最大节点
    private TreeNode getMax(TreeNode root){
          if(root==null){
              return null;
          }
          //最右边节点为最大
          while(root.right!=null){
              root=root.right;
          }
          return root;
    }
    //getMin返回以root为根的子树的最小节点
    private TreeNode getMin(TreeNode root){
        if(root==null){
            return null;
        }
        //最左边节点最小
        while(root.left!=null){
            root=root.left;
        }
        return root;
    }
```





## 算法三：递归

**算法思想：**

- 上面算法的简介版，由于上面每次都要去计算最小节点和最大节点非常麻烦，所以想到可以将树的上界和下界存储在参数中传递，随时更新



**算法实现：**

```
public boolean isValidBST(TreeNode root) {
		//初始不知道上下界，所以为null
        return helper(root, null, null);
    }
	//lower表示下界，upper表示上界
    private boolean helper(TreeNode root, Integer lower, Integer upper) {
    	//root为空，返回true
        if(root==null) return true;
        //如果lower不为空且逆序，则返回false，下同
        if(lower!=null&&root.val<=lower) return false;
        if(upper!=null&&root.val>=upper) return false;
        //递归判断左子树，此时更新上界为root.val
        if(!helper(root.left,lower,root.val)) return false;
        //递归判断右子树，此时更新下界为root.val
        if(!helper(root.right,root.val,upper)) return false;
        return true;
    }
```



**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)



## 算法四：迭代

**算法思想：**

- 将上面的算法改为迭代形式，分别用三个链表存储根节点，上界，下界
- 用深度优先遍历，依次判断每一个节点是否满足条件



**算法实现：**

```
	  //stack存储节点
	  LinkedList<TreeNode> stack=new LinkedList<>();
	  //uppers和lowers分别存储对应的上界与下界
      LinkedList<Integer> uppers=new LinkedList<>(),lowers=new LinkedList<>();
      //三个链表的入栈操作
      private void update(TreeNode root,Integer lower,Integer upper){
          stack.add(root);
          lowers.add(lower);
          uppers.add(upper);
      }
    public boolean isValidBST(TreeNode root) {
        Integer lower=null,upper=null,val;
        update(root,lower,upper);
        while(!stack.isEmpty()){
            root=stack.poll();
            lower=lowers.poll();
            upper=uppers.poll();
            if(root==null) continue;
            val=root.val;
            if (lower != null && val <= lower) return false;
            if (upper != null && val >= upper) return false;
            update(root.right,val,upper);
            update(root.left,lower,val);
        }
        return true;
    }
```

**算法分析：**

- **时间复杂度：**O(n)
- **空间复杂度：**O(n)---
title: 994.腐烂的橘子
date: 2020-07-10 15:17:05
tags: leetcode
categories: leetcode
---

# [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)

**题目描述：**

在给定的网格中，每个单元格可以有以下三个值之一：

值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。



```
示例 1：



输入：[[2,1,1],[1,1,0],[0,1,1]]
输出：4

示例 2：

输入：[[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。

示例 3：

输入：[[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
```





## BFS

**算法思想：**

- 由于最初可能会有多个位置值为2，所以是多源广度优先遍历的问题，首先需要将所有的腐烂的橘子放入队列中，遍历的轮数即为最终的结果。

```
	class Position{
        int x;
        int y;
        Position(int x,int y){
            this.x=x;
            this.y=y;
        }
    }


    private int[][] grid;

    public int orangesRotting(int[][] grid) {
        this.grid=grid;
        int m=grid.length,n=grid[0].length,res=0;
        res=bfs(grid,m,n);
        //最后如果还有橘子没被腐烂则返回-1
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1)
                    return -1;
            }
        }
        return res;
    }

    private int bfs(int[][] grid,int m,int n){
        Queue<Position> queue=new LinkedList<>();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==2)
                    queue.add(new Position(i,j));
            }
        }
        //res从-1开始
        int res=-1;
        while(!queue.isEmpty()){
            res++;
            int size=queue.size();
            for(int k=0;k<size;k++){
                Position pos=queue.poll();
                if(isVaild(pos.x+1,pos.y,m,n)) {
                    queue.add(new Position(pos.x + 1, pos.y));
                    //这里就要置这个位置为已访问
                    grid[pos.x+1][pos.y]=2;
                }
                if(isVaild(pos.x-1,pos.y,m,n)) {
                    queue.add(new Position(pos.x - 1, pos.y));
                    grid[pos.x-1][pos.y]=2;
                }
                if(isVaild(pos.x,pos.y+1,m,n)) {
                    queue.add(new Position(pos.x, pos.y + 1));
                    grid[pos.x][pos.y+1]=2;
                }
                if(isVaild(pos.x,pos.y-1,m,n)) {
                    queue.add(new Position(pos.x, pos.y - 1));
                    grid[pos.x][pos.y-1]=2;
                }

            }
        }
        //如果res==-1表示没有腐烂的橘子，则返回0
        return res==-1?0:res;
    }

    private boolean isVaild(int i,int j,int m,int n){
        return i>=0&&i<m&&j>=0&&j<n&&grid[i][j]==1;
    }
```

**时间复杂度：**O(mn)

**空间复杂度：**O(mn)



**错误点：**

1. res从-1开始，最后返回的时候没有做判断导致返回的结果有-1
2. 置一个位置为已放问需要在将其放入队列时进行，如果在其中队列拿出来的时候再置其为已放问，就会出现问题，例如**[[2,2],[1,1],[0,0],[2,0]]**，第一次队列中有三个2，然后全部出队后两个1入队，这个时候如果在访问时再标记，那么前面那个1出队时会判断后面那个1还没有变成2而又将其放入队列中。---
title: Dubbo
date: 2020-06-18 15:34:08
tags: Dubbo
categories: Dubbo
---

# 一重要的概念

## 1.1 什么是Dubbo

Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java **RPC 框架**，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。

## 1.2 什么是RPC？RPC原理是什么？

**什么是 RPC？**

RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。**比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法**该怎么办呢？使用 HTTP请求当然可以，但是可能会比较麻烦。 RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。

**RPC原理是什么？**

我这里这是简单的提一下。详细内容可以查看下面这篇文章：

![RPC原理图](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg)

1. 服务消费方（client）调用以本地调用方式调用服务；
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3. client stub找到服务地址，并将消息发送到服务端；
4. server stub收到消息后进行解码；
5. server stub根据解码结果调用本地的服务；
6. 本地服务执行并将结果返回给server stub；
7. server stub将返回结果打包成消息并发送至消费方；
8. client stub接收到消息，并进行解码；
9. 服务消费方得到最终结果。

下面再贴一个网上的时序图：

![RPC原理时序图](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/32527396.jpg)

**说了这么多，我们为什么要用 Dubbo 呢？**

## 1.3 为什么要用Dubbo

Dubbo 的诞生和 SOA 分布式架构的流行有着莫大的关系。SOA 面向服务的架构（Service Oriented Architecture），也就是把工程按照业务逻辑拆分成服务层、表现层两个工程。服务层中包含业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。SOA架构中有两个主要角色：服务提供者（Provider）和服务使用者（Consumer）。

![为什么要用 Dubbo](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-26/43050183.jpg)

**如果你要开发分布式程序，你也可以直接基于 HTTP 接口进行通信，但是为什么要用 Dubbo呢？**

我觉得主要可以从 Dubbo 提供的下面四点特性来说为什么要用 Dubbo：

1. **负载均衡**——同一个服务部署在不同的机器时该调用那一台机器上的服务。
2. **服务调用链路生成**——随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。
3. **服务访问压力以及时长统计、资源调度和治理**——基于访问压力实时管理集群容量，提高集群利用率。
4. **服务降级**——某个服务挂掉之后调用备用服务。

另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。

**我们刚刚提到了分布式这个概念，下面再给大家介绍一下什么是分布式？为什么要分布式？**

## 1.4 什么是分布式？

分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们**把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能**。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。

## 1.5 为什么要分布式？

从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。

另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。你想一想嘛？把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？

# 二Dubbo的架构

## 2.1 Dubbo的架构图解

![Dubbo 架构](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-26/46816446.jpg)

**上述节点简单说明：**

- **Provider：** 暴露服务的服务提供方
- **Consumer：** 调用远程服务的服务消费方
- **Registry：** 服务注册与发现的注册中心
- **Monitor：** 统计服务的调用次数和调用时间的监控中心
- **Container：** 服务运行容器

**调用关系说明：**

1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

**重要知识点总结：**

- **注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小**
- **监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示**
- **注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外**
- **注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者**
- **注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表**
- **注册中心和监控中心都是可选的，服务消费者可以直连服务提供者**
- **服务提供者无状态，任意一台宕掉后，不影响使用**
- **服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复**

# 三Dubbo的负载均衡策略

## 3.1 什么是负载均衡

比如我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。

## 3.2 Dubbo提供的负载均衡策略

在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 `random` 随机调用。

### 3.2.1 Random LoadBalance

- **随机，按权重设置随机概率。**
- 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

![基于权重的随机负载均衡机制](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/77722327.jpg)

### 3.2.2 RoundRobin LoadBalance

- 轮循，按公约后的权重设置轮循比率。
- 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

![基于权重的轮询负载均衡机制](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/97933247.jpg)

### 3.2.3 LeastActive LoadBalance

- 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
- 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

### 3.2.4 ConsistentHash LoadBalance

- **一致性 Hash，相同参数的请求总是发到同一提供者。(如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。)**
- 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。---
title: Hadoop
date: 2020-11-09 15:01:57
tags: Hadoop
categories: 大数据
---

# 大数据基础

- 大数据主要解决**海量数据的存储**和**海量数据的分析计算**问题。

## 大数据特点(4V)

1. **Volume(大量)**

2. **Velocity(高速)**

3. **Variety(多样)**

4. **Value(低价值密度)**

## 大数据部门组织结构

![image-20201110102636205.png](https://i.loli.net/2020/11/10/xN3YQGhVe8RJMSZ.png)

# Hadoop

## Hadoop的优势

![image-20201110111905495](https://i.loli.net/2020/11/10/GEtHTOdyblsQNuV.png)

## Hadoop组成

![image-20201110111726171](https://i.loli.net/2020/11/10/z5bQgjJWA8FLYv3.png)

### HDFS架构概述

1. **NameNode(nn)：**存储文件的元数据，如文件名，文件目录结构，文件属性(生成时间，副本数，文件权限)，以及每个文件的块列表和块所在的DataNode等。
2. **DataNode(dn)：**在本地文件系统存储文件块数据，以及块数据的校验和。
3. **Secondary NameNode(2nn)：**用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。

### YARN架构

![image-20201110112729302](https://i.loli.net/2020/11/10/81JTwckP63xtqeE.png)

### MapReduce架构

**MapReduce将计算过程分为两个阶段：Map和Reduce**

1. Map阶段并行处理输入数据
2. Reduce阶段对Map结果进行汇总

## 大数据技术生态体系

![image-20201110113503546](https://i.loli.net/2020/11/10/HaPX9uErInL4z6k.png)---
title: Hello World
---
Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).

## Quick Start

### Create a new post

``` bash
$ hexo new "My New Post"
```

More info: [Writing](https://hexo.io/docs/writing.html)

### Run server

``` bash
$ hexo server
```

More info: [Server](https://hexo.io/docs/server.html)

### Generate static files

``` bash
$ hexo generate
```

More info: [Generating](https://hexo.io/docs/generating.html)

### Deploy to remote sites

``` bash
$ hexo deploy
```

More info: [Deployment](https://hexo.io/docs/one-command-deployment.html)
---
title: HTTP
date: 2020-05-20 12:15:06
tags: HTTP
categories: HTTP
---

# 一.基础概念

## URI

URI 包含 URL 和 URN。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png)

## 请求报文和响应报文

### 1.请求报文

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_RequestMessageExample.png)

1. 请求行
2. 请求头
3. 请求空行
4. 请求体

请求行中有三个字段：

1. 方法字段：包括 GET 、POST 、HEAD 、PUT 和 DELETE
2. URL字段
3. HTTP版本字段

### 2.响应报文

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_ResponseMessageExample.png)

响应行有三个字段：

- 协议版本字段
- 状态码
- 相应状态信息

# 二.HTTP方法

客户端发送的 **请求报文** 第一行为请求行，包含了方法字段。

## GET

> 获取资源

当前网络请求中，绝大部分使用的是 GET 方法。

## HEAD

> 获取报文首部

和 GET 方法类似，但是不返回报文实体主体部分。

主要用于确认 URL 的有效性以及资源更新的日期时间等。

## POST

> 传输实体主体

POST 主要用来传输数据，而 GET 主要用来获取资源。

## PUT

> 上传文件

由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

```html
PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

<p>New File</p>
```

## PATCH

> 对资源进行部分修改

PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。

```html
PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: "e0023aa4e"
Content-Length: 100

[description of changes]
```

## DELETE

> 删除文件

与 PUT 功能相反，并且同样不带验证机制。

```html
DELETE /file.html HTTP/1.1
```

## OPTIONS

> 查询支持的方法

查询指定的 URL 能够支持的方法。

会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。

## CONNET

> 要求在与代理服务器通信时建立隧道

使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

```html
CONNECT www.example.com:443 HTTP/1.1
```

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg)

## TRACE

> 追踪路径

服务器会将通信路径返回给客户端。

发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。

通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。

# 三.HTTP状态码

服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |

## 1XX信息

**100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

## 2XX成功

- **200 OK**
- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

## 3XX重定向

- **301 Moved Permanently** ：永久性重定向
- **302 Found** ：临时性重定向
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

## 4XX客户端错误

- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被拒绝。
- **404 Not Found**

## 5XX服务器错误

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

# 四.HTTP首部

有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。

各种首部字段及其含义如下（不需要全记，仅供查阅）：

## 通用首部字段

| 首部字段名        | 说明                                       |
| ----------------- | ------------------------------------------ |
| Cache-Control     | 控制缓存的行为                             |
| Connection        | 控制不再转发给代理的首部字段、管理持久连接 |
| Date              | 创建报文的日期时间                         |
| Pragma            | 报文指令                                   |
| Trailer           | 报文末端的首部一览                         |
| Transfer-Encoding | 指定报文主体的传输编码方式                 |
| Upgrade           | 升级为其他协议                             |
| Via               | 代理服务器的相关信息                       |
| Warning           | 错误通知                                   |

## 请求首部字段

| 首部字段名          | 说明                                            |
| ------------------- | ----------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                        |
| Accept-Charset      | 优先的字符集                                    |
| Accept-Encoding     | 优先的内容编码                                  |
| Accept-Language     | 优先的语言（自然语言）                          |
| Authorization       | Web 认证信息                                    |
| Expect              | 期待服务器的特定行为                            |
| From                | 用户的电子邮箱地址                              |
| Host                | 请求资源所在服务器                              |
| If-Match            | 比较实体标记（ETag）                            |
| If-Modified-Since   | 比较资源的更新时间                              |
| If-None-Match       | 比较实体标记（与 If-Match 相反）                |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求            |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
| Max-Forwards        | 最大传输逐跳数                                  |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                  |
| Range               | 实体的字节范围请求                              |
| Referer             | 对请求中 URI 的原始获取方                       |
| TE                  | 传输编码的优先级                                |
| User-Agent          | HTTP 客户端程序的信息                           |

## 响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定 URI     |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP 服务器的安装信息        |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

## 实体首部字段

| 首部字段名       | 说明                   |
| ---------------- | ---------------------- |
| Allow            | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言     |
| Content-Length   | 实体主体的大小         |
| Content-Location | 替代对应资源的 URI     |
| Content-MD5      | 实体主体的报文摘要     |
| Content-Range    | 实体主体的位置范围     |
| Content-Type     | 实体主体的媒体类型     |
| Expires          | 实体主体过期的日期时间 |
| Last-Modified    | 资源的最后修改日期时间 |

# 五.具体应用

## 连接管理

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png)

### 短连接和长连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

**长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信**。

- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。

### 流水线

默认情况下，HTTP 请求是按顺序发出的，**下一个请求只有在当前请求收到响应之后才会被发出**。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

流水线是在同一条长连接上**连续发出请求**，而不用等待响应返回，这样可以减少延迟。

## Cookie

HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。

### 1.用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

### 2.创建过程

服务器发送的响应报文包含 **Set-Cookie 首部字段**，客户端得到响应报文后把 Cookie 内容保存到浏览器中。

```html
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。

```html
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

### 3.分类

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：**指定过期时间**（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

```html
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

### 4.作用域

Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。

Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：

- /docs
- /docs/Web/
- /docs/Web/HTTP

### 5.JavaScript

浏览器通过 `document.cookie` 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。

```html
document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
```

### 6.HTTPOnly

标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 `document.cookie` API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。

```html
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

### 7.Secure

标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。

### 8.Session

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

使用 Session 维护用户登录状态的过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

### 9.浏览器禁用Cookie

此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。

### 10.Cookie和Session选择

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

## 缓存

### 1. 优点

- 缓解服务器压力；
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。

### 2. 实现方法

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存。

### 3. Cache-Control

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

**3.1 禁止进行缓存**

no-store 指令规定不能对请求或响应的任何一部分进行缓存。

```html
Cache-Control: no-store
```

**3.2 强制确认缓存**

no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。

```html
Cache-Control: no-cache
```

**3.3 私有缓存和公共缓存**

private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。

```html
Cache-Control: private
```

public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。

```html
Cache-Control: public
```

**3.4 缓存过期机制**

max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。

```html
Cache-Control: max-age=31536000
```

Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。

```html
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```

- 在 HTTP/1.1 中，会优先处理 max-age 指令；
- 在 HTTP/1.0 中，max-age 指令会被忽略掉。

### 4. 缓存验证

需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 `http://www.google.com/` 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。

```html
ETag: "82e22293907ce725faf67773957acd12"
```

可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。

```html
If-None-Match: "82e22293907ce725faf67773957acd12"
```

Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。

```html
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

## 范围请求

如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。

### 1.Range

在请求报文中添加 Range 首部字段指定请求的范围。

```html
GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
```

请求成功的话服务器返回的响应包含 **206 Partial Content** 状态码。

```html
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
```

### 2.Accept-Ranges

响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。

```html
Accept-Ranges: bytes
```

### 3.响应状态码

- 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。
- 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。
- 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。

## 虚拟主机

HTTP/1.1 使用虚拟主机技术，**使得一台服务器拥有多个域名**，并且在逻辑上可以看成多个服务器。

### 通信数据转发

#### 1.代理

代理服务器接受客户端的请求，并且转发给其它服务器。

使用代理的主要目的是：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

代理服务器分为正向代理和反向代理两种：

- 用户察觉得到正向代理的存在。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png)

- 而反向代理一般位于内部网络中，用户察觉不到。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png)

#### 2.网关

与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。

#### 3.隧道

使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。

# 六.HTTPS

HTTP 有以下安全性问题：

- 使用**明文进行通信**，内容可能会被窃听；
- **不验证通信方的身份**，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了**加密**（防窃听）、**认证**（防伪装）和**完整性保护**（防篡改）。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg)

## 加密

### 1.对称密钥加密

对称密钥加密（Symmetric-Key Encryption），**加密和解密使用同一密钥**。

- 优点：运算速度快；
- 缺点：无法安全地将密钥传输给通信方。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png)

### 2.非对称加密

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用**公开密钥进行加密**，接收方收到通信内容后使用**私有密钥解密**。

非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png)

### 3.HTTPS采用的加密方式

上面提到对称密钥加密方式的传输效率更高，但是**无法安全地将密钥 Secret Key 传输给通信方**。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：

- 使用**非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key**，从而保证安全性;
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png)

## 中间人攻击

在使用非对称密钥的时候，服务端需要将自己的公钥发送给客户端，在这一过程中中间人可以拦截到服务端的公钥，对拦截到的公钥进行修改(修改成自己的公钥)。

## 认证

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png)

## 完整性保护

SSL 提供报文摘要功能来进行完整性保护。

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

## HTTPS的缺点

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

# 七.HTTP/2.0

## HTTP/1.x的缺陷

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要使用多个连接才能实现并发和缩短延迟；
- **不会压缩请求和响应首部**，从而导致不必要的网络流量；
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

## 二进制分帧层

HTTP/2.0 将报文分成 **HEADERS 帧**和 **DATA 帧**，它们都是二进制格式的。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png)

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。
- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
- 帧（Frame）是最小的通信单位，**来自不同数据流的帧可以交错发送**，然后再根据每个帧头的数据流标识符重新组装。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png)

## 服务端推送

HTTP/2.0 在客户端请求一个资源时，**会把相关的资源一起发送给客户端**，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png)

## 首部压缩

HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。

HTTP/2.0 要求客户端和服务器同时**维护和更新一个包含之前见过的首部字段表**，从而避免了重复传输。

不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png)

# 八.HTTP/1.1新特性

详细内容请见上文

- 默认是**长连接**
- **支持流水线**
- 支持同时打开多个 TCP 连接
- 支持虚拟主机
- 新增状态码 100
- 支持分块传输编码
- 新增缓存处理指令 max-age

# 九.GET和POST的比较

## 作用

GET 用于获取资源，而 POST 用于传输实体主体。

## 参数

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 **URL** 中，而 POST 的参数存储在**请求体**中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。

因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 `中文` 会转换为 `%E4%B8%AD%E6%96%87`，而空格会转换为 `%20`。POST 参数支持标准字符集。

```
GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1


POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com

name1=value1&name2=value2
```

## 安全

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。

**GET 方法是安全的**，而 **POST 却不是**，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

安全的方法除了 GET 之外还有：HEAD、OPTIONS。

不安全的方法除了 POST 之外还有 PUT、DELETE。

## 幂等性

**幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的**，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。

所有的安全方法也都是幂等的。

在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。

GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：

```
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
```

POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：

```
POST /add_row HTTP/1.1   -> Adds a 1nd row
POST /add_row HTTP/1.1   -> Adds a 2nd row
POST /add_row HTTP/1.1   -> Adds a 3rd row
```

DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：

```
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
```

## 可缓存

如果要对响应进行缓存，需要满足以下条件：

- 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
- 响应报文的 Cache-Control 首部字段没有指定不进行缓存。

## XMLHttpRequest

为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：

> XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。

- 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
- 而 GET 方法 Header 和 Data 会一起发送。

		- IO
---

# 概述

Java 的 I/O 大概可以分成以下几类：

- 磁盘操作：File
- 字节操作：InputStream 和 OutputStream
- 字符操作：Reader 和 Writer
- 对象操作：Serializable
- 网络操作：Socket
- 新的输入/输出：NIO

# 文件操作

## 实现文件复制

```java
public static void copyFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutputStream(dist);

    byte[] buffer = new byte[20 * 1024];
    int cnt;

    // read() 最多读取 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof，即文件尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }

    in.close();
    out.close();
}
```

## 装饰者模式

Java I/O 使用了装饰者模式来实现。以 InputStream 为例，

- InputStream 是抽象组件；
- FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；
- **FilterInputStream 属于抽象装饰者**，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9709694b-db05-4cce-8d2f-1c8b09f4d921.png)



实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。

```java
FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
```

# 字符操作

## 编码和解码

**编码就是把字符转换为字节，而解码是把字节重新组合成字符。**

如果编码和解码过程使用不同的编码方式那么就出现了乱码。

- GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；
- UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；
- UTF-16be 编码中，中文字符和英文字符都占 2 个字节。

Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。

## Reader与Writer

不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。

- InputStreamReader 实现从字节流解码成字符流；
- OutputStreamWriter 实现字符流编码成为字节流。

### 实现逐行输出文本文件的内容

```java
public static void readFileContent(String filePath) throws IOException {

    FileReader fileReader = new FileReader(filePath);
    BufferedReader bufferedReader = new BufferedReader(fileReader);

    String line;
    while ((line = bufferedReader.readLine()) != null) {
        System.out.println(line);
    }

    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象
    // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法
    // 因此只要一个 close() 调用即可
    bufferedReader.close();
}
```

# 对象操作

## 序列化

**序列化就是将一个对象转换成字节序列**，方便存储和传输。

- 序列化：ObjectOutputStream.writeObject()
- 反序列化：ObjectInputStream.readObject()

**不会对静态变量进行序列化**，因为序列化只是保存对象的状态，静态变量属于类的状态。

## Serializable

序列化的类需要**实现 Serializable 接口**，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {

    A a1 = new A(123, "abc");
    String objectFile = "file/a1";

    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile));
    objectOutputStream.writeObject(a1);
    objectOutputStream.close();

    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile));
    A a2 = (A) objectInputStream.readObject();
    objectInputStream.close();
    System.out.println(a2);
}

private static class A implements Serializable {

    private int x;
    private String y;

    A(int x, String y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "x = " + x + "  " + "y = " + y;
    }
}
```

## transient

transient 关键字可以使一些属性不会被序列化。

ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。

# 网络操作

Java 中的网络支持：

- InetAddress：用于表示网络上的硬件资源，即 IP 地址；
- URL：统一资源定位符；
- Sockets：使用 TCP 协议实现网络通信；
- Datagram：使用 UDP 协议实现网络通信。

## InetAddress

没有公有的构造函数，只能通过静态方法来创建实例。

```java
InetAddress.getByName(String host);

InetAddress.getByAddress(byte[] address);
```

## URL

可以直接从 URL 中读取字节流数据。

```java
public static void main(String[] args) throws IOException {

    URL url = new URL("http://www.baidu.com");

    /* 字节流 */
    InputStream is = url.openStream();

    /* 字符流 */
    InputStreamReader isr = new InputStreamReader(is, "utf-8");

    /* 提供缓存功能 */
    BufferedReader br = new BufferedReader(isr);

    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }

    br.close();
}
```

## Socket

- ServerSocket：服务器端类
- Socket：客户端类
- 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e6affc4-18e5-4596-96ef-fb84c63bf88a.png)

# NIO

![Java IO模型之NIO模型-云海天教程](https://m.yht7.com/upload/image/20200106/up-2048efd21712590f469fdff945c43c115ef.png)

## 流与块

I/O 与 NIO 最重要的区别是数据打包和传输的方式，**I/O 以流的方式处理数据，而 NIO 以块的方式处理数据**。

**面向流的 I/O 一次处理一个字节数据**：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。

**面向块的 I/O 一次处理一个数据块**，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。

I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。

## 通道和缓冲区

### 通道

通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。

通道与流的不同之处在于，**流只能在一个方向上移动**(一个流必须是 InputStream 或者 OutputStream 的子类)，而**通道是双向的**，可以用于读、写或者同时用于读写。

通道包括以下类型：

- FileChannel：从文件中读写数据；
- DatagramChannel：通过 UDP 读写网络中数据；
- SocketChannel：通过 TCP 读写网络中数据；
- ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。

### 缓冲区

发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。

缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

缓冲区包括以下类型：

- ByteBuffer
- CharBuffer
- ShortBuffer
- IntBuffer
- LongBuffer
- FloatBuffer
- DoubleBuffer

### 缓冲区状态变量

- capacity：最大容量；
- position：下一个要读取的字节索引；
- limit：缓冲区的当前读写终点。

状态变量的改变过程举例：

① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png)



② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/80804f52-8815-4096-b506-48eef3eed5c6.png)



③ 在将缓冲区的数据写到输出通道之前，需要先调用 **flip() 方法**，这个方法将 limit 设置为当前 position，并将 position 设置为 0。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/952e06bd-5a65-4cab-82e4-dd1536462f38.png)



④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png)



⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67bf5487-c45d-49b6-b9c0-a058d8c68902.png)

## 选择器

NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。

NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。

通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。

因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/093f9e57-429c-413a-83ee-c689ba596cef.png)

### 1. 创建选择器

```java
Selector selector = Selector.open();
```

### 2. 将通道注册到选择器上

```java
ServerSocketChannel ssChannel = ServerSocketChannel.open();
ssChannel.configureBlocking(false);
ssChannel.register(selector, SelectionKey.OP_ACCEPT);
```

**通道必须配置为非阻塞模式**，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。

在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：

- SelectionKey.OP_CONNECT
- SelectionKey.OP_ACCEPT
- SelectionKey.OP_READ
- SelectionKey.OP_WRITE

它们在 SelectionKey 的定义如下：

```java
public static final int OP_READ = 1 << 0;
public static final int OP_WRITE = 1 << 2;
public static final int OP_CONNECT = 1 << 3;
public static final int OP_ACCEPT = 1 << 4;
```

可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：

```java
int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
```

### 3. 监听事件

```java
int num = selector.select();
```

使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。

### 4. 获取到达的事件

```java
Set<SelectionKey> keys = selector.selectedKeys();
Iterator<SelectionKey> keyIterator = keys.iterator();
while (keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if (key.isAcceptable()) {
        // ...
    } else if (key.isReadable()) {
        // ...
    }
    keyIterator.remove();
}
```

### 5. 事件循环

因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。

```java
while (true) {
    int num = selector.select();
    Set<SelectionKey> keys = selector.selectedKeys();
    Iterator<SelectionKey> keyIterator = keys.iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if (key.isAcceptable()) {
            // ...
        } else if (key.isReadable()) {
            // ...
        }
        keyIterator.remove();
    }
}
```

## 套接字 NIO 实例

```java
public class NIOServer {

    public static void main(String[] args) throws IOException {

        Selector selector = Selector.open();

        ServerSocketChannel ssChannel = ServerSocketChannel.open();
        ssChannel.configureBlocking(false);
        ssChannel.register(selector, SelectionKey.OP_ACCEPT);

        ServerSocket serverSocket = ssChannel.socket();
        InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);
        serverSocket.bind(address);

        while (true) {

            selector.select();
            Set<SelectionKey> keys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = keys.iterator();

            while (keyIterator.hasNext()) {

                SelectionKey key = keyIterator.next();

                if (key.isAcceptable()) {

                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();

                    // 服务器会为每个新连接创建一个 SocketChannel
                    SocketChannel sChannel = ssChannel1.accept();
                    sChannel.configureBlocking(false);

                    // 这个新连接主要用于从客户端读取数据
                    sChannel.register(selector, SelectionKey.OP_READ);

                } else if (key.isReadable()) {

                    SocketChannel sChannel = (SocketChannel) key.channel();
                    System.out.println(readDataFromSocketChannel(sChannel));
                    sChannel.close();
                }

                keyIterator.remove();
            }
        }
    }

    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        StringBuilder data = new StringBuilder();

        while (true) {

            buffer.clear();
            int n = sChannel.read(buffer);
            if (n == -1) {
                break;
            }
            buffer.flip();
            int limit = buffer.limit();
            char[] dst = new char[limit];
            for (int i = 0; i < limit; i++) {
                dst[i] = (char) buffer.get(i);
            }
            data.append(dst);
            buffer.clear();
        }
        return data.toString();
    }
}

public class NIOClient {

    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("127.0.0.1", 8888);
        OutputStream out = socket.getOutputStream();
        String s = "hello world";
        out.write(s.getBytes());
        out.close();
    }
}
```

# 参考

> https://cyc2018.github.io/CS-Notes/#/README

---
title: java基础
date: 2020-05-20 22:12:45
tags: java
categories: java
---

# 一.数据类型

## 基本类型

- byte/8
- **char/16**
- short/16
- int/32
- float/32
- long/64
- double/64
- boolean/~

boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。

## 包装类型

基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。

```java
Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
```

## 缓存池

new Integer(123) 与 Integer.valueOf(123) 的区别在于：

- new Integer(123) 每次都会新建一个对象；
- Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```

**valueOf()** 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。

```
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

在 Java 8 中，Integer 缓存池的大小默认为 -128~127。

```java
static final int low = -128;
static final int high;
static final Integer cache[];

static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k < cache.length; k++)
        cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high >= 127;
}
```

编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。

```java
Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
```

```
Integer i=200;
Integer j=200;
System.out.println(i==j);	//false
```

上面因为超过了缓存池的范围，所以是用new返回了两个不同的对象。

基本类型对应的缓冲池如下：

- boolean values true and false
- all byte values
- short values between -128 and 127
- int values between -128 and 127
- char in the range \u0000 to \u007F

在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。

在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。

# 二.String

## 概览

String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）

在 Java 8 中，String 内部使用 char 数组存储数据。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}
```

在 Java 9 之后，String 类的实现改用 **byte 数组**存储字符串，同时使用 `coder` 来标识使用了哪种编码。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}
```

value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。

## 不可变的好处

**1. 可以缓存 hash 值**

因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。

**2. String Pool 的需要**

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191210004132894.png)



**3. 安全性**

String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。

**4. 线程安全**

String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

## String,StringBuilder,StringBuffer

**1. 可变性**

- String 不可变
- StringBuffer 和 StringBuilder 可变

**2. 线程安全**

- String 不可变，因此是线程安全的
- StringBuilder不是线程安全的
- StringBuffer 是线程安全的，**内部使用 synchronized 进行同步**

## String Pool

字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 **intern() 方法**在运行过程将字符串添加到 String Pool 中。

当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 **equals() 方法**进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。

下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。

```
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4);           // true
```

**如果是采用 "bbb" 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。**

```java
String s5 = "bbb";
String s6 = "bbb";
System.out.println(s5 == s6);  // true
```

在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

## new String("abc")

使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。

- **"abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量**；
- 而使用 new 的方式会在堆中创建一个字符串对象。

创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。

```java
public class NewStringTest {
    public static void main(String[] args) {
        String s = new String("abc");
    }
}
```

使用 javap -verbose 进行反编译，得到以下内容：

```java
// ...
Constant pool:
// ...
   #2 = Class              #18            // java/lang/String
   #3 = String             #19            // abc
// ...
  #18 = Utf8               java/lang/String
  #19 = Utf8               abc
// ...

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String
         3: dup
         4: ldc           #3                  // String abc
         6: invokespecial #4                  // Method java/lang/String."<init>":(Ljava/lang/String;)V
         9: astore_1
// 
```

在 Constant Pool 中，#19 存储这字符串字面量 "abc"，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。

以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，**并不会完全复制 value 数组内容，而是都会指向同一个 value 数组**。

```java
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
```

# 三.运算

## 参数传递

Java 的参数是以**值传递**的形式传入方法中，而不是引用传递。

以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。

```java
public class Dog {

    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
```

在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。

```java
class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName("B");
    }
}
```

但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。

```java
public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog("B");
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
```

## float和double

Java 不能隐式执行向下转型，因为这会使得精度降低。

**1.1 字面量属于 double 类型**，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。

```java
// float f = 1.1;
```

1.1f 字面量才是 float 类型。

```java
float f = 1.1f;
```

## 隐式类型转换

因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。

```java
short s1 = 1;
// s1 = s1 + 1;
```

但是使用 += 或者 ++ 运算符会执行隐式类型转换。

```java
s1 += 1;
s1++;
```

上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：

```java
s1 = (short) (s1 + 1);
```

## switch

从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。

```java
String s = "a";
switch (s) {
    case "a":
        System.out.println("aaa");
        break;
    case "b":
        System.out.println("bbb");
        break;
}
```

switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。

```java
// long x = 111;
// switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
```

# 四.关键字

## final

### 1.字段

声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

- 对于基本类型，final 使数值不变；
- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

```java
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
```

**final可以修饰成员变量和局部变量。**

### 2.方法

**声明方法不能被子类重写**。

private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

### 3.类

声明类不允许被继承。

## static

### 1.静态变量

- 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。
- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

```java
public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
```

### 2.静态方法

静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。

```java
public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'
}
```

只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。

```java
public class A {

    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field 'y' cannot be referenced from a static context
        // int b = this.y;     // 'A.this' cannot be referenced from a static context
    }
}
```

### 3.静态语句块

静态语句块在**类初始化**时运行一次。

```java
public class A {
    static {
        System.out.println("123");
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}

123
```

### 4.静态内部类

非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。

```java
public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
```

**静态内部类不能访问外部类的非静态的变量和方法**。

### 5.静态导包

在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。

```java
import static com.xxx.ClassName.*
```

### 6.初始化顺序

静态变量和静态语句块优先于实例变量和普通语句块，**静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序**。

```java
public static String staticField = "静态变量";

static {
    System.out.println("静态语句块");
}

public String field = "实例变量";

{
    System.out.println("普通语句块");
}
```

最后才是构造函数的初始化。

```java
public InitialOrderTest() {
    System.out.println("构造函数");
}
```

存在继承的情况下，初始化顺序为：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）

# 五.Object通用方法

## 概览

```

public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class<?> getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
```

## equals()方法

**1. 等价关系**

两个对象具有等价关系，需要满足以下五个条件：

Ⅰ 自反性

```java
x.equals(x); // true
```

Ⅱ 对称性

```java
x.equals(y) == y.equals(x); // true
```

Ⅲ 传递性

```java
if (x.equals(y) && y.equals(z))
    x.equals(z); // true;
```

Ⅳ 一致性

多次调用 equals() 方法结果不变

```java
x.equals(y) == x.equals(y); // true
```

Ⅴ 与 null 的比较

对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false

```java
x.equals(null); // false;
```

**2. 等价与相等**

- 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
- 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。

```java
Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false
```

**3. 实现**

- 检查是否为同一个对象的引用，如果是直接返回 true；
- 检查是否是同一个类型，如果不是，直接返回 false；
- 将 Object 对象进行转型；
- 判断每个关键域是否相等。

```java
public class EqualExample {

    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;

        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}
```

## hashCode()方法

hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。

在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，**保证等价的两个对象哈希值也相等**。

HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。

下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。

```
EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet<EqualExample> set = new HashSet<>();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
```

理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。

R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：`31*x == (x<<5)-x`，编译器会自动进行这个优化。

```
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
```

可以直接调用Objects.hash()方法，将其中的各个实例字段传进去。

## toString()方法

默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为**散列码**的无符号十六进制表示。

```java
public class ToStringExample {

    private int number;

    public ToStringExample(int number) {
        this.number = number;
    }
}

ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());

ToStringExample@4554617c
```

## clone()方法

**1. cloneable**

clone() 是 Object 的 **protected 方法**，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。

```java
public class CloneExample {
    private int a;
    private int b;
}
```

```
CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'
```

重写 clone() 得到以下实现：

```java
public class CloneExample {
    private int a;
    private int b;

    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
```

```
CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
```

```
java.lang.CloneNotSupportedException: CloneExample
```

以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。

应该注意的是，clone() 方法并不是 **Cloneable** 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。

```
public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

**2. 浅拷贝**

拷贝对象和原始对象的引用类型引用同一个对象。

```java
public class ShallowCloneExample implements Cloneable {

    private int[] arr;

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
```

```
ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222
System.out.println(e1==e2);    //false
```

既然指向同一对象引用，那么==应该返回true，结果返回false，看源码clone()方法是一个native(本地)方法。所以我猜测是new了一个新的对象，但是其中的数据域还是引用的之前的。

**3. 深拷贝**

拷贝对象和原始对象的引用类型引用不同对象。

```
public class DeepCloneExample implements Cloneable {

    private int[] arr;

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}
```

```
DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
```

**4. clone() 的替代方案**

使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用**拷贝构造函数**或者**拷贝工厂**来拷贝一个对象。

```
public class CloneConstructorExample {

    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i < original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
```

```
CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
```

# 六.继承

## 访问权限

Java 中有三个访问权限修饰符：private、protected 以及 public，**如果不加访问修饰符，表示包级可见**。

可以对类或类中的成员（字段和方法）加上访问修饰符。

- 类可见表示其它类可以用这个类创建实例对象。
- 成员可见表示其它类可以用这个类的实例对象访问到该成员；

protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。

设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。

**如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别(一大)**。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。

字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。

```
public class AccessExample {
    public String id;
}
```

可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。

```
public class AccessExample {

    private int id;

    public String getId() {
        return id + "";
    }

    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
```

但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。

```
public class AccessWithInnerClassExample {

    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x;  // 直接访问
    }
}
```

## 抽象类与接口

**1. 抽象类**

抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。

抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。

```
public abstract class AbstractClassExample {

    protected int x;
    private int y;

    public abstract void func1();

    public void func2() {
        System.out.println("func2");
    }
}
```

```
public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

```
// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is //abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();
```

**2. 接口**

接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。

从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。

接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。

**接口的字段默认都是 static 和 final 的**。

```
public interface InterfaceExample {

    void func1();

    default void func2(){
        System.out.println("func2");
    }

    int x = 123;
    // int y;               // Variable 'y' might not have been initialized
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}
```

```
public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

```
// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; //cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
```

**3. 比较**

- 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
- 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
- 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
- **接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限**。

**4. 使用选择**

使用接口：

- 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；
- 需要使用多重继承。

使用抽象类：

- 需要在几个相关的类中共享代码。
- 需要能控制继承来的成员的访问权限，而不是都为 public。
- 需要继承非静态和非常量字段。

在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。

## super

- 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。
- 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。

```
public class SuperExample {

    protected int x;
    protected int y;

    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void func() {
        System.out.println("SuperExample.func()");
    }
}
```

```
public class SuperExtendExample extends SuperExample {

    private int z;

    public SuperExtendExample(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    public void func() {
        super.func();
        System.out.println("SuperExtendExample.func()");
    }
}
```

```
SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
```

```
SuperExample.func()
SuperExtendExample.func()
```

## 重写和重载

**1. 重写（Override）**

存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。

为了满足里式替换原则，重写有以下三个限制(**一大两小**)：

- 子类方法的访问权限必须大于等于父类方法；
- 子类方法的返回类型必须是父类方法返回类型或为其子类型。
- 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。

使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。

下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：

- 子类方法访问权限为 public，大于父类的 protected。
- 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。
- 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。
- 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。

```
class SuperClass {
    protected List<Integer> func() throws Throwable {
        return new ArrayList<>();
    }
}

class SubClass extends SuperClass {
    @Override
    public ArrayList<Integer> func() throws Exception {
        return new ArrayList<>();
    }
}
```

在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：

- this.func(this)
- super.func(this)
- this.func(super)
- super.func(super)

**面试题**

**Q：静态方法能否被重写？**

A：不能。原因在于重写机制的目的是为了实现**多态**，即重写是实现多态的前提，发生在继承中且针对非静态方法。语法上子类允许出现和父类只有方法体不一样其它都一模一样的静态方法，但是**在父类引用指向子类对象时，通过父类引用调用的仍然是父类的静态方法，而不是子类的。**

即：**语法上 static 方法支持重写，但是运行效果上达不到目的**。

**2. 重载（Overload）**

存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是**参数类型、个数、顺序至少有一个不同**。

应该注意的是，**返回值不同，其它都相同不算是重载**。

# 七.反射

每个类都有一个 **Class** 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，**该文件内容保存着 Class 对象**。

**类加载相当于 Class 对象的加载**，类在第一次使用时才动态加载到 JVM 中。也可以使用 `Class.forName("com.mysql.jdbc.Driver")` 这种方式来控制类的加载，该方法会返回一个 Class 对象。

反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。

Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：

- **Field** ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；
- **Method** ：可以使用 invoke() 方法调用与 Method 对象关联的方法；
- **Constructor** ：可以用 Constructor 的 newInstance() 创建新的对象。

**反射的优点：**

- **可扩展性** ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- **类浏览器和可视化开发环境** ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- **调试器和测试工具** ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。

**反射的缺点：**

尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。

- **性能开销** ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- **安全限制** ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- **内部暴露** ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

# 八.异常

Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： **Error** 和 **Exception**。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：

- **受检异常** ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；
- **非受检异常** ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png)

## throw和throws的区别

### 位置不同

* throws 用在方法上，后面可跟一个或多个异常类
* throw 用在方法内，后面跟随异常对象

### 功能不同

* **throws 用于声明异常**，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式。**并不一定会发生这些异常**。
* throw 抛出具体问题对象，执行到 throw 时功能就已经结束了，跳转到调用者并将具体问题对象抛给调用者。即 throw 语句独立存在时，后面不定义其他语句，无法到达。**执行throw则一定抛出了某种异常对象**。
* 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。

# 九.泛型

泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，即所操作的数据类型被指定为一个参数。

* **注意**：1）基本类型无法作为类型参数；2）静态方法无法访问泛型类的类型参数

  ​	        3）同一个泛型接口的两种变体由于类型参数会被视作相同接口

## 泛型类

泛型类的声明与非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。泛型类的类型参数声明部分包含一个或多个类型参数，参数间使用逗号分隔。

```java
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{
    //在类中声明的泛型整个类里面都可以用，除了静态部分，因为泛型是实例化时声明的。
    //静态区域的代码在编译时就已经确定，只与类相关
    class A <E>{
        T t;
    }
    //类里面的方法或类中再次声明同名泛型是允许的，并且该泛型会覆盖掉父类的同名泛型T
    class B <T>{
        T t;
    }
    //静态内部类也可以使用泛型，实例化时赋予泛型实际类型
    static class C <T> {
        T t;
    }
    public static void main(String[] args) {
        //报错，不能使用T泛型，因为泛型T属于实例不属于类
//        T t = null;
    }
​
    //key这个成员变量的类型为T,T的类型由外部指定
    private T key;
​
    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    }
​
    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    }
}
```

## 泛型接口

定义一个泛型接口：public interface `GenericIntercace<T>`{}

- 实现泛型接口的方式：
  1. public class `ImplGenericInterface1<T>` implements `GenericIntercace`\<T>
  2. public class `ImplGenericInterface2` implements `GenericIntercace`\<String>

## 泛型方法

在调用时可以接受不同类型的参数，根据传递给泛型方法的参数类型，编译器适当地处理每个方法调用。

- **注意：对于一个static方法，无法访问类的泛型参数，所以想要static方法具有泛型能力，必须使其称为泛型方法。**

泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。

* 原则：在可以仅泛型化方法时不选择泛型整个类

```
public class Util {
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&p1.getValue().equals(p2.getValue());
    }
}
public class Pair<K, V> {
    private K key;
    private V value;
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}

// 实例
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");

// 调用
boolean same = Util.<Integer, String>compare(p1, p2);
// Java 1.7/1.8 利用 type inference 可以自动推导相应类型参数
// 自动推导仅作用于赋值操作，其他操作需要显式指明类型
boolean same1 = Util.compare(p1, p2);
```

## 边界符与通配符

类型通配符一般是使用 ? 代替**具体的类型参数**。例如 List<?>  在逻辑上是 List\<String>，List\<Integer> 等所有 List< 具体类型实参 > 的父类。

1. <? extends T> 设定了边界，表示该通配符所代表的类型是 T 类型的子类
2. <? super T> 设定了边界，表示该通配符所代表的类型是 T 类型的父类

## 类型擦除

### 特性

- **泛型只在编译阶段有效**

```
		List<String> stringArrayList = new ArrayList<String>();
        List<Integer> integerArrayList = new ArrayList<Integer>();
        Class classStringArrayList = stringArrayList.getClass();
        Class classIntegerArrayList = integerArrayList.getClass();
        System.out.println(classIntegerArrayList.equals(classStringArrayList));//true
```

> 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。
> 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。

### 原理

Java 中的泛型基本上都是在编译器这个层次来实现的。在**生成的 Java 字节代码中是不包含泛型中的类型信息的**。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。

* 在泛型代码内部，无法获得任何有关泛型参数类型的信息

  如在代码中定义的 List\<Object> 和 List\<String> 等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。 

* 在使用泛型时，任何具体的类型信息都被擦除

  **泛型类型参数将擦除到它的第一个边界**：List\<T> -> List、T -> Object。List<T extends Number> -> List,T extends Number -> Number，如果一个泛型有多个边界，例如List<T extends Number& Iterator>，上面的多个边界中最多只能有一个类，如果有类，则被擦除成类，否则擦除为第一个接口。

* 所有泛型的操作都发生在边界处，对传递进来的值进行编译器检查，对传递出去的值进行转型。

例如：

```
public class GenericHolder<T> {
    private T obj;

    public T getObj() {
        return obj;
    }

    public void setObj(T obj) {
        this.obj = obj;
    }
}
```

对上面的类，set方法的检查是在编译时，get方法返回的其实是一个Object类型(擦除到其第一个边界)，然后进行转型。

### 问题及补偿方案

泛型不能用于显式地引用运行时类型的操作之中，即存在以下四个问题：

* 不允许创建泛型数组

  解决方案：

  1. 创建被擦除类型的新数组
  2. 在集合内部使用 Object[]
  3. 使用前对其进行转型

  上述方案中数据运行期时仍为 Object 等上一级类型

* 子类在继承（或实现）父类（或接口）的泛型方法时，若在子类中明确指定了泛型类型，则在编译时编译器会自动生成桥接方法（Bridge Method），出现类型转换问题。

```
// 原始类
public class Node<T> {
    public T data;
    public Node(T data) { this.data = data; }
    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }
    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}

// 类型擦除后
public class MyNode extends Node {
    // Bridge method generated by the compiler
    public void setData(Object data) {
        setData((Integer) data);
    }
    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
    // ...
}

// 导致类型转换错误结果
MyNode mn = new MyNode(5);
Node n = mn; // A raw type - compiler throws an unchecked warning
n.setData("Hello"); // Causes a ClassCastException to be thrown.
// Integer x = mn.data;
```

- 只能提供静态类型检查，则类型信息擦除后无法使用类型参数创建实例 

  ```
  public static <E>  void append(List<E> list) {
  	E elem = new E();   // compile-time error
      list.add(elem);
  }
  
  // 利用反射可解决该问题，调用时加入类型信息传递
  public static <E> void append(List<E> list, Class<E> cls) throws Exception {
      E elem = cls.newInstance();   // OK
      list.add(elem);
  }
  ```

- 无法使用 instanceof 关键字

  ```
  public static <E> void rtti(List<E> list) {
      if (list instanceof ArrayList<Integer>) {  // compile-time error
          // ...
      }
  }
  => { ArrayList<Integer>, ArrayList<String>, LinkedList<Character>, ... }
  
  // 可使用通配符重新设置边界
  public static void rtti(List<?> list) {
      if (list instanceof ArrayList<?>) {  // OK; instanceof requires a reifiable type
          // ...
      }
  }
  ```

## 常见面试题

[10 道 Java 泛型面试题](https://cloud.tencent.com/developer/article/1033693)

# 十.注解

Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。

# 十一.内部类

## 定义

将类定义置入一个用于封装它的类内部。

## 类别

### 1.成员内部类

```
public class Out {
	private static int a;
	private int b;
	public class Inner {
		public void print() {
			System.out.println(a);
			System.out.println(b);
		}
	}
}

Out out = new Out();
Out.Inner in = out.new Inner();
```

### 2.嵌套类(静态内部类)

```
public class Out { 
    private static int a; 
    private int b; 
    public static class Inner { 
        public void print() { 
            System.out.println(a); 
        } 
    } 
}

Out.In obj = new Out.In();
```

**实质上不属于内部类，与外部类没有任何关系。**

* **创建时不需要外部对象**
* 无法访问非静态外部对象，**可访问外部类私有静态对象**
* 可置于接口中，可实现外部接口，创建公共代码时使用
* 可用于放置测试代码，即 main 模块
* 实例：**HashMap 的静态内部类 Entry**，是 HashMap 存放元素的抽象。HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。

### 3.匿名内部类

没有构造器，初始化可在定义字段时实现（直接使用的外部对象需为 **final** 属性，若传递给父类构造器则不需要 final）或通过实例初始化方法实现（不可重载）。

* 限制：不可同时实现接口与继承类；单次仅可实现一个接口。

```java
// 创建一个继承自 C 的匿名类的对象
// 通过 new 表达式返回的引用被自动向上转型为对 C 的引用
public C c() {
    return new C() { 
    //....方法定义
    };
}
```

事实上，除了匿名内部类内部，方法和作用域内的内部类内部使用的外部变量也必须是 final 的。

原因如下：

内部类会自动拷贝外部变量的引用，为了避免：

1. 外部方法修改引用，而导致内部类得到的引用值不一致 
2. 内部类修改引用，而导致外部方法的参数值在修改前和修改后不一致。

于是就用 final 来让该引用不可改变，**避免数据不同步的问题**。

### 4.局部内部类

即定义在方法中的类，仅在方法中使用。

```java
public class Out { 
    private static int a; 
    private int b; 
    public void test(final int c) { 
        final int d = 1; 
        class Inner { 
            public void print() { 
                System.out.println(c); 
            } 
        } 
    } 
}
```

# 十二.特性

## java各版本的特性

### JDK1.5

1.**泛型**、2. 自动装箱/拆箱、3. for-each、4. static、import、5. 变长参数、协变返回类型（实际返回类型可以是要求的返回类型的一个子类型）、6. 枚举

### JDK1.6

1.**增强的 for 循环**、2. 监视和管理、3. 插入式注解处理、4. 安全性

### JDK1.7

1.模块化新特性、2. 多语言支持、3. 改善开发效率、4. 改善执行效率、5. **提供了新的垃圾回收器 G1**

### JDK1.8

1. 接口允许默认方法 / 扩展方法

   default 关键字

2. 方法与构造函数引用

   允许使用 :: 关键字来传递方法或者构造函数引用

3. Lambda

   - 表达式：无需再使用传统匿名对象方式

   - 函数式接口

     每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 

   - 访问局部变量：可以直接在lambda表达式中访问外层的局部变量

   - 访问对象字段与静态变量

     和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的。

   - 访问接口的默认方法

     JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。

## Java 与 C++ 的区别

* Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
* **Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台**。
* Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
* **Java 支持自动垃圾回收，而 C++ 需要手动回收**。
* Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 **C++ 支持多重继承**。
* Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
* Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。
* Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。

# 十三.原码，反码和补码

## 原码

- 原码就是符号位加上所要表达值得绝对值，即用第一位表示符号，其他位表示值，比如在8位二进制中：

  [+1]~原~=0000 0001

  [-1]~原~=1000 0001

- 所以可以得到8位二进制得取值范围是[1111 1111] - [0111 1111]即-127到127

## 反码

- 正数的反码是自己，负数的反码是在其原码基础上，符号位不变，其他位取反，例如：

  [0000 0001]=[+1]~原~=[+1]~反~

  [-1]~原~=1000 0001 ，[-1]~反~=1111 1110

## 补码

- 正数的补码就是自己，负数的补码是反码加1

  [0000 0001]=[+1]~原~=[+1]~反~=[+1]~补~

  [-1]~原~=1000 0001 ，[-1]~反~=1111 1110 ，[-1]~补~= 1111 1111

## 为什么使用原码，反码和补码

- 以原码为例，当涉及到减法时，计算机会将其转换为加法，以1-1为例

  1 - 1 = 1 + (-1) = [00000001]~原~ + [10000001]~原~ = [10000010]~原~ = -2

- 补码可以解决这个问题，统一加法和减法

  1-1 = 1 + (-1) =[0000 0001]~补~ + [1111 1111]~补~ = [0000 0000]~补~=[0000 0000]~原~

---
title: java基础常见问题
date: 2020-05-24 19:04:41
tags: java
categories: java
---

# 1.面向对象和面向过程的区别

- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**
- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。

# 2.java语言有哪些特点

1. 简单易学；
2. **面向对象**（封装，继承，多态）；
3. **平台无关性**（ Java 虚拟机实现平台无关性）；
4. 可靠性；
5. 安全性；
6. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
7. 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
8. 编译与解释并存；

# 3.JVM,JRE,JDk

## JVM

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

**Java 程序从源代码到运行一般有下面 3 步：**

![Java程序运行过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png)

我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 **JIT 编译器**，而 JIT 属于运行时编译。**当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用**。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。

**总结：**

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。

## JDK和JRE

JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。

# 4.java和C++的区别

- 都是面向对象的语言，都支持封装、继承和多态
- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理机制，不需要程序员手动释放无用内存

# 5.java面向对象编程三大特性：封装，继承，多态

## 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

## 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

**关于继承如下 3 点请记住：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

## 多态

所谓多态就是指程序中定义的**引用变量所指向的具体类型**和**通过该引用变量发出的方法调用**在编程时并不确定，而是**在程序运行期间才确定**，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

# 6.成员变量与局部变量的区别

1. 从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
2. 从变量在内存中的存储方式来看:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

# 7.==与equals()

**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。

**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

```
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```

**说明：**

- String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。

# 8.hashCode()与equals()

面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”

## hashCode()介绍

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

## 为什么要有hashCode()

**我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：** 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 `equals()`方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

通过我们可以看出：`hashCode()` 的作用就是**获取哈希码**，也称为散列码；它实际上是返回一个 int 整数。这个**哈希码的作用**是确定该对象在哈希表中的索引位置。**`hashCode()`在散列表中才有用，在其它情况下没用**。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

## hashCode()和equals()的相关规定

1. 如果两个对象相等，则 hashcode 一定也是相同的
2. 两个对象相等,对两个对象分别调用 equals 方法都返回 true
3. 两个对象有相同的 hashcode 值，它们也不一定是相等的
4. **因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖**
5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

#  9.说说List，Set，Map区别

- **List(对付顺序的好帮手)：** List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象
- **Set(注重独一无二的性质):** 不允许重复的集合。不会有多个元素引用相同的对象。
- **Map(用Key来搜索的专家):** 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

# 10.说说HashMap和HashTable的区别

1. **程是否安全：** HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
2. **效率：** 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；
3. **对Null key 和Null value的支持：** HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。
4. **初始容量大小和每次扩充容量大小的不同 ：** ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。
5. **底层数据结构：** JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

# 11.HashMap的长度为什么是2的幂次方

为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ `(n - 1) & hash`”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。

**这个算法应该如何设计呢？**

我们首先可能会想到采用%取余的操作来实现。但是，重点来了：**“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。**

# 12.HashMap多线程操作导致死循环的问题

主要原因在于并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。

# 13.什么是进程和线程？

## 何为进程

**进程是程序的一次执行过程，是系统运行程序的基本单位**，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。

## 何为线程

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

# 14.为什么调用start()方法时会执行run()方法，为什么不能直接调用run()方法？

new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 **start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作**。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**

# 15.讲一下synchronized的底层原理

**synchronized 关键字底层原理属于 JVM 层面。**

**① synchronized 同步语句块的情况**

```java
public class SynchronizedDemo {
    public void method() {
        synchronized (this) {
            System.out.println("synchronized 代码块");
        }
    }
}
```

通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 `javac SynchronizedDemo.java` 命令生成编译后的 .class 文件，然后执行`javap -c -s -v -l SynchronizedDemo.class`。

![synchronized关键字原理](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86.png)

从上面我们可以看出：

**synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。** 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

**② synchronized 修饰方法的的情况**

```java
public class SynchronizedDemo2 {
    public synchronized void method() {
        System.out.println("synchronized 方法");
    }
}
Copy to clipboardErrorCopied
```

![synchronized关键字原理](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png)

synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

# 16.AQS

AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。---
title: jvm
date: 2020-05-04 16:35:00
tags: 
	  - 面试
	  - jvm
categories: 虚拟机
---

# 1.走进java

- 可以把java程序语言设计，java虚拟机，javaAPI类库这三部分统称为**JDK**
- 把javaAPI类库中的java SE API子集和java虚拟机统称为**JRE**

# 2.java内存区域和内存溢出异常

## 运行时数据区域

![image-20200422173253871.png](https://i.loli.net/2020/05/04/GmyuLJ6xgcTQC8P.png)

### 程序计数器

- 可以看作当前线程所执行字节码的**行号指示器**。
- 唯一一个不会出现**OOM**的区域

### java虚拟机栈

是描述 Java 方法执行的内存模型，每个 Java 方法在执行的同时会创建一个**栈帧用于存储局部变量表、操作数栈、常量池引用、动态链接、方法出口等信息**。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

栈帧是用于存储数据和部分过程结果的数据结构，同时也被用于处理动态链接、方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。

可以通过 **-Xss** 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：

```java
java -Xss512M 
```

所需内存空间在编译期间完成分配，大小在运行期间不会发生改变。

对这个区域规定了两种异常：

1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出**StackOverflowError**异常。
2. 如果虚拟机允许动态扩展，如果扩展时无法申请到足够的内存，就会抛出**OutOfMemoryError**异常。

特另： 

* 在**单个线程情况下**，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时均抛出 StackOverflowError 异常。
* 不断建立线程的情况下，为每个线程的栈分配的内存越大，越容易产生内存溢出异常。需要考虑减少最大堆和栈容量来换取更多线程的情况。

#### 面试题：什么时候会报StackOverFlowError/OutOfMemoryError

- 如果线程请求的栈深度大于虚拟机允许最大深度，会抛出StackOverFlowError。
- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OOM(可以通过不停的开启新线程实现)。

### 本地方法栈

与虚拟机栈的区别是：

- 虚拟机栈是执行java方法的，而本地方法栈是执行(Native)本地方法的

同样本地方法栈也会抛出**StackOverflowError**和**OutOfMemoryError**异常。

### java堆

用于存放**对象实例与数组**，几乎所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。

现代的垃圾收集器基本都是采用**分代收集**算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：

* **新生代**（Young Generation）

  用于存放新生的对象，一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁出发 **MinorGC** 进行垃圾回收。

  又分为 Eden 区、From Survivor 区 和 To Survivor 区（空间划分为 8 ：1 ：1 ）三个区域。

  * Eden 区：Java 新对象的出生地。当 Eden 区内存不够时会触发 MinorGC，对新生代区进行一次垃圾回收。
  * SurvivorFrom 区：上一次 GC 的幸存者，作为这一次 GC 的扫描者。
  * SurvivorTo 区：保留了一次 MinorGC 过程中的幸存者。

* **老生代**（Old Generation）

  主要存放应用程序中生命周期长的内存对象。

从内存分配的角度来看，线程共享的区还可以划分出多个**线程私有的分配缓冲区**

堆不需要连续物理内存，并且可以动态扩展其内存，无多余内存可完成实例分配且扩展失败时会抛出 OutOfMemoryError 异常。

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

```java
java -Xms1M -Xmx2M 
```

### 方法区

用于存放**已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。

和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常，可选择不实现垃圾收集。

对这块区域进行垃圾回收的主要目标是对**常量池的回收**和对**类的卸载**，但是对类的卸载一般比较难实现。

#### 运行时常量池

运行时常量池是方法区的一部分。

Class 文件中的常量池（编译期生成的字面量和符号引用）会在类加载后被放入这个区域。

除了在编译期生成的常量，还允许存储运行期间动态生成的常量，例如 String 类的 intern ()。

* 在 JDK 1.6 中， intern() 会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用。
* 在 JDK 1.7 中，intern() 不会再复制实例，而只是在常量池中记录首次出现的实例引用。

> **JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

## 对象的创建

1. 虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的**类是否已被加载**，解析和初始化过，如果没有，那必须先执行相应的类加载过程
2. 在类加载完成后，接下来就是虚拟机将为新生对象分配内存，分配内存的方法基于java堆的空闲内存是否连续可以分为两类：
   1. **指针碰撞**。空闲内存连续时，只需要移动指针即可
   2. **空闲列表**。空闲内存不连续时，需要一个列表来记录哪些位置是空闲的
3. 内存分配完毕后，虚拟机将分配到的内存空间都初始化为零值
4. 最后虚拟机要对对象进行一些必要的配置

**在上面工作完成后，在虚拟机的角度，一个对象已经创建，但从java程序的角度来看，对象创建才刚刚开始，\<init>方法还没有执行，所有字段还是零值**

**Q：如何解决并发情况下，在java堆中给对象分配内存时是线程安全的(例如同时创建对象A和B，在给A分配内存时，指针还未来得及移动的情况下，B又在原来的基础上分配内存)**

A：两种解决方案：

1. 虚拟机采取**CAS操作**配上失败重试来保证更新操作的原子性
2. 每个线程在java堆中分配一小块区域，称为**本地线程分配缓冲**(TLAB)，哪个线程要分配内存时，就在自己的TLAB上分配。

## 对象的内存布局

- 在HotSpot虚拟机中，对象的内存布局可以分为：**对象头**，**实例数据**，**对齐填充**
- **对象头**包括两部分的信息：
  1. 存储对象自身运行时数据，如哈希码，**GC分代年龄**，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等
  2. **类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例
- **实例数据**是对象真正存储的有效信息，也是在程序段中所定义的各种类型字段(包括父类的)。

## 对象的访问定位

通过栈上的reference数据来操作堆上的对象有两种访问方式：

1. **句柄**。java堆中专门划分出一个句柄池，reference存储的是句柄的地址，而句柄包含了对象实例数据和类型数据各自的具体地址信息。

   优点：对象移动时，只需要修改句柄中的指针即可，reference不需要修改

   ![image-20200423105805390.png](https://i.loli.net/2020/05/04/kLbrJshPKEmzXfd.png)

2. **直接指针**。reference直接存储对象地址

   优点：节省了一次地址定位的时间

   ![image-20200423105905341.png](https://i.loli.net/2020/05/04/ARrelvUxwqQsBj6.png)

## OOM

### java堆内存溢出

```
/**
     * VM:-verbose:gc
     * -Xms20M
     * -Xmx20M
     * -Xmn10M
     * -XX:+PrintGCDetails
     * -XX:SurvivorRatio=8
     */
    static class OOMObject{

    }
    public static void main(String[] args) {
        List<OOMObject> list=new ArrayList<>();
        while (true){
            list.add(new OOMObject());
        }
    }
```

通过设置参数：`-XX:+HeapDumpOnOutOfMemoryError`可以在虚拟机出现内存溢出时Dump出当前的内存堆转储快照。

然后用内存映像分析工具(VisualVM)对Dump出的堆转储快照进行分析，重点是确认内存中的对象是否有必要存在，即判断是发生了**内存泄漏**还是**内存溢出**。

- 如果是**内存泄漏**，可进一步查看泄漏对象到GC Roots的引用链，就可以找到泄漏对象是怎么和GC Roots相连的导致垃圾回收器无法自动回收它们。
- 如果**内存溢出**,那就应当检查虚拟机的堆参数，能不能调大一点。

### 虚拟机栈和本地方法栈溢出

- 在单个线程的情况下只会抛出StackOverFlow异常

# 3.垃圾收集器与内存分配策略

GC需要考虑三件事情：

1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何让回收？

## 判断对象是否已经死亡

### 引用计数法

- 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；计数器为0的对象就是不可能再被使用的。

**主要问题：**无法解决循环引用的问题。

### 可达性分析算法

- 通过一系列的称为**GC Roots**的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链时，就证明对象不可用。

**GC Roots对象包括以下几种：**

1. **虚拟机栈中引用的对象(局部变量)**
2. **方法区中类变量引用的变量**
3. **方法区中常量引用的变量**
4. **本地方法栈中引用的对象**

### 引用

强引用>软引用>弱引用>虚引用

- **强引用**。类似Object obj=new Object()这类的引用，只要强引用在，垃圾回收器就无法回收掉引用的对象。

- **软引用**。被软引用关联的对象只有在**内存不够**的情况下才会被回收，通常用在对内存敏感的程序中。

  ```
  SoftReference<Object> sf=new SoftReference<>(new Object());
  ```

- **弱引用**。被弱引用关联的对象只能活到**下次垃圾收集发生之前**。当垃圾收集器工作时，弱引用关联的对象总会被回收

  ```
  WeakReference<Object> wf=new WeakReference<>(new Object());
  ```

- **虚引用**。虚引用对对象的生存时间不会构成影响，也无法通过虚引用来获取对象实例。

   ```
  ReferenceQueue<Object> rq=new ReferenceQueue<>();   //引用队列
  
  PhantomReference<Object> pr=new PhantomReference<>(new Object(),rq);
  
  System.out.println(pr.get());  //null
  System.out.println(rq.poll()); //null
  ```

## 回收方法区

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

主要是对常量池的回收和对类的卸载。

为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。

类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：

* 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
* 加载该类的 ClassLoader 已经被回收。
* 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

## 垃圾收集算法

### 标记-清除算法(Mark-Sweep)

- 分为**标记**和**清除**两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象

**主要不足：**

1. 效率不高
2. 会产生大量不连续的内存碎片

### 复制算法

- 将内存划分成两块，每次只是用其中的一块，当这一块的内存用完以后，就将还存活的对象复制到另外一块上，然后把已使用的内存空间一次清理掉

现在的虚拟机都采用这种复制算法来回收新生代，只不过时分成一块较大的Eden区和两块较小的Survivor区。

当Survivor区空间不够用时，需要依赖其他内存进行**分配担保**，也就是另一块 Survivor 没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将之间通过分配担保机制进入老生代。

### 标记-整理算法

- 标记的过程和标记-清除算法一样，但后续步骤是让所有存活的对象都**向一端移动**，然后清除掉端边界以外的内存。

### 分代收集算法

- 将java堆分成新生代和老年代。在**新生代使用复制算法**，在**老年代使用标记-清除和标记-整理算法**。

## 垃圾收集器

**串行、并行与并发**

* 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
* 串行：**串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；**
* 并行：多条垃圾收集线程并行工作，但**此时用户线程仍处于等待状态**；
* 并发：**用户线程与垃圾收集线程同时执行**（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上。
* 除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。



![1553654058045.png](https://i.loli.net/2020/05/04/fCWVLmtyOlPR6hq.png)

### Serial收集器

![1557456534404.png](https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png)

- Serial收集器是一个**单线程**的，这意味着它将只使用一个线程去完成垃圾收集工作，此外在它垃圾收集时，**必须暂停其他所有线程**。

**优点：**简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有**最高的单线程收集效率**。

它是 **Client** 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆新生代垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

### ParNew收集器

- ParNew收集器是Serial收集器的多线程版本，使用多条线程进行垃圾收集，使用**复制**算法。
- 默认开启线程数与 CPU 的数量相同
- 它是 **Server** 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

![image-20200424094451166.png](https://i.loli.net/2020/05/04/LYv8euROzHmphQN.png)

### Parallel Scavenge收集器

与 ParNew 一样是并行多线程收集器，使用**复制**算法，新生代使用。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是**达到一个可控制的吞吐量**，因此它被称为 “**吞吐量优先**” 收集器。这里的**吞吐量指 CPU 用于运行用户程序的时间占总时间的比值**。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，**适合在后台运算而不需要太多交互的任务**。

提供了精确控制吞吐量的参数：

```java
-XX:MaxGCPauseMills		// 控制最大垃圾收集停顿时间
-XX:GCTimeRatio			// 垃圾收集时间占总时间的比率，即吞吐量的倒数，例如19，则表示垃圾收集时间							   占比为1/(1+19)=5%
```

* 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打开 **GC 自适应的调节策略（GC Ergonomics）**，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老生代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

```java
-XX:+UseAdaptiveSizePolicy  // 开关参数
```

### Serial Old 收集器

![1557456534404.png](https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png)

是 **Serial 收集器的老生代版本**，同样是一个**单线程**收集器（无法充分利用服务器多 CPU 的处理能力），使用 **”标记 - 整理“** 算法。该收集器主要是给 **Client** 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

* 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
* 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### Parallel Old收集器

![1557471744502.png](https://i.loli.net/2020/05/04/wItovSGp4yO2KWl.png)

JDK 1.6 中开始提供，是 Parallel Scavenge 收集器的老生代版本，使用**多线程**和 **”标记 - 整理“** 算法。

在JDK1.6之前，新生代使用 ParallelScavenge 收集器只能搭配老生代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了**在老生代同样提供吞吐量优先**的垃圾收集器，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### CMS收集器

![1557471755660.png](https://i.loli.net/2020/05/04/pVKXBGeJgI5dSnq.png)

CMS（Concurrent Mark Sweep）是一种以**获取最短回收停顿时间**为目标的收集器，Mark Sweep 指的是**标记 - 清除**算法。

分为以下四个流程：

* **初始标记：**

  仅仅只是**标记一下 GC Roots 能直接关联到的对象**，速度很快，**需要停顿**。

* **并发标记：**

  进行 **GC Roots Tracing** 的过程，它在整个回收过程中耗时最长，**不需要停顿**。

* **重新标记：**

  为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，**需要停顿**，时间长于初始标记、短于并发标记。

* **并发清除：**

  **不需要停顿**。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

**缺点：**

* **吞吐量低**：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。

* **无法处理浮动垃圾，可能出现 Concurrent Mode Failure。**浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老生代快满的时候再回收。**如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure**，这时虚拟机将临时启用 **Serial Old** 来替代 CMS。

* **标记 - 清除**算法导致的空间碎片，往往出现老生代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

  可使用 ` -XX：+UseCMSCompactAtFullCollection` 参数（默认开启）在需要进行 Full GC 时开启内存碎片合并整理过程，该过程无法并发，导致停顿时间变长。

  可使用 `-XX：CMSFullGCsBeforeCompaction` 参数设置执行多少次不压缩的 Full GC 后进行带压缩的 Full GC（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。

### G1收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

* 适用于**追求低停顿情况**，不适用于追求吞吐量的情况

堆被分为新生代和老生代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和老生代一起回收。

![4cf711a8-7ab2-4152-b85c-d5c226733807.png](https://i.loli.net/2020/05/04/hTZxBYk85dyJ1SC.png)

**G1 把堆划分成多个大小相等的独立区域**（Region），区大小为 2 的幂，范围为 1M 到 32M，目标是根据最小的 Java 堆大小划分出约 2048 个区域。

新生代和老生代不再物理隔离，仅保留逻辑上的分代概念，每个分区都可能随着 G1 的运行在不同代之间前后切换。

![9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png](https://i.loli.net/2020/05/04/hExQiLy1Urlb8Ft.png)

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收，**避免全内存扫描**。这种划分方法带来了很大的灵活性，使得**可预测的停顿时间模型**（软目标）成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个**优先列表**，每次根据允许的收集时间，**优先回收价值最大的 Region**，有计划地避免在整个 Java 堆中进行全区域的垃圾收集，确保在有限时间内获得最高的垃圾收集效率。

每个 Region 都有一个 **Remembered Set**，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![1557474325452.png](https://i.loli.net/2020/05/04/LsviNBzleEoTXF3.png)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

* 初始标记：

  标记 GC Roots 能直接关联到的对象并修改 TAMS（Next Top at Mark Set）的值，使下一阶段用户程序并发运行时能在正确可用的 Region 中创建新对象。需要停顿，但耗时很短。

* 并发标记：

  从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象。耗时较长，但可以与用户程序并发执行。

* 最终标记：

  为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要**停顿线程**，但是可并行执行。

* 筛选回收：

  首先，对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

**特点：**

* **并行与并发**：利用多个 CPU 缩短停顿时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作， G1 收集器仍然可以通过并发的方式使 Java 程序继续执行。
* **分代收集**：分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。
* **空间整合**：整体来看是基于 **“标记 - 整理”** 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 **“复制”** 算法实现的，这意味着运行期间不会产生内存空间碎片。
* **可预测的停顿**：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

### CMS 与 G1 整体区别

- 两者都追求最短停顿时间，无法兼顾吞吐量

- **CMS 使用标记清除算法**实现，会导致空间碎片，提前触发 GC 

  **G1 使用标记整理算法**，不会导致空间碎片

- G1 中分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。

  **CMS 针对理整个老年代进行处理。G1可以回收新生代和老年代**

### **总结**

|      收集器       |                      定义                      |                             特点                             |             垃圾算法              |                          应用场景                          |                   备注                   |
| :---------------: | :--------------------------------------------: | :----------------------------------------------------------: | :-------------------------------: | :--------------------------------------------------------: | :--------------------------------------: |
|      Serial       |        最基本、发展历史最长的垃圾收集器        |                      并发、单线程、高效                      |               复制                |              客户端模式下，虚拟机的新生代区域              |                                          |
|    Serial Old     |      Serial 收集器应用在老年代区域的版本       |                      并发、单线程、高效                      |            标记 - 整理            |              客户端模式下，虚拟机的老生代区域              |        CMS 的后备预案，失败时使用        |
|      ParNew       |           Serial 收集器的多线程版本            |                并发、多线程、性能低于 Serial                 |               复制                |              客户端模式下，虚拟机的新生代区域              |       唯一可配合 CMS 工作的收集器        |
| Parallel Scavenge |             ParNew 收集器的升级版              |      并发、多线程、自适应调节，以达到可控制吞吐量为目标      |               复制                |              服务器模式下，虚拟机的新生代区域              |                                          |
|   Parallel Old    | Parallel Scavenge 收集器应用在老年代区域的版本 |      并发、多线程、自适应调节，以达到可控制吞吐量为目标      |            标记 - 整理            |              服务器模式下，虚拟机的老生代区域              |                                          |
|        CMS        |        基于**标记 - 清除**算法的收集器         | 并行、单线程、垃圾收集停顿时间短，总吞吐量低，无法处理浮动垃圾，产生空间碎片 |            标记 - 清除            | 重视应用的响应速度、希望系统停顿时间最短的场景（如老年代） | 初始标记、并发标记、重新标记、并发清除、 |
|        G1         |            最新、技术最前沿的收集器            | 并行、多线程、垃圾回收效率高（可预测的停顿时间模型），分代收集、无空间碎片 | 新生代：复制、老生代：标记 - 整理 |        服务器端虚拟机的内存区域（含新生代与老生代）        | 初始标记、并发标记、最终标记、筛选回收、 |

### 组合选择

* **单 CPU 或小内存，单机程序：**

  **-XX:+UseSerialGC：**新生代 Serial + 复制，老生代 SerialOld + 标记整理

* **多 CPU，需要最大吞吐量，如后台计算型应用：**

  **-XX:+UseParallelGC：**新生代 Parallel + 复制，老生代 ParallelOld + 标记整理

  **-XX:+UseParallelOldGC：**同上

* **多 CPU，追求低停顿时间，需要快速响应如互联网应用**

  **-XX:+UseConcMarkSweepGC：**新生代 ParNew + 复制，老生代 CMS +SerialOld 的收集器组合 + 标记清除

  **-XX:+UseG1GC：**整体采用标记整理，局部使用复制，不会产生碎片

## 内存分配和回收策略

### Minor GC 和 Full GC

* Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
* Full GC / Major GC：回收老生代和新生代，老生代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。出现了 Full GC，经常会伴随至少一次 Minor GC。

### 内存分配

#### 对象优先在Eden区分配

* 大多数情况下，对象在新生代的 Eden 区上分配，**当 Eden 空间不够时，发起 Minor GC**
* 若启动了本地线程分配缓冲，则将按线程优先在 TLAB （本地线程分配缓冲）上分配

**实例：**

1. 内存大小设定

```java
// 限制堆大小为 20M，不可扩展，10M 分配给新生代、10M 分配给老生代
-Xms20M -Xmx20M -Xmn10M
// 决定新生代中 Eden：Survivor = 8：1
-XX:SurvivorRatio=8
```

2. 内存分配

```java
byte[] allocation1，allocation2，allocation3，allocation4;
allocation1=new byte[2*_1MB];
allocation2=new byte[2*_1MB];
allocation3=new byte[2*_1MB];
allocation4=new byte[4*_1MB]; // 出现一次Minor GC
```

​	分配 allocation4 对象的语句时会发生一次 Minor GC，这次 GC 的结果是新生代 6651KB 变为 148KB，而总内存占用量则几乎没有减少（因为 allocation1、allocation2、allocation3 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。

​	这次 GC 发生的原因是给 allocation4 分配内存的时候，发现 Eden 已经被占用了 6MB，剩余空间已不足以分配 allocation4 所需的 4MB 内存，因此发生 Minor GC。GC 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 Survivor 空间（ Survivor 空间只有 1MB 大小），所以**只好通过分配担保机制提前转移到老生代去。**

3. 结果

​	Eden 占用 4 MB（被 allocation4 占用），Survivor 空闲，老生代被占用 6MB（被allocation1、 allocation2、allocation3 占用）。

#### 大对象直接进入老生代

* 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组

* 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象

* -XX:PretenureSizeThreshold，大于此值的对象直接在老生代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

  该参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge收集器一般并不需要设置，若遇到必须使用该参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。

#### 长期存活的对象进入老年代

* 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄（默认 15）则移动到老生代中。
* -XX:MaxTenuringThreshold 用来定义年龄的阈值。

#### 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老生代，如果在 Survivor 中**相同年龄所有对象大小的总和大于 Survivor 空间的一半**，则年龄大于或等于该年龄的对象可以直接进入老生代，无需等到 MaxTenuringThreshold 中要求的年龄。

#### 空间分配担保

**JDK 6 Update 24 之后不再使用 HandlePromotionFailure  参数**，规则变为只要**老生代的连续空间大于新生代对象总大小或者历次晋升的平均大小**就会进行Minor GC，否则将进行Full GC。

## Full GC 触发条件

对于 Minor GC，其触发条件非常简单，**当 Eden 空间满时，就将触发一次 Minor GC**。而 Full GC 则相对复杂，有以下条件：

### 调用 System.gc()

只是**建议虚拟机执行 Full GC**，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

### 老生代空间不足

老生代空间不足的常见场景为前文所讲的大对象直接进入老生代、长期存活的对象进入老生代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老生代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老生代的年龄，让对象在新生代多存活一段时间。

### 空间分配担保失败

使用复制算法的 Minor GC 需要老生代的内存空间作担保，如果担保失败会执行一次 Full GC。

### JDK 1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 信息、Meta 信息、常量、静态变量等数据。GC 不会在主程序运行期对永久代区域进行清理。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

### Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

# 4.虚拟机性能监控与故障处理工具

## jps：虚拟机进程状况工具

- `jps -l`

## jstat：虚拟机统计信息监控工具

- 监视虚拟机的各种运行状态

## jinfo：java配置信息工具

- 实时的查看和调整虚拟机的各项参数

## jmap：java内存映像工具

- 用于生成堆转储快照(heapdump)

## jstack：java堆栈跟踪工具

- 生成虚拟机当前时刻的线程快照(threaddump)

# 6.类文件结构

## 平台无关性

- 可以额运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的**字节码**(.class)，从而实现平台无关性

## Class类文件的结构

根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类会可以有个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

**Class文件字节码结构组织示意图** 

![类文件字节码结构组织示意图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

### 魔数

- 每个Class文件的前四个字节称为魔数，它的唯一作用是**确定这个文件是否为一个能被虚拟机接受的Class文件**

### Class文件版本

紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是**次版本号**，第七和第八是**主版本号**。

高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。

### 常量池

```java
   u2             constant_pool_count;//常量池的数量
   cp_info        constant_pool[constant_pool_count-1];//常量池
```

紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（**常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”**）。

- 常量池主要存放两大类常量：**字面量**和**符号引用**。
- 字面量包括文本字符串，**声明为final的常量值**等。
- 符号引用包括：
  1. 类和接口的全限定名
  2. 字段的名称和修饰符
  3. 方法的名称和修饰符

常量池中每一项常量都是一个表，这14种表有一个共同的特点：**开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．**

`.class` 文件可以通过`javap -v class类名` 指令来看一下其常量池中的信息

### 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。

类访问和属性修饰符:

![image-20200426102227919.png](https://i.loli.net/2020/05/23/uMFYsnlka2qRGOr.png)

### 当前类索引，父类索引与接口索引集合

```java
   	u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
```

需要注意的是：这些索引都是指向常量池中的。

**类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 `java.lang.Object` 之外，所有的 java 类都有父类，因此除了 `java.lang.Object` 外，所有 Java 类的父类索引都不为 0。**

**接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按`implents`(如果这个类本身是接口的话则是`extends`) 后的接口顺序从左到右排列在接口索引集合中。**

### 字段表集合

```java
   u2             fields_count;//Class 文件的字段的个数
   field_info     fields[fields_count];//一个类会可以有个字段
```

字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。

**field info(字段表) 的结构:**

![字段表的结构 ](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)

- **access_flags:** 字段的作用域（`public` ,`private`,`protected`修饰符），是实例变量还是类变量（`static`修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。
- **name_index:** 对常量池的引用，表示的字段的名称；
- **descriptor_index:** 对常量池的引用，表示字段和方法的描述符(如int，long或引用类型)；
- **attributes_count:** 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；
- **attributes[attributes_count]:** 存放具体属性具体内容。

上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。

### 方法表集合

```java
  u2             methods_count;//Class 文件的方法的数量
    method_info    methods[methods_count];//一个类可以有个多个方法Copy to clipboardErrorCopied
```

methods_count 表示方法的数量，而 method_info 表示的方法表。

Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。

**method_info(方法表的) 结构:**

![方法表的结构](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)

**注意：**方法中的java代码经编译器翻译成字节码指令后，存放在方法表集合中一个名为**Code的属性**中

### 属性表集合

```java
 u2             attributes_count;//此类的属性表中的属性数
 attribute_info attributes[attributes_count];//属性表集合
```

在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。

# 7.虚拟机类加载机制

- 虚拟机把描述类得数据从class文件加载到内存中，并对数据进行检验，转换解析和初始化，最终形成可以额被虚拟机直接使用得java类型，这就是虚拟机的类加载机制
- java是在虚拟机加载class文件时进行动态连接的

## 类初始化时机

### 主动引用

虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了**有且只有**下列五种情况必须对类进行初始化（加载、验证、准备需要在此之前开始）

- 遇到 **new、getstatic、putstatic、invokestatic** 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。

- 使用 **java.lang.reflect** 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。

- 当初始化一个类的时候，如果发现其**父类**还没有进行过初始化，则需要先触发其父类的初始化。

  接口初始化时不要求其父接口全部完成初始化。仅在真正使用到父接口（引用父接口中定义的常量）时才会对父接口进行初始化。

- 当虚拟机启动时，用户需要指定一个要执行的**主类**（包含 main () 方法的那个类），虚拟机会先初始化这个主类。

- 当使用 JDK 1.7 的动态语言支持时，如果一个 **java.lang.invoke.MethodHandle** 实例最后的解析结果为 **REF_getStatic, REF_putStatic, REF_invokeStatic** 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

**有且只有**以上5种行为称为对一个类进行主动调用。除此以外所有引用类的方法都不会触发初始化，称为**被动引用**。

### 被动引用

* 通过子类引用父类的**静态**字段，不会导致子类初始化。

```java
System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
```

* 通过数组定义来引用类，不会触发此类的初始化。该过程会对**数组类**进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法（安全性在于该类封装了数组元素的访问方法，越界等情况会抛出异常，而 C++ 直接翻译为对数组指针的移动）。

```java
SuperClass[] sca = new SuperClass[10];
```

* 常量在编译阶段会存入调用类的常量池中（编译阶段**常量传播优化**），本质上并没有直接引用到定义常量的被调用类，而是被转化为调用类对自身常量池的引用，实际调用类的 Class 文件中并没有对被调用类（ConstClass）的符号引用，因此不会触发定义常量的类的初始化。

```java
System.out.println(ConstClass.HELLOWORLD);
```

其他：

* 通过类名获取 Class 对象，不会触发类的初始化
* 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化
* 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作

## 类加载过程

### 加载

加载过程完成以下三件事：

* **通过类的完全限定名称获取定义该类的二进制字节流**

  可控性最强，既可通过系统提供的引导类加载器完成，也可以通过自定义类加载器完成。

* **将该字节流表示的静态存储结构转换为方法区的运行时存储结构**

  存储格式由虚拟机自行定义

* **在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区中该类各种数据的外部访问接口**

  没有明确规定在 Java 堆中存放，对于 HotSpot 虚拟机而言，Class 对象虽然是对象，但是存放在方法区中。

其中二进制字节流可以从以下方式中获取：

* 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
* 从网络中获取，最典型的应用是 Applet。
* 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
* 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。
* 从数据库中读取，SAP Netweaver 等中间件服务器可选择将程序安装到数据库中来完成程序代码在集群间的分发。

加载阶段与连接阶段的部分内容（如部分字节码文件格式验证动作）是**交叉进行**的，加载阶段尚未完成，连接阶段可能已经开始，但是夹在加载阶段之中进行的动作仍然属于连接阶段的内容，即这两个阶段的**开始时间**仍然保持着**固定的先后顺序**。

### 验证(非必要)

**目的：**确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

### 准备

- 准备阶段是为**类变量(被static修饰的变量)**分配内存并设置类变量初始值的过程，这些变量所使用的内存都将在**方法区**中进行分配

- 注意：

  1. 此阶段进行内存分配的只有类变量，没有实例变量，实例变量将会在对象实例初始化时随着对象一起分配在堆中。

  2. 此处的初始值是数据类型的**零值**。

  3. 如果类变量是**常量**，即类字段的字段属性中存在 ConstantValue 属性，那么该常量将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。

     ```java
     public static final int value = 123;
     ```


### 解析

- 将常量池中的符号引用替换为直接引用的过程

其中，解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。

* 符号引用

  以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，其形式在 Java 虚拟机规范的 Class 文件格式中被明确定义，因此各虚拟机能接受的符号引用必须一致。

  符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。

* 直接引用

  可以是指向目标的**指针**、相对偏移量或是一个能间接定位到目标的句柄。

  直接引用与虚拟机实现的内存布局相关，如果存在直接引用，那么引用的目标必定已经在内存中存在。

**发生时间**：

解析阶段发生的具体时间并未规定，可根据需要来判断是在类被加载时就进行解析还是等到符号引用将要被使用前才去解析。

* 对于 invokedynamic 指令，其所对应的引用称为 “动态调用点限定符” ，此处动态的含义即为必须等到程序实际运行到这条指令时解析才能进行。
* 除了动态绑定的指令 invokedynamic 之外，其余可触发解析的指令都是静态的，可在刚刚完成加载阶段还没有开始执行代码时进行。

**重复解析**：

除了动态绑定的指令 invokedynamic 之外，当对同一个符号引用进行多次解析请求时，虚拟机实现可以对第一次解析的结果进行**缓存**，在运行时常量池中记录直接引用并把常量标识为已解析状态。

### 初始化

初始化阶段才真正开始执行类中定义的 Java 程序代码（字节码）。初始化阶段是虚拟机执行**类构造器 \<clinit>() 方法**的过程，**且仅执行一次**。（实例初始化方法为 < init >()）在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

\<clinit>() 是由编译器自动收集类中**所有类变量的赋值动作和静态语句块中的语句**合并产生的，编译器收集的顺序由**语句在源文件中出现的顺序**决定。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成 < clinit \>() 方法。

特别注意的是，**静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问**。例如以下代码：

```java
public class Test {
    static int b;			  // 自动初始化为 0
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
        
        int a = 1;			  // 需要初始化
        System.out.print(a);  // 正常访问
        System.out.print(b);  // 正常访问
    }
    static int i = 1;
}
```

虚拟机会保证在子类的 ＜clinit＞() 方法执行之前，父类的 ＜clinit＞() 方法已经执行完毕，也就意味着**父类中定义的静态语句块的执行要优先于子类**。

在虚拟机中第一个被执行的 ＜clinit＞() 方法的类肯定是 java.lang.Object。

例如以下代码：

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 \<clinit>() 方法。但接口与类不同的是，执行接口的 \<clinit>() 方法不需要先执行父接口的 \<clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 \<clinit>() 方法。

虚拟机会保证一个类的 \<clinit>() 方法在多线程环境下被正确的加锁和同步，**如果多个线程同时初始化一个类，只会有一个线程执行这个类的 \<clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 \<clinit>() 方法完毕**。如果在一个类的 \<clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。

## 类加载器

- 虚拟机设计团队将类加载阶段中的"**通过一个类的全限定名来获取描述此类的二进制字节流**"放到虚拟机的外部去实现，实现这个动作的模块就叫做**类加载器**。

**两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。**这是因为每一个类加载器都拥有一个独立的类名称空间。

这里的相等，包括类的 Class 对象的 equals () 方法、isAssignableFrom () 方法、isInstance () 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。

```java
public class ClassLoaderTest{
	public static void main(String[]args)throws Exception{
		ClassLoader myLoader=new ClassLoader(){
		@Override
		public Class＜?＞loadClass(String name)throws ClassNotFoundException{
			try {
				String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class";
				InputStream is = getClass().getResourceAsStream(fileName);
				if(is == null){
					return super.loadClass(name);
				} byte[]b = new byte[is.available()];
				is.read(b);
				return defineClass(name,b，0，b.length);
				} catch(IOException e) {
					throw new ClassNotFoundException(name);
				}
	        } 
        };
		Object obj = myLoader.loadClass("ClassLoaderTest").newInstance();
		System.out.println(obj.getClass());
		// class ClassLoaderTest
		System.out.println(obj instanceof ClassLoaderTest);
		// false 
    }
}
```

虚拟机中存在了两个 ClassLoaderTest 类，一个是由系统应用程序类加载器加载的，另外一个是由自定义的类加载器加载的，虽然都来自同一个 Class 文件，但依然是两个独立的类，做对象所属类型检查时结果自然为 false 。

### 双亲委派模型

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。

2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。

3. **AppClassLoader(应用程序类加载器)** :面向我们用户的加载器，负责加载当前应用**classpath**下的所有jar包和类。

每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。**当父类加载器为null时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器**。

![ClassLoader](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png)

每个类加载都有一个父类加载器，我们通过下面的程序来验证。

```java
public class ClassLoaderDemo {
    public static void main(String[] args) {
        System.out.println("ClassLodarDemo's ClassLoader is " + ClassLoaderDemo.class.getClassLoader());
        System.out.println("The Parent of ClassLodarDemo's ClassLoader is " + ClassLoaderDemo.class.getClassLoader().getParent());
        System.out.println("The GrandParent of ClassLodarDemo's ClassLoader is " + ClassLoaderDemo.class.getClassLoader().getParent().getParent());
    }
}
```

Output

```
ClassLodarDemo's ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2
The Parent of ClassLodarDemo's ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586
The GrandParent of ClassLodarDemo's ClassLoader is null
```

`AppClassLoader`的父类加载器为`ExtClassLoader` `ExtClassLoader`的父类加载器为null，**null并不代表`ExtClassLoader`没有父类加载器，而是 `BootstrapClassLoader`** 。

#### 向前兼容

**实例：**双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在。

**解决：**JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 **findClass()** 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。

#### 双亲委派模型源码

以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass () 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。**若父加载器为空则默认使用启动类加载器作为父加载器**。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。

```java
public abstract class ClassLoader {
    // 用于委派的父加载器
    private final ClassLoader parent;

    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }

    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // 首先检查请求的类是否已经被加载过了
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 如果父加载器抛出 ClassNotFoundException 
                    // 说明父加载器无法完成加载请求
                }

                if (c == null) {
                    // 在父加载器无法完成加载的时候
                    // 调用本身的 findClass 方法来进行类加载
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
```

#### 双亲委派模型的好处

双亲委派模型保证了Java程序的稳定运行，可以**避免类的重复加载**（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也**保证了 Java 的核心 API 不被篡改**。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

#### 如果我们不想用双亲委派模型怎么办？

为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 `loadClass()` 即可。

# 逃逸分析

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为**方法逃逸**。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为**线程逃逸**。

>-XX:+DoEscapeAnalysis 开启逃逸分析（jdk1.8 默认开启，其它版本未测试）
>-XX:-DoEscapeAnalysis 关闭逃逸分析

方法逃逸的几种方式如下：

```java
public class EscapeTest {
    public static Object obj;
    public void globalVariableEscape() {  // 给全局变量赋值，发生逃逸
        obj = new Object();
    }
    public Object methodEscape() {  // 方法返回值，发生逃逸
        return new Object();
    }
    public void instanceEscape() {  // 实例引用发生逃逸
        test(this); 
    }
}
```

## 处理方案

如果已经确定一个对象不会逃逸到方法或线程之外，则可能为这个对象进行一些高效的优化。

### 1. 栈上分配

把方法中的变量和对象分配到栈上，方法执行完后自动销毁，而不需要垃圾回收的介入，从而提高系统性能。

### 2. 同步消除

线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，无法被其它线程访问到，那该对象的读写就不会存在竞争，对这个变量的同步措施就可以消除掉。单线程中没有锁竞争。

### 3. 标量替换

Java 虚拟机中的原始数据类型（int，long 等数值类型以及 reference 类型等）都不能再进一步分解，它们就可以称为**标量**。相对的，如果一个数据可以继续分解，那它称为聚合量，Java 中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将**可能不创建这个对象**，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化， 可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。




---
title: LFU缓存
date: 2020-06-15 14:34:24
tags: leetcode
categories: leetcode
---

# [460. LFU缓存](https://leetcode-cn.com/problems/lfu-cache/)

**题目描述：**

请你为 **最不经常使用（LFU）缓存**算法设计并实现数据结构。它应该支持以下操作：get 和 put。

get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。
put(key, value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键。

「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 





**算法思想：**

- 由于在访问频度相等时，需要删除的是最久未使用的，所以需要用一个集合把频度相等的元素存在一起，并且要维持其中的访问顺序，所以用LinkedHashSet来存储频度相等的元素。
- 数据域包括四个部分：
  1. 存放key和其对应的node的map：data
  2. 存放访问频度和其对应的元素集合的map：freqMap
  3. 最小的访问频度：minfreq
  4. 最多能有多少元素：maxSize
- get()方法流程如下：
  - 如果data中不包含该元素，则直接返回-1；
  - 否则从data中取出对应的node，同时需要将node的freq++，并存储到新的set中，然后返回value
- put()方法流程如下：
  - 如果data中不包含该元素，则表示需要添加新的节点了，首先判断节点数目是否大于等于maxsize，如果成立，则需要移除节点，然后建立新的node，将其存入data和freqMap中，同时需要更新minfreq为1；
  - 如果包含该元素，则取出对应的node，替换其value值，并且freq++，同时放到新的set中

```
public class LFUCache {

    Map<Integer,Node> data;

    Map<Integer, LinkedHashSet<Node>> freqMap;

    int maxSize;

    int minfreq;

    public LFUCache(int capacity){
        data=new HashMap<>();
        freqMap=new HashMap<>();
        maxSize=capacity;
        minfreq=0;
    }

    public int get(int key) {
        if(!data.containsKey(key)) return -1;
        Node node=data.get(key);
        freqInc(node);
        return node.value;
    }


    public void put(int key, int value) {
        if(data.containsKey(key)){
            Node node = data.get(key);
            node.value=value;
            freqInc(node);
        }else {
            if(data.size()>=maxSize){
                removeNode();
            }
            Node node=new Node(key,value);
            node.freq=1;
            data.put(key,node);
            addNode(node);
        }
    }

	//移除minfreq对应set中的第一个元素
    private void removeNode() {
        LinkedHashSet<Node> set = freqMap.get(minfreq);
        //用迭代器去获取
        Node node = set.iterator().next();
        set.remove(node);
        data.remove(node.key);
    }
	
	//将元素添加到频度为1的set中
    private void addNode(Node node) {
        LinkedHashSet<Node> set = freqMap.get(1);
        if(set==null){
            set=new LinkedHashSet<>();
            freqMap.put(1,set);
        }
        set.add(node);
        minfreq=1;
    }

	//该方法完成频度++，并且放到下一个set中
    private void freqInc(Node node) {
        int key=node.key;
        int freq=node.freq;
        LinkedHashSet<Node> set = freqMap.get(freq);
        set.remove(node);
        //如果该频度为最小频道，并且删除以后就没有了，那么更新minfreq
        if(freq==minfreq&&set.isEmpty())
            minfreq++;
        node.freq++;
        LinkedHashSet<Node> newSet = freqMap.get(freq+1);
        if(newSet==null){
            newSet=new LinkedHashSet<>();
            //如果取出来为null，需要将newSet存进去
            freqMap.put(freq+1,newSet);
        }
        newSet.add(node);
    }
	
	//Node中包含key，value和freq
    static class Node{
        int key;
        int value;
        int freq;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
```

---
title: Linux
date: 2020-05-08 11:27:45
tags:
		- Linux
categories:
		- Linux
---

# 1.初识操作系统

- **操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；**
- **操作系统本质上是运行在计算机上的软件程序 ；**
- **为用户提供一个与系统交互的操作界面 ；**
- **操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。**

# 2.Linux基础指令

## 2.1 目录切换指令

- **`cd usr`：** 切换到该目录下usr目录
- **`cd ..（或cd../）`：** 切换到上一层目录
- **`cd /`：** 切换到系统根目录
- **`cd ~`：** **切换到用户主目录**
- **`cd -`：** 切换到上一个操作所在目录

## 2.2 目录的操作命令(增删改查)

1. **`mkdir 目录名称`：** 增加目录

2. **`ls或者ll`**（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息

3. **`find 目录 参数`：** 寻找目录（查）

   示例：

   - 列出当前目录及子目录下所有文件和文件夹: `find .`
   - 在`/home`目录下查找以.txt结尾的文件名:`find /home -name "*.txt"`
   - 同上，但忽略大小写: `find /home -iname "*.txt"`
   - 当前目录及子目录下查找所有以.txt和.pdf结尾的文件:`find . \( -name "*.txt" -o -name "*.pdf" \)`或`find . -name "*.txt" -o -name "*.pdf"`

4. **`mv 目录名称 新目录名称`：** **修改目录的名称**（改）

   注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。

5. **`mv 目录名称 目录的新位置`：** 移动目录的位置---剪切（改）

   注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。

6. **`cp -r 目录名称 目录拷贝的目标位置`：** 拷贝目录（改），**-r代表递归拷贝**

   注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归

7. **`rm [-rf] 目录`:** 删除目录（删）

   注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用`rm -rf` 目录/文件/压缩包

## 2.3 文件的操作指令(增删改查)

1. **`touch 文件名称`:** 文件的创建（增）

2. **`cat/more/less/tail 文件名称`** 文件的查看（查）

   - **`cat`：** 查看显示文件内容
   - **`more`：** 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看
   - **`less`：** 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看
   - **`tail-10` ：** 查看文件的后10行，Ctrl+C结束

   注意：命令 tail -f 文件 可以对某个文件进行**动态监控**。

3. **`vim 文件`：** 修改文件的内容（改）

   vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。

   **在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：**

   vim 文件------>进入文件----->命令模式------>按**i**进入编辑模式----->编辑文件 ------->按Esc进入底行模式----->输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）

4. **`rm -rf 文件`：** 删除文件（删）

## 2.4 压缩文件的指令

### 打包并压缩文件

Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。

而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：**`tar -zcvf 打包压缩后的文件名 要打包压缩的文件`** 其中：

z：调用gzip压缩命令进行压缩

c：打包文件

v：显示运行过程

f：指定文件名

比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：**`tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt`或：`tar -zcvf test.tar.gz       /test/`**

### 解压压缩包

命令：tar [-xvf] 压缩文件

其中：**-x：代表解压**

示例：

1 将/test下的test.tar.gz解压到当前目录下可以使用命令：**`tar -xvf test.tar.gz`**

2 将/test下的test.tar.gz解压到根目录/usr下:**`tar -xvf test.tar.gz -C /usr`**（- C代表指定解压的位置）

## 2.5 Linux权限指令

用户分为三种：**文件拥有者**、**群组**以及**其它人**，对不同的用户有不同的文件权限。

使用 ll 查看一个文件时，会显示一个文件的信息，例如 `drwxr-xr-x 3 root root 17 May 6 00:14 .config`，对这个信息的解释如下：

- drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段
- 3：链接数
- root：文件拥有者
- root：**所属群组**
- 17：**文件大小**
- May 6 00:14：文件最后被修改的时间
- .config：文件名

常见的文件类型及其含义有：

- d：目录
- -：**文件**
- l：链接文件

9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。

可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。

```html
# chmod [-R] xyz dirname/filename
```

示例：将 .bashrc 文件的权限修改为 -rwxr-xr--。

```html
# chmod 754 .bashrc
```

也可以使用符号来设定权限。

```html
# chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限
```

示例：为 .bashrc 文件的所有用户添加写权限。

```html
# chmod a+w .bashrc
```

## 2.6 其他常用指令

- **`pwd`：** 显示当前所在位置

- `sudo + 其他命令`：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。

- **`grep 要搜索的字符串 要搜索的文件 --color`：** 搜索命令，--color代表高亮显示

- **`ps -ef`/`ps -aux`：** 这两个命令都是查看当前系统正在运行**进程**，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**`ps aux|grep redis`** （查看包括redis字符串的进程），也可使用 `pgrep redis -a`。

  注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。

- **`kill -9 进程的pid`：** 杀死进程（-9 表示强制终止。）

  先用ps查找进程，然后用kill杀掉

- `free`：查看内存信息

- `top`：查看各个进程的CPU占比

  **补充：top指令中的CPU占用率是把所有核数加起来，例如4核，则最高CPU利用率为400%**

- `netstat`:  显示各种网络相关信息

  `netstat -t: `显示TCP连接信息

- `df -h`:查找磁盘所使用的情况

- `awk:`AWK 是一种处理文本文件的语言

  示例：

  1. `awk '{print $1,$4}' log.txt`默认分割符为空格或TAB，然后输出文本中的1、4项
  2. `awk -F, '{print $1,$2}'   log.txt`指定分隔符为`，`

# 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为**孤儿进程**。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。



# 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait () 或 waitpid () 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait () 或 waitpid ()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为**僵尸进程**。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。---
title: MySQL
date: 2020-05-07 11:44:30
tags:
		-面试
		- MySQL
categories:
		-MySQL
---

# 数据库系统原理

## 事务

数据库事务是访问并可能操作各种数据项的一个数据库**操作序列**，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。

## ACID

### 1.原子性(Atomicity)

事务被视为**不可分割的最小单元**，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用**回滚日志（Undo Log）**来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

### 2.一致性(Consistency)

数据库从一个一致性状态到另一个一致性状态。**在一致性状态下，所有事务对同一个数据的读取结果都是相同的。**

### 3.隔离性(Isolation)

两个事务之间彼此隔离，不相互影响。

### 4.持久性(Durability)

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

**系统发生奔溃可以用重做日志（Redo Log）**进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

## 并发一致性问题

### 丢失修改

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png)

### 脏读

T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据(读到了其他事务中未提交的数据)。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png)

### 不可重复读

T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同(读到的是其他事务已经提交的结果)。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png)

### 幻读

T1 读取某个**范围**的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png)



------

产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

## 封锁

### 封锁粒度

MySQL 中提供了两种封锁粒度：**行级锁**以及**表级锁**。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

### 封锁类型

#### 1.读写锁

- 互斥锁（Exclusive），简写为 **X 锁**，又称写锁。
- 共享锁（Shared），简写为 **S 锁**，又称读锁。

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

#### 2.意向锁

使用意向锁（Intention Locks）可以更容易地**支持多粒度封锁**。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

各种锁的兼容关系如下：

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png)

- 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；

## 隔离级别

### 读未提交（READ UNCOMMITTED）

事务中的修改，即使没有提交，对其它事务也是可见的。

### 读已提交（READ COMMITTED）

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

### 可重复读（REPEATABLE READ）

保证在同一个事务中多次读取同一数据的结果是一样的。

### 可串行化（SERIALIZABLE）

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

------

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png)

InnoDB中使用next-key Locking解决了幻读问题，使得在**repeatable read**下也可以解决幻读。

## 多版本并发控制(MVCC)

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，**用于实现读已提交和可重复读这两种隔离级别。**而读未提交隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### 基本思想

在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而**读操作去读旧版本快照**，没有互斥关系，这一点和 CopyOnWrite 类似。

**在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。**

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

### 版本号

- 系统版本号 SYS_ID：是一个递增的数字，**每开始一个新的事务，系统版本号就会自动递增。**
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

### 版本链

对于使用`InnoDB`存储引擎的表来说，它的聚簇索引记录中都包含两个必要的**隐藏列**（`row_id`并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含`row_id`列）：

- `trx_id`：每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给`trx_id`隐藏列。
- `roll_pointer`：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

### Undo日志

MVCC 的多版本指的是多个版本的快照，快照存储在 **Undo 日志**中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。

例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

因为没有使用 `START TRANSACTION` 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png)

INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。

### ReadView

核心问题就是：**需要判断一下版本链中的哪个版本是当前事务可见的。**

MVCC 维护了一个 ReadView 结构，主要**包含了当前系统未提交的事务列表 TRX_IDs** {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png)



在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。
- TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 提交读：**如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。**否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。

在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。

#### READ COMMITED---每次读取数据前都要生成一个ReadView

使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。

#### REPEATABLE READ ---在第一次读取数据时生成一个ReadView

对于使用`REPEATABLE READ`隔离级别的事务来说，只会在第一次执行查询语句时生成一个`ReadView`，之后的查询就会复用这个ReadView，解决了不可重复读的问题。

#### 参考

> https://juejin.im/post/5c9b1b7df265da60e21c0b57

### 快照读和当前读

#### 1.快照读

**MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作(一致性非锁定读)**。

```sql
SELECT * FROM table ...;
```

#### 2.当前读

MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行**加锁**操作，从而读取最新的数据。可以看到 **MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作**。

```sql
INSERT;
UPDATE;
DELETE;
```

在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。

```sql
SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
```

## Next-Key Locking

Next-Key Locking 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

**MVCC 不能解决幻影读问题**，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

### Record Lock

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

### Gap Lock

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

### Next-key Lock

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

如果索引具有**唯一属性**，那么Next-Key Lock会降级为Record Lock

## 关系数据库设计理论

### 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为**主属性的集合**。

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是**部分函数依赖**，否则就是完全函数依赖。

对于 A->B，B->C，则 A->C 是一个**传递函数依赖**。

### 范式

#### 第一范式(1NF)

属性不可分。

#### 第二范式(2NF)

在1NF的基础上消除非主属性对主属性的部分函数依赖。

#### 第三范式(3NF)

在2NF的基础上消除非主属性对主属性的传递函数依赖。



# SQL语法

## 创建表

```
CREATE TABLE mytable (
  # int 类型，不为空，自增
  id INT NOT NULL AUTO_INCREMENT,
  # int 类型，不可为空，默认值为 1，不为空
  col1 INT NOT NULL DEFAULT 1,
  # 变长字符串类型，最长为 45 个字符，可以为空
  col2 VARCHAR(45) NULL,
  # 日期类型，可为空
  col3 DATE NULL,
  # 设置主键为 id
  PRIMARY KEY (`id`));
```

## 查询

### DISTINCT

**相同值只会出现一次**。它作用于所有列，也就是说所有列的值都相同才算相同。

```sql
SELECT DISTINCT col1, col2	FROM mytable;
```

### LIMIT

限制返回的行数。可以有**两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。**

返回前 5 行：

```sql
SELECT * FROM mytable LIMIT 5;

SELECT * FROM mytable LIMIT 0, 5;
```

返回第 3 ~ 5 行：

```sql
SELECT * FROM mytable LIMIT 2, 3;
```

## 排序

- **ASC** ：升序（默认）
- **DESC** ：降序

可以按多个列进行排序，并且为每个列指定不同的排序方式：

```sql
SELECT * FROM mytable ORDER BY col1 DESC, col2 ASC;
```

## 分组

**把具有相同的数据值的行放在同一组中。**

可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。

指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。

```sql
SELECT col, COUNT(*) AS num 
FROM mytable 
GROUP BY col;
```

GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。

```sql
SELECT col, COUNT(*) AS num	
FROM mytable 
GROUP BY col 
ORDER BY num;
```

**WHERE 过滤行，HAVING 过滤分组**，**行过滤应当先于分组过滤。**

```sql
SELECT col, COUNT(*) AS num
FROM mytable
WHERE col > 2
GROUP BY col
HAVING num >= 2;
```

分组规定：

- GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；
- 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；
- **NULL 的行会单独分为一组**；
- 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。

## 连接

连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。

连接可以替换子查询，并且比子查询的效率一般会更快。

可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。

### 内连接

内连接又称等值连接，使用 INNER JOIN 关键字。

```sql
SELECT A.value, B.value
FROM tablea AS A INNER JOIN tableb AS B
ON A.key = B.key;
```

**可以不明确使用 INNER JOIN**，而使用普通查询并在 **WHERE** 中将两个表中要连接的列用等值方法连接起来。

```sql
SELECT A.value, B.value
FROM tablea AS A, tableb AS B
WHERE A.key = B.key;
```

### 外连接

**外连接保留了没有关联的那些行**。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。

检索所有顾客的订单信息，包括还没有订单信息的顾客。

```sql
SELECT Customers.cust_id, Orders.order_num
FROM Customers LEFT OUTER JOIN Orders
ON Customers.cust_id = Orders.cust_id;
```

customers 表：

| cust_id | cust_name |
| ------- | --------- |
| 1       | a         |
| 2       | b         |
| 3       | c         |

orders 表：

| order_id | cust_id |
| -------- | ------- |
| 1        | 1       |
| 2        | 1       |
| 3        | 3       |
| 4        | 3       |

结果：

| cust_id | cust_name | order_id |
| ------- | --------- | -------- |
| 1       | a         | 1        |
| 1       | a         | 2        |
| 3       | c         | 3        |
| 3       | c         | 4        |
| 2       | b         | Null     |

# MySQL

## 索引

### B+树原理

**在B+树中只有叶节点保存数据，其他非叶节点保存的都是索引。**

**而B树只是一个平衡多叉树，数据不一定保存在叶节点中。**

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key~i~ 和 key~i+1~，且不为 null，则该指针指向节点的所有 key 大于等于 key~i~ 且小于等于 key~i+1~。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png)

#### 操作

进行查找操作时，首先在**根节点进行二分查找**，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

#### 与红黑树的比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

**（一）更少的查找次数**

平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。

红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

**（二）利用磁盘预读特性**

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

## MySQL索引

**索引是在存储引擎层实现的**，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

### B+Tree索引

是大多数 MySQL 存储引擎的默认索引类型。

因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

因为 B+ Tree 的有序性，所以除了用于查找，还可以用于**排序和分组**。

可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。**主索引的叶子节点 data 域记录着完整的数据记录**，这种索引方式被称为**聚簇索引**。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png)



**辅助索引的叶子节点的 data 域记录着主键的值**，因此在使用辅助索引进行查找时，需要先查找到主键值，**然后再到主索引中进行查找**。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png)

### 哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“**自适应哈希索引**”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

### 空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

## 索引优化

### 独立的列

在进行查询时，**索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。**

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

### 多列索引

在需要使用多个列作为条件进行查询时，**使用多列索引比使用多个单列索引性能更好**。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

### 索引列的顺序

**让选择性最强的索引列放在前面。**

**索引的选择性是指：不重复的索引值和记录总数的比值**。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;

   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

### 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

前缀长度的选取需要根据索引选择性来确定。

### 覆盖索引

索引包含所有需要查询的字段的值。

- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 索引的优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器**避免进行排序和分组**，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- **将随机 I/O 变为顺序 I/O**（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

## 查询性能优化

### 使用Explain进行分析

Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

比较重要的字段有：

- **select_type** : 查询类型，有简单查询、联合查询、子查询等
- **type**：连接类型
- **key** : 使用的索引
- **rows** : 扫描的行数

其中type类型有：

1. **system：**表只有一行，这是一个`const` type 的特殊情况。

2. **const：**最多只有一行匹配。当使用**主键或者唯一索引**的时候，就是`const`类型

3. **eq_ref：**主键索引(primary key)或者非空唯一索引(unique not null)等值连接查询

4. **ref：**非主键非唯一索引等值连接查询

5. **range：**范围扫描

6. **index：**索引树扫描。index类型，需要**扫描全部的索引**，它仅比全表扫描快一点。例如：

   `select count(1) from user`

7. **ALL：**全表扫描

## 存储引擎

### InnoDB

是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

**不支持事务。**

**不支持行级锁，只能对整张表加锁**，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

### 比较

- 事务：**InnoDB 是事务型**的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

## 数据类型

#### 整型

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

#### 浮点数

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

#### 字符串

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在**执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作**。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。

##### CHAR和VARCHAR的比较

- CHAR占据固定空间的大小，VARCHAR是变长的。
- VARCHAR中null值不占据空间，这是通过行记录首部的变长字符串大小实现的；CHARnull值需要占据空间。

#### 时间和日期

MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。

##### DATETIME

能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。

它与时区无关。

默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。

##### TIMESTAMP

和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。

它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。

默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。

应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。

## 切分

### 水平切分

水平切分又称为 **Sharding**，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg)

###  垂直切分

垂直切分是将一张表**按列切分**成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg)

### sharding策略

- 哈希取模：hash(key) % N；
- 范围：可以是 ID 范围也可以是时间范围；
- 映射表：使用单独的一个数据库来存储映射关系。

## 复制

### 主从复制

主要涉及三个线程：**binlog 线程**、**I/O 线程**和 **SQL 线程**。

- **binlog 线程** ：负责将主服务器上的数据更改写入**二进制日志**（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的**中继日志**（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png)

### 读写分离

**主服务器处理写操作以及实时性要求比较高的读操作**，而**从服务器处理读操作**。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用**代理方式**来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png)



# 补充

## 如果保证缓存和数据库的双写一致性

数据库和缓存更新，就容易出现**缓存(Redis)和数据库（MySQL）间的数据一致性问题**。

不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：

1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。

2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。

因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。

### **第一种方案：延时双删**

在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。

伪代码如下

```
public void write( String key, Object data )
{
	redis.delKey( key );
	db.updateData( data );
	Thread.sleep( 500 );
	redis.delKey( key );
}复制代码
```

**具体的步骤就是：**

1. 先删除缓存
2. 再写数据库
3. 休眠500毫秒
4. 再次删除缓存

**那么，这个500毫秒怎么确定的，具体该休眠多久呢？**

需要评估自己的项目的**读数据业务逻辑的耗时**。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。

**该方案的弊端**

结合双删策略+缓存超时设置，这样**最差的情况就是在超时时间内数据存在不一致**，而且又增加了写请求的耗时。



### **第二种方案：异步更新缓存(基于binlog的同步机制)**

**1.技术整体思路：**

MySQL binlog增量订阅消费+消息队列+增量数据更新到redis

- **读Redis**：热数据基本都在Redis
- **写MySQL**:增删改都是操作MySQL
- **更新Redis数据**：MySQ的数据操作binlog，来更新到Redis

**2.Redis更新**

**(1）数据操作主要分为两大块：**

- 一个是全量(将全部数据一次写入到redis)
- 一个是增量（实时更新）

这里说的是增量,指的是mysql的update、insert、delate变更数据。

**(2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。**

这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。

其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。

这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。

当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!

## 一条SQL语句如何在mysql中执行

### MySQL基础架构

**连接器：** 身份认证和权限相关(登录 MySQL 的时候)。

**分析器:**   分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。

**优化器：** 按照 MySQL 认为最优的方案去执行。

**执行器:** 执行语句，然后从存储引擎返回数据。

![img](https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TzWuuhjqx58LnibzsWR0Pf8x9nVefLe59Q8SBNcZGIGn1VGNFfNUVQyOwQksDoyvIOUJicgzU6ICVLg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

简单来说 MySQL 主要分为 Server 层和存储引擎层：

- **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
- **存储引擎**： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**

### 查询语句执行流程

先经过连接器去验证是否有权限；

然后通过分析器去看这条语句是对哪个表进行操作，执行什么操作，检查语法是否有问题；

通过优化器去选择一条mysql认为最优的方案

最后交给执行器去执行。

### 更新语句执行流程

前面流程和查询语句一样，最后该需要记录日志，二进制日志和redo log

## 联合索引

首先，表T1有字段a,b,c,d,e，其中a是主键，除e为varchar其余为int类型，并创建了一个联合索引**idx_t1_bcd(b,c,d)**，然后b、c、d三列作为联合索引，在B+树上的结构正如上图所示。联合索引的所有索引列都出现在索引数上，并依次比较三列的大小。上图树高只有两层不容易理解，下面是假设的表数据以及我对其联合索引在B+树上的结构图的改进。PS：基于InnoDB存储引擎。



![bcd联合索引在B+树上的结构图](https://user-gold-cdn.xitu.io/2020/2/27/170867cb6af0a72d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

​                       bcd联合索引在B+树上的结构图



![img](https://user-gold-cdn.xitu.io/2020/2/27/170867dfaa4ca5f6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



​                                                      T1表

### 联合索引的查找方式

当我们的SQL语言可以应用到索引的时候，比如 select * from T1 where b = 12 and c = 14 and d = 3; 也就是T1表中a列为4的这条记录。存储引擎首先从根节点（一般常驻内存）开始查找，第一个索引的第一个索引列为1,12大于1，第二个索引的第一个索引列为56,12小于56，于是从这俩索引的中间读到下一个节点的磁盘文件地址，从磁盘上Load这个节点，通常伴随一次磁盘IO，然后在内存里去查找。当Load叶子节点的第二个节点时又是一次磁盘IO，比较第一个元素，b=12,c=14,d=3完全符合，于是找到该索引下的data元素即ID值，再从主键索引树上找到最终数据。



![img](https://user-gold-cdn.xitu.io/2020/2/27/170867e984dd5594?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 最左前缀匹配原则

之所以会有最左前缀匹配原则和联合索引的索引构建方式及存储结构是有关系的。

首先我们创建的idx_t1_bcd(b,c,d)索引，相当于创建了(b)、（b、c）（b、c、d）三个索引，看完下面你就知道为什么相当于创建了三个索引。

我们看，**联合索引是首先使用多列索引的第一列构建的索引树**，用上面idx_t1_bcd(b,c,d)的例子就是**优先使用b列构建，当b列值相等时再以c列排序，若c列的值也相等则以d列排序**。我们可以取出索引树的叶子节点看一下。

![img](https://user-gold-cdn.xitu.io/2020/2/27/170867eb79a354d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



索引的**第一列也就是b列可以说是从左到右单调递增**的，但我们看c列和d列并没有这个特性，它们只能在**b列值相等的情况下这个小范围内递增**，如第一叶子节点的第1、2个元素和第二个叶子节点的后三个元素。  由于联合索引是上述那样的索引构建方式及存储结构，所以联合索引只能从多列索引的第一列开始查找。所以如果你的查找条件不包含b列如（c,d）、(c）、(d)是无法应用缓存的，以及跨列也是无法完全用到索引如(b,d)，只会用到b列索引。

## SQL注入攻击

### 概念

服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。

### 攻击原理

例如一个网站登录验证的 SQL 查询代码为：

```sql
strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');"
```

如果填入以下内容：

```sql
userName = "1' OR '1'='1";
passWord = "1' OR '1'='1";
```

那么 SQL 查询字符串为：

```
strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');"
```

此时无需验证通过就能执行以下查询：

```sql
strSQL = "SELECT * FROM users;"
```

### 防范手段

#### 1.使用参数化查询

Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。

```java
PreparedStatement stmt = connection.prepareStatement("SELECT * FROM users WHERE userid=? AND password=?");
stmt.setString(1, userid);
stmt.setString(2, password);
ResultSet rs = stmt.executeQuery();
```

#### 2.单引号转换

将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。---
title: mysql索引优化总结
date: 2020-05-11 11:08:18
tags:	
		- mysql
categories:
		- mysql
---

# 为什么要使用索引

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2. 可以**大大加快数据的检索速度**（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
3. **帮助服务器避免排序和临时表**。
4. **将随机IO变为顺序IO**
5. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

# 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？

1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

# 使用索引的注意事项

1. 经常需要搜索的列上，可以加快搜索的速度；
2. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
3. 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
4. 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
5. 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
6. 避免 where 子句中对宇段施加函数，这会造成无法命中索引。
7. 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
8. 将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描
9. 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用
10. 在使用 limit offset 查询缓慢时，可以借助索引来提高性能

# Mysql索引主要使用的两种数据结构

## 哈希索引

对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择B+Tree索引。

## B+Tree索引

# MyISAM和InnoDB实现B+Tree索引的区别

## MyISAM

B+Tree叶节点的data域存放的是**数据记录的地址**。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。

## InnoDB

其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其**表数据文件本身就是按B+Tree组织的一个索引结构**，树的叶节点**data域保存了完整的数据记录**。这个索引的key是数据表的**主键**，因此InnoDB表数据文件本身就是主索引。这被称为“**聚簇索引**（或聚集索引）”，而其余的索引都作为辅助索引，**辅助索引的data域存储相应记录主键的值而不是地址**，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

# 覆盖索引介绍

## 什么是覆盖索引

**如果一个索引包含（或者说覆盖）所有需要查询的字段的值**，我们就称之为“覆盖索引”。我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

## 覆盖索引实例

现在我创建了索引(username,age)，我们执行下面的 sql 语句

```sql
select username , age from user where username = 'Java' and age = 22
```

在查询数据的时候：要查询出的列在叶子节点都存在！所以，就不用回表。



# 最左匹配原则

MySQL中的索引可以以一定顺序引用多列，这种索引叫作**联合索引**。如User表的name和city加联合索引就是(name,city)，而**最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到**。如下：

```
select * from user where name=xx and city=xx ; ／／可以命中索引
select * from user where name=xx ; // 可以命中索引
select * from user where city=xx ; // 无法命中索引            
```

这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。

# Mysql如何为表字段添加索引

1.添加PRIMARY KEY（主键索引）

```
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
```

2.添加UNIQUE(唯一索引)

```
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
```

3.添加INDEX(普通索引)

```
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
```

4.添加FULLTEXT(全文索引)

```
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
```

5.添加多列索引

```
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

# 什么是索引

**索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和Hash。**

索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

# 为什么要用索引？索引的优缺点分析

## 索引的优点

**可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的。 ** 另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

## 索引的缺点

1. **创建索引和维护索引需要耗费许多时间**：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。
2. **占用物理存储空间** ：索引需要使用物理文件存储，也会耗费一定空间。

# B树和B+树的区别

- **B树的所有节点既存放 键(key) 也存放 数据(data)**;而B+树只有叶子节点存放 key 和 data，其他内节点只存放key。
- B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
- B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

![B+树](https://snailclimb.gitee.io/javaguide/media/pictures/database/B+%E6%A0%91.png)

# Hash索引和B+索引的区别

**Hash索引定位快**

Hash索引指的就是Hash表，最大的优点就是能够在很短的时间内，根据Hash函数定位到数据所在的位置，这是B+树所不能比的。

**Hash冲突问题**

知道HashMap或HashTable的同学，相信都知道它们最大的缺点就是Hash冲突了。不过对于数据库来说这还不算最大的缺点。

**Hash索引不支持顺序和范围查询(Hash索引不支持顺序和范围查询是它最大的缺点。**）

试想一种情况:

```text
SELECT * FROM tb1 WHERE id < 500;
```

B+树是有序的，在这种范围查询中，优势非常大，直接遍历比500小的叶子节点就够了。而Hash索引是根据hash算法来定位的，难不成还要把 1 - 499的数据，每个都进行一次hash计算来定位吗?这就是Hash最大的缺点了。

---
title: Netty
date: 2020-05-25 10:05:04
tags: Netty
categories: Netty
---

# 1.Netty是什么

1. Netty 是一个 **基于 NIO** 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。
2. 它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。
3. **支持多种协议** 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。

# 2.Netty的特点是什么

- 高并发：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的网络通信框架，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。
- 传输快：Netty 的传输依赖于**零拷贝**特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。
- 封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。

# 3.Netty的优势有哪些

- 使用简单：封装了 NIO 的很多细节，使用更简单。
- 功能强大：预置了多种编解码功能，支持多种主流协议。
- 定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。
- 性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。
- 稳定：Netty 修复了已经发现的所有 NIO 的 bug，让开发人员可以专注于业务本身。
- 社区活跃：Netty 是活跃的开源项目，版本迭代周期短，bug 修复速度快。

# 4.Netty的应用场景

典型的应用有：阿里分布式服务框架 Dubbo，默认使用 Netty 作为基础通信组件，还有 RocketMQ 也是使用 Netty 作为通讯的基础。

# 5.Netty高性能表现在哪些方面

- IO 线程模型：同步非阻塞，用最少的资源做更多的事。
- 内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。
- 内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。
- 串形化处理读写：避免使用锁带来的性能开销。
- 高性能序列化协议：支持 protobuf 等高性能序列化协议。

# 6.BIO，AIO，NIO的区别

**BIO**：**一个连接一个线程**，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。
伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。

**NIO**：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

**AIO**：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，

BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的。

NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。

在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。

# 7.NIO的组成

**Buffer**：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的

flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式

clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。

rewind方法 ： 重绕此缓冲区，将position置为0

DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。

**Channel**：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！

**Selector**可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的

原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。

NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件

# 8.Netty的线程模型

Netty通过**Reactor模型**基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中**boss线程池的线程负责处理请求的accept事件**，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。

单线程模型：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。

多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。

主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；

# 9.TCP粘包和拆包的原因及解决办法

TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。

TCP粘包/分包的原因：

应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；

进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包
以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。

**解决方法：**

**1.使用 Netty 自带的解码器**

- **`LineBasedFrameDecoder`** : 发送端发送数据包的时候，每个数据包之间以换行符作为分隔，`LineBasedFrameDecoder` 的工作原理是它依次遍历 `ByteBuf` 中的可读字节，判断是否有换行符，然后进行相应的截取。
- **`DelimiterBasedFrameDecoder`** : 可以自定义分隔符解码器，**`LineBasedFrameDecoder`** 实际上是一种特殊的 `DelimiterBasedFrameDecoder` 解码器。
- **`FixedLengthFrameDecoder`**: 固定长度解码器，它能够按照指定的长度对消息进行相应的拆包。
- **`LengthFieldBasedFrameDecoder`**：

![image-20200619085705224](C:\Users\extra\AppData\Roaming\Typora\typora-user-images\image-20200619085705224.png)

# 10.什么是Netty的零拷贝

Netty 的零拷贝主要包含三个方面：

1. 使用 Netty 提供的 `CompositeByteBuf` 类, 可以将多个`ByteBuf` 合并为一个逻辑上的 `ByteBuf`, 避免了各个 `ByteBuf` 之间的拷贝。
2. `ByteBuf` 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 `ByteBuf`, 避免了内存的拷贝。
3. 通过 `FileRegion` 包装的`FileChannel.tranferTo` 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 `Channel`, 避免了传统通过循环 write 方式导致的内存拷贝问题.

# 11.Netty的核心组件有哪些？分别有什么作用？

## 1.Channel

`Channel` 接口是 Netty 对网络操作抽象类，它除了包括基本的 I/O 操作，如 `bind()`、`connect()`、`read()`、`write()` 等。

比较常用的`Channel`接口实现类是`NioServerSocketChannel`（服务端）和`NioSocketChannel`（客户端），这两个 `Channel` 可以和 BIO 编程模型中的`ServerSocket`以及`Socket`两个概念对应上。Netty 的 `Channel` 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。

## 2.EventLoop

**`EventLoop` 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。**

那 `Channel` 和 `EventLoop` 直接有啥联系呢？

`Channel` 为 Netty 网络操作(读写等操作)抽象类，`EventLoop` 负责处理注册到其上的`Channel` 处理 I/O 操作，两者配合参与 I/O 操作。

## 3.ChannelFuture

Netty 是异步非阻塞的，所有的 I/O 操作都为异步的。

因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 `ChannelFuture` 接口的 `addListener()` 方法注册一个 `ChannelFutureListener`，当操作执行成功或者失败时，监听就会自动触发返回结果。

并且，你还可以通过`ChannelFuture` 的 `channel()` 方法获取关联的`Channel`

```
public interface ChannelFuture extends Future<Void> {    
	Channel channel();   
    
	ChannelFuture addListener(GenericFutureListener<? extends Future<? super Void>> var1);     ......    
	
	ChannelFuture sync() throws InterruptedException;}
```

另外，我们还可以通过 `ChannelFuture` 接口的 `sync()`方法让异步的操作变成同步的。

## 4.ChannelHandler 和 ChannelPipeline

下面这段代码使用过 Netty 的小伙伴应该不会陌生，我们指定了序列化编解码器以及自定义的 `ChannelHandler` 处理消息。

```
         b.group(eventLoopGroup)
          .handler(new ChannelInitializer<SocketChannel>() {
               @Override
               protected void initChannel(SocketChannel ch) {
                    ch.pipeline().addLast(new NettyKryoDecoder(kryoSerializer, RpcResponse.class));
                     ch.pipeline().addLast(new NettyKryoEncoder(kryoSerializer, RpcRequest.class));
                     ch.pipeline().addLast(new KryoClientHandler());
                    }
                });
```

`ChannelHandler` 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。

`ChannelPipeline` 为 `ChannelHandler` 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 `Channel` 被创建时，它会被自动地分配到它专属的 `ChannelPipeline`。

我们可以在 `ChannelPipeline` 上通过 `addLast()` 方法添加一个或者多个`ChannelHandler` ，因为一个数据或者事件可能会被多个 Handler 处理。当一个 `ChannelHandler` 处理完之后就将数据交给下一个 `ChannelHandler` 。

# 12.EventLoopGroup


![img](https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TyHkpkttoicqYcbytibtU38aaqML3uQghC5WA6X8PNZ9h9YiaQDZpwREFEMIaqHkeUERAibAW9d0hmJ5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

`EventLoopGroup` 包含多个 `EventLoop`（每一个 `EventLoop` 通常内部包含一个线程），上面我们已经说了 **`EventLoop` 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理**。

并且 `EventLoop` 处理的 I/O 事件都将在它专有的 `Thread` 上被处理，即 `Thread` 和 `EventLoop` 属于 1 : 1 的关系，从而保证线程安全。

上图是一个服务端对 `EventLoopGroup` 使用的大致模块图，其中 `Boss EventloopGroup` 用于接收连接，`Worker EventloopGroup` 用于具体的处理（消息的读写以及其他逻辑处理）。

从上图可以看出：当客户端通过 `connect` 方法连接服务端时，`bossGroup` 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 `workerGroup` 来处理，然后 `workerGroup` 负责处理其 IO 相关操作。

# 13.Bootstrap 和 ServerBootstrap 了解么？

1. `Bootstrap` 通常使用 `connet()` 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，`Bootstrap` 也可以通过 `bind()` 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。
2. `ServerBootstrap`通常使用 `bind()` 方法绑定本地的端口上，然后等待客户端的连接。
3. `Bootstrap` 只需要配置一个线程组— `EventLoopGroup` ,而 `ServerBootstrap`需要配置两个线程组— `EventLoopGroup` ，一个用于接收连接，一个用于具体的处理。

# 14.NioEventLoopGroup 默认的构造函数会起多少线程？

**`CPU核心数*2`**

# 15.Netty长连接，心跳机制

所谓，短连接说的就是 server 端 与 client 端建立连接之后，读写完成之后就关闭掉连接，如果下一次再要互相发送消息，就要重新连接。短连接的有点很明显，就是管理和实现都比较简单，缺点也很明显，每一次的读写都要建立连接必然会带来大量网络资源的消耗，并且连接的建立也需要耗费时间。

长连接说的就是 client 向 server 双方建立连接之后，即使 client 与 server 完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的可以省去较多的 TCP 建立和关闭的操作，降低对网络资源的依赖，节约时间。对于频繁请求资源的客户来说，非常适用长连接。

## 为什么要使用心跳机制？

在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，它们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入 **心跳机制** 。

心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 PING-PONG 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性.

TCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：`SO_KEEPALIVE`。但是，TCP 协议层面的长连接灵活性不够。所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 `IdleStateHandler` 。

# 16. 为什么还需要应用层keepalive

![image-20200619093216169](C:\Users\extra\AppData\Roaming\Typora\typora-user-images\image-20200619093216169.png)

# 17.JDK NIO BUG

- 正常情况下，`selector.select()` 操作是阻塞的，只有被监听的 `fd` 有读写操作时，才被唤醒
- 但是，在这个 `bug` 中，没有任何 `fd` 有读写请求，但是 `select()` 操作依旧被唤醒
- 很显然，这种情况下，`selectedKeys()` 返回的是个空数组
- 然后按照逻辑执行到 `while(true)` 处，循环执行，导致死循环。

Netty 解决方案：

```java
long currentTimeNanos = System.nanoTime();
for (;;) {
    // 1.定时任务截止事时间快到了，中断本次轮询
    //...
    // 2.轮询过程中发现有任务加入，中断本次轮询
    //...
    // 3.阻塞式select操作
    selector.select(timeoutMillis);
    // 4.解决jdk的nio bug
    long time = System.nanoTime();
    if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {
        selectCnt = 1;
    } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&
            selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {

        rebuildSelector();
        selector = this.selector;
        selector.selectNow();
        selectCnt = 1;
        break;
    }
    currentTimeNanos = time;
    //...
 }
```

`netty` 会在每次进行 `selector.select(timeoutMillis)` 之前记录一下开始时间 `currentTimeNanos` ，在 `select` 之后记录一下结束时间，**判断 `select` 操作是否至少持续了 `timeoutMillis` 秒**。如果持续的时间大于等于 `timeoutMillis` ，说明就是一次有效的轮询，重置 `selectCnt` 标志，否则，表明该阻塞方法并没有阻塞这么长时间，可能触发了 `jdk` 的空轮询 `bug` ，当空轮询的次数超过一个阀值的时候，默认是 `512` ，就开始重建 `selector`。

# 18.Netty心跳机制

## 核心Handler —— IdleStateHandler

在 `Netty` 中, 实现心跳机制的关键是 `IdleStateHandler`, 那么这个 `Handler` 如何使用呢? 先看下它的构造器：



```cpp
public IdleStateHandler(int readerIdleTimeSeconds, int writerIdleTimeSeconds, int allIdleTimeSeconds) {
    this((long)readerIdleTimeSeconds, (long)writerIdleTimeSeconds, (long)allIdleTimeSeconds, TimeUnit.SECONDS);
}
```

这里解释下三个参数的含义：

- readerIdleTimeSeconds: 读超时. 即当在指定的时间间隔内没有从 `Channel` 读取到数据时, 会触发一个 `READER_IDLE` 的 `IdleStateEvent` 事件.
- writerIdleTimeSeconds: 写超时. 即当在指定的时间间隔内没有数据写入到 `Channel` 时, 会触发一个 `WRITER_IDLE` 的 `IdleStateEvent` 事件.
- allIdleTimeSeconds: 读/写超时. 即当在指定的时间间隔内没有读或写操作时, 会触发一个 `ALL_IDLE` 的 `IdleStateEvent` 事件.

**源码剖析：**

初步地看下IdleStateHandler源码，先看下IdleStateHandler中的channelRead方法：

![img](https://img-blog.csdn.net/20160512174210997?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

请注意254行代码其实表示该方法只是进行了透传，不做任何业务逻辑处理，让channelPipe中的下一个handler处理channelRead方法，但是记录了一下这里的调用时间---
title: Redis
date: 2020-05-20 21:02:25
tags: Redis
categories: Redis
---

# 一.概述

Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。

键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。

Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。

# 二.数据类型

| 数据类型 | 可以存储的值           | 操作                                                         |
| -------- | ---------------------- | ------------------------------------------------------------ |
| STRING   | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 |
| LIST     | 列表                   | 从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素 |
| SET      | 无序集合               | 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 |
| HASH     | 包含键值对的无序散列表 | 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 |
| ZSET     | 有序集合               | 添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名 |

## STRING

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png)



```html
> set hello world
OK
> get hello
"world"
> del hello
(integer) 1
> get hello
(nil)
```

## LIST

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png)



```html
> rpush list-key item
(integer) 1
> rpush list-key item2
(integer) 2
> rpush list-key item
(integer) 3

> lrange list-key 0 -1
1) "item"
2) "item2"
3) "item"

> lindex list-key 1
"item2"

> lpop list-key
"item"

> lrange list-key 0 -1
1) "item2"
2) "item"
```

## SET

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png)



```html
> sadd set-key item
(integer) 1
> sadd set-key item2
(integer) 1
> sadd set-key item3
(integer) 1
> sadd set-key item
(integer) 0

> smembers set-key
1) "item"
2) "item2"
3) "item3"

> sismember set-key item4
(integer) 0
> sismember set-key item
(integer) 1

> srem set-key item2
(integer) 1
> srem set-key item2
(integer) 0

> smembers set-key
1) "item"
2) "item3"
```

## HASH

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7bd202a7-93d4-4f3a-a878-af68ae25539a.png)



```html
> hset hash-key sub-key1 value1
(integer) 1
> hset hash-key sub-key2 value2
(integer) 1
> hset hash-key sub-key1 value1
(integer) 0

> hgetall hash-key
1) "sub-key1"
2) "value1"
3) "sub-key2"
4) "value2"

> hdel hash-key sub-key2
(integer) 1
> hdel hash-key sub-key2
(integer) 0

> hget hash-key sub-key1
"value1"

> hgetall hash-key
1) "sub-key1"
2) "value1"
```

## ZSET

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png)



```html
> zadd zset-key 728 member1
(integer) 1
> zadd zset-key 982 member0
(integer) 1
> zadd zset-key 982 member0
(integer) 0

> zrange zset-key 0 -1 withscores
1) "member1"
2) "728"
3) "member0"
4) "982"

> zrangebyscore zset-key 0 800 withscores
1) "member1"
2) "728"

> zrem zset-key member1
(integer) 1
> zrem zset-key member1
(integer) 0

> zrange zset-key 0 -1 withscores
1) "member0"
2) "982"
```

# 三.数据结构

## 字典

dictht 是一个散列表结构，使用**拉链法**解决哈希冲突。

```c
/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```

Redis 的字典 dict 中包含**两个哈希表 dictht**，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。

```c
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;
```

rehash 操作不是一次性完成，而是采用**渐进方式**，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。

渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。

**在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。**

采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。

## 跳表

是有序集合的底层实现之一。

跳跃表是基于多指针有序链表实现的，可以看成**多个有序链表**。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png)

在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ea37ee2-c224-4c79-b895-e131c6805c40.png)



与红黑树等平衡树相比，跳跃表具有以下优点：

- **插入速度非常快速，因为不需要进行旋转等操作来维护平衡性**；
- 更容易实现；
- 支持无锁操作。

# 四.使用场景

## 计数器

可以对 String 进行自增自减运算，从而实现计数器功能。

Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

## 缓存

将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

## 查找表

例如 DNS 记录就很适合使用 Redis 进行存储。

查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

## 消息队列

List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息

不过最好使用 Kafka、RabbitMQ 等消息中间件。

## 会话缓存

可以使用 Redis 来统一存储多台应用服务器的会话信息。

当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

## 分布式锁实现

在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

## 其他

Set 可以实现交集、并集等操作，从而实现共同好友等功能。

ZSet 可以实现有序性操作，从而实现排行榜等功能。

# 五.Redis与Memcached

两者都是非关系型内存键值数据库，主要有以下不同：

## 数据类型

Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。

## 数据持久化

Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。

## 分布式

Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。

Redis Cluster 实现了分布式的支持。

## 内存管理机制

- 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。
- Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。

# 六.键的过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

# 七.数据淘汰策略

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

Redis 具体有 6 种淘汰策略：

| 策略            | 描述                                                 |
| --------------- | ---------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| volatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰     |
| volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰           |
| allkeys-lru     | 从所有数据集中挑选最近最少使用的数据淘汰             |
| allkeys-random  | 从所有数据集中任意选择数据进行淘汰                   |
| noeviction      | 禁止驱逐数据                                         |

作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。

使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。

# 八.持久化

Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。

## RDB持久化

将某个时间点的所有数据都存放到硬盘上。

可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。

如果系统发生故障，将会丢失最后一次创建**快照**之后的数据。

如果数据量很大，保存快照的时间会很长。

## AOF持久化

将写命令追加到 AOF 文件（Append Only File）的末尾。

使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：

| 选项     | 同步频率                 |
| -------- | ------------------------ |
| always   | 每个写命令都同步         |
| everysec | 每秒同步一次             |
| no       | 让操作系统来决定何时同步 |

- always 选项会严重减低服务器的性能；
- everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
- no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。

随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 **AOF 重写**的特性，能够去除 AOF 文件中的冗余写命令。

# 九.事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis 最简单的事务实现方式是使用 **MULTI** 和 **EXEC** 命令将事务操作包围起来。

# 十.复制

通过使用 **slaveof host port** 命令来让一个服务器成为另一个服务器的从服务器。

一个从服务器只能有一个主服务器，并且不支持主主复制。

## 连接过程

1. 主服务器创建**快照文件**，发送给从服务器，并**在发送期间使用缓冲区记录执行的写命令**。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
2. 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；
3. 主服务器**每执行一次写命令**，就向从服务器发送相同的写命令。

## 主从链

随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png)

# 十一.哨兵

Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。

# 十二.分片

分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。

假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。

- 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。
- 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。

根据执行分片的位置，可以分为三种分片方式：

- 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
- 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
- 服务器分片：Redis Cluster。

# 十三.集群

在redis cluster集群架构中，可以由N个redis master node组成，每个master node都可以挂载多个slave node。
可以自动将数据进行分片，每个master上放一部分数据。

**实现原理：**Redis 集群中内置了 **16384**个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 **0-16383** 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。

## 哈希一致性算法

一致性Hash算法将整个哈希值空间组织成一个**虚拟的圆环**，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：

![img](https://pic1.zhimg.com/80/v2-fd44ab71c834f3fe458a6f76f3997f98_720w.jpg)

下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：

![img](https://pic1.zhimg.com/80/v2-509993a49d447b378273e455a095de3c_720w.jpg)

接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，**从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器**！

# 十四.一个简单的论坛系统分析

该论坛系统功能如下：

- 可以发布文章；
- 可以对文章进行点赞；
- 在首页可以按文章的发布时间或者文章的点赞数进行排序显示。

## 文章信息

文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。

Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 **HASH 的键名为 article:92617**，其中 article 为命名空间，ID 为 92617。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c54de21-e2ff-402e-bc42-4037de1c1592.png)

## 点赞功能

当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立**文章的已投票用户集合**来进行记录。

为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/485fdf34-ccf8-4185-97c6-17374ee719a0.png)

## 对文章进行排序

为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png)

---
title: Redis常见问题总结
date: 2020-05-06 20:05:58
tags:
		- java
		- 面试
categories:
		- Redis
---

# Redis简介

简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在**内存**中的，所以读写速度非常快，因此 redis 被广泛应用于**缓存**方向。另外，redis 也经常用来做**分布式锁**。redis 提供了多种数据类型来支持不同的业务场景。

# 为什么用Redis/为什么用缓存

主要从“高性能”和“高并发”这两点来看待这个问题。

**高性能：**

假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg)

**高并发：**

直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg)

# 为什么用Redis而不用map做缓存

缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，**缓存不具有一致性**。

使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，**缓存具有一致性**。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

# Redis的线程模型

redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是**单线程**的，所以 redis 才叫做单线程的模型。它采用 **IO 多路复用机制同时监听多个 socket**，根据 socket 上的事件来选择对应的事件处理器进行处理。

## IO多路复用

基础知识：**文件描述符fd**：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向**内核为每一个进程所维护的该进程打开文件的记录表**。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

> 参考视频 ：https://www.bilibili.com/video/BV1qJ411w7du?from=search&seid=11427655416887836287

IO多路复用的基本原理就是select，poll，epoll这个function会**不断的轮询**所负责的所有socket，当某个socket有数据到达了，就通知用户进程。

### Select

```
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过**遍历fdset，来找到就绪的描述符**。

**缺点：**

1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 
2. 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
3. select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为**1024**

### Poll

```
int poll (struct pollfd *fds, unsigned int nfds, int timeout);
```

不同与select使用三个位图来表示三个fdset的方式，poll使用一个 **pollfd**的指针实现。

```
struct pollfd {
    int fd; /* file descriptor */
    short events; /* requested events to watch */
    short revents; /* returned events witnessed */
};
```

pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要**轮询pollfd来获取就绪的描述符**。

**缺点：**从上面看，select和poll都需要在返回后，通过**遍历文件描述符**来获取已经就绪的socket。

### epoll

```
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

epoll_ctl () 用于**向内核注册新的描述符或者是改变某个文件描述符的状态。进程调用 epoll_wait () 便可以得到事件完成的描述符。**

**epoll的优点：**

1. **没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）**；

2. **效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；**
   **即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。**

3. **epoll通过内核和用户空间共享一块内存来实现的。**

#### 工作模式

epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。

##### LT 模式

当 epoll_wait () 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait () 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

##### ET 模式

和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait () 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读 / 阻塞写操作把处理多个文件描述符的任务饿死。

# Redis和memcached的区别

1. **redis支持更丰富的数据类型（支持更复杂的应用场景）**：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。
2. **Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。**
3. **集群模式**：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.
4. **Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。**

# Redis的常见数据结构以及使用场景分析

## 1.String

> **常用命令:** set,get,decr,incr,mget 等。

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是**数字**。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。

## 2.Hash

> **常用命令：** hget,hset,hgetall 等。

hash 是一个 string 类型的 field 和 value 的**映射表**，**hash 特别适合用于存储对象**，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。

## 3.List

> **常用命令:** lpush,rpush,lpop,rpop,lrange等

list 就是**链表**，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。

Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现**分页查询**，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。

## 4.Set

> **常用命令：** sadd,spop,smembers,sunion 等

set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以**自动排重**的。

当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 **set 轻易实现交集、并集、差集**的操作。

比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如**共同关注、共同粉丝、共同喜好**等功能。这个过程也就是求交集的过程，具体命令如下：

`sinterstore key1 key2 key3     将交集存在key1内`

## 5.Sorted Set

> **常用命令：** zadd,zrange,zrem,zcard等

和set相比，sorted set增加了一个**权重参数score**，使得集合中的元素能够**按score进行有序排列**。

**举例：** 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。

# Redis设置过期时间

Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。

我们 set key 的时候，都可以给一个 **expire time**，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。

如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？

**定期删除+惰性删除。**

通过名字大概就能猜出这两个删除方式的意思了。

- **定期删除**：redis默认是每隔 100ms 就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- **惰性删除** ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ **redis 内存淘汰机制。**

# Redis内存淘汰机制

**Redis提供6种数据淘汰策略：**

1. **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

**4.0后增加了两种：**

7. **volatile-lfu**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰

8. **allkeys-lfu**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

# Redis持久化机制

很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。

Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。**Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）**。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。

**快照（snapshotting）持久化（RDB）**

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。

快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：

```conf
save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```

**AOF（append-only file）持久化**

与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：

```conf
appendonly yes
```

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。

在Redis的配置文件中存在**三种不同的 AOF 持久化方式**，它们分别是：

```conf
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```

为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

**Redis 4.0 对于持久化机制的优化**

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，**AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头**。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

**补充内容：AOF 重写**

AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。

AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。

在执行 **BGREWRITEAOF** 命令时，Redis 服务器会维护一个 **AOF 重写缓冲区**，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，**服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾**，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作

# Redis事务

Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，**并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求**，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有一致性（Consistency）和隔离性（Isolation），Redis不一定具有原子性和持久性。

> 不满足原子性的原因是Redis没有回滚操作。
>
> Redis在执行事务命令的时候，**在命令入队的时候， Redis 就会检测事务的命令是否正确**，如果不正确则会产生错误。无论之前和之后的命令都会被事务所回滚，就变为什么都没有执行(类似于编译报错)。
>
> 当命令格式正确，而因为操作数据结构引起的错误 ，则该命令执行出现错误，而其之前和之后的命令都会被正常执行。这点和数据库很不一样，这是需注意的地方(类似于执行报错)。

# 缓存穿透

**什么是缓存穿透？**

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，**导致请求直接到了数据库上**，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

**正常缓存处理流程：**

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E6%AD%A3%E5%B8%B8%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-redis.png)

**缓存穿透情况处理流程：**

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-redis.png)

**有哪些解决办法？**

最基本的就是首先做好**参数校验**，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。

**1）缓存无效 key** : 如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间，具体命令如下：`SET key value EX 10086`。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。

**2）布隆过滤器：**布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。具体是这样做的：**把所有可能存在的请求的值都存放在布隆过滤器中**，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。总结一下就是下面这张图

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-redis.png)

## 布隆过滤器

布隆过滤器是由位数组和一系列哈希函数两部分组成的数据结构。

![6Wfc1rkLolHUgdn.png](https://i.loli.net/2020/05/07/6Wfc1rkLolHUgdn.png)

位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。



**当一个元素加入布隆过滤器中的时候，会进行如下操作：**

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

例如：

![wBm3Ihrn59sGxkH.png](https://i.loli.net/2020/05/07/wBm3Ihrn59sGxkH.png)



**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

# 缓存雪崩

**什么是缓存雪崩？**

简介：**缓存同一时间大面积的失效**，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

**解决：**

可以在原有的失效时间基础上**增加一个随机值**，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

# 如何保证缓存与数据库双写时的一致性

你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？

一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况

串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

**一般是采取先更新数据库，再删除缓存的策略。**

# Sentinel(哨兵)

Sentinel（哨兵）可以监听集群中的服务器，并**在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。**

# 主从复制

通过使用 **slaveof** host port 命令来让一个服务器成为另一个服务器的从服务器。

一个从服务器只能有一个主服务器，并且不支持主主复制。

## 连接过程

1. 主服务器创建**快照文件**，发送给从服务器，并在发送期间使用**缓冲区**记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
2. 从服务器丢弃所有旧数据，**载入主服务器发来的快照文件**，之后从服务器开始接受主服务器发来的写命令；
3. 主服务器**每执行一次写命令**，就向从服务器发送相同的写命令。

---
title: socket
date: 2020-05-20 15:51:36
tags: IO
categories: socket
---

# 一.I/O模型

一个输入操作通常包括两个阶段：

- 等待数据准备好
- 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

Unix 有五种 I/O 模型：

- 阻塞式 I/O
- 非阻塞式 I/O
- I/O 复用（select 和 poll）
- 信号驱动式 I/O（SIGIO）
- 异步 I/O（AIO）

## 阻塞式I/O

应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。

应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。

下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。

```c
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
```

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928416812_4.png)

## 非阻塞式I/O

应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。

由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929000361_5.png)

## I/O复用

使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。

它**可以让单个进程具有处理多个 I/O 事件的能力**。又被称为 Event Driven I/O，即事件驱动 I/O。

如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929444818_6.png)

## 信号驱动I/O

应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。

相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929553651_7.png)

## 异步I/O

应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492930243286_8.png)

# 二.I/O复用

select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。

## select

```c
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。

- fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。
- timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。
- 成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。

```c
fd_set fd_in, fd_out;
struct timeval tv;

// Reset the sets
FD_ZERO( &fd_in );
FD_ZERO( &fd_out );

// Monitor sock1 for input events
FD_SET( sock1, &fd_in );

// Monitor sock2 for output events
FD_SET( sock2, &fd_out );

// Find out which socket has the largest numeric value as select requires it
int largest_sock = sock1 > sock2 ? sock1 : sock2;

// Wait up to 10 seconds
tv.tv_sec = 10;
tv.tv_usec = 0;

// Call the select
int ret = select( largest_sock + 1, &fd_in, &fd_out, NULL, &tv );

// Check if select actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    if ( FD_ISSET( sock1, &fd_in ) )
        // input event on sock1

    if ( FD_ISSET( sock2, &fd_out ) )
        // output event on sock2
}
```

## poll

```c
int poll(struct pollfd *fds, unsigned int nfds, int timeout);
```

poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。

poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：

```c
struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };


// The structure for two events
struct pollfd fds[2];

// Monitor sock1 for input
fds[0].fd = sock1;
fds[0].events = POLLIN;

// Monitor sock2 for output
fds[1].fd = sock2;
fds[1].events = POLLOUT;

// Wait 10 seconds
int ret = poll( &fds, 2, 10000 );
// Check if poll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // If we detect the event, zero it out so we can reuse the structure
    if ( fds[0].revents & POLLIN )
        fds[0].revents = 0;
        // input event on sock1

    if ( fds[1].revents & POLLOUT )
        fds[1].revents = 0;
        // output event on sock2
}
```

## 比较

### 1.功能

select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。

- select 会修改描述符，而 poll 不会；
- select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；
- poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。
- 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。

### 2.速度

select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。

### 3.可移植性

几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。

## epoll

```
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。

从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。

epoll 仅适用于 Linux OS。

epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。

epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。

```
// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.
// The function argument is ignored (it was not before, but now it is), so put your favorite number here
int pollingfd = epoll_create( 0xCAFE );

if ( pollingfd < 0 )
 // report error

// Initialize the epoll structure in case more members are added in future
struct epoll_event ev = { 0 };

// Associate the connection class instance with the event. You can associate anything
// you want, epoll does not use this information. We store a connection class pointer, pConnection1
ev.data.ptr = pConnection1;

// Monitor for input, and do not automatically rearm the descriptor after the event
ev.events = EPOLLIN | EPOLLONESHOT;
// Add the descriptor into the monitoring list. We can do it even if another thread is
// waiting in epoll_wait - the descriptor will be properly added
if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1->getSocket(), &ev ) != 0 )
    // report error

// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)
struct epoll_event pevents[ 20 ];

// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array
int ready = epoll_wait( pollingfd, pevents, 20, 10000 );
// Check if epoll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // Check if any events detected
    for ( int i = 0; i < ret; i++ )
    {
        if ( pevents[i].events & EPOLLIN )
        {
            // Get back our connection pointer
            Connection * c = (Connection*) pevents[i].data.ptr;
            c->handleReadEvent();
         }
    }
}
```

## 工作模式

epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。

### 1.LT模式

当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，**进程可以不立即处理该事件**，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

### 2.ET模式

和 LT 模式不同的是，通知之后**进程必须立即处理事件**，下次再调用 epoll_wait() 时不会再得到事件到达的通知。

很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

---
title: Spring源码
date: 2020-05-10 10:31:08
tags: Spring
categories: Spring
---

# SpringIOC

## SpringBean初始化过程

初始化所有的singleton beans是在finishBeanFactoryInitialization(beanFactory)方法中，进一步是在其中的的preInstantiateSingletons()方法中，在里面如果是普通的bean(非抽象，非懒加载，非FactoryBean)，就会直接调用getBean(beanName)方法，这是一个空壳方法，然后会调用doGetBean()方法，主要代码如下：

```
public void preInstantiateSingletons() throws BeansException {
   // this.beanDefinitionNames 保存了所有的 beanNames
   List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);

   // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作
   for (String beanName : beanNames) {
         // 处理 FactoryBean
         if (isFactoryBean(beanName)) {
            // FactoryBean 的话，在 beanName 前面加上 ‘&’ 符号。再调用getBean()
            final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);
         }  
         else {
            // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了
            getBean(beanName);
         }
      }
   }

```

总结preInstantiateSingletons()方法，首先会遍历一个装着BeanDenifinitionName的集合，然后依次调用getBean(beanName)方法，如果这个beanName是FactoryBean，则会在其前面加上一个&符号后再调用getBean()方法。

```
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
		//对beanName进行处理，一是处理别名，二是处理&符号的FactoryBean
        String beanName = this.transformedBeanName(name);
        //第一次调用getSingleton()方法，这个方法检查对象是否已经放在单例池中，可以解决循环依赖
        Object sharedInstance = this.getSingleton(beanName);
        //返回值
        Object bean;
        if (sharedInstance != null && args == null) {
        //如果是普通Bean，则直接返回；如果是BeanFactory则会返回它创建的哪个对象。
        bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
        } else {
            try {
                RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
                this.checkMergedBeanDefinition(mbd, beanName, args);
                //先初始化依赖的所有 Bean，这个很好理解。
         		// 注意，这里的依赖指的是 depends-on 中定义的依赖
                String[] dependsOn = mbd.getDependsOn();
                String[] var11;
                if (dependsOn != null) {
                    var11 = dependsOn;
                    int var12 = dependsOn.length;

                    for(int var13 = 0; var13 < var12; ++var13) {
                        String dep = var11[var13];
                        //检查是不是有循环依赖，这里是depends-on的循环依赖
                        if (this.isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }
						//注册一下依赖关系
                        this.registerDependentBean(dep, beanName);
                        //先初始化被依赖的项
                        this.getBean(dep);
                    }
                }
				//如果是singleton的，创建实例
                if (mbd.isSingleton()) {
                    sharedInstance = this.getSingleton(beanName, () -> {
                        try {
                        	//执行创建bean
                            return this.createBean(beanName, mbd, args);
                        } catch (BeansException var5) {
                            this.destroySingleton(beanName);
                            throw var5;
                        }
                    });
                    //如果是普通Bean，则直接返回；如果是BeanFactory则会返回它创建的哪个对象。
                    bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                //如果是 prototype scope 的，创建 prototype 的实例
                } else if (mbd.isPrototype()) {
                    var11 = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        //执行创建Bean
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }
					//如果是普通Bean，则直接返回；如果是BeanFactory则会返回它创建的哪个对象。
                    bean = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                } 
         //返回bean
         return bean;
     
    }
```

总结一下doGetBean()，首先会调用transformedBeanName()方法转换别名或者是FactoryBean的name，然后会调用getSingleton()方法从单例池中获取，没有获取到的话，就会调用getSingleton()中重载的有ObjectFactory参数的方法，其中传入一个拉姆达表达式重写getObject()方法为调用createBean()方法，这个方法里面会创建bean。

插一下`getSingleton(String beanName, ObjectFactory<?> singletonFactory)`方法：

```
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
        synchronized(this.singletonObjects) {
            Object singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
            	//这个方法会把当前的beanName添加到一个singletonsCurrentlyInCreation的set				   中，这个set用于解决循环依赖
                this.beforeSingletonCreation(beanName);
                try {
                	//调用ObjectFactory的getObject()方法
                    singletonObject = singletonFactory.getObject();
                    newSingleton = true;
                } 
                	//将beanName从singletonsCurrentlyInCreation中移除
                    this.afterSingletonCreation(beanName);
                }

                if (newSingleton) {
                	//将对象加入单例池，并将其从singletonFactories和earlySingletonObjects						中移除
                    this.addSingleton(beanName, singletonObject);
                }
            }

            return singletonObject;
        }
    }
```

总结一下getSingleton(ObjectFactory)方法：首先会调用beforeSingletonCreation(beanName)方法，将beanName加入到singletonsCurrentlyInCreation的set中，然后调用传进来的ObjectFactory的getObject()方法，这个方法过后，对象就会创建成功，后面就是从singletonsCurrentlyInCreation移除beanName，并且将当前的对象加入单例池中，同时将其从singletonFactories和earlySingletonObjects中移除。

下面是createBean()方法：

```
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
       
        RootBeanDefinition mbdToUse = mbd;
        //确保 BeanDefinition 中的 Class 被加载
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }
        
        Object beanInstance;
        try {
        	//让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var11) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var11);
        }

        try {
        	//创建bean
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            return beanInstance;
    }
```

createBean()方法会调用doCreateBean()方法来创建bean。

下面是doCreateBean()方法：

```
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        BeanWrapper instanceWrapper = null;
        if (mbd.isSingleton()) {
            instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
        }

        if (instanceWrapper == null) {
        	//这里实例化Bean
            instanceWrapper = this.createBeanInstance(beanName, mbd, args);
        }

        Object bean = instanceWrapper.getWrappedInstance();
        Class<?> beanType = instanceWrapper.getWrappedClass();
        if (beanType != NullBean.class) {
            mbd.resolvedTargetType = beanType;
        }
		
		//解决循环依赖，将beanName对应的ObjectFactory放入到singletonFactories中
        boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
        if (earlySingletonExposure) {
            this.addSingletonFactory(beanName, () -> {
                return this.getEarlyBeanReference(beanName, mbd, bean);
            });
        }

        Object exposedObject = bean;

        try {
        	//属性装配
            this.populateBean(beanName, mbd, instanceWrapper);
            //处理bean初始化完成后的各种回调
            exposedObject = this.initializeBean(beanName, exposedObject, mbd);
        } 
        return exposedObject;
    }
```

总结一下doCreateBean()方法：其首先会实例化Bean，然后判断当前是否支持循环依赖，如果支持循环依赖就把beanName对应的ObjectFactory放到singletonFactories中，然后进行属性装配，最后处理各种回调。

然后是实例化Bean的createBeanInstance()方法：

```
protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
        Class<?> beanClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        //如果不是第一次创建，比如第二次创建 prototype bean。
   		// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化
        boolean resolved = false;
        boolean autowireNecessary = false;
        if (args == null) {
               synchronized(mbd.constructorArgumentLock) {
                     if (mbd.resolvedConstructorOrFactoryMethod != null) {
                           resolved = true;
                           autowireNecessary = mbd.constructorArgumentsResolved;
                        }
                    }
                }

         if (resolved) {
             return autowireNecessary ? this.autowireConstructor(beanName, mbd, (Constructor[])null, (Object[])null) : this.instantiateBean(beanName, mbd);
         } else {
         	//判断是否有有参构造函数，然后判断调用有参构造还是无参构造
             Constructor<?>[] ctors = this.determineConstructorsFromBeanPostProcessors(beanClass, beanName);
         	 return ctors == null && mbd.getResolvedAutowireMode() != 3 && !mbd.hasConstructorArgumentValues() && ObjectUtils.isEmpty(args) ? this.instantiateBean(beanName, mbd) : this.autowireConstructor(beanName, mbd, ctors, args);
          }
       }
    }
}
```

上面的方法就是实例化的过程。

属性注入的populateBean()方法：

```
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
        if (bw == null) {
            boolean continueWithPropertyPopulation = true;
            if (continueWithPropertyPopulation) {
                PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : null;
                if (mbd.getResolvedAutowireMode() == 1 || mbd.getResolvedAutowireMode() == 2) {
                    MutablePropertyValues newPvs = new MutablePropertyValues((PropertyValues)pvs);
                    if (mbd.getResolvedAutowireMode() == 1) {
                    	//通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依							赖关系
                        this.autowireByName(beanName, mbd, bw, newPvs);
                    }

                    if (mbd.getResolvedAutowireMode() == 2) {
                    	//通过类型装配
                        this.autowireByType(beanName, mbd, bw, newPvs);
                    }

                    pvs = newPvs;
                }

                if (pvs != null) {
                	//设置 bean 实例的属性值
                    this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs);
                }

            }
        }
    
```

处理回调的initializeBean()方法：

```
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
    //如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调
        this.invokeAwareMethods(beanName, bean);
        Object wrappedBean = bean;
        if (mbd == null || !mbd.isSynthetic()) {
       	    //BeanPostProcessor 的 postProcessBeforeInitialization 回调
            wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName);
        }

        try {
        //处理 bean 中定义的 init-method，
        // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法
            this.invokeInitMethods(beanName, wrappedBean, mbd);
        } catch (Throwable var6) {
            throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, "Invocation of init method failed", var6);
        }

        if (mbd == null || !mbd.isSynthetic()) {
        //BeanPostProcessor 的 postProcessAfterInitialization 回调
   		wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
        }

        return wrappedBean;
    }
```

可以发现BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method

# FactoryBean和BeanFactory的区别

**BeanFactory**是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口。

**FactoryBean**首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。

**一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用`getObject()`返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上'`&`'符号。**

- getObject('name')返回工厂中的实例
- getObject('&name')返回工厂本身的实例

# Spring循环依赖

Spring中默认**单例**是支持循环依赖的。

解决循环依赖的主要代码在getSingleton(beanName)方法中：

```
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		//首先会从单例池中获取
        Object singletonObject = this.singletonObjects.get(beanName);
        //如果没有获取到，并且当前对象正在创建中
        if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
            synchronized(this.singletonObjects) {
            	//尝试直接从三级缓存中拿
                singletonObject = this.earlySingletonObjects.get(beanName);
                //没有拿到则会从二级缓存中拿到对应的ObjectFactory，并调用其中的getObject()方法				获取到对象。
                if (singletonObject == null && allowEarlyReference) {
                    ObjectFactory<?> singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);
                    if (singletonFactory != null) {
                        singletonObject = singletonFactory.getObject();
                        //获取到之后将其加入到三级缓存中，并将其从二级缓存中移除。
                        this.earlySingletonObjects.put(beanName, singletonObject);
                        this.singletonFactories.remove(beanName);
                    }
                }
            }
        }

        return singletonObject;
    }
```

有一个三级缓存的结构：

1. singletonObjects：单例池
2. singletonFactory：存放ObjectFactory类型的工厂对象
3. earlySingletonObjects：主要存放的是还未完成属性注入的bean



`isSingletonCurrentlyInCreation(beanName)`会判断singletonsCurrentlyInCreation表示的set集合中是否包含当前的beanName。



# 总结

## 面试题：是否看过Spring的源码，讲一下IOC的流程

对refresh()方法中的finishBeanFactoryInitialization()比较了解，里面会调用preInstantiateSingletons()，这个方法里面会获取到一个装着beanName的List集合，然后遍历这个集合，依次调用getBean(beanName)方法，这是个空方法，会调用doGetBean()方法，doGetBean()方法里面首先会转换beanName，例如转换别名或者FactoryBean对应的前面加的&符号去掉，然后会调用getSingleton()方法，会尝试从单例池中获取，也可以解决循环依赖的问题，(后面到属性注入的时候，再退回来讲，假设现在是A，B两个类，然后相互依赖，现在首先加载A)，这次不会获取到，然后会调用getSingleton()方法中有ObjectFactory参数的重载方法，传入的ObjectFactory是一个拉姆达表达式，用一个createBean()方法来覆盖getObject()方法，进入getSingleton()方法后，首先会将beanName加入到一个singletonsCurrentlyInCreation的set集合中，也是用来解决循环依赖，然后会调用ObjectFactory的getObject()方法，也就会调用createBean()方法，在这个方法里面首先会把bean通过反射实例化出来，然后判断是否运行循环依赖，允许的话就把它对应的ObjectFactory加入到singletonFactories的map集合中，然后下一步就是属性注入，按上面的案例。会注入B，但是B还没有实例化，就会先调用getbean()方法去获取B，流程也是一样，也会先调用getSingleton()方法，这个时候还是获取不到的，然后会走到属性注入，同样去注入A，也会调用getBean()方法去获取A，先调用getSingleton()方法，这个方法里面，首先会尝试从singletonObjects也就是单例池中获取，获取不到，就会判断beanName是否在singletonsCurrentlyInCreation的set集合中，如果在就会尝试从earlySingletonObjects中获取，也获取不到，然后就会从singletonFactories中获取对应的ObjectFacory，调用getObject()方法就会获取到bean，然后将其加入到earlySingletonObjects中，并从singletonFactories中移除。



![image-20200514102601370.png](https://i.loli.net/2020/05/14/65ZnRUdOLbDyeVA.png)

# 1.什么是Spring框架

Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。

我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。

Spring 官网列出的 Spring 的 6 个特征:

- **核心技术** ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。
- **测试** ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。
- **数据访问** ：事务，DAO支持，JDBC，ORM，编组XML。
- **Web支持** : Spring MVC和Spring WebFlux Web框架。
- **集成** ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。
- **语言** ：Kotlin，Groovy，动态语言。

# 2.列举一些重要的Spring模块

图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。

![Spring主要模块](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Spring%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97.png)

- **Spring Core：** 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。
- **Spring Aspects** ： 该模块为与AspectJ的集成提供支持。
- **Spring AOP** ：提供了面向切面的编程实现。
- **Spring JDBC** : Java数据库连接。
- **Spring JMS** ：Java消息服务。
- **Spring ORM** : 用于支持Hibernate等ORM工具。
- **Spring Web** : 为创建Web应用程序提供支持。
- **Spring Test** : 提供了对 JUnit 和 TestNG 测试的支持。

# 3.@RestController VS @Controller

**`Controller` 返回一个页面**

单独使用 `@Controller` 不加 `@ResponseBody`的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。

![SpringMVC 传统工作流程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringMVC%E4%BC%A0%E7%BB%9F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

**`@RestController` 返回JSON 或 XML 形式数据**

但`@RestController`**只返回对象**，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。

![SpringMVC+RestController](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringMVCRestController.png)

**`@Controller +@ResponseBody` 返回JSON 或 XML 形式数据**

如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用`@Controller` 并结合`@ResponseBody`注解，也就是说`@Controller` +`@ResponseBody`= `@RestController`（Spring 4 之后新加的注解）。

> `@ResponseBody` 注解的作用是将 `Controller` 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。

![Spring3.xMVC RESTfulWeb服务工作流程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/Spring3.xMVCRESTfulWeb%E6%9C%8D%E5%8A%A1%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

# 4.Spring IOC&AOP

## 4.1 谈谈自己对SpringIOC和AOP的理解

### IOC

IoC（Inverse of Control:控制反转）是一种**设计思想**，就是 **将原本在程序中手动创建对象的控制权，交由Spring框架来管理。** IoC 在其他语言中也有应用，并非 Spring 特有。 **IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。**

将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 **IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。** 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。

**Spring IoC的初始化过程：**

![Spring IoC的初始化过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringIOC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png)

### AOP

**AOP： 面向切面编程**，可以在不改变原有业务逻辑的基础上，加上一些**横切逻辑代码**，例如：事务控制，权限控制。

AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来**，便于**减少系统的重复代码**，**降低模块间的耦合度**，并**有利于未来的可拓展性和可维护性**。

**Spring AOP就是基于动态代理的**，如果要代理的对象，实现了某个接口，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用**Cglib** ，这时候Spring AOP会使用 **Cglib** 生成一个被代理对象的子类来作为代理，如下图所示：

![SpringAOPProcess](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg)

当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。

使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。

## 4.2 SpringAOP和AspectJ AOP有什么区别

**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** **Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。**

Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，

如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。

# 5.SpringBean

## 5.1 Spring中bean的作用域有哪些

- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
- prototype : 每次请求都会创建一个新的 bean 实例。
- request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
- session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。

## 5.2 Spring中的单例bean的线程安全问题了解吗

大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。

常见的有两种解决办法：

1. 在Bean对象中尽量避免定义可变的成员变量（不太现实）。
2. 在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。

## 5.3 @Component和@Bean的区别

1. 作用对象不同: `@Component` 注解作用于类，而`@Bean`注解作用于方法。
2. `@Component`通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 `@ComponentScan` 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。`@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了Spring这是某个类的示例，当我需要用它的时候还给我。
3. `@Bean` 注解比 `Component` 注解的自定义性更强，而且很多地方我们只能通过 `@Bean` 注解来注册bean。比如当我们引用第三方库中的类需要装配到 `Spring`容器时，则只能通过 `@Bean`来实现。

`@Bean`注解使用示例：

```java
@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

}
```

上面的代码相当于下面的 xml 配置

```xml
<beans>
    <bean id="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
```

下面这个例子是通过 `@Component` 无法实现的。

```java
@Bean
public OneService getService(status) {
    case (status)  {
        when 1:
                return new serviceImpl1();
        when 2:
                return new serviceImpl2();
        when 3:
                return new serviceImpl3();
    }
}
```

## 5.4 将一个类声明为Spring的bean的注解有哪些

我们一般使用 `@Autowired` 注解自动装配 bean，要想把类标识成可用于 `@Autowired` 注解自动装配的 bean 的类,采用以下注解可实现：

- `@Component` ：通用的注解，可标注任意类为 `Spring` 组件。如果一个Bean不知道属于哪个层，可以使用`@Component` 注解标注。
- `@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。
- `@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。
- `@Controller` : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。

## 5.5 Spring生命周期

- Bean 容器找到配置文件中 Spring Bean 的定义。
- Bean 容器利用 Java Reflection API 创建一个Bean的实例。
- 如果涉及到一些属性值 利用 `set()`方法设置一些属性值。
- 如果 Bean 实现了 `BeanNameAware` 接口，调用 `setBeanName()`方法，传入Bean的名字。
- 如果 Bean 实现了 `BeanClassLoaderAware` 接口，调用 `setBeanClassLoader()`方法，传入 `ClassLoader`对象的实例。
- 与上面的类似，如果实现了其他 `*.Aware`接口，就调用相应的方法。
- 如果有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessBeforeInitialization()` 方法
- 如果Bean实现了`InitializingBean`接口，执行`afterPropertiesSet()`方法。
- 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。
- 如果有和加载这个 Bean的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessAfterInitialization()` 方法
- 当要销毁 Bean 的时候，如果 Bean 实现了 `DisposableBean` 接口，执行 `destroy()` 方法。
- 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。

图示：

![Spring Bean 生命周期](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg)

与之比较类似的中文版本:

![Spring Bean 生命周期](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg)

# 6. SpringMVC

## 6.1说说自己对SpringMVC了解

MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。

**Spring MVC 的简单原理图如下：**

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/60679444.jpg)

## 6.2 SpringMVC的工作原理了解吗

**原理如下图所示：** ![SpringMVC运行原理](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg)

上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 `DispatcherServlet` 的作用是接收请求，响应结果。

**流程说明（重要）：**

1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。
3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。
4. `HandlerAdapter` 会根据 `Handler`来调用真正的处理器开处理请求，并处理相应的业务逻辑。
5. 处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
8. 把 `View` 返回给请求者（浏览器）

# 7.Spring框架用到了哪些设计模式

- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。
- **单例设计模式** : Spring 中的 Bean 默认都是单例的。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。

# 8.Spring事务

## 8.1 Spring管理事务的方式

1. 编程式事务，在代码中硬编码。(不推荐使用)
2. 声明式事务，在配置文件中配置（推荐使用）

**声明式事务又分为两种：**

1. 基于XML的声明式事务
2. 基于注解的声明式事务

## 8.2 Spring事务的隔离级别

**TransactionDefinition 接口中定义了五个表示隔离级别的常量：**

- **TransactionDefinition.ISOLATION_DEFAULT:** 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.
- **TransactionDefinition.ISOLATION_READ_UNCOMMITTED:** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**
- **TransactionDefinition.ISOLATION_READ_COMMITTED:** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**
- **TransactionDefinition.ISOLATION_REPEATABLE_READ:** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**
- **TransactionDefinition.ISOLATION_SERIALIZABLE:** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

## 8.3 Spring事务中哪几种事务传播行为

**支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- **TransactionDefinition.PROPAGATION_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- **TransactionDefinition.PROPAGATION_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

**不支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRES_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NOT_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。

**其他情况：**

- **TransactionDefinition.PROPAGATION_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

## 8.4 @Transactional(rollbackFor=Exception.class)注解

我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。

当`@Transactional`注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。

在`@Transactional`注解中如果不配置`rollbackFor`属性,那么事物只会在遇到`RuntimeException`的时候才会回滚,加上`rollbackFor=Exception.class`,可以让事物在遇到非运行时异常时也回滚。---
title: SQL刷题
date: 2020-05-08 17:22:24
tags:	
		- SQL
categories:
		- SQL
---

# [176. Second Highest Salary](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database 题解?id=_176-second-highest-salary)

## [Description](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database 题解?id=description-10)

```html
+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
```

查找工资第二高的员工。

```html
+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
```

没有找到返回 null 而不是不返回数据。

## [Solution](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database 题解?id=solution-10)

为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。

```sql
SELECT
    ( SELECT DISTINCT Salary 
     FROM Employee 
     ORDER BY Salary DESC 
     LIMIT 1, 1 ) SecondHighestSalary;
```

## [SQL Schema](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database 题解?id=sql-schema-10)

```sql
DROP TABLE
IF
    EXISTS Employee;
CREATE TABLE Employee ( Id INT, Salary INT );
INSERT INTO Employee ( Id, Salary )
VALUES
    ( 1, 100 ),
    ( 2, 200 ),
    ( 3, 300 );
```



# SQL 19

## 题目描述

**查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工**
CREATE TABLE `departments` (
`dept_no` char(4) NOT NULL,
`dept_name` varchar(40) NOT NULL,
PRIMARY KEY (`dept_no`));
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `employees` (
`emp_no` int(11) NOT NULL,
`birth_date` date NOT NULL,
`first_name` varchar(14) NOT NULL,
`last_name` varchar(16) NOT NULL,
`gender` char(1) NOT NULL,
`hire_date` date NOT NULL,

PRIMARY KEY (`emp_no`));



**思想：**

- 需要将三个表连接在一起，其中需要首先将`departments` 表和`dept_emp` 表内连接在一起，然后再`employees`再与其做一个左外连接

```
select em.last_name,em.first_name,de.dept_name from 
employees em left outer join(dept_emp d_e inner join departments de on d_e.dept_no=de.dept_no) t on em.emp_no=t.emp_no;
```

---
title: U-Net论文笔记
date: 2021-03-06 09:59:12
tags: 深度学习
categories: 深度学习
---
---
title: zookeeper
date: 2020-06-11 20:05:42
tags: zookeeper
categories: zookeeper
---

# 1.Zookeeper概览

ZooKeeper 是一个开源的分布式协调服务，ZooKeeper框架最初是在“Yahoo!"上构建的，用于以简单而稳健的方式访问他们的应用程序。 后来，Apache ZooKeeper成为Hadoop，HBase和其他分布式框架使用的有组织服务的标准。 例如，Apache HBase使用ZooKeeper跟踪分布式数据的状态。**ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。**

> **原语：** 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。

**ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。**

**Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务)。** 服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo架构中 Zookeeper 就担任了注册中心这一角色。

![Dubbo](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-10/35571782.jpg)

**为什么最好使用奇数台服务器构成 ZooKeeper 集群？**

所谓的zookeeper容错是指，当宕掉几个zookeeper服务器之后，剩下的个数必须大于宕掉的个数的话整个zookeeper才依然可用。假如我们的集群中有n台zookeeper服务器，那么也就是剩下的服务数必须大于n/2。先说一下结论，2n和2n-1的容忍度是一样的，都是n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。 比如假如我们有3台，那么最大允许宕掉1台zookeeper服务器，如果我们有4台的的时候也同样只允许宕掉1台。 假如我们有5台，那么最大允许宕掉2台zookeeper服务器，如果我们有6台的的时候也同样只允许宕掉2台。

综上，何必增加那一个不必要的zookeeper呢？

# 2.重要概念总结

- **ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。**
- **为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。**
- **ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟**（但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因）。
- **ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。**（“读”多于“写”是协调服务的典型场景。）
- **ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。**
- ZooKeeper 底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提供数据节点监听服务。

# 3.会话

Session 指的是 ZooKeeper 服务器与客户端会话。**在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接**。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。**通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。** Session的`sessionTimeout`值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，**只要在`sessionTimeout`规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。**

**在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。**

# 3.Znode

**在谈到分布式的时候，我们通常说的“节点"是指组成集群的每一台机器。然而，在Zookeeper中，“节点"分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。**

Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。

**在Zookeeper中，node可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。** 另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：**SEQUENTIAL**.一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。

# 4.zookeeper集群节点介绍

**在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色**。如下图所示

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-10/89602762.jpg)

**ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和 Observer 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。**

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-13/91622395.jpg)

**当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的Leader服务器。这个过程大致是这样的：**

1. Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。
2. Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。
3. Synchronization（同步阶段）:同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。
4. Broadcast（广播阶段） 到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。

# 5.Zookeeper&ZAB协议&Paxos算法

## 1.ZAB协议介绍

**ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。**

## 2.ZAB协议两种基本模式：崩溃恢复和消息广播

ZAB协议包括两种基本的模式，分别是 **崩溃恢复和消息广播**。当**整个服务框架在启动过程中**，**或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时**，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，**所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致**。

**当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。** 当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进人数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理。Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。

# 6.分布式和集群的区别理解

比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 **一样** 提供秒杀服务，这个时候就是 **`Cluster` 集群** 。

![cluster](http://img.francisqiang.top/img/cluster.jpg)

但是，我现在换一种方式，我将一个秒杀服务 **拆分成多个子服务** ，比如创建订单服务，增加积分服务，扣优惠券服务等等，**然后我将这些子服务都部署在不同的服务器上** ，这个时候就是 **`Distributed` 分布式** 。

![distributed](http://img.francisqiang.top/img/distributed.jpg)

而我为什么反驳同学所说的分布式就是加机器呢？因为我认为加机器更加适用于构建集群，因为它真是只有加机器。而对于分布式来说，你首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时你还要去解决分布式带来的一系列问题。

# 7.一致性协议和算法

## 2PC(两阶段提交)

我们所需要解决的是在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 **原子性问题** 。

在两阶段提交中，主要涉及到两个角色，分别是**协调者**和**参与者**。

第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 `prepare` 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先**执行但不提交**，执行后请给我回复。然后参与者收到 `prepare` 消息后，他们会开始执行事务（但不提交），并将 `Undo` 和 `Redo` 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。

第二阶段：第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。

比如这个时候 **所有的参与者** 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 **`Commit` 请求** ，当参与者收到 `Commit` 请求的时候会执行前面执行的事务的 **提交操作** ，提交完毕之后将给协调者发送提交成功的响应。

而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 **回滚事务的 `rollback` 请求**，参与者收到之后将会 **回滚它在第一阶段所做的事务处理** ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。

![2PC流程](http://img.francisqiang.top/img/2PC.jpg)

- **单点故障问题**，如果协调者挂了那么整个系统都处于不可用的状态了。
- **阻塞问题**，即当协调者发送 `prepare` 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。
- **数据不一致问题**，比如当第二阶段，协调者只发送了一部分的 `commit` 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。

## 3PC(三阶段提交)

1. **CanCommit阶段**：协调者向所有参与者发送 `CanCommit` 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。
2. **PreCommit阶段**：协调者根据参与者返回的响应来决定是否可以进行下面的 `PreCommit` 操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送 `PreCommit` 预提交请求，**参与者收到预提交请求后，会进行事务的执行操作，并将 `Undo` 和 `Redo` 信息写入事务日志中** ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。如果在第一阶段协调者收到了 **任何一个 NO** 的信息，或者 **在一定时间内** 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。
3. **DoCommit阶段**：这个阶段其实和 `2PC` 的第二阶段差不多，如果协调者收到了所有参与者在 `PreCommit` 阶段的 YES 响应，那么协调者将会给所有参与者发送 `DoCommit` 请求，**参与者收到 `DoCommit` 请求后则会进行事务的提交工作**，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在 `PreCommit` 阶段 **收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应** ，那么就会进行中断请求的发送，参与者收到中断请求后则会 **通过上面记录的回滚日志** 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。

![3PC流程](http://img.francisqiang.top/img/3PC.jpg)

> 这里是 `3PC` 在成功的环境下的流程图，你可以看到 `3PC` 在很多地方进行了超时中断的处理，比如协调者在指定时间内为收到全部的确认消息则进行事务中断的处理，这样能 **减少同步阻塞的时间** 。还有需要注意的是，**`3PC` 在 `DoCommit` 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交**。为什么这么做呢？是因为这个时候我们肯定**保证了在第一阶段所有的协调者全部返回了可以执行事务的响应**，这个时候我们有理由**相信其他系统都能进行事务的执行和提交**，所以**不管**协调者有没有发消息给参与者，进入第三阶段参与者都会进行事务的提交操作。

总之，`3PC` 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如在 `PreCommit` 阶段，当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，这就会出现数据不一致性问题。

## Paxos算法

`Paxos` 算法是基于**消息传递且具有高度容错特性的一致性算法**，是目前公认的解决分布式一致性问题最有效的算法之一，**其解决的问题就是在分布式系统中如何就某个值（决议）达成一致** 。

在 `Paxos` 中主要有三个角色，分别为 `Proposer提案者`、`Acceptor表决者`、`Learner学习者`。`Paxos` 算法和 `2PC` 一样，也有两个阶段，分别为 `Prepare` 和 `accept` 阶段。

### prepare阶段

- `Proposer提案者`：负责提出 `proposal`，每个提案者在提出提案时都会首先获取到一个 **具有全局唯一性的、递增的提案编号N**，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在**第一阶段是只将提案编号发送给所有的表决者**。
- `Acceptor表决者`：每个表决者在 `accept` 某提案后，会将该提案编号N记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个**编号最大的提案**，其编号假设为 `maxN`。每个表决者仅会 `accept` 编号大于自己本地 `maxN` 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 `Proposer` 。

> 下面是 `prepare` 阶段的流程图，你可以对照着参考一下。

![paxos第一阶段](http://img.francisqiang.top/img/paxos1.jpg)

### accept阶段

当一个提案被 `Proposer` 提出后，如果 `Proposer` 收到了超过半数的 `Acceptor` 的批准（`Proposer` 本身同意），那么此时 `Proposer` 会给所有的 `Acceptor` 发送真正的提案（你可以理解为第一阶段为试探），这个时候 `Proposer` 就会发送提案的内容和提案编号。

表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 **大于等于** 已经批准过的最大提案编号，那么就 `accept` 该提案（此时执行提案内容但不提交），随后将情况返回给 `Proposer` 。如果不满足则不回应或者返回 NO 。

![paxos第二阶段1](http://img.francisqiang.top/img/paxos2.jpg)

当 `Proposer` 收到超过半数的 `accept` ，那么它这个时候会向所有的 `acceptor` 发送提案的提交请求。需要注意的是，因为上述仅仅是超过半数的 `acceptor` 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要**向未批准的 `acceptor` 发送提案内容和提案编号并让它无条件执行和提交**，而对于前面已经批准过该提案的 `acceptor` 来说 **仅仅需要发送该提案的编号** ，让 `acceptor` 执行提交就行了。

![paxos第二阶段2](http://img.francisqiang.top/img/paxos3.jpg)

而如果 `Proposer` 如果没有收到超过半数的 `accept` 那么它将会将 **递增** 该 `Proposal` 的编号，然后 **重新进入 `Prepare` 阶段** 。

> 对于 `Learner` 来说如何去学习 `Acceptor` 批准的提案内容，这有很多方式，读者可以自己去了解一下，这里不做过多解释。

# 8.ZAB

## ZAB中的三种角色

和介绍 `Paxos` 一样，在介绍 `ZAB` 协议之前，我们首先来了解一下在 `ZAB` 中三个主要的角色，`Leader 领导者`、`Follower跟随者`、`Observer观察者` 。

- `Leader` ：集群中 **唯一的写请求处理者** ，能够发起投票（投票也是为了进行写请求）。
- `Follower`：能够接收客户端的请求，如果是读请求则可以自己处理，**如果是写请求则要转发给 `Leader`** 。在选举过程中会参与投票，**有选举权和被选举权** 。
- `Observer` ：就是没有选举权和被选举权的 `Follower` 。

在 `ZAB` 协议中对 `zkServer`(即上面我们说的三个角色的总称) 还有两种模式的定义，分别是 **消息广播** 和 **崩溃恢复** 。

## 消息广播模式

说白了就是 **`ZAB` 协议是如何处理写请求的**，上面我们不是说只有 `Leader` 能处理写请求嘛？那么我们的 `Follower` 和 `Observer` 是不是也需要 **同步更新数据** 呢？总不能数据只在 `Leader` 中更新了，其他角色都没有得到更新吧？

第一步肯定需要 `Leader` 将写请求 **广播** 出去呀，让 `Leader` 问问 `Followers` 是否同意更新，如果超过半数以上的同意那么就进行 `Follower` 和 `Observer` 的更新（和 `Paxos` 一样）。当然这么说有点虚，画张图理解一下。

![消息广播](http://img.francisqiang.top/img/%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD1.jpg)

嗯。。。看起来很简单，貌似懂了🤥🤥🤥。这两个 `Queue` 哪冒出来的？答案是 **`ZAB` 需要让 `Follower` 和 `Observer` 保证顺序性** 。何为顺序性，比如我现在有一个写请求A，此时 `Leader` 将请求A广播出去，因为只需要半数同意就行，所以可能这个时候有一个 `Follower` F1因为网络原因没有收到，而 `Leader` 又广播了一个请求B，因为网络原因，F1竟然先收到了请求B然后才收到了请求A，这个时候请求处理的顺序不同就会导致数据的不同，从而 **产生数据不一致问题** 。

所以在 `Leader` 这端，它为每个其他的 `zkServer` 准备了一个 **队列** ，采用先进先出的方式发送消息。由于协议是 **通过 `TCP` **来进行网络通信的，保证了消息的发送顺序性，接受顺序性也得到了保证。

除此之外，在 `ZAB` 中还定义了一个 **全局单调递增的事务ID `ZXID`** ，它是一个64位long型，其中高32位表示 `epoch` 年代，低32位表示事务id。`epoch` 是会根据 `Leader` 的变化而变化的，当一个 `Leader` 挂了，新的 `Leader` 上位的时候，年代（`epoch`）就变了。而低32位可以简单理解为递增的事务id。

定义这个的原因也是为了顺序性，每个 `proposal` 在 `Leader` 中生成后需要 **通过其 `ZXID` 来进行排序** ，才能得到处理。

## 崩溃恢复模式

说到崩溃恢复我们首先要提到 **`ZAB` 中的 `Leader` 选举算法**，当系统出现崩溃影响最大应该是 `Leader` 的崩溃，因为我们只有一个 `Leader` ，所以当 `Leader` 出现问题的时候我们势必需要重新选举 `Leader` 。

`Leader` 选举可以分为两个不同的阶段，第一个是我们提到的 `Leader` 宕机需要重新选举，第二则是当 `Zookeeper` 启动时需要进行系统的 `Leader` 初始化选举。下面我先来介绍一下 `ZAB` 是如何进行初始化选举的。

假设我们集群中有3台机器，那也就意味着我们需要两台以上同意（超过半数）。比如这个时候我们启动了 `server1` ，它会首先 **投票给自己** ，**投票内容为服务器的 `myid` 和 `ZXID`** ，因为初始化所以 `ZXID` 都为0，此时 `server1` 发出的投票为 (1,0)。但此时 `server1` 的投票仅为1，所以不能作为 `Leader` ，此时还在选举阶段所以整个集群处于 **`Looking` 状态**。

接着 `server2` 启动了，它首先也会将投票选给自己(2,0)，并将投票信息广播出去（`server1`也会，只是它那时没有其他的服务器了），`server1` 在收到 `server2` 的投票信息后会将投票信息与自己的作比较。**首先它会比较 `ZXID` ，`ZXID` 大的优先为 `Leader`，如果相同则比较 `myid`，`myid` 大的优先作为 `Leader`**。所以此时`server1` 发现 `server2` 更适合做 `Leader`，它就会将自己的投票信息更改为(2,0)然后再广播出去，之后`server2` 收到之后发现和自己的一样无需做更改，并且自己的 **投票已经超过半数** ，则 **确定 `server2` 为 `Leader`**，`server1` 也会将自己服务器设置为 `Following` 变为 `Follower`。整个服务器就从 `Looking` 变为了正常状态。

当 `server3` 启动发现集群没有处于 `Looking` 状态时，它会直接以 `Follower` 的身份加入集群。

还是前面三个 `server` 的例子，如果在整个集群运行的过程中 `server2` 挂了，那么整个集群会如何重新选举 `Leader` 呢？其实和初始化选举差不多。

首先毫无疑问的是剩下的两个 `Follower` 会将自己的状态 **从 `Following` 变为 `Looking` 状态** ，然后每个 `server` 会向初始化投票一样首先给自己投票（这不过这里的 `zxid` 可能不是0了，这里为了方便随便取个数字）。

假设 `server1` 给自己投票为(1,99)，然后广播给其他 `server`，`server3` 首先也会给自己投票(3,95)，然后也广播给其他 `server`。`server1` 和 `server3` 此时会收到彼此的投票信息，和一开始选举一样，他们也会比较自己的投票和收到的投票（`zxid` 大的优先，如果相同那么就 `myid` 大的优先）。这个时候 `server1` 收到了 `server3` 的投票发现没自己的合适故不变，`server3` 收到 `server1` 的投票结果后发现比自己的合适于是更改投票为(1,99)然后广播出去，最后 `server1` 收到了发现自己的投票已经超过半数就把自己设为 `Leader`，`server3` 也随之变为 `Follower`。

那么说完了 `ZAB` 中的 `Leader` 选举方式之后我们再来了解一下 **崩溃恢复** 是什么玩意？

其实主要就是 **当集群中有机器挂了，我们整个集群如何保证数据一致性？**

如果只是 `Follower` 挂了，而且挂的没超过半数的时候，因为我们一开始讲了在 `Leader` 中会维护队列，所以不用担心后面的数据没接收到导致数据不一致性。

如果 `Leader` 挂了那就麻烦了，我们肯定需要先暂停服务变为 `Looking` 状态然后进行 `Leader` 的重新选举（上面我讲过了），但这个就要分为两种情况了，分别是 **确保已经被Leader提交的提案最终能够被所有的Follower提交** 和 **跳过那些已经被丢弃的提案** 。

确保已经被Leader提交的提案最终能够被所有的Follower提交是什么意思呢？

假设 `Leader (server2)` 发送 `commit` 请求（忘了请看上面的消息广播模式），他发送给了 `server3`，然后要发给 `server1` 的时候突然挂了。这个时候重新选举的时候我们如果把 `server1` 作为 `Leader` 的话，那么肯定会产生数据不一致性，因为 `server3` 肯定会提交刚刚 `server2` 发送的 `commit` 请求的提案，而 `server1` 根本没收到所以会丢弃。

![崩溃恢复](http://img.francisqiang.top/img/%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D1.jpg)

那怎么解决呢？

聪明的同学肯定会质疑，**这个时候 `server1` 已经不可能成为 `Leader` 了，因为 `server1` 和 `server3` 进行投票选举的时候会比较 `ZXID` ，而此时 `server3` 的 `ZXID` 肯定比 `server1` 的大了**。(不理解可以看前面的选举算法)

那么跳过那些已经被丢弃的提案又是什么意思呢？

假设 `Leader (server2)` 此时同意了提案N1，自身提交了这个事务并且要发送给所有 `Follower` 要 `commit` 的请求，却在这个时候挂了，此时肯定要重新进行 `Leader` 的选举，比如说此时选 `server1` 为 `Leader` （这无所谓）。但是过了一会，这个 **挂掉的 `Leader` 又重新恢复了** ，此时它肯定会作为 `Follower` 的身份进入集群中，需要注意的是刚刚 `server2` 已经同意提交了提案N1，但其他 `server` 并没有收到它的 `commit` 信息，所以其他 `server` 不可能再提交这个提案N1了，这样就会出现数据不一致性问题了，所以 **该提案N1最终需要被抛弃掉** 。

![崩溃恢复](http://img.francisqiang.top/img/%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D2.jpg)---
title: 三数之和
date: 2020-05-30 18:04:37
tags: leetcode
categories: leetcode
---

# [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。



**算法思想：**

- 问题的关键在于如何避免重复。先将数组排序后，依次从最左边元素开始寻找其**后面**是否存在两数使得这三数之和为0.

```
List<List<Integer>> res=new ArrayList<>();
        if(nums==null||nums.length<3) return res;
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            if(nums[i]>0) break;
            int L=i+1,R=nums.length-1;
            while (L<R){
                int num=nums[i]+nums[L]+nums[R];
                if(num==0) {
                    List<Integer> list=new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[L]);
                    list.add(nums[R]);
                    res.add(list);
                    //避免重复
                    while (L<R&&nums[L]==nums[L+1]) L++;
                    while(L<R&&nums[R]==nums[R-1]) R--;
                    L++;
                    R--;
                }else if(num<0) L++;
                else R--;
            }
            //避免重复
            while (i+1<nums.length&&nums[i]==nums[i+1]) i++;
        }
        return res;
```

---
title: 丑数
date: 2020-05-23 16:35:08
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。





# 动态规划

```
public int GetUglyNumber_Solution(int index) {
        if(index==0) return 0;
        if(index==1) return 1;
        int[] memo=new int[index+1];
        memo[1]=1;
        int i2=1,i3=1,i5=1;
        for(int i=2;i<memo.length;i++){
            int min=Math.min(memo[i2]*2,Math.min(memo[i3]*3,memo[i5]*5));
            if(min==memo[i2]*2) i2++;
            if(min==memo[i3]*3) i3++;
            if(min==memo[i5]*5) i5++;
            memo[i]=min;
        }
        return memo[index];
    }
```

---
title: 二叉搜索树的第K个节点
date: 2020-05-28 20:04:45
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）  中，按结点数值大小顺序第三小结点的值为4。



**第二次写问题出在不能将k放在参数中传递，因为是值传递，递归中值改变，原方法中k不会变，要把k设置成成员变量。**

```
	private int k;
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        this.k=k;
        return helper(pRoot);
    }
    private TreeNode helper(TreeNode root){
        if(root!=null) {
            TreeNode left=helper(root.left);
            if(left!=null) return left;
            k--;
            if (k == 0) return root;
            TreeNode right=helper(root.right);
            if(right!=null) return right;
        }
        return null;
    }
```

---
title: 二叉树
date: 2020-05-17 21:45:38
tags:	
		二叉树常见面试题
---

# 二叉树

二叉树的测试用例中，将数组转换为树结构的方法：

```
private TreeNode createTree(Integer[] array){
        return createTree(array,0);
    }

    private TreeNode createTree(Integer[] array,int index){
        if(index>=array.length||array[index]==null) return null;
        TreeNode node=new TreeNode(array[index]);
        node.left=createTree(array,2*index+1);
        node.right=createTree(array,2*index+2);
        return node;
    }
```

## 按层次打印二叉树

按层次打印有两种实现方式：1. 记录每每层中节点数目；2.记录每层的最后一个节点。

```
public List<List<Integer>> levelOrder(TreeNode root){
        List<List<Integer>> res=new ArrayList<List<Integer>>();
        if(root==null) return res;
        Queue<TreeNode> queue=new LinkedList<>();
        TreeNode p=root;
        queue.offer(p);
        int count=1;
        while (!queue.isEmpty()){
            List<Integer> list=new ArrayList<>();
            int i=count;
            count=0;
            while (i>0){
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left!=null){
                    queue.offer(node.left);
                    count++;
                }
                if(node.right!=null){
                    queue.offer(node.right);
                    count++;
                }
                i--;
            }
            res.add(list);
        }
        return res;
    }
```



## 序列化二叉树

二叉树先序序列化的方式：假设序列化的结果字符串为 str，初始时 str 等于空字符串。先序遍历二叉树，如果遇到空节点，就在 str 的末尾加上 “#!”，“#” 表示这个节点为空，节点值不存在，当然你也可以用其他的特殊字符，“!” 表示一个值的结束。
如果遇到不为空的节点，假设节点值为 3，就在 str 的末尾加上 “3!”。现在请你实现树的先序序列化。

给定树的根结点 root，请返回二叉树序列化后的字符串。

```
public String preOrderSerrial(TreeNode root){
        StringBuilder res=new StringBuilder();
        preOrderSerrial(root,res);
        return res.toString();
    }

    private void preOrderSerrial(TreeNode root,StringBuilder res){
        if(root==null) {
            res.append("#!");
            return ;
        }
        res.append(root.val+"!");
        preOrderSerrial(root.left,res);
        preOrderSerrial(root.right,res);
    }
```

反序列化：

```
private TreeNode preOrderDeSerial(StringBuilder str){
        if(str==null) return null;
        if(str.charAt(0)=='#'){
        	//删两次，#!
            str.deleteCharAt(0);
            str.deleteCharAt(0);
            return null;
        }
        boolean flag=true;
        //标记正负
        if(str.charAt(0)=='-'){
            flag=false;
            str.deleteCharAt(0);
        }
        int num=0;
        while (str.length()!=0&&str.charAt(0)!='!'){
            num=10*num+str.charAt(0)-'0';
            str.deleteCharAt(0);
        }
        //删去!
        str.deleteCharAt(0);
        TreeNode root=new TreeNode(flag?num:-num);
        root.left=preOrderDeSerial(str);
        root.right=preOrderDeSerial(str);
        return root;
    }
```

## 递归遍历二叉树

```
//先序
public void preOrder(TreeNode root,List<Integer> res){
        if(root!=null){
            res.add(root.val);
            preOrder(root.left,res);
            preOrder(root.right,res);
        }
    }
 
//中序
public void inOrder(TreeNode root,List<Integer> res){
        if(root!=null){
            inOrder(root.left,res);
            res.add(root.val);
            inOrder(root.right,res);
        }
    }

//后序
    public void postOrder(TreeNode root,List<Integer> res){
        if(root!=null){
            postOrder(root.left,res);
            postOrder(root.right,res);
            res.add(root.val);
        }
    }
```

## 非递归遍历二叉树

注意一下三种实现的不同之处。

```
//先序非递归
public List<Integer> PreOrder(TreeNode root){
        List<Integer> res=new ArrayList<>();
        TreeNode curr=root;
        Stack<TreeNode> stack=new Stack<>();
        while (curr!=null||!stack.isEmpty()){
            while (curr!=null){
                res.add(curr.val);
                stack.push(curr);
                curr=curr.left;
            }
            curr=stack.pop().right;
        }
        return res;
    }
  
 //非递归中序
 public List<Integer> inOrder(TreeNode root){
        List<Integer> res=new ArrayList<>();
        TreeNode curr=root;
        Stack<TreeNode> stack=new Stack<>();
        while (curr!=null||!stack.isEmpty()){
            while (curr!=null){
                stack.push(curr);
                curr=curr.left;
            } 
            curr = stack.pop();
            res.add(curr.val);
            curr = curr.right;
            
        }
        return res;
    }
	
	//非递归后序
    public List<Integer> postOrder(TreeNode root){
        List<Integer> res=new ArrayList<>();
        TreeNode curr=root,last=root;
        Stack<TreeNode> stack=new Stack<>();
        while (curr!=null||!stack.isEmpty()){
            while (curr!=null){
                stack.push(curr);
                curr=curr.left;
            }
            curr = stack.peek();
            if(curr.right!=null&&curr.right!=last) {
                curr=curr.right;
            }else {
                stack.pop();
                res.add(curr.val);
                last=curr;
                //最后要将curr置为null
                curr=null;
            }
        }
        return res;
    }       
```

## 判断是否是平衡二叉树

有一棵二叉树，请设计一个算法判断这棵二叉树是否为平衡二叉树。

给定二叉树的根结点 root，请返回一个 bool 值，代表这棵树是否为平衡二叉树。

讲求树高度的方法进行改进，使得在其左右子树已经不平衡时返回-1.

```
public boolean isSub(TreeNode root){
        return height(root)!=-1;
    }

    private int height(TreeNode root){
        if(root==null) return 0;
        int left = height(root.left);
        int right=height(root.right);
        if(left==-1||right==-1){
            return -1;
        }
        if(Math.abs(left-right)>1) return -1;
        return Math.max(left,right)+1;
    }
```

## 确定二叉树内最大距离

从二叉树的节点 A 出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点 B 时，路径上的**节点数**叫作 A 到 B 的距离。对于给定的一棵二叉树，求整棵树上节点间的最大距离。

给定一个二叉树的头结点 root，请返回最大距离。保证点数大于等于 2 小于等于 500.

最大距离的两个节点一定是叶子节点，并且一定有相同的祖节点，遍历所有的节点，判断其左右子树高度和+1，即为以其为祖节点的最大距离。

```
	//全局变量记录最大距离
	private int longest=0;
    public int maxSize(TreeNode root){
        longest(root);
        return longest;
    }

    private int longest(TreeNode root){
        if(root==null) return 0;
        int left=longest(root.left);
        int right=longest(root.right);
        //比较最大距离
        longest=Math.max(longest,left+right+1);
        return Math.max(left,right)+1;
    }
```

## 判断是否为完全二叉树

有一棵二叉树，请设计一个算法判断它是否是完全二叉树。

给定二叉树的根结点 root，请返回一个 bool 值代表它是否为完全二叉树。
树的结点个数小于等于 500。

```
public boolean isCurr(TreeNode root){
         if(root==null) return false;
         Queue<TreeNode> queue=new LinkedList<>();
         TreeNode p=root;
         queue.add(p);
         //用isLeaf来表示第一个叶节点
         boolean isLeaf=false;
         while (!queue.isEmpty()){
             TreeNode node = queue.poll();
             //左为空，右不为空
             if(node.left==null&&node.right!=null) return false;
             //右为空，则之后的节点(层次遍历顺序)都是叶子节点
             if(node.right==null) isLeaf=true;
             if(isLeaf&&(node.left!=null||node.right!=null)) return false;
             if(node.left!=null) queue.add(node.left);
             if(node.right!=null) queue.add(node.right);
         }
         return true;
    }
```

---
title: 二叉树中和为某一值的路径
date: 2020-05-22 18:23:21
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

```
	private ArrayList<ArrayList<Integer>> res;
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {
        res=new ArrayList<>();
        Findpath(root,target,new ArrayList<>());
        return res;
    }

    private void Findpath(TreeNode root,int target,ArrayList<Integer> array){
        if(root==null||root.val>target) return;
        if(root.left==null&&root.right==null&&target==root.val){
            array.add(root.val);
            res.add(new ArrayList<>(array));
            array.remove(array.size()-1);
            return;
        }
        array.add(root.val);
        Findpath(root.left,target-root.val,array);
        Findpath(root.right,target-root.val,array);
        array.remove(array.size()-1);
    }
```

---
title: 二叉树的直径
date: 2020-06-02 10:42:46
tags: leetcode
categories: leetcode
---

# [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。



## 分别求以每个节点为根的最大路径

**算法思想：**

- 最后的最大路径一定是以某一个节点为根节点的树的直径，所以分别以每一个节点为根节点求最长直径。

```
	public int diameterOfBinaryTree(TreeNode root) {
        if(root==null) return 0;
        //分别递归求左右孩子的最长直径
        int left=diameterOfBinaryTree(root.left);
        int right=diameterOfBinaryTree(root.right);
        //三者取最大
        return Math.max(height(root.left)+height(root.right),Math.max(left,right));
    }
	
	//求树高，左子树树高+右子树树高即为直径
    private int height(TreeNode root){
        if(root==null) return 0;
        int left=height(root.left);
        int right=height(root.right);
        return Math.max(left,right)+1;
    }
```



## 求树高时直接比较

**算法思想：**

- 分别计算以每一个节点为父节点的最大直径，则其中最大的即为结果，而其中以每一个节点为父节点的最大直径又等于其左子树高度+右子树高度+1。

```
	private int max;
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return max;
    }

    private int maxDepth(TreeNode root){
        if(root==null) return 0;
        int left=maxDepth(root.left);
        int right=maxDepth(root.right);
        max=Math.max(max,left+right);
        return Math.max(left,right)+1;
    }
```

---
title: 分布式
date: 2020-06-14 22:34:10
tags: 分布式
categories: 分布式
---

# 一.分布式锁

在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。

阻塞锁通常使用互斥量来实现：

- 互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；
- 互斥量为 1 表示未锁定状态。

1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。

## 数据库的唯一索引

获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。

存在以下几个问题：

- 锁没有失效时间，解锁失败的话其它进程无法再获得该锁；
- 只能是非阻塞锁，插入失败直接就报错了，无法重试；
- 不可重入，已经获得锁的进程也必须重新获取锁。

## Redis的SETNX的指令

使用 SETNX（set if not exist）指令插入一个键值对，**如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True**。

SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。

**EXPIRE 指令可以为一个键值对设置一个过期时间**，从而避免了数据库唯一索引实现方式中释放锁失败的问题。

## Redis的RedLock算法

使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。

- 尝试从 N 个互相独立 Redis 实例获取锁；
- 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；
- 如果获取锁失败，就到每个实例上释放锁。

## Zookeeper的有序节点

### 1.Zookeeper的抽象模型

Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aefa8042-15fa-4e8b-9f50-20b282a2c624.png)

## 2.节点类型

- 永久节点：不会因为会话结束或者超时而消失；
- 临时节点：如果会话结束或者超时就会消失；
- 有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。

### 3.监听器

为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。

### 4.分布式锁的实现

- 创建一个锁目录 /lock；
- 当一个客户端需要获取锁时，在 /lock 下创建**临时的且有序**的子节点；
- 客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则**监听自己的前一个子节点**，获得子节点的变更通知后重复此步骤直至获得锁；
- 执行业务代码，完成后，删除对应的子节点。

### 5.会话超时

如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题

### 6.羊群效应

一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。

# 二.分布式事务

指**事务的操作位于不同的节点上**，需要保证事务的 ACID 特性。

例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。

分布式锁和分布式事务区别：

- 锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。
- 而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。

## 2PC

两阶段提交（Two-phase Commit，2PC），通过引入**协调者**（Coordinator）来协调**参与者**的行为，并最终决定这些参与者是否要真正执行事务。

### 1.运行过程

#### 1.1 准备阶段

**协调者询问参与者事务是否执行成功**，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/44d33643-1004-43a3-b99a-4d688a08d0a1.png)

#### 1.2 提交阶段

如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者**提交事务**；否则，协调者发送通知让参与者**回滚事务**。

需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2ae9932-e2b1-4191-8ee9-e573f36d3895.png)

### 2.存在的问题

#### 2.1 同步阻塞

所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。

#### 2.2 单点问题

协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。

#### 2.3 数据不一致

在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。

#### 2.4 太过保守

任意一个节点失败就会导致整个事务失败，没有完善的容错机制。

## 本地消息表

本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。

1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
2. 之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/476329d4-e2ef-4f7b-8ac9-a52a6f784600.png)

## 3PC

`Three Phase`分别为`CanCommit`、`PreCommit`、`DoCommit`。
![img](https://user-gold-cdn.xitu.io/2018/4/21/162e70c4250f5fea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

三阶段提交针对两阶段提交做了改进：

- 引入超时机制。在`2PC`中，只有协调者拥有超时机制，`3PC`同时在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

# 三.CAP

分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a14268b3-b937-4ffa-a34a-4cc53071686b.jpg)

## 一致性

一致性指的是**多个数据副本是否能保持一致**的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。

对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。

## 可用性

可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。

**在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。**

## 分区容忍性

网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。

在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。

## 权衡

在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。

可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，

- 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；
- 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。

## 权衡关系的理解

一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。

当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。

提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。

然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。

总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。

# 四.BASE

BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。

BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

## 基本可用

**指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。**

例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。

## 软状态

指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。

## 最终一致性

最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。

ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。

在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。

# 五.Paxos

# 六.Raft

Raft 也是分布式一致性协议，主要是用来竞选主节点。

## 单个Candidate的竞选

有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。

- 下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118015898.gif)



- 此时 Node A 发送投票请求给其它所有节点。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118445538.gif)



- 其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118483039.gif)



- 之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118640738.gif)

## 多个Candidate的竞选

- 如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119203347.gif)



- 由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119368714.gif)

## 数据同步

- 来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/71550414107576.gif)



- Leader 会把修改复制到所有 Follower。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/91550414131331.gif)



- Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/101550414151983.gif)



- 此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111550414182638.gif)---
title: 判断二分图
date: 2020-06-29 09:55:29
tags: leetcode
categories: leetcode
---

# [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

**题目描述：**

给定一个无向图graph，当这个图为二分图时返回true。

如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。

graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。

```
示例 1:
输入: [[1,3], [0,2], [1,3], [0,2]]
输出: true
解释: 
无向图如下:
0----1
|    |
|    |
3----2
我们可以将节点分成两组: {0, 2} 和 {1, 3}。


示例 2:
输入: [[1,2,3], [0,2], [0,1,3], [0,2]]
输出: false
解释: 
无向图如下:
0----1
| \  |
|  \ |
3----2
我们不能将节点分割成两个独立的子集。
```





## 深度优先着色(递归)

**算法思想：**

- 用一个map来存储每个节点的着色情况，如果着色出现冲突，则表示不可以

```
	private Map<Integer,Integer> map;

    private boolean[] memo;

    public boolean isBipartite(int[][] graph) {
        if(graph==null||graph.length==0) return true;
        map=new HashMap<>();
        int len=graph.length;
        memo=new boolean[len];
        //由于可能有多个连通分量，所以外层要循环
        for(int i=0;i<len;i++){
            if(!memo[i]){
            	//第一个颜色可以随便给定
                map.put(i,0);
                if(!dfs(graph,i))
                    return false;
            }
        }
        return true;
    }

    private boolean dfs(int[][] graph,int i){
        int k=map.get(i);
        memo[i]=true;
        for(int num:graph[i]){
            if(!map.containsKey(num)){
                map.put(num,1-k);
                if(!dfs(graph,num))
                    return false;
            }
            else if(map.get(num)==k)
                return false;
        }
        return true;
    }
```

---
title: 剪绳子
date: 2020-05-29 10:13:19
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。





**注意：动态规划时不能直接递推，例如memo[1]=1,memo[2]=1，结果得出memo[3]=1**，原因是因为递推时确定了每一段都必须分成两份，所以memo[2]=1，其实计算memo[3]时，使用的1*2，所以对于target之前的memo元素，需要用上值本身。

```
public int cutRope(int target) {
        if(target==1) return 1;
        int[] memo=new int[target+1];
        memo[1]=1;
        for(int i=2;i<=target;i++){
            int max;
            if(i==target){
                max=0;
            }else{
            	//从i开始
                max=i;
            }
            for(int j=1;j<=i/2;j++){
                int num=memo[j]*memo[i-j];
                if(num>max) max=num;
            }
            memo[i]=max;
        }
        return memo[target];
    }
```

---
title: 反转链表
date: 2020-05-22 16:06:56
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

输入一个链表，反转链表后，输出新链表的表头。



## 递归

递归函数可以这样设计：以反转链表1->2->3->4->5为例，先将头节点单独拿出来，然后递归反转剩下的2->3->4->5，然后将后面链表的头节点2指向原头节点1可以得到最终结果**(注意要将两个链断开)**。

```
public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        return helper(head);
    }
    private ListNode helper(ListNode head){
        if(head==null||head.next==null) return head;
        //用node记录头节点之后的一个节点，然后将两个链断开
        ListNode node=head.next;
        head.next=null;
        //递归反转后一条链，此时返回的节点作为新的链表头节点返回
        ListNode newHead = helper(node);
        //node节点指向原链表头节点的后一个节点，反转后变成后面链表的最后一个节点，令其指向原头节点
        node.next=head;
        return newHead;
    }
```



## 头插法

```
public ListNode ReverseList(ListNode head) {
        if(head==null) return null;
        ListNode p=head,q=head.next;
        ListNode node=new ListNode(0);
        while(p!=null){
            p.next=node.next;
            node.next=p;
            p=q;
            if(q==null) break;
            q=q.next;
        }
        return node.next;
    }
```

---
title: 合并k个排序链表
date: 2020-05-30 21:36:51
tags: leetcode
categories: leetcode
---

# [23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

示例:

输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```





## 分治法

**算法思想：**

- 将数组分成两部分，分别合并之后再将两个链表合并即可。

```
public ListNode mergeKLists(ListNode[] lists) {
        return mergeHelper(lists,0,lists.length-1);
    }
	
    private ListNode mergeHelper(ListNode[] lists,int left,int right){
        if(left>right) return null;
        if(left==right) return lists[left];
        int mid=left+(right-left)/2;
        ListNode L=mergeHelper(lists,left,mid);
        ListNode R=mergeHelper(lists,mid+1,right);
        return mergeTwoLists(L,R);
    }

    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null&&l2==null) return null;
        if(l1==null) return l2;
        if(l2==null) return l1;
        ListNode p=l1,q=l2;
        ListNode head=new ListNode(0);
        ListNode tail=head;
        while(p!=null&&q!=null){
            if(p.val<=q.val){
                tail.next=p;
                p=p.next;
            }else{
                tail.next=q;
                q=q.next;
            }
            tail=tail.next;
        }
        if(p!=null) tail.next=p;
        if(q!=null) tail.next=q;
        return head.next;
    }
```



**时间复杂度的推导：**

假设数组大小为n，及有n个链表合并，其中链表最大长度为L，则根据分治法有T(n)=2*T(n/2)+n\*L

**其中合并的时间复杂度为n\*L是因为T(n)中是一般数组和另一半数组的合并，即n/2\*L**

---
title: 和为S的连续正数序列
date: 2020-05-24 10:49:02
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

## 输出描述:

```
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
```



第二次写的时候想出来的方法，更容易理解。

从1开始依次计算以每一个数作为开头能否求出和为S，如果能就加入。

```
public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
       ArrayList<ArrayList<Integer>> res=new ArrayList<>();
        for(int i=1;i<=sum/2;i++){
            find(i,sum,new ArrayList(),res);
        }
        return res;
    }
    
    private void find(int start,int sum,ArrayList<Integer> list,ArrayList<ArrayList<Integer>> res){
        while(sum>0){
            sum-=start;
            list.add(start);
            start++;
        }
        if(sum==0){
            res.add(new ArrayList(list));
        }
        list.clear();
    }
```

---
title: 复杂链表的复制
date: 2020-05-23 15:03:02
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）



**注意一点：当从map中去取时，如果已经取到了就可以直接返回了，不用再走下面的复制next域和random域。因为当一个节点被加进去以后已经开始走这个过程了。**

```
private Map<RandomListNode,RandomListNode> map=new HashMap<>();
    public RandomListNode Clone(RandomListNode pHead)
    {
        if(pHead==null) return null;
        RandomListNode node=map.get(pHead);
        if(node==null){
            node=new RandomListNode(pHead.label);
            map.put(pHead,node);
            //如果能取到直接返回
        }else return node;
        node.next=Clone(pHead.next);
        node.random=Clone(pHead.random);
        return node;
    }
```

---
title: 奇偶链表
date: 2020-06-03 22:20:51
tags: leetcode
categories: leetcode
---

# [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

**题目描述：**

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。



```
示例 1:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL


示例 2:

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```





# 算法思想：

- 用Ltail来表示奇数节点的尾节点，Rtail表示偶数节点的尾节点，每次插入一个奇数节点时，需要在Ltail的后面插入，但是需要保证偶数节点依旧在其后面，所以有点类似头插法；偶数节点的插入则直接尾插即可。

```
public ListNode oddEvenList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode Head=new ListNode(0);
        ListNode Ltail=Head,Rtail=Head,p=head,next=p.next;
        int i=0;
        while(p!=null){
        	//奇数节点的情况
            if(i%2==0){
            	//类似于头插
                p.next=Ltail.next;
                Ltail.next=p;
                Ltail=p;
            //偶数情况
            }else{
            	//需要特别注意偶数节点第一个插入节点为第一个奇数节点后
                if(Rtail==Head)
                    Rtail=Ltail;
                Rtail.next=p;
                Rtail=p;
            }
            i++;
            p=next;
            if(next==null) break;
            next=next.next;
        }
        //这一步需要特别注意，没有这一步会导致链表成环(因为最后一个节点的next域还是指向其后面那个奇		   数节点)
        Rtail.next=null;
        return Head.next;
    }
```

---
title: 字符串的排列
date: 2020-05-23 15:39:45
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

## 输入描述:

```
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
```



```
public ArrayList<String> Permutation(String str) {
        ArrayList<String> arrs=new ArrayList<>();
        if(str==null||str.length()==0) return arrs;
        helper(arrs,str.toCharArray(),0);
        Collections.sort(arrs);
        return arrs;
    }

    private void helper(ArrayList<String> arrs,char[] chars,int index){
        if(index==chars.length-1){
            String str=new String(chars);
            if(!arrs.contains(str))  arrs.add(str);
        }
        for(int i=index;i<chars.length;i++){
                swap(chars,index,i);
                helper(arrs,chars,index+1);
                swap(chars,index,i);
        }
    }

    private void swap(char[] chars,int i,int j){
        char temp=chars[i];
        chars[i]=chars[j];
        chars[j]=temp;
    }
```

---
title: 孩子们的游戏
date: 2020-05-25 12:16:46
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

如果没有小朋友，请返回-1





用一个boolean数组来记录每个孩子是否被移除，**最后需要遍历数组去寻找其中为false的元素即为所求**

```
public int LastRemaining_Solution(int n, int m) {
        if(n==0||m==0) return -1;
        boolean[] memo=new boolean[n];
        int count=0;
        int i=0;
        int relax=n;
        while(relax>1){
            if(memo[i]) {
                i=(i+1)%n;
                continue;
            }
            if(count==m-1){
                memo[i]=true;
                relax--;
            }
            count=(count+1)%m;
            i=(i+1)%n;
        }
        int res=0;
        while(memo[res]) res++;
        return res;
    }
```

**第二次写错误出现在直接返回了i，最后的i是倒数第二个被移除的孩子，不是结果**

---
layout: w
title: 容器
date: 2020-05-07 21:25:29
tags:	
		- java
		- 容器
categories: 容器
---

常见面试问题：

1. 底层数据结构
2. 增删改查方式
3. 初始容量，扩容方式，扩容时机
4. 线程安全与否
5. 是否允许为null，是否允许重复，是否有序



# 一.概览

容器主要包括 **Collection** 和 **Map** 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。

## Collection

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png)

### 1.Set

- TreeSet：基于**红黑树**实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
- HashSet：基于**哈希表**实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
- LinkedHashSet：具有 HashSet 的查找效率，并且**内部使用双向链表维护元素的插入顺序**。

### 2.List

- ArrayList：基于动态数组实现，支持随机访问。
- Vector：和 ArrayList 类似，但它是线程安全的。
- LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。

### 3.Queue

- LinkedList：可以用它来实现双向队列。
- PriorityQueue：基于**堆**结构实现，可以用它来实现优先队列。

## Map

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208224757855.png)

- TreeMap：基于**红黑树**实现。
- HashMap：基于**哈希表**实现。
- HashTable：和 HashMap 类似，但它是**线程安全**的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
- LinkedHashMap：使用**双向链表**来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

# 二.容器中的设计模式

## 迭代器模式

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png)

Collection **继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象**，通过这个对象就可以迭代遍历 Collection 中的元素。

从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。

```java
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
for (String item : list) {
    System.out.println(item);
}
```

# List

## ArrayList

### 1.概览

因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

**数组的默认大小为 10。**

```java
private static final int DEFAULT_CAPACITY = 10;
```

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208232221265.png)

### 2.扩容

添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 `oldCapacity + (oldCapacity >> 1)`，也就是旧容量的 1.5 倍。

扩容操作需要调用 `Arrays.copyOf()` 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。

```
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

### 3.删除元素

需要**调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上**，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。

```
public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}
```

### 4.序列化

ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。

保存元素的数组 elementData 使用 **transient** 修饰，该关键字声明数组默认不会被序列化。

```java
transient Object[] elementData; // non-private to simplify nested class access
```

ArrayList 实现了 **writeObject()** 和 **readObject()** 来控制**只序列化数组中有元素填充那部分内容**。

```
private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }
```

序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。

```java
ArrayList list = new ArrayList();
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
oos.writeObject(list);
```

### 5.缩容

主动调用ArrayList的trimToSize()方法可以将数组大小设置为数组中元素的个数。

```
public void trimToSize() {
        modCount++;
        if (size < elementData.length) {
            elementData = (size == 0)
              ? EMPTY_ELEMENTDATA
              : Arrays.copyOf(elementData, size);
        }
    }
```

### 6.构造方法

```
	public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
    
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
```

**调用ArrayList的无参构造方法，或者是传入的initialCapacity为0时，会构造一个长度为0的空数组，然后在第一次添加元素时，扩容到默认的数组大小也就是10.**

### Fail-Fast

**modCount 用来记录 ArrayList 结构发生变化的次数**。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。

**在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变**，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。

## Vector

Vector默认容量也是10，扩容时有一个 **capacityIncrement** 参数来控制每次增加多少容量，如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的**两倍**。

### 1.同步

它的实现与 ArrayList 类似，但是使用了 **synchronized** 进行同步。

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
```

### 2.扩容

Vector 的构造函数可以传入 **capacityIncrement** 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的**两倍**。

```java
public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}
```

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

**调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0**，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。

```java
public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

public Vector() {
    this(10);
}
```

### 3.与ArrayList的比较

- Vector 是**同步**的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；
- **Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。**

### 4.替代方案

可以使用 `Collections.synchronizedList();` 得到一个线程安全的 ArrayList。

```java
List<String> list = new ArrayList<>();
List<String> synList = Collections.synchronizedList(list);
```

也可以使用 concurrent 并发包下的 **CopyOnWriteArrayList** 类。

```java
List<String> list = new CopyOnWriteArrayList<>();
```

## CopyOnWriteArrayList

### 1.读写分离

写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。

**写操作需要加锁**，防止并发写入时导致写入数据丢失。

写操作结束之后需要把原始数组指向新的复制数组。

```
public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
```

### 适用场景

CopyOnWriteArrayList **在写操作的同时允许读操作**，大大提高了读操作的性能，因此很**适合读多写少**的应用场景。

但是 CopyOnWriteArrayList 有其缺陷：

- **内存占用**：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；
- **数据不一致**：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。

所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。

## LinkedList

### 1.概览

基于**双向链表**实现，使用 Node 存储链表节点信息。

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
}
```

每个链表存储了 first 和 last 指针：

```java
transient Node<E> first;
transient Node<E> last;
```

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png)

### 2.与ArrayList的比较

ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：

- **数组支持随机访问，但插入删除的代价很高**，需要移动大量元素；
- **链表不支持随机访问，但插入删除只需要改变指针**。

## Stack

### 1.概览

**Stack继承自Vector类，因此也是线程安全的。**

# Queue

Queue接口定义了队列数据结构，元素是有序的(按插入顺序)，先进先出。

![RNxU4LTi623taOI.png](https://i.loli.net/2020/05/08/RNxU4LTi623taOI.png)

## DeQueue

DeQueue(Double-ended queue)为接口，继承了Queue接口，创建**双端队列**，灵活性更强，可以前向或后向迭代，在队头队尾均可心插入或删除元素。它的两个主要实现类是ArrayDeque和LinkedList。

### ArrayDequeue

- 其是用**循环数组**实现的双端队列。

## PriorityQueue(底层用数组实现堆)

优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。 而优先队列每次拿数据的时候都会拿出优先级最高的数据。

优先队列内部维护着一个堆，**每次取数据的时候都从堆顶拿数据（堆顶的优先级最高）**，这就是优先队列的原理。

**其默认为小根堆。**

**总结与同步相关的问题：**

- PriorityQueue是一个**线程不安全**的类，如果要在多线程环境下使用，可以使用 **PriorityBlockingQueue** 这个优先阻塞队列。其中add、poll、remove方法都使用 **ReentrantLock 锁**来保持同步，take() 方法中如果元素为空，则会一直保持阻塞。

# Map

## HashMap

以下以JDK1.7为例：

### 1.存储结构

内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208234948205.png)

```
transient Entry[] table;
```

```
static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    int hash;
}
```

### 2.put()操作

```java
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 键为 null 单独处理
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    // 头插法插入新键值对
    addEntry(hash, key, value, i);
    return null;
}
```

**HashMap 允许插入键为 null 的键值对**。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。**HashMap 使用第 0 个桶存放键为 null 的键值对。**

```java
private V putForNullKey(V value) {
    for (Entry<K,V> e = table[0]; e != null; e = e.next) {
        if (e.key == null) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(0, null, value, 0);
    return null;
}
```

从上面的putForNullKey(V value)方法中可以看出HashMap中只能存放一个键为null的键值对(新添加进来的键为null的键值对会替换之前的)，值无要求，可以任意取值，取null也可以。

使用链表的**头插法**，也就是新的键值对插在链表的头部，而不是链表的尾部。

```java
void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size >= threshold) && (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }
    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
    // 头插法，链表头部指向新的键值对
    table[bucketIndex] = new Entry<>(hash, key, value, e);
    size++;
}

Entry(int h, K k, V v, Entry<K,V> n) {
    value = v;
    next = n;
    key = k;
    hash = h;
}
```

### 3.确定桶下标

很多操作都需要先确定一个键值对所在的桶下标。

```java
int hash = hash(key);
int i = indexFor(hash, table.length);
```

**3.1 计算 hash 值**

```java
final int hash(Object k) {
    int h = hashSeed;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}

//Entry中的hashcode()方法
public final int hashCode() {
    return Objects.hashCode(key) ^ Objects.hashCode(value);
}
```

**3.2 取模**

令 x = 1<<4，即 x 为 2 的 4 次方，它具有以下性质：

```
x   : 00010000
x-1 : 00001111
```

令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：

```
y       : 10110010
x-1     : 00001111
y&(x-1) : 00000010
```

这个性质和 y 对 x 取模效果是一样的：

```
y   : 10110010
x   : 00010000
y%x : 00000010
```

我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。

确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，**如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算**。

```java
static int indexFor(int h, int length) {
    return h & (length-1);
}
```

### 4.扩容-基本原理

设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。

为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。

和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。

| 参数       | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| capacity   | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。 |
| size       | **键值对数量**。                                             |
| threshold  | size 的**阈值**，当 size 大于等于 threshold 就必须进行扩容操作。 |
| loadFactor | 装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。 |

```java
static final int DEFAULT_INITIAL_CAPACITY = 16;

static final int MAXIMUM_CAPACITY = 1 << 30;

static final float DEFAULT_LOAD_FACTOR = 0.75f;

transient Entry[] table;

transient int size;

int threshold;

final float loadFactor;

transient int modCount;
```

从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的**两倍**。

```java
void addEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
    table[bucketIndex] = new Entry<>(hash, key, value, e);
    if (size++ >= threshold)
        resize(2 * table.length);
}
```

扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。

```java
void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable);
    table = newTable;
    threshold = (int)(newCapacity * loadFactor);
}

void transfer(Entry[] newTable) {
    Entry[] src = table;
    int newCapacity = newTable.length;
    for (int j = 0; j < src.length; j++) {
        Entry<K,V> e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry<K,V> next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
```

### 5.扩容-重新计算桶下标

在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。

假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：

```html
capacity     : 00010000
new capacity : 00100000
```

对于一个 Key，它的哈希值 hash 在第 5 位：

- 为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；
- 为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。

### 6.计算数组容量

HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。

先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：

```
mask |= mask >> 1    11011000
mask |= mask >> 2    11111110
mask |= mask >> 4    11111111
```

mask+1 是大于原始数字的最小的 2 的 n 次方。

```
num     10010000
mask+1 100000000
```

以下是 HashMap 中计算数组容量的代码：

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

### 7.链表转红黑树

从 JDK 1.8 开始，一个桶存储的**链表长度大于等于 8 时**会将链表转换为红黑树。

### 8.与Hashtable的比较

- **Hashtable 使用 synchronized 来进行同步。**
- **HashMap 可以插入键为 null 的 Entry，而Hashtable的键和值都不能是null。**
- HashMap 的迭代器是 fail-fast 迭代器。
- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。

### 9.HashMap并发情况下的成环原因

**hashmap成环原因的代码出现在transfer代码中，也就是扩容之后的数据迁移部分，代码如下：**

```
void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}
```

解释一下transfer的过程：

**首先获取新表的长度，之后遍历新表的每一个entry，然后每个ertry中的链表，以反转的形式，形成rehash之后的链表。**

**并发问题：**

**若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next = new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。**

## ConcurrentHashMap

### 1.存储结构

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209001038024.png)

```java
static final class HashEntry<K,V> {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry<K,V> next;
}
```

ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。

Segment 继承自 ReentrantLock。

```java
static final class Segment<K,V> extends ReentrantLock implements Serializable {

    private static final long serialVersionUID = 2249069246763182397L;

    static final int MAX_SCAN_RETRIES =
        Runtime.getRuntime().availableProcessors() > 1 ? 64 : 1;

    transient volatile HashEntry<K,V>[] table;

    transient int count;

    transient int modCount;

    transient int threshold;

    final float loadFactor;
}

final Segment<K,V>[] segments;
```

默认的并发级别为 16，也就是说**默认创建 16 个 Segment**。

```java
static final int DEFAULT_CONCURRENCY_LEVEL = 16;
```

### 2.size操作

每个 Segment 维护了一个 count 变量来统计**该 Segment 中的键值对个数**。

```java
/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;
```

在执行 size 操作时，需要**遍历所有 Segment 然后把 count 累计起来**。

ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。

尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。

如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。

```java
/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */
static final int RETRIES_BEFORE_LOCK = 2;

public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment<K,V>[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            // 超过尝试次数，则对每个 Segment 加锁
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j < segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j < segments.length; ++j) {
                Segment<K,V> seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c < 0 || (size += c) < 0)
                        overflow = true;
                }
            }
            // 连续两次得到的结果一致，则认为这个结果是正确的
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries > RETRIES_BEFORE_LOCK) {
            for (int j = 0; j < segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
```

### 3.JDK1.8的改动

JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。

JDK 1.8 使用了 **CAS 操作**来支持更高的并发度，**在 CAS 操作失败时使用内置锁 synchronized**。

并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。

## LinkedHashMap

```
static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;	//before和after用于维护双向链表
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
}
```



![这里写图片描述](https://camo.githubusercontent.com/f32ce0004748f74cf7587048480d718614ef7458/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303137303531323136303733343237353f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176616e567a64477876646d5635623356662f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374)

### 存储结构

继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>
```

内部维护了一个**双向链表**，用来**维护插入顺序或者 LRU 顺序**。

```java
/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry<K,V> head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry<K,V> tail;
```

**accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序**。

```java
final boolean accessOrder;
```

LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。

```java
void afterNodeAccess(Node<K,V> p) { }
void afterNodeInsertion(boolean evict) { }
```

### afterNodeAccess()

当一个节点被**访问(get()或者是put()中替换旧值)**时，如果 **accessOrder 为 true**，则会将该节点移到链表**尾部**。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么**链表首部就是最近最久未使用的节点**。

```java
void afterNodeAccess(Node<K,V> e) { // move node to last
    LinkedHashMap.Entry<K,V> last;
    if (accessOrder && (last = tail) != e) {
        LinkedHashMap.Entry<K,V> p =
            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
```

### afterNodeInsertion()

在 put 等操作之后执行，当 **removeEldestEntry()** 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。

evict 只有在构建 Map 的时候才为 false，在这里为 true。

```java
void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry<K,V> first;
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}
```

removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。

```java
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;
}
```

### LRU缓存

以下是使用 LinkedHashMap 实现的一个 LRU 缓存：

- 设定**最大缓存空间** MAX_ENTRIES 为 3；
- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；
- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。

```java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}
```

## WeakHashMap

### 存储结构

WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。

WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。

```java
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V>
```

### ConcurrentCache

Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。

ConcurrentCache 采取的是**分代缓存**：

- 经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；
- 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。
- 当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，**当从 longterm 获取到就把对象放入 eden 中**，从而保证经常被访问的节点不容易被回收。
- 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。

```java
public final class ConcurrentCache<K, V> {

    private final int size;

    private final Map<K, V> eden;

    private final Map<K, V> longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap<>(size);
        this.longterm = new WeakHashMap<>(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() >= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
```

# 补充

`Arrays.asList()`方法返回的list集合**不能进行add()和remove()操作**。

原因是**Arrays.asList() 返回java.util.Arrays$ArrayList，也就是Arrays的一个内部类，而不是ArrayList。**Arrays$ArrayList和ArrayList都是继承AbstractList，remove，add等方法在AbstractList中是默认`throw UnsupportedOperationException`而且不作任何操作。---
title: 对称的二叉树
date: 2020-05-25 17:06:55
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。



root是对称的，表示root的左孩子和右孩子是对称的

```
 boolean isSymmetrical(TreeNode pRoot)
    {
        if(pRoot==null) return true;
        return isSymmetrical(pRoot.left,pRoot.right);
    }
    
    boolean isSymmetrical(TreeNode left,TreeNode right){
        if(left==null&&right==null) return true;
        if(left==null||right==null) return false;
        if(left.val!=right.val) return false;
        return isSymmetrical(left.left,right.right)&&isSymmetrical(left.right,right.left);
    }
```

---
title: 常见智力题
date: 2020-06-07 21:31:21
tags: 面试
categories: 面试
---

# 赛马次数

> 有 25 匹马和 5 条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前 3 名。

先把 25 匹马分成 5 组，进行 5 场赛马，得到每组的排名。再将每组的第 1 名选出，进行 1 场赛马，按照这场的排名将 5 组先后标为 A、B、C、D、E。可以知道，A 组的第 1 名就是所有 25 匹马的第 1 名。而第 2、3 名只可能在 A 组的 2、3 名，B 组的第 1、2 名，和 C 组的第 1 名，总共 5 匹马，让这 5 匹马再进行 1 场赛马，前两名就是第 2、3 名。所以总共是 **5+1+1=7** 场赛马。  

A 组：1，**2，3**，4，5
B 组：**1，2**，3，4，5
C 组：**1**，2，3，4，5
D 组：1，2，3，4，5
E 组：1，2，3，4，5

# 用绳子计时 15 分钟

> 给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量 15 分钟。

- 点燃第一条绳子 R1 两头的同时，点燃第二条绳子 R2 的一头；
- 当 R1 烧完，正好过去 30 分钟，而 R2 还可以再烧 30 分钟；
- 点燃 R2 的另一头，15 分钟后，R2 将全部烧完。

# 九球称重

> 有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。

将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。

对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。

# 药丸称重

> 有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。

可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克 / 粒，那么称重结果就会比正常情况下重 0.1 * i 克。

# 得到 4 升的水

> 有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。

可以理解为用若干个 5 和 3 做减法得到 4。

- 不能从 3 做减法得到 4，那么只能从 5 做减法得到 4，即最后一个运算应该为 5 - 1 = 4，此时问题转换为得到 1 升的水；
- 1 升的水可以由 3 做减法得到，3 - 2 = 1，此时问题转换为得到 2 升的水；
- 5 - 3 = 2。

**具体过程：**

1. 将5升的水导入3升杯子，剩下的就是2L
2. 将2L水导入3L杯子中，剩下的空间就是1L
3. 5L水转满之后，将3L杯子倒满还需要1L，就是还剩下4L

# 三个人喝啤酒

> 有三个人去喝酒，老板问都要喝啤酒吗？
> 第一个人：不知道
> 第二个人：不知道
> 第三个人：全都喝啤酒
> 为什么第三个人决定前两个人也喝啤酒？

有一个人不喝，就是老板提问的否定回答，不全都。 前两个人说不知道是因为不知道其他两个人的答案， 既然前面的人都没有否定，就意味着第三个人知道他们会喝。（&& 的短路机制）

---
title: 平方数之和
date: 2020-06-27 20:57:58
tags: leetcode
categories: leetcode
---

# [633. 平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

**题目描述：**

给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 a2 + b2 = c。

```
示例1:

输入: 5
输出: True
解释: 1 * 1 + 2 * 2 = 5
 

示例2:

输入: 3
输出: False
```



## 双指针法

**算法思想：**

- a，b的有效范围只能是从0~Math.sqrt(c)，用双指针分别从左从右逼近

```
public boolean judgeSquareSum(int c) {
        int l=0,r=(int)Math.sqrt(c);
        while(l<=r){
            int num=l*l+r*r;
            if(num==c)
                return true;
            else if(num<c)
                l++;
            else r--;
        }
        return false;
    }
```

---
title: 平衡二叉树
date: 2020-05-24 10:29:17
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

输入一棵二叉树，判断该二叉树是否是平衡二叉树。

在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树



第二次写忘了加上下面的第8，10行。

```
public boolean IsBalanced_Solution(TreeNode root) {
        return treeHeight(root)!=-1;
    }

    private int treeHeight(TreeNode root){
        if(root==null) return 0;
        int left=treeHeight(root.left);
        if(left==-1) return -1;
        int right=treeHeight(root.right);
        if(right==-1) return -1;
        if(Math.abs(left-right)>1) return -1;
        return Math.max(left,right)+1;
    }
```

---
title: 并发
date: 2020-05-04 16:35:00
tags: 
	   - 面试
       - 并发
categories: 并发
---

# 1.并发编程的挑战

## 上下文切换

- CPU通过**时间片分配算法**来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次**上下文切换**。

# 2.java并发机制的底层实现原理

## Volatile的应用

- volatile关键字保证了共享变量的**可见性**。可见性的意思是当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。
- 如果一个字段被声明成volatile，java线程模型保证所有线程看到的这个变量是一致的。

对volatile变量的写操作时，以Lock为前缀的指令引发了以下两件事情：

1. 将当前处理器缓存行的数据写回到系统内存。
2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

## synchronized的实现原理与应用

synchronized可以表现为以下3种形式：

1. 对于**普通同步方法**，锁是当前实例对象。
2. 对于**静态同步方法**，锁是当前类的**Class对象**。
3. 对于**同步方法块**，锁是synchronized括号里匹配的对象。

当线程试图访问同步代码块时，它首先必须获得锁，**退出或抛出异常时必须释放锁**。

### 锁的升级与对比

在java SE1.6中，锁一共有4种状态。级别从高到低依次是：**无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态**。

**锁可以升级但是不可以降级。**

#### java对象头

synchronized使用的锁是存在java对象头中的。

在运行期间，Java对象头的Mark Word里储存的数据是会随着锁的标志位的变化而变化的。

![img](https://user-gold-cdn.xitu.io/2019/11/8/16e4ad75b4f1ed7b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

synchronized锁膨胀过程：

![img](https://user-gold-cdn.xitu.io/2019/11/8/16e4aab8de83ece5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 偏向锁

HotSpot的作者研究发现，大多数情况下，不但没有锁竞争，而且总是由同一个线程多次获取到锁。因为引入了偏向锁。当一个线程访问同步块的时候，通过CAS操作获取到锁的时候，会在**对象头**和栈帧中的锁记录里面存入**锁偏向的线程ID**。后面该线程进入和退出的时候不需要在进行CAS操作，只需要比较线程对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功则直接获取到锁，如果失败，则比较对象头的标识是不是1（表示当前是偏向锁），如果是1，则尝试使用CAS把对象头的偏向锁指向当前线程，否则使用CAS竞争。

偏向锁的撤销

- 当有其他线程来竞争锁的时候，持有偏向锁的线程才会进行撤销。
- 这种撤销必须要等到全局安全点。
- 具体的步骤
  - 暂停当前持有偏向锁的线程
  - 如果该线程不处于活动状态，则直接把对象头设置成无锁状态
  - 如果该线程仍然活着，拥有偏向锁的栈会被执行，栈中的锁记录和对象头的Mark Word要么偏向于其他线程，要么恢复或者标记对象不适合偏向锁。最终唤醒暂停的线程，**升级成轻量级锁**。

#### 轻量级锁

- 轻量级锁的加锁：

  在线程执行代码块的时候，Jvm会在当前线程的栈帧中创建用于储存锁记录的空间，并且把对象头中的 MarkWord复制到锁记录中。然后线程尝试使用CAS**将对象头中的MarkWord替换成指向锁记录的指针**。如果成功，则当前线程获取到锁；如果失败，则表示其他线程竞争成功，当前线程便通过尝试使用**自旋**来获取锁。**当自旋达到一定阀值的时候就会升级成重量级锁**。

- 轻量级锁的解锁：

  轻量级锁解锁的时候，会使用原子的CAS操作将Mark Word替换回到对象头，如果成功则表示没有竞争关系，如果失败，则表示锁存在竞争，锁就会膨胀成重量级锁。

### 锁的优缺点

|    锁    | 优点                                                         | 缺点                                              | 适用场景                       |
| :------: | :----------------------------------------------------------- | :------------------------------------------------ | :----------------------------- |
|  偏向锁  | **加锁和解锁不需要额外的消耗**，和非同步块只有纳秒级别的差距 | 如果存在线程竞争，会带来额外的锁撤销消耗          | 使用于一个线程访问同步块       |
| 轻量级锁 | 竞争的线程不会阻塞，提高线程的响应速度                       | 如果始终得不到锁竞争的线程，是使用**自旋消耗CPU** | 追求响应 同步块执行速度非常快  |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | **线程阻塞**，响应时间缓慢                        | 追求吞吐量，同步块执行速度较长 |

## 原子操作的原理

- **CAS**(Compare and Swap)操作：CAS操作需要输入一个旧值和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。

处理器提供**总线锁定**和**缓存锁定**来保证复杂内存操作的原子性。

1. **总线锁定：**使用处理器提供的一个**LOCK #信号**，当一个处理器在总线上输出此信号时，其他处理器的请求被阻塞住，那么该处理器可以独占共享内存。
2. **缓存锁定：**内存区域如果缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK #信号，而是修改内部的内存地址。

java中实现原子操作

- 在java中可以通过**锁**和**循环CAS**的方式来实现原子操作

```
private void safeCount() {
        for(;;){					循环CAS
            int i=atomicInteger.get();
            boolean b = atomicInteger.compareAndSet(i, ++i);
            if(b) break;
        }
    }
```

CAS的问题：

1. **ABA问题：**如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查是会判定其值没有发生改变。

   ABA问题可以通过添加一个版本号来解决

JVM实现锁的方式都用到了**循环CAS**，即当一个线程进入同步块时使用循环CAS的方式来获取锁，当它退出同步块时使用循环CAS释放锁。

# 3.java内存模型(JMM)

- 在执行程序时，为了提高性能，编译器和处理器常常会对指令做**重排序**。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的**内存屏障**指令。

## happens-before

在JMM中，**如果一个操作执行的结果需要对另一个操作可见**，那么这两个操作之间必须要存在happens-before关系。

happens-before规则如下：

1. **程序顺序规则：**一个线程中的每个操作，happens-before于该线程中的任意后续操作。
2. **监视器锁规则：**对于一个锁的解锁，happens-before于随后对这个锁的加锁。
3. **volatile变量规则：**对一个volatile变量域的写，happens-before于任意后续对这个volatile域的读。
4. **传递性：**如果A happens-before B，且B happens-before C，则A happens-before C。
5. **start()规则：**如果线程A执行操作ThreadB.start()(启动线程B),那么A线程的ThreadB.start() happens-before于线程B中的任意操作。
6. **join()规则：**如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从**ThreadB.join()操作成功返回**。

> 两个操作具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行。happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，而且第一个操作的执行顺序排在第二个操作前面。

## 重排序

### 数据依赖性

如果两个操作访问同一个变量，且**这两个操作中有一个为写操作**，此时这两个操作之间就存在**数据依赖性**。

编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序。

### as-if-serial语义

as-if-serial的语义是，不管怎么重排序，单线程程序执行的结果不能被改变。

为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。

## volatile的内存语义

volatile变量自身具有下列特性：

1. **可见性：**对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入
2. **原子性。**对任意单个volatile变量的读/写具有原子性，但**类似于volatile++这样的复合操作不具有原子性**。

- 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。
- 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量

volatile写/读建立的happens-before关系：

```
	int a=0;
    volatile boolean flag=false;

    public void writer(){
        a=1;                //1
        flag=true;          //2
    }

    public void reader(){
        if(flag){           //3
            int i=a;        //4
        }
    }
```

根据程序次序规则：1 happens-before 2；3 happens-before 4

根据volatile规则：2 happens-before 3

所以根据传递性有1 happens-before 4

## 锁的内存语义

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。

当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而被监视器(锁)保护的临界区代码只能从主内存中读取共享变量。

## 双重检查锁定

可以通过volatile变量来实现延迟初始化：

```
	private volatile static Instance instance;      //必须要volatile修饰

    public static Instance getInstance(){
        if(instance==null){
            synchronized (SelfDoubleCheckedLocking.class){
                if(instance==null){
                    instance=new Instance();
                }
            }
        }
        return instance;
    }
```

基于类初始化的解决方案：

```
public class InstanceFactory {
    private static class InstanceHolder{
        public static Instance instance=new Instance();
    }

    public static Instance getInstance(){
        return InstanceHolder.instance;			//这里导致InstanceHolder被初始化
    }
}
```

以上是因为虚拟机会保证一个类的 \<clinit>() 方法在多线程环境下被正确的加锁和同步，**如果多个线程同时初始化一个类，只会有一个线程执行这个类的 \<clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 \<clinit>() 方法完毕**。

# 4.java并发编程基础

## 线程的状态

![1553672445387.png](https://i.loli.net/2020/05/12/5SDPmyvWaqLnATO.png)

### 新建 new

* 当线程被创建时会短暂地处于这种状态，尚未启动
* 此时 JVM 为其分配了必须的系统资源并执行了初始化

### 就绪 Runnable

* 包含了操作系统线程状态中的 **Running 和 Ready**，可能正在运行，也可能正在等待 CPU 时间片
* 在 Ready 状态下，只要调度器分配时间片给线程，线程就可以运行

### 阻塞 Blocked

* 线程能够运行，但是存在某个条件阻止其运行
* 调度器将忽略该线程，不会分配给其任何 CPU 时间，直至转换为就绪状态
* 等待获取一个排它锁，如果其线程释放了锁就会结束此状态

### 等待 Waiting

等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。

| 进入方法                                    | 退出方法                             |
| ------------------------------------------- | ------------------------------------ |
| 没有设置 Timeout 参数的 Object.wait () 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join () 方法 | 被调用的线程执行完毕                 |
| LockSupport.park () 方法                    | LockSupport.unpark(Thread)           |

### 超时等待 Timed Waiting

无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

* 调用 Thread.sleep () 方法使线程进入限期等待状态时，常常用 “使一个线程睡眠” 进行描述

* 调用 Object.wait () 方法使线程进入限期等待或者无限期等待时，常常用 “挂起一个线程” 进行描述

睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。

阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep () 和 Object.wait () 等方法进入。

| 进入方法                                  | 退出方法                                          |
| ----------------------------------------- | ------------------------------------------------- |
| Thread.sleep () 方法                      | 时间结束                                          |
| 设置了 Timeout 参数的 Object.wait () 方法 | 时间结束 / Object.notify () / Object.notifyAll () |
| 设置了 Timeout 参数的 Thread.join () 方法 | 时间结束 / 被调用的线程执行完毕                   |
| LockSupport.parkNanos () 方法             | LockSupport.unpark(Thread)                        |
| LockSupport.parkUntil () 方法             | LockSupport.unpark(Thread)                        |

### 终止 Terminated

* 此时线程不再是可调度的，再也不会得到 CPU 时间
* 可以是线程结束任务之后自己结束，**或者产生了异常而结束**

## 守护线程(Daemon线程)

- Daemon线程是一种支持型线程，因为他主要被用作程序中后台调度以及支持型工作。
- 当java虚拟机中**不存在非Daemon线程时**，java虚拟机就会退出，同时会杀死所有守护线程。
- 可以通过**Thread.setDaemon(true)**将线程设置为Daemon线程。

## 等待/通知的经典范式

- 等待方的伪代码为：

  ```
  synchronized(对象){
  	while(条件不满足){
  		对象.wait();
  	}
  	对应的处理逻辑
  }
  ```

- 通知方的伪代码为：

  ```
  synchronized(对象){
  	改变条件
  	对象.notifyAll();
  }
  ```

例如：

```
//等待方
static class wait implements Runnable{
        @Override
        public void run() {
            synchronized (lock){
                while (flag){
                    try {
                        System.out.println("wait锁住了");
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("wait醒过来了");
            }
        }
    }
//通知方
    static class Notify implements Runnable{
        @Override
        public void run() {
            synchronized (lock){
                System.out.println("notify工作");
                flag=false;
                lock.notify();
                System.out.println("notify工作完毕");
            }
        }
    }
```

在实际中，等待方也可以成为通知方，通知方也可以成为等待方

## 常见方法

### join()方法

- 如果线程A执行了thread.join()方法，其含义是：当前线程A必须等待thread线程终止之后才能从thread.join()返回

### ThreadLocal的使用

- ThreadLocal即线程变量，是一个以ThreadLocal对象为键，任意对象为值得存储结构。
- 一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上得一个值

# 5.java中的锁

Lock中常见的方法：

| 方法名称                                  | 描述                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| void lock()                               | 获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。 |
| void lockInterruptibly()                  | 获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和lock()方法不同的是**在锁的获取中可以中断当前线程**（响应中断）。 |
| Condition newCondition()                  | 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁。 |
| boolean tryLock()                         | 只有在调用时才可以获得锁。如果可用，则**获取锁定**，并**立即**返回值为true；如果锁不可用，则此方法将立即返回值为false 。 |
| boolean tryLock(long time, TimeUnit unit) | 超时获取锁，当前线程在一下三种情况下会返回： 1. 当前线程在超时时间内获得了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false. |
| void unlock()                             | 释放锁。                                                     |

**Lock接口提供的synchronized关键字不具备的主要特性：**

| 特性                                          | 描述                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| 尝试**非阻塞**地获取锁(tryLock())             | 当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 |
| 能被中断地获取锁(lockInterruptibly())         | 获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 |
| 超时获取锁(tryLock(long time, TimeUnit unit)) | 在指定的截止时间之前获取锁， 超过截止时间后仍旧无法获取则返回 |

## 队列同步器(AQS)

- 队列同步器AbstractQueuedSynchronizer，使用了一个**int成员变量表示同步状态**，通过内置的FIFO队列来完成资源获取线程的排队工作。

同步器的设计是基于**模板方法模式**

### 队列同步器实现分析

#### 同步队列

- 同步器的实现依赖于内部的**同步队列**(一个FIFO双向队列)，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点并加入同步队列。

![image-20200429160459478.png](https://i.loli.net/2020/05/23/9EDLli65pAId2Uu.png)

- 设置尾节点需要用CAS操作
- **首节点是获取同步状态成功的节点**，首节点在释放同步状态时，会唤醒后继节点，而后继节点将在获取同步状态成功时，将自己设置为首节点。因为设置首节点是通过获取同步状态成功的线程来设置的，所以不需要CAS操作

##### 节点状态waitStatus

 这里我们说下Node。Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。

- **CANCELLED**(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。
- **SIGNAL**(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。
- **CONDITION**(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将**从等待队列转移到同步队列中**，等待获取同步锁。
- **PROPAGATE**(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。
- **0**：新结点入队时的默认状态。

注意，**负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用>0、<0来判断结点的状态是否正常**。

##### 独占式同步状态获取和释放

- 通过调用队列同步器的acquire(int arg)方法可以获取同步状态，其源码如下：

```
独占模式下获取同步状态， 既是当前只允许一个线程获取到同步状态

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

上述方法的逻辑是：

1. 首先调用tryAcquire(int arg)方法，如果成功，则表示成功获取同步状态
2. 否则，如果获取失败，先调用addWaiter()方法，方法中会先构造同步节点(**独占式Node.EXCLUSIVE**，同一时刻只能有一个线程成功获取同步状态)，并将它放在**同步队列**的尾部。
3. 然后会调用acquiredQueued()方法，使得节点以死循环的方式获取同步状态。如果获取不到则阻塞节点中的线程。

其中addWaiter()方法如下：

```
private Node addWaiter(Node mode) {
	// 绑定当前线程 创建 Node 节点
    Node node = new Node(Thread.currentThread(), mode);
    // 先尝试快速在尾部添加
    Node pred = tail;
    // 判断同步队列尾节点是否为空
    if (pred != null) {
    	// node 的前置节点指向队列尾部
        node.prev = pred;
        // 将同步队列的 tail 移动指向 node
        if (compareAndSetTail(pred, node)) {
        	// 将原同步队列的尾部后置节点指向 node
            pred.next = node;
            return node;
        }
    }
    // tail为空或者CAS失败则调用enq方法。tail 为空说明同步队列还未初始化
    // 此时调用 enq 完成队列的初始化及 node 入队
    enq(node);
    return node;
}

private Node enq(final Node node) {
	// 循环CAS操作
	// 成功入队后退出
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
        	// 创建 Node, 并将 head 指向该节点
        	// 同时将 tail 指向该节点
        	// 完成队列的初始化
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
        	// node 的前置节点指向队列尾部
            node.prev = t;
            // 将同步队列的 tail 移动指向 node
            if (compareAndSetTail(t, node)) {
            	// 将原同步队列的尾部后置节点指向 node
                t.next = node;
                return t;
            }
        }
    }
}
```



```
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        // 
        for (;;) {
        	// 获取当前节点的前置节点
            final Node p = node.predecessor();
            // 判断前置节点是否为 head 头节点
            // 若前置节点为 head 节点，则再次尝试获取同步状态
            if (p == head && tryAcquire(arg)) {
            	// 若获取同步状态成功
            	// 则将队列的 head 移动指向当前节点
                setHead(node);
                // 将原头部节点的 next 指向为空，便于对象回收
                p.next = null; // help GC
                failed = false;
                // 退出轮询过程
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

```
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
    	// 若前置节点状态为 -1 ，则说明后置节点 node 可以安全挂起了
        return true;
    if (ws > 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        do {
        	// ws > 0 说明前置节点状态为 CANCELLED , 也就是说前置节点为无效节点
        	// 此时从前置节点开始向队列头节点方向寻找有效的前置节点
        	// 此操作也即是将 CANCELLED 节点从队列中移除
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don't park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        // 若前置节点状态为初始状态 则将其状态设为 -1
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
```

其中**waitStatus** 节点的等待状态，可取值如下 :

- 0 : 初始状态
- -1 : SIGNAL 处于该状态的节点，说明其后置节点处于等待状态； 若当前节点释放了锁可唤醒后置节点
- -2 : CONDITION 该状态与 Condition 操作有关后续在说明
- -3 : PROPAGATE 该状态与共享式获取同步状态操作有关后续在说明
- 1 : CANCELLED 处于该状态的节点会取消等待，从队列中移除

```
private final boolean parkAndCheckInterrupt() {
	// 将当前线程挂起
    LockSupport.park(this);
    // 被唤醒后检查当前线程是否被挂起
    return Thread.interrupted();
}
```

从 acquireQueued 的实现可以看出，节点在入队后会采用轮询的方式（自旋）重复执行以下过程：

- 判断前置节点是否为 head， 若为 head 节点则尝试获取同步状态； 若获取同步状态成功则移动 head 指向当前节点并退出循环
- 若前置节点非 head 节点或者获取同步状态失败，则将前置节点状态修改为 -1， 并挂起当前线程，等待被唤醒重复执行以上过程

如下图所示：



![AQS-节点自旋活动图](https://user-gold-cdn.xitu.io/2018/11/27/167543bc86ada28d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态后，会唤醒后继节点。

```
public final boolean release(int arg) {
	// 尝试释放同步状态
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
        	// 唤醒后置节点
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

##### 共享式同步状态获取与释放

- 共享式获取与独占式获取最主要的区别在于**同一时刻能否有多个线程同时获取到同步状态**。例如文件读就是共享式

通过调用同步器的**acquireShared(int arg)**方法可以共享式地获取同步状态

```
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
    	// 获取锁失败
        doAcquireShared(arg);
}

private void doAcquireShared(int arg) {
	// 不同于独占模式下，创建的节点模式不同
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                	// 不同独占模式
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

tryAcquireShared(arg)返回值大于等于0时，表示能够获取到同步状态

```
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);
    
    // 若 progagate > 0 说明可继续向下传播唤醒节点
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
```

从 doAcquireShared 实现可以看出，共享模式下同步队列的节点在自旋的过程与独占模式基本类似，不同在于自旋过程中成功获取同步状态时的处理。

从 setHeadAndPropagate 的实现我们可以看出在移动 head 节点之后，若满足继续往下传播唤醒的条件时将会调用 doReleaseShared 方法。

 

共享锁的释放：

```
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
    	// 释放同步状态
        doReleaseShared();
        return true;
    }
    return false;
}



private void doReleaseShared() {   
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
            	// 将 head 节点状态重置为 0
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                // CAS 成功则唤醒下个节点
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        // 头节点指向未发生变化的时候 退出循环
        if (h == head)                   // loop if head changed
            break;
    }
}
```

共享式的releaseShared方法与独占式的主要区别在于：共享式锁的释放可能有多个线程同时释放，所以必须用循环CAS操作来保证安全释放。

## 重入锁(ReentrantLock)

- 重入锁就是可以支持重进入的锁，它表示锁能够支持一个线程对资源的重复加锁
- **在重入锁中，同步状态表示的是锁被一个线程重复获取的次数**。
- synchronized关键字隐式的支持重进入。

### 支持重进入

实现重进入需要解决以下两个问题：

1. **支持重进入。**锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。
2. **锁的最终释放。**线程重复n次获取了锁，随后在第n次释放锁后，其他线程能够获取到锁。锁的最终释放要求锁对于获取进行计数自增，**计数表示当前锁被重复获取的次数**，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。

```
final boolean nonfairTryAcquire(int acquires) {
            Thread current = Thread.currentThread();
            int c = this.getState();
            if (c == 0) {
                if (this.compareAndSetState(0, acquires)) {
                    this.setExclusiveOwnerThread(current);
                    return true;
                }
            } else if (current == this.getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) {
                    throw new Error("Maximum lock count exceeded");
                }

                this.setState(nextc);
                return true;
            }
            return false;
        }
```



```
protected final boolean tryRelease(int releases) {
            int c = this.getState() - releases;
            if (Thread.currentThread() != this.getExclusiveOwnerThread()) {
                throw new IllegalMonitorStateException();
            } else {
                boolean free = false;
                if (c == 0) {
                    free = true;
                    this.setExclusiveOwnerThread((Thread)null);
                }

                this.setState(c);
                return free;
            }
        }
```

如果锁被获取了n次，那么前n-1次tryRelease()操作必须返回false。

### 公平锁与非公平锁的区别

在构造函数中传入true表示是公平锁，false为非公平锁，默认为非公平锁

```
ReentrantLock fairlock=new ReentrantLock(true);			//公平锁
ReentrantLock nofairlock=new ReentrantLock(false);		//非公平锁
```

- 如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对是件顺序，也就是FIFO

公平锁的tryAcquire()方法如下：

```
protected final boolean tryAcquire(int acquires) {
            Thread current = Thread.currentThread();
            int c = this.getState();
            if (c == 0) {
                if (!this.hasQueuedPredecessors() && this.compareAndSetState(0, acquires)) {
                    this.setExclusiveOwnerThread(current);
                    return true;
                }
            } else if (current == this.getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) {
                    throw new Error("Maximum lock count exceeded");
                }

                this.setState(nextc);
                return true;
            }

            return false;
        }
    }
```

与公平锁的唯一区别在于节点的判断条件多了**hasQueuedPredecessors()**，该方法会判断在同步队列中当前节点是否有前驱节点，如果返回true，表示有前驱节点，则需要等待前驱节点获取并释放锁。

- 非公平锁可能会**造成线程"饥饿"**，但**极少线程切换**(因为刚释放的线程很有可能再次获取锁)。

## 读写锁(ReadWriteLock)

- 读写锁的实现是ReentrantReadWriteLock

### 读写锁实现分析

包括读写状态设计，写锁的获取与释放，读锁的获取与释放，锁降级

#### 读写锁状态设计

- 在ReentrantLock中，同步状态表示**锁被一个线程重复获取的次数**。
- 在ReentrantReadWriteLock中，将一个整型变量拆分成两部分，**前16位表示读状态，后16位表示写状态**。其中每个状态表示其被重进入的次数。

![image-20200430101338992.png](https://i.loli.net/2020/05/06/Y1noXNbFQqBcvwC.png)

 通过位运算可以迅速获取读和写的各自状态

假设当前同步状态为S，写状态为S&0x0000FFFF，读状态为**S>>>16(无符号右移)**。当写状态增加1时，S=S+1;当读状态增加1时，S=S+(1<<16)                                                 

#### 写锁的获取与释放

- 如果当前线程获取写锁时，读锁已经被获取或则该线程不是已经已经获取写锁的线程，则当前线程进入等待状态。

```
protected final boolean tryAcquire(int acquires) {
            Thread current = Thread.currentThread();
            int c = this.getState();
            int w = exclusiveCount(c);		//获取写标志位，即后16位
            if (c != 0) {
                if (w != 0 && current == this.getExclusiveOwnerThread()) {
                    if (w + exclusiveCount(acquires) > 65535) {		//判断是否越界
                        throw new Error("Maximum lock count exceeded");
                    } else {
                        this.setState(c + acquires);
                        return true;
                    }
                } else {
                    return false;
                }
            } else if (!this.writerShouldBlock() && this.compareAndSetState(c, c + acquires)) {
                this.setExclusiveOwnerThread(current);
                return true;
            } else {
                return false;
            }
        }
```

获取写锁：

1. 首先会判断状态位c是否为0，如果为0，则表示读锁和写锁都没有被获取过，则CAS获取锁。
2. 如果c不为0，则判断写状态位w，如果w不为0，则判断获取写锁的线程是否是当前线程，如果是，则进一步判断写锁状态位是否会越界，如果会则抛出异常，否则获取写锁成功。
3. 否则c不为0，且w为0，则表示读状态不为0，则获取失败

所以从上面过程可以发现**获取读锁之后不能去获取写锁**(上面c!=0且w=0时表示读标志位不为0，且写标志位为0，返回false，也可以理解为获取读锁的线程可以有很多，如果再去获取写锁，则其他读锁都不能工作了)

写锁的释放和ReentrantLock类似，每次释放减少写状态，当写状态为0时，表示释放成功。

#### 读锁的获取与释放

读锁获取过程的重要部分如下：

```
protected final int tryAcquireShared(int unused) {
	for (;;) {
		int c = getState();
		int nextc = c + (1 << 16);
		if (nextc < c)
			throw new Error("Maximum lock count exceeded");
		if (exclusiveCount(c) != 0 && owner != Thread.currentThread())
			return -1;
		if (compareAndSetState(c, nextc))
			return 1;
	}
}
```

如果当前线程已经获取写锁或者写锁未被获取，则当前线程通过循环CAS来增加读状态。

**从上面可以发现获取写锁之后，同一线程可以去获取读锁。**(在获取读锁时会在获取写锁的线程不是当前线程时才返回-1，如果是同一线程去获取读锁，则会成功)

读锁的释放也是每次减少读状态，减少的值是1<<16

#### 锁降级

锁降级是指**写锁降级为读锁**。具体是指把持住当前拥有的写锁，再获取到读锁，然后释放写锁的过程。(从源码上看，是获取读锁的过程会判断如果写锁是被当前线程获取，则返回1)

ReentrantReadWriteLock不支持锁升级(先获取读锁，再获取写锁，然后释放读锁。(从源码上看，是获取写锁的过程中，只要写状态为0，且读状态不为0就会获取失败)



## LockSupport工具

![img](https://img-blog.csdnimg.cn/20190819121814731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjg1Mjc1,size_16,color_FFFFFF,t_70)

在java6中，增加了park(Object blocker)，park(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，其中**参数blocker是用来标识当前线程在等待的对象**。

**park()方法会响应中断，也就是调用interrupt()方法，park()方法会返回并且不会抛出异常。**

## Condition接口

Condition接口与Object中的监视器方法比较如下：

![image-20200430224800833.png](https://i.loli.net/2020/05/06/pJGh9mowrzCni7t.png)

上面需要注意Object.wait()方法会响应中断



使用Condition接口实现停止/等待：

```
public class BoundedQueue<T> {
    private Object[] items;
    private int addIndex,removeIndex,count;
    private Lock lock=new ReentrantLock();
    private Condition notFull=lock.newCondition();
    private Condition notEmpty=lock.newCondition();

    public BoundedQueue(int size){
        items=new Object[size];
    }

    public void add(T t) throws InterruptedException {
        lock.lock();
        try{
            while (count==items.length) notFull.await();
            items[addIndex]=t;
            if(++addIndex==items.length) addIndex=0;
            ++count;
            notEmpty.signal();
        }finally {
            lock.unlock();
        }
    }

    public T remove() throws InterruptedException {
        lock.lock();
        try{
            while (count==0) notEmpty.await();
            Object item = items[removeIndex];
            if(++removeIndex==items.length) removeIndex=0;
            --count;
            notFull.signal();
            return (T) item;
        }finally {
            lock.unlock();
        }
    }
}
```

注意上面是用的while，而不是if，是为了防止过早或意外的通知，只有条件符合时才能退出循环。



### Condition的实现分析

- ConditionObject是AQS(队列同步器)的内部类
- 每个Condition对象都包含着一个队列(**等待队列**)

#### 等待队列

一个Condition包含一个等待队列，Condition拥有首节点(firstWaiter)和尾节点(lastWaiter)。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部添加到等待队列。

![image-20200501093303274.png](https://i.loli.net/2020/05/06/Lybw1cEpnr3sRJq.png)

#### 等待

- 从队列的角度来看await()方法，当调用await()方法时，相当于同步队列的首节点(获取了锁的节点)移动到了Condition的等待队列中。

await()方法源码如下：

```
public final void await() throws InterruptedException {
            if (Thread.interrupted()) {
                throw new InterruptedException();
            } else {
            	//当前线程加入等待队列
                AbstractQueuedSynchronizer.Node node = this.addConditionWaiter();
                //释放同步状态
                int savedState = AbstractQueuedSynchronizer.this.fullyRelease(node);
                int interruptMode = 0;

                while(!AbstractQueuedSynchronizer.this.isOnSyncQueue(node)) {
                    LockSupport.park(this);
                    if ((interruptMode = this.checkInterruptWhileWaiting(node)) != 0) {
                        break;
                    }
                }

                if (AbstractQueuedSynchronizer.this.acquireQueued(node, savedState) && interruptMode != -1) {
                    interruptMode = 1;
                }

                if (node.nextWaiter != null) {
                    this.unlinkCancelledWaiters();
                }

                if (interruptMode != 0) {
                    this.reportInterruptAfterWait(interruptMode);
                }

            }
        }

```

其中addConditionWaiter()方法如下：

```
private AbstractQueuedSynchronizer.Node addConditionWaiter() {
            if (!AbstractQueuedSynchronizer.this.isHeldExclusively()) {
                throw new IllegalMonitorStateException();
            } else {
            	//找到尾节点
                AbstractQueuedSynchronizer.Node t = this.lastWaiter;
                //如果尾节点为null或者无效，则清除链表中所有失效节点，并重新赋值t
                if (t != null && t.waitStatus != -2) {
                    this.unlinkCancelledWaiters();
                    t = this.lastWaiter;
                }
				//创建新的节点，其状态waitStatus为-2 : CONDITION
                AbstractQueuedSynchronizer.Node node = new AbstractQueuedSynchronizer.Node(-2);
                if (t == null) {
                    this.firstWaiter = node;
                } else {
                    t.nextWaiter = node;
                }
                this.lastWaiter = node;
                return node;
            }
        }
```

# 6.java并发容器和框架

## ConcurrentHashMap

- HashMap在多线程环境下进行put()操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构。
- HashTable使用synchronized来保证线程安全，所以**效率低下**。
- ConcurrentHashMap使用**分段锁技术**。将数据分成一段一段地保存，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

### ConcurrentHashMap的结构

- ConcurrentHashMap由**Segment数组结构**和**HashEntry数组结构**组成，Segment是一种可重入锁(ReentrantLock)，扮演锁的角色。**HashEntry则用于存储键值对数据**。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表的结构。

![img](https://user-gold-cdn.xitu.io/2018/7/23/164c47f35b08fddd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 核心成员

```
   /**
     * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。
     */
    final Segment<K,V>[] segments;

    transient Set<K> keySet;
    transient Set<Map.Entry<K,V>> entrySet;
```

Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：

```
    static final class Segment<K,V> extends ReentrantLock implements Serializable {

        private static final long serialVersionUID = 2249069246763182397L;
        
        // 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶
        transient volatile HashEntry<K,V>[] table;

        transient int count;

        transient int modCount;

        transient int threshold;

        final float loadFactor;
        
	}
```

看看其中 HashEntry 的组成：

![img](https://user-gold-cdn.xitu.io/2018/7/23/164c47f35e216684?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。

#### 构造方法

默认构造函数会调用带三个参数的构造函数

```
public ConcurrentHashMap() {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
    }

    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        if (concurrencyLevel > MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;
        //步骤① start
        int sshift = 0;
        int ssize = 1;
        while (ssize < concurrencyLevel) {
            ++sshift;
            ssize <<= 1;
        }
        this.segmentShift = 32 - sshift;
        this.segmentMask = ssize - 1;
        this.segments=Segments.newArray(ssize);
        //步骤① end
        //步骤② start
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        int c = initialCapacity / ssize;
        if (c * ssize < initialCapacity)
            ++c;
        int cap = MIN_SEGMENT_TABLE_CAPACITY;
        while (cap < c)
            cap <<= 1;
        //步骤② end
        //步骤③ start
        for(int i=0;i<this.segments.lenght)
        	this.segments[i]=new Segment<K,V>(cap,loadFactor);
        //步骤③ end
    }
```

- Segments数组的长度ssize是**大于等于concurrencyLevel的最小的2的N次方值**，之所以选取为2的N次方，是为了后面能通过**按位与**的散列算法来定位segments数组的索引。
- segmentMask是散列运算的掩码，等于ssize-1；segmentShift等于32-sshift，其中sshift为ssize向左移位的次数，也可以看成是ssize是2的多少次方，例如在默认情况下，concurrencyLevel为16，所以sshift为4，segmentShift为28
- 上面的cap就是每个segment中每个HashEntry数组的长度，可以发现其的计算过程是先求出c，c是初始容量平分到每个Segment的大小，然后cap就是大于等于c的最小的2的N次方。



### jdk1.8之后的改进

![ConcurrentHashMap结构图](https://user-gold-cdn.xitu.io/2017/11/3/e6ac01f07ca641a54ff6f17c41a386df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 1.8在1.7的基础上**添加了红黑树**，并且抛弃了原有的Segment分段锁，而**采用了CAS+` synchronized` 来保证并发安全性。**



#### 哈希桶table的初始化

初始化table的工作将发生在**进行put操作时**，如果发现table还没有被初始化，那么就会调用方法initTable来进行table的初始化，下面展示了初始化table的具体流程代码：

```
  private final Node<K,V>[] initTable() {
        Node<K,V>[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            if ((sc = sizeCtl) < 0)
                Thread.yield(); // lost initialization race; just spin
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = tab = nt;
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }
```

- 其中**sizeCtl变量**是一个用于同步多个线程的共享变量，**如果它的当前值为负数，则说明table正在被某个线程初始化或者扩容**，所以，如果某个线程想要初始化table或者对table扩容，需要去竞争sizeCtl这个共享变量，获得变量的线程才有许可去进行接下来的操作。

- Thread.yield()方法是令当前线程让出CPU的执行时间，使其从运行态(Running)变成就绪态(Ready)。
- 上面在CAS操作的前后各有一次table是否为null的检查，也就是**双重检查**，这样是必要的，例如线程1首先通过第一个判断table为null，然后获取了同步状态，在其还未完成初始化的时候，线程2通过了第一次判断table为null，然后在线程1成功初始化并释放同步状态后，其得到了同步状态，那么如果没有第二个table是否为null的判断，则其会再初始化一次，那么发生在这期间的put操作就会被覆盖。



#### get方法

```
  public V get(Object key) {
        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
        int h = spread(key.hashCode());
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (e = tabAt(tab, (n - 1) & h)) != null) {
            if ((eh = e.hash) == h) {
                if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                    return e.val;
            }
            else if (eh < 0)
                return (p = e.find(h, key)) != null ? p.val : null;
            while ((e = e.next) != null) {
                if (e.hash == h &&
                    ((ek = e.key) == key || (ek != null && key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }
```

首先计算出hashCode，然后通过(hashCode&(length-1))得到其在table中的索引，然后判断该位置上是否为null，如果为null，则返回null，否则如果该位置上第一个元素与要查找的记录匹配，则直接返回，否则，如果该节点的hashCode的值小于0，则说明该位置上是一颗红黑树，会调用find()方法来查找；否则表示是链表，则顺序查找。

**get()方法中没有做什么与锁相关的同步操作来做线程同步，其是通过在Node的val域和next域添加volatile来实现线程可见性问题**

```
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        volatile V val;
        volatile Node<K,V> next;
   
        ....
   }
```



#### put方法

- 在put的过程中，可能发现数组还未初始化，则会先调用initTable()方法完成初始化；还有可能发现元素个数超过阈值，则要进行扩容。

```
   public V put(K key, V value) {
        return putVal(key, value, false);
    }
    
 /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh >= 0) {
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }    
```

首先，计算记录的key的hashCode，然后计算table的index位置，然后获取该index的值，如果该位置还为null，说明该位置上还没有记录，则通过调用**casTabAt**方法来讲该新的记录插入到table的index位置上去，否则，**通过synchronized关键字对table的index位置加锁**，需要注意的是，**当前线程只会锁住table的index位置**，其他位置上没有锁住，所以此时其他线程可以安全的获得其他的table位置来进行操作。这也就提高了ConcurrentHashMap的并发度。然后判断table的index位置上的第一个节点的hashCode值，这个节点要么是链表的头节点，要么是红黑树的根节点，如果hashCode值小于0，那么就是一颗红黑树，如果不小于0，那么就还是一条链表，如果是一条链表，那么就寻找是否已经有记录的key和当前想要插入的记录是一致的，如果一致，那么这次put的效果就是replace，否则，将该记录添加到链表中去。如果是一颗红黑树，那么就通过调用putTreeVal方法来进行插入操作。在插入操作完成之后，需要判断本次操作是否是更新操作，如果是更新操作，则不会造成size的变化，否则，如果本次put操作时一次添加操作，那么就需要进行更新size的操作。

**binCount记录的是该索引处的元素个数，如果大于8，则要转换为红黑树。**

**ConcurrentHashMap和HashMap的区别还有一点，就是HashMap允许一个key和value为null，而ConcurrentHashMap则不允许key和value为null**

## ConcurrentLinkedQueue

### 入队列

![image-20200502122346505.png](https://i.loli.net/2020/05/06/o75GmAivlRpuFCX.png)

tail并不总是指向队尾节点，如果tail节点的next节点为空，则将入队节点设置为tail的next节点；如果tail的next节点不为空，则将入队节点设置成tail节点。

```
 public boolean offer(E e) {
        // 检查是否是null，如果是null ，抛出NullPointerException
        checkNotNull(e);
        // 创建一个node 对象，使用  CAS 创建对象
        final Node<E> newNode = new Node<E>(e);
        // 轮询链表节点，知道找到节点的 next 为null，才会进行赋值
        for (Node<E> t = tail, p = t;;) {
            Node<E> q = p.next;
            if (q == null) {
                // 找到null值之后将刚刚创建的值通过CAS放入
                if (p.casNext(null, newNode)) {
                    // 因为 p 遍历在轮询后会变化，因此需要判断，如果不相等，则使用CAS将新节点作为尾部节点。
                    if (p != t)
                        casTail(t, newNode);  // Failure is OK.
                     // 放入成功后返回 ture
                    return true;
                }
            }
            // 轮询后p有可能等于q，此时，就需要对p重新赋值。
            else if (p == q)
                // 这里需要注意一下：判断t != t，是因为并发下可能 tail 被改了，如果被改了，则使用				新的 t，否则从链表头重新轮询。
                p = (t != (t = tail)) ? t : head;
            else
                // 同样，当 t 不等于 p 时，说明 p 在上面被重新赋值了，并且 tail 也被别的线程改				了，则使用新的 tail，否则循环检查p的下个节点
                p = (p != t && t != (t = tail)) ? t : q;
        }
    }
```

### 出队列

![image-20200502142411061.png](https://i.loli.net/2020/05/06/WlFdJve8fys1BrG.png)



## java中的阻塞队列

- **阻塞队列(BlockingQueue)**是一个支持两个附加操作的队列。这两个附加操作支持**阻塞的插入和移除方法**。

  - **阻塞的插入**是指当队列满时，队列会阻塞插入元素的线程，直到队列不满
  - **阻塞的移除**是指当队列为空时，队列会阻塞获取元素的线程，直到队列不空


阻塞队列中对于的操作如下：

![image-20200502143727511.png](https://i.loli.net/2020/05/06/tKNSIdZ9hxYLeup.png)



JDK7提供的7个阻塞队列如下：

1. **ArrayBlockingQueue:数组实现的有界阻塞队列**
2. **LinkedBlockingQueue:链表实现的有界阻塞队列**
3. **PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列**
4. **DelayQueue:一个使用优先级队列实现的无界阻塞队列**
5. **SynchronousQueue:一个不存储元素的阻塞队列**
6. **LinkedTransferQueue:链表实现的无界阻塞队列**
7. **LinkedBlockingDeque:链表实现的双向阻塞队列**

### ArrayBlockingQueue

- 其使用数组实现的一个有界阻塞队列，默认情况下是不公平的，访问的公平性是通过重入锁实现的

```
public ArrayBlockingQueue(int capacity, boolean fair) {
        if (capacity <= 0)
            throw new IllegalArgumentException();
        this.items = new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    }
```

### LinkedBlockingQueue

- 其是用链表实现的有界阻塞队列，默认和最大长度为Integer.MAX_VALUE

### PriorityBlockingQueue

- 其是一个**支持优先级的无界阻塞队列**(通过自定义类实现compareTo()来指定元素排序规则，或者指定Comparator来对元素排序)

### DelayQueue

- 支持**延时获取元素**的**无界阻塞队列**。队列使用PriorityQueue来实现。队列中的元素必须实现**Delayed接口**，在创建元素时指定多久能从队列中获取当前元素。**只有在延迟期满时，才能从队列中提取元素**。

实现Delayed接口需要去实现**getDelay()方法，该方法返回当前元素还要延迟多长时间**；还要实现compareTo()方法，来指定元素的排序

### SynchronousQueue

- 其是一个**不存储元素的队列**，其每一个put操作必须等待一个take操作，否则不能继续添加元素。

### LinkedTransferQueue

- 用链表实现的无界阻塞队列，其与其他队列的不同之处在于多了transfer()和tryTransfer()方法

#### transfer()方法

- 如果当前有消费者正在等待接收元素(消费者使用take()方法或者带有时间限制的poll()方法)，transfer()方法可以把生产者传入的元素立刻传输给消费者。如果没有消费者等待，会将其放在队列的tail节点，并等到被消费者消费了才返回。

#### tryTransfer()方法

- 是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，就会**立即返回**false。



### LinkedBlockingDeque

- 其是用链表组成的**双向阻塞队列**



# 7.java中的13个原子操作类

## 原子更新基本类型

Atomic提供了以下3个类：

1. **AtomicBoolean**：原子更新布尔类型
2. **AtomicInteger：**原子更新整型
3. **AtomicLong：**原子更新长整型

其中AtomicBoolean是先将Boolean转换为Integer，再实现的



# 8.java中的并发工具类

## 等待多线程完成的CountDownLatch

- CountDownLatch允许一个或多个线程等待其他线程完成操作

```
static CountDownLatch downLatch=new CountDownLatch(2);

    public static void main(String[] args) throws InterruptedException {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(1);
                downLatch.countDown();
                System.out.println(2);
                downLatch.countDown();
            }
        }).start();
        downLatch.await();
        System.out.println(3);
    }
```

CountDownLatch的构造函数传入一个int类型参数作为计数器，如果想在N个点等待，就传入N。

CountDownLatch的await()方法会阻塞当前线程。countDown()会使N减一，当N减到0时，阻塞的线程被唤醒。



## 同步屏障CyclicBarrier

- 其作用是让一组线程到达一个屏障时被阻塞，直到最后一个到达屏障时为止，屏障才会开门。
- CyclicBarrier的构造方法传入一个int类型数，表示屏障拦截的线程个数，每个线程调用await()方法表示我已经到达屏障，当前线程被阻塞。



## CountDownLatch和CyclicBarrier的区别

- CountDownLatch的计数器只能用一次，CyclicBarrier的计数器可以使用reset()方法重置



# 9.java中的线程池

**ThreadPoolExecutor**执行execute()方法的示意图如下：

![image-20200502212024375.png](https://i.loli.net/2020/05/06/QJfEKMcpT6bwS1l.png)

1. 如果当前运行的线程少于corePoolSize(核心线程池数目)，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁）。 
2. 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。
3. 如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 
4. 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。

在ThreadPoolExecutor完成预热后(当前线程个数大于核心corePoolSize)，会执行步骤2，这一步骤不需要获取全局锁。

## ThreadPoolExecutor核心参数

### 1.corePoolSize：核心线程个数

- 核心线程会一直存活，即使没有任务需要执行
- **当线程数小于核心线程数时，即使有线程处于空闲状态，线程池也会优先创建新线程处理**
- 设置 allowCoreThreadTimeout = true（默认为 false）时，核心线程会超时关闭。

### 2.maxmumPoolSize：线程池最大数量

- 如果队列已经满了，并且创建的线程数目小于最大线程数量，则线程池会创建新的线程执行任务。
- 如果使用的是无界队列，这个参数没有什么意思

### 3.keepAliveTime：线程空闲时间

- 当线程空闲时间达到 keepAliveTime 时，线程会退出，**直到线程数量等于核心线程数**
- 若 **allowCoreThreadTimeout** = true（允许核心线程超时），则会退出直到线程数量等于零
- 单位为 **unit**（也是一个参数，TimeUnit 类型）

### 4.RunnableTaskQueue：任务队列

任务对垒中存放的是等待执行的任务，所以其泛型是Runnable

可以选择以下几个阻塞队列：

1. ArrayBlockingQueue
2. LinkedBlockingQueue：静态工厂方法Executors.newFixedThreadPool()使用的就是这个队列
3. SynchronizedQueue：静态工厂方法Executors.newCachedThreadPool()使用了这个队列
4. PriorityBlockingQueue

### 5.ThreadFactory：创建线程的工厂

表示生成线程池中工作线程的线程工厂，用户创建新线程，一般使用默认参数即可

### 6.RejectExecutionHandler：饱和策略

- 当线程池和队列都满了以后，采取的处理新提交的任务的策略，有以下4种：
  - **AbortPolicy**：丢弃任务，抛运行时异常
  - **CallerRunsPolicy** ：调用者所在线程来执行任务
  - **DiscardPolicy**：直接丢弃任务，不进行任何处理也不抛出异常
  - **DiscardOldestPolicy**：从队列中踢出最先进入队列（等待最久）的任务，将当前任务加入队列尝试再次提交

## 向线程池中提交任务

两种方法execute()和submit()方法

1. execute()方法用于提交**没有返回值的任务**
2. submit()方法用于提交**有返回值的任务**。线程会返回一个future类似的对象，通过调用future的get()方法来获取返回的结果，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout,TimeUnit unit)则会阻塞一段时间后返回，这时候可能任务还未完成

## 关闭线程池

可以调用线程池的shutdown或shutdownNow方法来关闭线程池。他们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法关闭。

shutdown和shutdownNow的区别为：

1. shutDownNow首先将线程池的状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表
2. shutdown只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程。



# 10.Executor框架



# 补充

## ThreadLocal

### 简介

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？** JDK中提供的`ThreadLocal`类正是为了解决这样的问题。 **`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

**如果你创建了一个`ThreadLocal`变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是`ThreadLocal`变量名的由来。他们可以使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。**

再举个简单的例子：

比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。

### 原理

在Thread类中：

```
public class Thread implements Runnable {
 ......
//与此线程有关的ThreadLocal值。由ThreadLocal类维护
ThreadLocal.ThreadLocalMap threadLocals = null;

//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 ......
}
```

`Thread` 类中有一个 `threadLocals` 和 一个 `inheritableThreadLocals` 变量，它们都是 `ThreadLocalMap` 类型的变量,我们可以把 `ThreadLocalMap` 理解为`ThreadLocal` 类实现的定制化的 `HashMap`。默认情况下这两个变量都是null，只有当前线程调用 `ThreadLocal` 类的 `set`或`get`方法时才创建它们，实际上调用这两个方法的时候，我们调用的是`ThreadLocalMap`类对应的 `get()`、`set()`方法。

`ThreadLocal`类的`set()`方法:

```java
    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
```

**最终的变量是放在了当前线程的 `ThreadLocalMap` 中**

**每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为key ，Object 对象为 value的键值对。**

```java
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
 ......
}
```

### ThreadLocal内存泄漏问题

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用,而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，`ThreadLocalMap` 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 key 为 null 的记录。使用完 `ThreadLocal`方法后 最好手动调用`remove()`方法

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
```

## synchronized和ReentrantLock的比较

**1. 锁的实现**

synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

**2. 性能**

新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。

**3. 等待可中断**

当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

ReentrantLock 可中断，而 synchronized 不行。

**4. 公平锁**

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

**5. 锁绑定多个条件**

一个 ReentrantLock 可以同时绑定多个 Condition 对象。

**如果选择：**

除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。

---
title: 并发基础
date: 2020-05-22 09:16:18
tags: 并发
categories: 并发
---

# 一.使用线程

有三种使用线程的方法(面试就讲两个)：

- 实现 Runnable 接口；
- 实现 Callable 接口；
- 继承 Thread 类。

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。

**Thread实现了Runnable接口。**

## 实现Runnable接口

需要实现接口中的 run() 方法。

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}
```

使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。

```java
public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
```

## 实现Callable接口

与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。

```java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}
```

```
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
```

## 继承Thread类

同样也是需要实现 run() 方法，因为 **Thread 类也实现了 Runable 接口**。

当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。

```java
public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
```

```
public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
```

## 实现接口VS继承Thread

实现接口会更好一些，因为：

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。

# 二.基础线程机制

## Executor

Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

主要有三种 Executor：

- CachedThreadPool：一个任务创建一个线程；
- FixedThreadPool：所有任务只能使用固定大小的线程；
- SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}
```

## Daemon

守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。

**当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。**

main() 属于非守护线程。

在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。

```java
public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
```

## sleep()

Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。

sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

```java
public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

**sleep()方法不会释放锁。**

## yield()

对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

```java
public void run() {
    Thread.yield();
}
```

**调用Thread.yield()方法会使得当前线程从Running状态变成Ready状态，来让其他具有相同优先级的线程获得运行机会。**

# 三.中断

一个线程执行完毕之后会自动结束，**如果在运行过程中发生异常也会提前结束**。

## InterruptedException

通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。

对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。

```java
public class InterruptExample {

    private static class MyThread1 extends Thread {
        @Override
        public void run() {
            try {
                Thread.sleep(2000);
                System.out.println("Thread run");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```
public static void main(String[] args) throws InterruptedException {
    Thread thread1 = new MyThread1();
    thread1.start();
    thread1.interrupt();
    System.out.println("Main run");
}
```

```
Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at InterruptExample.lambda$main$0(InterruptExample.java:5)
    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:745)
```

## interrupted()

如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。

但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。

```
public class InterruptExample {

    private static class MyThread2 extends Thread {
        @Override
        public void run() {
            while (!interrupted()) {
                // ..
            }
            System.out.println("Thread end");
        }
    }
}
```

```
public static void main(String[] args) throws InterruptedException {
    Thread thread2 = new MyThread2();
    thread2.start();
    thread2.interrupt();
}
```

```
Thread end
```

## 线程池的中断操作

调用线程池的 **shutdown() 方法会等待线程都执行完毕之后再关闭**，但是如果调用的是 **shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法**。

以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。

```
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> {
        try {
            Thread.sleep(2000);
            System.out.println("Thread run");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    executorService.shutdownNow();
    System.out.println("Main run");
}
```

```
Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)
    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
```

如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future<?> 对象，通过调用该对象的 **cancel(true) 方法**就可以中断线程。

```
Future<?> future = executorService.submit(() -> {
    // ..
});
future.cancel(true);
```

# 四.互斥同步

Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。

## synchronized

**同步一个静态方法**

```java
public synchronized static void fun() {
    // ...
}
```

**作用于整个类(锁对象是class对象)**。

## ReentrantLock

ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。

```java
public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}
```

```
public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> lockExample.func());
    executorService.execute(() -> lockExample.func());
}
```

```
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

## 比较

**1. 锁的实现**

synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

**2. 性能**

新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。

**3. 等待可中断**

当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

ReentrantLock 可中断，而 synchronized 不行。

**4. 公平锁**

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

**5. 锁绑定多个条件**

一个 ReentrantLock 可以同时绑定多个 Condition 对象。

## 使用选择

除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且**使用 synchronized 不用担心没有释放锁而导致死锁问题**，因为 JVM 会确保锁的释放。

# 五.线程之间的协作

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。

## join()

**在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束**。

对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。

```
public class JoinExample {

    private class A extends Thread {
        @Override
        public void run() {
            System.out.println("A");
        }
    }

    private class B extends Thread {

        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("B");
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}
```

```
public static void main(String[] args) {
    JoinExample example = new JoinExample();
    example.test();
}
```

```
A
B
```

## wait(),notify(),notifyAll()

调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。

它们都属于 Object 的一部分，而不属于 Thread。

**只能用在同步方法或者同步控制块中使用**，否则会在运行时抛出 IllegalMonitorStateException。

**使用 wait() 挂起期间，线程会释放锁**。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。

```
public class WaitNotifyExample {

    public synchronized void before() {
        System.out.println("before");
        notifyAll();
    }

    public synchronized void after() {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("after");
    }
}


public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    WaitNotifyExample example = new WaitNotifyExample();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}


before
after
```

**wait() 和 sleep() 的区别**

- wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
- wait() 会释放锁，sleep() 不会。

## await(),singal(),singalAll()

java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。

相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。

使用 Lock 来获取一个 Condition 对象。

```
public class AwaitSignalExample {

    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void before() {
        lock.lock();
        try {
            System.out.println("before");
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println("after");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}


public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}


before
after
```

# 六.线程状态

一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。

## 创建(NEW)

创建后尚未启动。

## 可运行(Runnable)

正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。

## 阻塞(BLOCKED)

请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。

## 无限期等待(WAITING)

等待其它线程显式地唤醒。

阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。

| 进入方法                                   | 退出方法                             |
| ------------------------------------------ | ------------------------------------ |
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                 |
| LockSupport.park() 方法                    | LockSupport.unpark(Thread)           |

## 限期等待(TIMED_WAITING)

无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

| 进入方法                                 | 退出方法                                        |
| ---------------------------------------- | ----------------------------------------------- |
| Thread.sleep() 方法                      | 时间结束                                        |
| 设置了 Timeout 参数的 Object.wait() 方法 | 时间结束 / Object.notify() / Object.notifyAll() |
| 设置了 Timeout 参数的 Thread.join() 方法 | 时间结束 / 被调用的线程执行完毕                 |
| LockSupport.parkNanos() 方法             | LockSupport.unpark(Thread)                      |
| LockSupport.parkUntil() 方法             | LockSupport.unpark(Thread)                      |

调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。

## 死亡(TERMINATED)

可以是线程结束任务之后自己结束，或者产生了异常而结束。

# 七.JUC-AQS

java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。

## CountDownLatch

用来控制一个或者多个线程等待多个线程。

维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png)

```
public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("run..");
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println("end");
        executorService.shutdown();
    }
}


run..run..run..run..run..run..run..run..run..run..end
```

## CyclicBarrier

用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

和 CountdownLatch 相似，都是通过维护计数器来实现的。**线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。**

CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。

CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties <= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
```

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png)

```java
public class CyclicBarrierExample {

    public static void main(String[] args) {
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("before..");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.print("after..");
            });
        }
        executorService.shutdown();
    }
}

before..before..before..before..before..before..before..before..before..before..after
```

## Semaphore

Semaphore 类似于操作系统中的**信号量**，可以控制对互斥资源的访问线程数。

以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。

```
public class SemaphoreExample {

    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalRequestCount; i++) {
            executorService.execute(()->{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + " ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}


2 1 2 2 2 2 2 1 2 2
```

# 八.JUC-其他组件

## FutureTask

在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。

```java
ublic class FutureTask<V> implements RunnableFuture<V>
    
public interface RunnableFuture<V> extends Runnable, Future<V>
```

FutureTask 可用于**异步**获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。

```
public class FutureTaskExample {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<Integer> futureTask = new FutureTask<Integer>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                int result = 0;
                for (int i = 0; i < 100; i++) {
                    Thread.sleep(10);
                    result += i;
                }
                return result;
            }
        });

        Thread computeThread = new Thread(futureTask);
        computeThread.start();

        Thread otherThread = new Thread(() -> {
            System.out.println("other task is running...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        otherThread.start();
        System.out.println(futureTask.get());
    }
}


other task is running...
4950
```

## BlockingQueue

java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：

- **FIFO 队列** ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）
- **优先级队列** ：PriorityBlockingQueue

提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。

**使用 BlockingQueue 实现生产者消费者问题**

```java
public class ProducerConsumer {

    private static BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);

    private static class Producer extends Thread {
        @Override
        public void run() {
            try {
                queue.put("product");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private static class Consumer extends Thread {

        @Override
        public void run() {
            try {
                String product = queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**注意：**如果将两个类放在一起作为两个内部类，那么就要注意BlockingQueue加上static字段；如果分开，就需要额外定义构造函数。

# 九.java内存模型

Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

## 主内存和工作内存

处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。

加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png)

所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。

线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png)

## 内存间的交互操作

Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png)



- read：把一个变量的值从主内存传输到工作内存中
- load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
- use：把工作内存中一个变量的值传递给执行引擎
- assign：把一个从执行引擎接收到的值赋给工作内存的变量
- store：把工作内存的一个变量的值传送到主内存中
- write：在 store 之后执行，把 store 得到的值放入主内存的变量中
- lock：作用于主内存的变量
- unlock

## 内存模型三大特性

### 1.原子性

Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。

有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。

为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。

下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg)



AtomicInteger 能保证多个线程修改的原子性。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg)

## 2.可见性

可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。

主要有三种实现可见性的方式：

- volatile
- synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。

## 3.有序性

有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过**添加内存屏障**的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

# 十.线程安全

多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。

线程安全有以下几种实现方式：

## 不可变

不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。

不可变的类型：

- final 关键字修饰的基本数据类型
- String
- 枚举类型
- Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。

对于集合类型，可以使用 **Collections.unmodifiableXXX() 方法**来获取一个不可变的集合。

```java
public class ImmutableExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        Map<String, Integer> unmodifiableMap = Collections.unmodifiableMap(map);
        unmodifiableMap.put("a", 1);
    }
}
```

```
Exception in thread "main" java.lang.UnsupportedOperationException
    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
    at ImmutableExample.main(ImmutableExample.java:9)
```

Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。

```java
public V put(K key, V value) {
    throw new UnsupportedOperationException();
}
```

## 互斥同步

synchronized 和 ReentrantLock。

### 非阻塞同步

互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。

互斥同步属于一种**悲观**的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。

#### 1.CAS

乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。

#### 2.AtomicInteger

J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。

以下代码使用了 AtomicInteger 执行了自增的操作。

```java
private AtomicInteger cnt = new AtomicInteger();

public void add() {
    cnt.incrementAndGet();
}
```

以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。

```java
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
```

以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。

**可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。**

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

#### 3.ABA

如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。

J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的**版本**来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。

## 无同步方案

要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。

### 1.栈封闭

多个线程访问同一个方法的**局部变量**时，不会出现线程安全问题，**因为局部变量存储在虚拟机栈中，属于线程私有的**。

```java
public class StackClosedExample {
    public void add100() {
        int cnt = 0;
        for (int i = 0; i < 100; i++) {
            cnt++;
        }
        System.out.println(cnt);
    }
}
```

```
public static void main(String[] args) {
    StackClosedExample example = new StackClosedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> example.add100());
    executorService.execute(() -> example.add100());
    executorService.shutdown();
}



100
100
```

### 2.线程本地缓存

如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。

可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。

对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。

```
public class ThreadLocalExample {
    public static void main(String[] args) {
        ThreadLocal threadLocal = new ThreadLocal();
        Thread thread1 = new Thread(() -> {
            threadLocal.set(1);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(threadLocal.get());
            threadLocal.remove();
        });
        Thread thread2 = new Thread(() -> {
            threadLocal.set(2);
            threadLocal.remove();
        });
        thread1.start();
        thread2.start();
    }
}


1
```

为了理解 ThreadLocal，先看以下代码：

```java
public class ThreadLocalExample1 {
    public static void main(String[] args) {
        ThreadLocal threadLocal1 = new ThreadLocal();
        ThreadLocal threadLocal2 = new ThreadLocal();
        Thread thread1 = new Thread(() -> {
            threadLocal1.set(1);
            threadLocal2.set(1);
        });
        Thread thread2 = new Thread(() -> {
            threadLocal1.set(2);
            threadLocal2.set(2);
        });
        thread1.start();
        thread2.start();
    }
}
```

它所对应的底层结构图为：

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6782674c-1bfe-4879-af39-e9d722a95d39.png)



**每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。**

```java
/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
```

当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal->value 键值对插入到该 Map 中。

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

get() 方法类似。

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。

在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况(**原因是ThreadLocalMap中的key是弱引用，在下一次GC时就会被清除**)，应该尽可能在**每次使用 ThreadLocal 后手动调用 remove()**，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。

### 3.可重入代码(Reentrant Code)

这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。

可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

# 十一.锁优化

这里的锁优化主要是指 JVM 对 synchronized 的优化。

## 自旋锁

互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。**自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态**。

自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。

在 JDK 1.6 中引入了**自适应的自旋锁**。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。

## 锁消除

**锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除**。

锁消除主要是通过**逃逸分析**来支持，**如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。**

对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：

```java
public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
```

String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：

```java
public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。

## 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。

上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。

## 轻量级锁

JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：**无锁状态**（unlocked）、**偏向锁状态**（biasble）、**轻量级锁状态**（lightweight locked）和**重量级锁状态**（inflated）。

以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 **Mark Word**。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png)

下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png)

轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。

当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/baaa681f-7c52-4198-a5ae-303b9386cf47.png)

如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。

## 偏向锁

**偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。**

当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg)

# 十二.多线程开发的良好实践

- 给线程起个有意义的名字，这样可以方便找 Bug。
- 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。
- 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。
- 使用 BlockingQueue 实现生产者消费者问题。
- 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。
- 使用本地变量和不可变类来保证线程安全。
- 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。

---
title: 待办
date: 2020-05-04 21:51:35
tags: 
	- 生活
	- 代办
categories:
	- 代办
---

# 2020.05.08

- [x] java容器整理
- [ ] leetcode数据库刷题
- [ ] 面试算法题
- [ ] Linux常见指令整理

# 2020.05.07

- [x] 数据库

# 2020.05.06

- [x] 看设计模式，整理笔记
- [ ] 看java容器原理并整理笔记
- [x] 剑指offer两道
- [x] 数据库

# 2020.05.05

- [x] 交周报
- [ ] 看设计模式，整理笔记
- [ ] 看java容器原理并整理笔记





---
title: 扑克牌顺子
date: 2020-05-24 15:26:25
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小  王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So  Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何，  如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。





第二次写忘了一种情况：0，0，1，0，1.也就是可能存在数相等的情况。

```
public boolean isContinuous(int [] numbers) {
        if(numbers==null||numbers.length==0) return false;
        Arrays.sort(numbers);
        int sum=0;
        for(int i=0;i<numbers.length;i++){
            if(numbers[i]==0) sum++;
            else break;
        }
        for(int i=sum;i<numbers.length-1;i++){
            int bet=numbers[i+1]-numbers[i];
            //也就是这一行别忘了
            if(bet==0) return false;
            if(bet==1) continue;
            if(bet-1>sum) return false;
            sum-=bet-1;
        }
        return true;
    }
```

---
title: 找出数组中出现次数大于N/K的数
date: 2020-06-26 10:08:40
tags: leetcode
categories: leetcode
---

# 找出数组中出现次数大于数组长度 N/K 的数 

>  **要求：时间复杂度为 O(NK)，额外空间复杂度为 O(K)。**

**算法思想：**

- 需要找出次数大于N/K的数，也就是说将数组分成很多区间，这个数必定在其中过一个区间中出现的次数大于1/K倍的区间长度.
- 用map去统计频度

```
public static List<Integer> findMoreThank(int[] nums,int K){
        Map<Integer,Integer> map=new HashMap<>();
        for(int num:nums){
            if(!map.containsKey(num)){
            	//每次出现时频度就加上K-1，然后其他元素频度-1
                map.put(num,K-1);
                allDeleteOneExcept(num,map);
            }else {
                map.put(num,map.get(num)+K-1);
                allDeleteOneExcept(num,map);
            }
        }
        //统计真正的个数
        countReal(map,nums);
        List<Integer> res=new ArrayList<>();
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){
            if(entry.getValue()>nums.length/K){
                res.add(entry.getKey());
            }
        }
        return res;
    }

    private static void countReal(Map<Integer, Integer> map, int[] nums) {
        for(Map.Entry<Integer, Integer> entry:map.entrySet()){
            int count=0;
            for(int num:nums){
                if(entry.getKey()==num){
                    count++;
                }
            }
            map.put(entry.getKey(),count);
        }
    }

    private static void allDeleteOneExcept(int num, Map<Integer, Integer> map) {
    	//遍历里面要删除元素，使用迭代器
        Iterator<Map.Entry<Integer, Integer>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()){
            Map.Entry<Integer, Integer> entry = iterator.next();
            if(entry.getKey()!=num){
                if(entry.getValue()==1)
                    iterator.remove();
                else {
                    map.put(entry.getKey(),entry.getValue()-1);
                }
            }
        }
    }
```

---
title: 把字符串转换成整数
date: 2020-05-25 13:39:47
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。        数值为0或者字符串不是一个合法的数值则返回0

## 输入描述:

```
输入一个字符串,包括数字字母符号,可以为空
```

## 输出描述:

```
如果是合法的数值表达则返回该数字，否则返回0
```

示例1

## 输入

```
+2147483647
1a33
```

## 输出

```
2147483647
0
```







第二次写出现的问题：少考虑了"+"这种情况。

全部改成负数去做减法。

```
public int StrToInt(String str) {
        if(str==null||str.length()==0) return 0;
        int i=0;
        boolean flag=true;
        int res=0;
        if(str.charAt(0)=='+'){
            i++;
        }
        else if(str.charAt(0)=='-') {
            flag=false;
            i++;
        }
        while(i<str.length()){
            if(str.charAt(i)<'0'||str.charAt(i)>'9') return 0;
            int num=str.charAt(i)-'0';
           if(res<Integer.MIN_VALUE/10||(res==Integer.MIN_VALUE/10&&num>8)) return 0;
            res=res*10-num;
            i++;
        }
        if(flag){
            if(res==Integer.MIN_VALUE) return 0;
            return -res;
        }
        return res;
    }
```

---
title: 把数组排成最小的数
date: 2020-05-23 16:06:31
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。



**注意：**将数组转换为字符串数组后再去排序。

```
 public String PrintMinNumber(int [] numbers) {
        if(numbers==null||numbers.length==0) return "";
        Comparator<String> comparator=new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return (s1+s2).compareTo(s2+s1);
            }
        };
        String[] strs=new String[numbers.length];
        for(int i=0;i<numbers.length;i++){
            strs[i]=String.valueOf(numbers[i]);
        }
        Arrays.sort(strs,comparator);
        String res="";
        for(String str:strs){
            res+=str;
        }
        return res;
    }
```

---
title: 排序与查找
date: 2020-05-04 16:35:00
tags: 
	   - 面试
       - 算法
categories: 排序
---

# 排序

## Comparable接口和Comparator接口比较

### 1.Comparable接口

- Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。

- 该接口定义如下：

  ```
  package java.lang;
  import java.util.*;
  public interface Comparable<T> 
  {
      public int compareTo(T o);
  }
  ```

  待比较的元素需要去实现Comparable接口，并且重写其中的compareTo方法，例如定义一个Person类并且按照年龄升序排列：

  ```
  public class Person implements Comparable<Person>
  {
      String name;
      int age;
      public Person(String name, int age)
      {
          super();
          this.name = name;
          this.age = age;
      }
      public String getName()
      {
          return name;
      }
      public int getAge()
      {
          return age;
      }
      @Override
      public int compareTo(Person p)
      {
          return this.age-p.getAge();
      }
  }
  ```



### 2.Comparator接口

- Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的**比较器**”来进行排序，这个“比较器”只需要实现Comparator接口即可。也就是说，我们可以通过实现Comparator来新建一个比较器，然后通过这个比较器对类进行排序。该接口定义如下：

  ```
  package java.util;
  public interface Comparator<T>
   {
      int compare(T o1, T o2);
      boolean equals(Object obj);
   }
  ```

  **注意：**若一个类要实现Comparator接口：它一定要实现compare(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。



### 3.Comparable和Comparator接口比较

- Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。
- Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。
- 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。

```
private void swap(int[] array,int i,int j){
        int temp=array[i];
        array[i]=array[j];
        array[j]=temp;
    }
```

## 选择排序

从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。

选择排序需要 N^2^/2 次比较和 ~N 次交换，**它的运行时间与输入无关**，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。



```
public void selectionSort(int[] array){
        for(int i=0;i<array.length;i++){
            int min=i;
            for(int j=i+1;j<array.length;j++){
                if(array[j]<array[min]) min=j;
            }
            swap(array,i,min);
        }
    }
```



## 冒泡排序

从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最小元素浮到最左边。

在一轮循环中，**如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。**

```
public void BubbleSort(int[] array){
        boolean isSorted=false;
        for(int i=0;i<array.length;i++){
        	//每次循环前将isSorted设为true
            isSorted=true;
            for(int j=array.length-1;j>i;j--){
            	//如果有交换表示此时还未有序
                if(array[j]<array[j-1]) {
                    isSorted=false;
                    swap(array,j-1,j);
                }
            }
            //如果上面没有交换，表示已经有序
           	if(isSorted) return;    
        }
    }
```



## 插入排序

每次都将**当前元素插入到左侧已经排序的数组中，**使得插入之后左侧数组依然有序。

对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此**插入排序需要交换的次数为逆序数量**。

插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。

- 平均情况下插入排序需要 N^2^/4 比较以及 N^2^/4 次交换；
- 最坏的情况下需要 N^2^/2 比较以及 N^2^/2 次交换，最坏的情况是数组是倒序的；
- 最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。

```
public void insertSort(int[] array){
        for(int i=1;i<array.length;i++){
            int num=array[i];
            int j=i-1;
            //找到其要插入的位置，并且将元素后移
            while (j>=0&&num<array[j]) {
                array[j+1]=array[j];
                j--;
            }
            //要插入的位置是循环结束时的j+1
            array[j+1]=num;
        }
    }
```



## 希尔排序

对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。

希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7818c574-97a8-48db-8e62-8bfb030b02ba.png)

````
public void shellSort(int[] array){
        int len=array.length;
        int h=1;
        //找到初始h
        while (h<len/3) h=3*h+1;	//1,4,13,....
        while (h>=1){
            for(int i=0;i<h;i++){
                for(int j=i+h;j<len;j+=h){
                    int num=array[j];
                    //k为j之前的一个元素
                    int k=j-h;
                    while (k>=0&&num<array[k]){
                        array[k+h]=array[k];
                        k-=h;
                    }
                    array[k+h]=num;
                }
            }
            h/=3;
        }
    }
````

希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ... 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。



## 归并排序

归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ec840967-d127-4da3-b6bb-186996c56746.png)

### 1.归并方法

归并方法将数组中两个已经排序的部分归并成一个。

```
//需要借助辅助数组
private int[] aux;

private void merge(int[] array,int left,int right){
        int mid=(left+right)/2;
        int i=left,j=mid+1;
        int index=0;
        while (i<=mid&&j<=right){
            if(array[i]<=array[j]) aux[index]=array[i++];
            else aux[index]=array[j++];
            index++;
        }
        while (i<=mid) aux[index++]=array[i++];
        while (j<=right) aux[index++]=array[j++];
        //最后将数组复制回来
        System.arraycopy(aux,0,array,left,index);
    }
```



### 2.自顶向下归并排序

将一个大数组分成两个小数组去求解。

因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 **O(NlogN)**。

```
public void mergeSort(int[] array){
        aux=new int[array.length];
        mergeSort(array,0,array.length-1);
    }

    private void mergeSort(int[] array,int left,int rigth){
        if(left>=rigth) return;
        int mid=(left+rigth)/2;
        mergeSort(array,left,mid);
        mergeSort(array,mid+1,rigth);
        merge(array,left,rigth);
    }
```



## 快速排序

### 1.基本算法

- 归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；
- 快速排序通过一个**切分元素(partition)**将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6234eb3d-ccf2-4987-a724-235aef6957b1.png)

```
public void quickSort(int[] array){
        quickSort(array,0,array.length-1);
    }

    private void quickSort(int[] array,int left,int right){
        if(left>=right) return;
        int partition = partition(array, left, right);
        quickSort(array,left,partition-1);
        quickSort(array,partition+1,right);
    }
```



### 2.切分

- 切分方法返回的是基准元素在数组中的位置

```
private int partition(int[] array,int left,int right){
        if(left==right) return left;
        int paratiton=array[left];
        while (left<right){
        	//注意要带上等号
            while (left<right&&array[right]>=paratiton) right--;
            array[left]=array[right];
            while (left<right&&array[left]<=paratiton) left++;
            array[right]=array[left];
        }
        array[left]=paratiton;
        return left;
    }
```



### 3.性能分析

快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。

快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。

最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N^2^/2。为了防止数组最开始就是有序的，在进行快速排序时需要**随机打乱数组**。



### 4.算法改进

1. **切换到插入排序**

   因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此**在小数组中可以切换到插入排序**。

2. **三数取中**

   最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。

3. **三数切分**

   对于有**大量重复元素**的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。

   三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。



### 基于切分的快速选择算法

快速排序的 partition() 方法，可以将数组分成两部分，左边比其小，右边比其大

可以利用这个特性在数组中查找数组中第k大的元素。



## 堆排序

### 1.堆

堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗**完全二叉树**。

堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。**这里不使用数组索引为 0 的位置**，是为了更清晰地描述节点的位置关系。

- **当数组索引从0开始时，位置为k的两个子节点为2k+1和2k+2，其父节点为(k-1)/2，所以得出最后一个非叶节点为(N-1)/2，其中N为最后一个节点的索引，也就是array.length-1**

**注意：**数组索引从1开始使用

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f48883c8-9d8a-494e-99a4-317d8ddb8552.png)



### 2.上浮和下沉(以大根堆为例，下面是索引从0开始使用)

在堆中，当一个节点比父节点大，那么需要交换这个两个节点。**交换后还可能比它新的父节点小大，因此需要不断地进行比较和交换操作**，把这种操作称为上浮。

在堆中插入元素时，一般是插入在最末尾，然后再上浮。

```
private void swim(int[] array,int k){
		//father指向其父节点
        int father=(k-1)/2;
        while (father>=0){
            if(array[father]>=array[k]) break;
            swap(array,father,k);
            k=father;
            father=(k-1)/2;
        }
    }
```



类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中**最大那个节点**进行交换。

**堆排序建成堆后，若要得到有序序列，则需要依次将堆顶和最后一个元素互换，然后再让新的堆顶下沉**

```
private void sink(int[] array,int k){
        int N=array.length-1;
        //(N-1)/2表示最后一个非叶节点，其中N指向最后一个节点
        while (2*k+1<=N){
            int child=2*k+1;
            //取两个孩子中较小的一个
            if (child+1<N&&array[child+1]<array[child]) child++;
            if(array[k]<=array[child]) break;
            swap(array,k,child);
            k=child;
        }
    }
```

### 3.插入元素

将新元素放到数组末尾，然后上浮到合适的位置。

```
private void insert(T v){
        heap[++N]=v;
        swim(N);
    }
```

### 4.删除最大元素

从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素**下沉**到合适的位置。

```
private T delMax(){
        T max=heap[1];
        heap[1]=heap[N--];
        heap[N+1]=null;
        sink(1);
        return max;
    }
```

### 5.堆排序

把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序(**若要得到从小到大的排列则要得到大根堆**)。

#### 5.1构造堆

从第一个非叶节点（(N-1）/2)进行下沉操作即可

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c2ca8dd2-8d00-4a3e-bece-db7849ac9cfd.gif)



```
public void heapSort(int[] array){
        int N=array.length-1;
        //构建堆的过程就是从最后一个非叶节点开始下沉
        for(int i=(N-1)/2;i>=0;i--){
            sink(array,i,N);
        }
        //N记录最后一个节点的位置
        while (N>0){
            swap(array,0,N--);
            //交换之后，N--表示要将最后一个元素排除在下沉区间外
            sink(array,0,N);
        }
    }
//N为数据的有用区间   
private void sink(int[] array,int k,int N){
        while (2*k+1<=N){
            int child=2*k+1;
            if (child+1<=N&&array[child+1]>array[child]) child++;
            if(array[k]>=array[child]) break;
            swap(array,k,child);
            k=child;
        }
    }
```

### 6.分析

一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。

对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。

同时**构建堆的时间复杂度为O(N)**

堆排序是一种**原地排序**，没有利用额外的空间。

现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。



## 小结

| 算法     | 稳定性 | 时间复杂度                   | 空间复杂度 | 备注                                    |
| -------- | ------ | ---------------------------- | ---------- | --------------------------------------- |
| 选择排序 | ×      | N^2^                         | 1          |                                         |
| 冒泡排序 | √      | N~N^2^                       | 1          |                                         |
| 插入排序 | √      | N ~ N^2^                     | 1          | 时间复杂度和初始顺序有关                |
| 希尔排序 | ×      | N 的若干倍乘于递增序列的长度 | 1          | 改进版插入排序                          |
| 快速排序 | ×      | NlogN                        | logN       |                                         |
| 归并排序 | √      | NlogN                        | N          | 临时数组的长度为N，递归调用栈深度为logN |
| 堆排序   | ×      | NlogN                        | 1          | 无法利用局部性原理                      |

- 选择排序不稳定的例子：2，2，1

  

快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。



- Java 主要排序方法为 java.util.Arrays.sort()，对于**原始数据类型使用三向切分的快速排序**，**对于引用类型使用归并排序**。



# 查找

## 二分查找

二分查找是用来在**有序的数组**中寻找特定元素的算法，每次选取中间的元素作为比较，然后借机排除掉一半的元素。

```
public int halfCutSearch(int[] array,int num){
        int left=0,right=array.length-1;
        //此处要取等号
        while (left<=right){
            int mid=(left+right)/2;
            if(array[mid]==num) return mid;
            else if(array[mid]<num) left=mid+1;
            else right=mid-1;
        }
        return -1;
    }
```



上面的情况可以存在变形，例如求数组中num第一次出现的索引和num最后一次出现的索引，这种情况下唯一不同的就是相等时的情况，要额外判断是否其左边(右边)也是num

```
public int halfCutSearchFirst(int[] array,int num){
        int left=0,right=array.length-1;
        while (left<=right){
            int mid=(left+right)/2;
            //相等时分开判断
            if(array[mid]==num){
                if(mid-1>=0&&array[mid-1]==num) right=mid-1;
                else return mid;
            }else if(array[mid]<num) left=mid+1;
            else right=mid-1;
        }
        return -1;
    }

    public int halfCutSearchLast(int[] array,int num){
        int left=0,right=array.length-1;
        while (left<=right){
            int mid=(left+right)/2;
            if(array[mid]==num){
                if(mid+1<array.length&&array[mid+1]==num) left=mid+1;
                else return mid;
            }else if(array[mid]<num) left=mid+1;
            else right=mid-1;
        }
        return -1;
    }
```



**注意：**

- 二分查找的循环条件是**left<=right**
- 在循环体内判断时，除了舍弃一半元素外，也要判断mid后再做选择，不能做出像left=mid或right=mid这样，这样会导致死循环出不来。

## 参考

> [Comparable接口和Comparator接口](https://www.cnblogs.com/xujian2014/p/5215082.html)
>
> [cyc2018](https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F)

---
title: 搜索旋转数组
date: 2020-06-17 11:46:33
tags: leetcode
categories: leetcode
---

# [面试题 10.03. 搜索旋转数组](https://leetcode-cn.com/problems/search-rotate-array-lcci/)

**题目描述：**

搜索**旋转数组**。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。**若有多个相同元素，返回索引值最小的一个**。



```
示例1:

 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
 输出: 8（元素5在该数组中的索引）
 
示例2:

 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11
 输出：-1 （没有找到）
```



**算法思想：**

- 还是使用二分法，需要注意的是可能有重复元素的存在，例如1,2,1,1,1的情况，如果简单的通过arr[mid]>=arr[0]不能判断左边递增，因此需要将等于的情况单独拿出来，然后遍历去寻找即可
- 还有一种情况就是相同的值并不一定是挨在一起的，例如2,1,2,2,2，所以不能在mid等于target时，简单的判断左边是否等于target，而是将其值记录下来，一次又一次的更新，最后得到的结果就是最左边的

```
public int search(int[] arr, int target) {
        int left=0,right=arr.length-1;
        //res记录最左边的结果
        int res=-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(arr[mid]==target) {
            	//更新结果，然后去左边找
                res=mid;
                right=mid-1;
            }
            //相等的时候就顺序查找
            if(arr[mid]==arr[left]){
                for(int i=left;i<=mid;i++){
                    if(arr[i]==target) return i;
                }
                left=mid+1;
            }
            else if(arr[mid]>arr[left]){
                if(arr[mid]<target){
                    left=mid+1;
                }else{
                    if(target>=arr[left])
                        right=mid-1;
                    else left=mid+1;
                }
            }else{
                if(arr[mid]>target){
                    right=mid-1;
                }else{
                    if(target>=arr[left])
                        right=mid-1;
                    else left=mid+1;
                }
            }
        }
        return res;
    }
```



---
title: 操作系统
date: 2020-05-18 21:02:44
tags: 操作系统
categories: 操作系统
---

# 基本特征

## 1.并发

并发是指宏观上在**一段时间内**能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

## 2.共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：**互斥共享**和**同时共享**。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

## 3.虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：**时（时间）分复用技术**和**空（空间）分复用技术**。

**时分复用技术**是指多个进程通过**进程调度算法**，可以并发的执行。

虚拟内存使用了**空分复用技术**，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行**页面置换算法**，将该页置换到内存中。

## 4.异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

# 用户态和内核态

- `CPU`将指令分为**特权指令**和**非特权指令**，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。
- 在具体实现上，将CPU的状态划分为**用户态**和**内核态**，处于内核态时可以执行特权指令。

用户态切换到内核态可以通过**系统调用**或者**异常，比如缺页异常**。

# 进程管理

## 进程

进程是**资源分配**的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

## 线程

线程是**独立调度**的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png)

## 区别

1. **拥有资源：**进程是**资源分配**的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
2. **调度：**线程是**独立调度**的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3. **系统开销：**创建和撤销进程的开销大，同时进程切换时也有更大的开销；线程开销小。

## 进程状态的切换

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png)



- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有ready和running可以相互转换，其它的都是单向转换。ready的进程通过调度算法从而获得 CPU 时间，转为running；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为ready，等待下一次调度。
- waiting是缺少需要的资源从而由running转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从running转换为ready。

## 进程调度算法

1. **先来先服务（FCFS）算法**，从**就绪队列**中选择一个**最先进入该队列**的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

   缺点：对长作业有利，对短作业不利

2. **短作业优先（SFS）算法**，从就绪队列中选出一个**估计运行时间最短**的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

   缺点：对长作业不利，如果一直有短作业进入就绪队列，则会导致长作业一直得不到调度

3. **优先级调度算法**， 为每个流程分配优先级，首先执行具有**最高优先级**的进程，依此类推。**具有相同优先级的进程以 FCFS 方式**执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

4. **时间片轮转调度算法**，进程调度总是选择就绪队列中的第一个进程执行，即 **先来先服务**的原则，但仅能运行**一个时间片**。当时间片用完时，由计时器发出时钟中断，**调度程序便停止该进程的执行，并将它送往就绪队列的末尾**，同时继续把 CPU 时间分配给队首的进程。

5. **多级反馈队列调度算法**，通过**动态调整进程优先级和时间片大小**，多级反馈队列调度算法可以兼顾多方面的系统目标。

   其实现思想如下：

   1. 应设置**多个就绪队列**，并为各个队列赋予不同的优先级，**第1级队列的优先级最高**，第2级队列次之，其余队列的优先级逐次降低。

   2. 赋予各个队列中进程执行**时间片的大小也各不相同**，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍，以此类推。
   3. 当一个新进程进入内存后，首先将它放入第1级队列的末尾，按**FCFS**原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统，否则，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行。如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。
   4. 仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ i-1中的任何一个队列），则此时新进程将**抢占**正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。

   ![image-20200417145656581.png](https://i.loli.net/2020/05/18/kRi3xNP2y6mchnQ.png)

## 进程同步

### 1.临界区

对临界资源进行访问的那段代码称为临界区。

### 2.同步和互斥

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的**先后执行关系**。
- 互斥：多个进程在**同一时刻只有一个进程**能进入临界区。

### 3.信号量

#### 使用信号量实现同步

```
 semaphore S = 0; //初始化信号量
 P1 ( ) {
     P1 process
     x; //语句x
     V(S); //告诉进程P2,语句乂已经完成
 }
 P2()）{
     P2 process1
     P(S) ; //检查语句x是否运行完成
     y; // 检查无误，运行y语句
     P2 process2
 }
```

#### 使用信号量实现互斥

```
 semaphore S = 1; //初化信号量
 P1 ( ) {
     P1 process1
     P(S); // 准备开始访问临界资源，加锁
     // 进程P1的临界区
     V(S); // 访问结束，解锁
     P1 process2
 }
 P2() {
     P2 process1
     P(S); //准备开始访问临界资源，加锁
     // 进程P2的临界区；
     V(S); // 访问结束，解锁
     P2 process2
 }
```

### 经典同步问题

#### 哲学家进餐问题

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。



![img](https:////upload-images.jianshu.io/upload_images/5853159-6b72f9c6c61014e0.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/250/format/webp)

**问题分析**

1. 关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。
2. 整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。解决的方案有以下几种

- 至多允许四位哲学家同时去拿左边的筷子，保证至少一位哲学家可以拿到两只筷子，并在使用完毕后，释放两只筷子。
- 仅当哲学家的左右筷子均可用时，才允许他拿起筷子进餐。
- 规定奇数哲学家先拿左边筷子，偶数哲学家先拿右边筷子，1，2哲学家竞争1号筷子，3，4哲学家竞争3号筷子。进而，所有哲学家先竞争奇数筷子，再竞争偶数筷子。

1. 信号量设置。定义互斥信号量数组chopstick[5] = {1, 1, 1, 1, 1}用于对5个筷子的互斥访问。对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。

**可能导致死锁的方案**

```cpp
semaphore chopstick[5] = {1,1,1,1,1}; //定义信号量数组chopstick[5],并初始化
Pi(){  //i号哲学家的进程
    do{
        P (chopstick[i] ) ; //取左边筷子
        P (chopstick[(i+1) %5] ) ；  //取右边篌子
        eat;  //进餐
        V(chopstick[i]) ; //放回左边筷子
        V(chopstick[(i+l)%5]);  //放回右边筷子
        think;  //思考
    } while (1);
}
```

当所有哲学家都只拿到左边的筷子时，将出现死锁的情况。



**记录型信号量实现**

在思路整理中的三种方案中，我们选取第二种方案（仅当哲学家的左右筷子均可用时，才允许他拿起筷子进餐），用记录型信号量进行实现。

```cpp
semaphore chopstick[5] = {1,1,1,1,1}; //初始化信号量
semaphore mutex=l;  //设置取筷子的信号量
Pi(){ //i号哲学家的进程
    do{
        P (mutex) ; //在取筷子前获得互斥量
        P (chopstick [i]) ; //取左边筷子
        P (chopstick[ (i+1) %5]) ;  //取右边筷子
        V (mutex) ; //释放取筷子的信号量
        eat;  //进餐
        V(chopstick[i] ) ;  //放回左边筷子
        V(chopstick[ (i+l)%5]) ;  //放回右边筷子
        think;  // 思考
    }while(1);
}
```

#### 生产者-消费者问题

**信号量设置：**信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。

```
semaphore mutex=1; //临界区互斥信号量
semaphore empty=n;  //空闲缓冲区
semaphore full=0;  //缓冲区初始化为空
producer () { //生产者进程
    while(1){
        produce an item in nextp;  //生产数据
        P(empty);  //获取空缓冲区单元
        P(mutex);  //进入临界区.
        add nextp to buffer;  //将数据放入缓冲区
        V(mutex);  //离开临界区,释放互斥信号量
        V(full);  //满缓冲区数加1
    }
}

consumer () {  //消费者进程
    while(1){
        P(full);  //获取满缓冲区单元
        P(mutex);  // 进入临界区
        remove an item from buffer;  //从缓冲区中取出数据
        V (mutex);  //离开临界区，释放互斥信号量
        V (empty) ;  //空缓冲区数加1
        consume the item;  //消费数据
    }
}
```

## 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

### 1.管道

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

```c
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在**父子进程或者兄弟进程**中使用。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png)



当管道的一端被关闭后，会出现下面的几种情况：

1. 当读一个写端被关闭的管道时，在所有数据都被读取后，read返回0，表示文件结束；如果写端没有被关闭，但是没有数据，则读端读完数据后阻塞；

2. 当写一个读端被关闭的管道时，则产生信号SIGPIPE，write返回-1，errno设置为EPIPE；如果读端没有被关闭，写端写满数据后，则写端阻塞。

### 2.命名管道

FIFO的两个特性：

- 和管道一样，FIFO仅提供半双工的数据通信，即只支持单向的数据流；
- 和管道不同的是，FIFO可以支持任意两个进程间的通信。

```
//成功则返回0，失败返回-1 
int mkfifo(const char *pathname, mode_t mode);  
```

- pathname：一个Linux路径名，它是FIFO的名字。即每个FIFO与一个路径名相对应；
- mode：指定的文件权限位，类似于open函数的第三个参数。即创建该FIFO时，指定用户的访问权限，有以下值：S_IRUSR，S_IWUSR，S_IRGRP，S_IWGRP，S_IROTH，S_IWOTH。

### 3.信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

### 4.共享存储

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

### 5.套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

# 死锁

## 必要条件

- **互斥**：资源只能互斥访问。
- **占有和等待**：已经得到了某个资源的进程可以再请求新的资源。
- **不可抢占**：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- **环路等待**：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

## 处理方法

- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

### 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

#### 1. 每种类型一个资源的死锁检测

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png)



上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

#### 2.每种类型多个资源的死锁检测

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png)



上图中，有三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量

进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

#### 死锁恢复

- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

### 死锁预防

在程序运行之前预防发生死锁。通过破坏死锁的必要条件。

1. **破坏互斥条件：**例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。
2. **破坏占有和等待条件：**一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

3. **破坏不可抢占条件**
4. **破坏环路等待：**给资源统一编号，进程只能按编号顺序来请求资源。

### 死锁避免

在程序运行时避免发生死锁。

#### 1.安全状态

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png)



图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。

定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然**存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的**。

#### 2.单个资源的银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png)



上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

#### 3.多个资源的银行家算法

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png)



上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

检查一个状态是否安全的算法如下：

- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

如果一个状态不是安全的，需要拒绝进入这个状态。

# 内存管理

## 虚拟内存

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

## 分页系统地址映射

- **分页**：把主存空间划分为大小相等且固定的**块**，**块相对较小**，作为主存的基本单位。**每个进程也以块进行划分**，进程执行时，以块为单位逐个申请主存中的块空间。

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储**页面号**，一部分存储**页内偏移量**。

![image-20200427154555561.png](https://i.loli.net/2020/05/19/q1USgAjGrYcsvpa.png)

### 局部性原理

1. **时间局部性。**程序中的某条指令一旦执行，不久后该指令可能再次执行；某条数据被访问后，不久后该数据可能再次被访问。(循环)
2. **空间局部性。**一旦程序访问了某个存储单元，在不久以后，其附近的存储单元也会被访问。

### 快表

增设一个高速缓冲存储器——**快表**，用来存储当前访问的若干页表项，以加速地址变换的过程。

![image-20200427155135678.png](https://i.loli.net/2020/05/19/2PhSeTn4FH5kDKm.png)

快表的有效性基于**局部性原理**。

### 二级页表

引入多级页表的主要原因是：由于页表需要在内存中连续存储，如果页表过大，会占据内存中很大的连续空间，所以想到对页表再进行分页存储，同时为了避免把全部页表一直放在内存中占用过多空间。

![image-20200427160420711.png](https://i.loli.net/2020/05/19/DEjg4sTYhCQbpwu.png)

## 分段存储

![image-20200427160913475.png](https://i.loli.net/2020/05/19/F62em5dyxX8V1Yn.png)



![image-20200427161207072.png](https://i.loli.net/2020/05/19/L8Wr9bkZtPJFmjR.png)



![image-20200427161930743.png](https://i.loli.net/2020/05/19/m6CeIcFqJS5z2OB.png)

## 分段与分页的相同点和不同点

### 共同点：

1. 分页机制和分段机制都是为了**提高内存利用率**，较少内存碎片。
2. 页和段都是**离散存储的**，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。

### 不同点：

- **页的大小是固定的**，由操作系统决定；**而段的大小不固定**，取决于我们当前运行的程序。
- 分页仅仅是为了满足操作系统内存管理的需求，而**段是逻辑信息的单位，在程序中可以体现为代码段，数据段**，能够更好满足用户的需要。

- 分页透明，但是**分段需要程序员显式划分每个段**。

## 段页式

![image-20200427213312568.png](https://i.loli.net/2020/05/19/ltuZvQUS9fGR68j.png)



![image-20200427213415569.png](https://i.loli.net/2020/05/19/QNnPe3A9hd5YJXB.png)

在段页式系统中，作业的逻辑地址分为三部分：段号，页号，页内偏移量。

![image-20200427214341018.png](https://i.loli.net/2020/05/19/Lp2FeBQy4EZcK9T.png)

![image-20200427213749646.png](https://i.loli.net/2020/05/19/8cdfXpBwbN63n9Y.png)

## 请求分页存储

在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存中时，再通过**调页**功能将其调入，同时还通过置换功能将暂时不用的页面**换出**到外存上。

缺页中断机构

- 每当所要访问的页面不在内存中时，便产生一个**缺页中断**，若内存中有空闲块，则将调入的页装入该块，**并修改相应的页表项**，若此时内存中已经没有空闲块，则要淘汰某页(若该页被修改过，则还需要将其写回外存)

### 页面置换算法

#### 1.最佳(OPT)

所选择的被换出的页面将是**最长时间内不再被访问**，通常可以保证获得最低的缺页率。

是一种**理论**上的算法，因为无法知道一个页面多长时间不再被访问。

举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

```html
7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
```

开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。

#### 2. 先进先出(FIFO)

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

可能会出现**Belady异常**，其是指随着所分配的内存块的增多而页面置换的次数不减反增的现象。

#### 3.最近最久未使用(LRU)

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。

为了实现 LRU，需要在内存中维护一个所有页面的**链表**。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

```html
4，7，0，7，1，0，1，2，1，2，6
```

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png)

#### 4.第二次机会置换算法

为了避免FIFO算法将重要的页换出内存，Second Chance算法提供了一些改进。Second Chance算法在将页面换出内存前检查其使用位（使用位前文有介绍），如果其使用位为1，证明此页最近有被使用，猜测它还可能被使用，于是不把它置换出内存，但是把其使用位置为0，随后检查下一个页面，直到发现某页的使用位为0，将此页置换出内存。

#### 5.时钟置换算法(Clock)

为了节约Second Chance算法一个接着一个检查使用位的开销，时钟轮转法又提出了改进。时钟轮转法将所有的页组成一个圆，圆心的指针指向下一个要被置换的页面，置换前同样检查使用位，如果使用位为1，同样将其使用位置为0，随后将顺指针旋转，检查下一个页面，直到发现某页的使用位为0，将此页置换出内存。

#### 6.最近未使用(NRU)

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

**NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）**。---
title: 数值的整数次方
date: 2020-05-21 16:37:57
tags: 剑指offer
categories: 剑指offer
---

**题目描述：**

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0





**注意：**

1. 处理特殊情况
2. 将负次方变为导数的整数次方



```
public double Power(double base, int exponent) {
        if(base==0&&exponent<=0) throw new RuntimeException("运算不合法");
        if(base==0) return 0;
        if(exponent==0) return 1;
        if(exponent<0) {
            base=1/base;
            exponent=-exponent;
        }
        double half=Power(base,exponent/2);
        if(exponent%2==0){
            return half*half;
        }else return half*half*base;
  }
```

---
title: 最大单词长度乘积
date: 2020-06-01 09:42:57
tags: leetcode
categories: leetcode
---

# [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。



# 位运算

**算法思想：**

- 关键在于怎么判断两个字符串是否有公共字母，可以用32位整数来表示，对应位数代表对应的字母是否存在即可。

```
public int maxProduct(String[] words) {
        if(words==null||words.length==0) return 0;
        int len=words.length;
        int[] mask=new int[len];
        for(int i=0;i<len;i++){
            for(int j=0;j<words[i].length();j++){
            	//注意这里是|，而不能是+，否则例如"aaa"，+则会进位
                mask[i]+=1<<(words[i].charAt(j)-'a');
            }
        }
        int max=0;
        for(int i=0;i<len;i++){
            for(int j=i+1;j<len;j++){
                if((mask[i]&mask[j])==0){
                    max=Math.max(max,words[i].length()*words[j].length());
                }
            }
        }
        return max;
    }
```

---
title: 最长上升子序列
date: 2020-06-06 15:24:17
tags: leetcode
categories: leetcode
---

# [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。





## 动态规划

**算法思想：**

- memo[i]表示以nums[i]结尾并且必须包括nums[i]的最长上升序列，则memo[i]=max(memo[j]+1|nums[j]<nums[i])，最后结果不再是memo[len-1]，而是整个数组中的最大值

```
public int lengthOfLIS(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        int[] memo=new int[nums.length];
        for(int i=0;i<memo.length;i++)
            memo[i]=1;
        for(int i=1;i<memo.length;i++){
            for(int j=i-1;j>=0;j--){
                if(nums[j]<nums[i]){
                    memo[i]=memo[i]=Math.max(memo[i],memo[j]+1);
                }
            }
        }
        int max=0;
        for(int i=0;i<memo.length;i++){
            if(memo[i]>max)
                max=memo[i];
        }
        return max;
    }
```

---
title: 最长有效括号
date: 2020-06-13 20:40:29
tags: leetcode
categories: leetcode
---

# [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

**题目描述：**

给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。



```
示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"

示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```



## 动态规划

- memo[i]表示以下标i的字符结束的最长有效括号子串长度，则如果s[i]=='('时，其肯定为0，只用考虑为右括号的情况。
- 根据其前一个字符可以分为两种情况：
  1. s[i-1]=='('，则memo[i]=memo[i-2]+2
  2. s[i-1]==')'，则判断s[i-1-memo[i-1]]是否为'('，如果成立，则memo[i]=memo[i-1]+memo[i-2-memo[i-1]]+2

```
public int longestValidParentheses(String s) {
        if(s==null||s.length()==0) return 0;
        int[] memo=new int[s.length()];
        int max=0;
        for(int i=1;i<memo.length;i++){
            if(s.charAt(i)==')'){
                if(s.charAt(i-1)=='('){
                    memo[i]=i-2>=0?memo[i-2]+2:2;
                }else{
                    if(i-2>=0&&i-1-memo[i-1]>=0&&s.charAt(i-1-memo[i-1])=='('){
                        memo[i]=i-2-memo[i-1]>=0?memo[i-1]+memo[i-2-memo[i-1]]+2:memo[i-1]+2;
                    }
                }
            }
            max=Math.max(max,memo[i]);
        }
        return max;
    }
```

---
title: 有序矩阵中第k小的元素
date: 2020-06-01 15:56:45
tags: leetcode
categories: leetcode
---

给定一个 *n x n* 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。



## 二分查找

**算法思想：**

- 基于值域的二分查找，对于mid，统计其中小于等于mid的元素个数count，如果count<k，则l=mid+1;否则r=mid，这里在count==k的时候不能直接返回，必须一直逼近直到l==r即为结果
- 有序矩阵中统计小于mid的元素个数类似于查找，从左下角开始。

```
public int kthSmallest(int[][] matrix, int k) {
        if(matrix==null||matrix.length==0) return -1;
        int N=matrix.length;
        int l=matrix[0][0],r=matrix[N-1][N-1];
        while(l<r){
            int mid=l+(r-l)/2;
            int count=noMoreThanMid(matrix,N,mid);
            if(count<k)
                l=mid+1;
            else r=mid;
        }
        return l;
    }

    private int noMoreThanMid(int[][] matrix,int N,int mid){
        int i=N-1,j=0,res=0;
        while(i>=0&&j<N){
            if(matrix[i][j]<=mid){
                res+=i+1;
                j++;
            }
            else
                i--;
        }
        return res;
    }
```



# 优先队列

**算法思想：**

- 使用大小为k的大根堆去存储，最后堆顶元素即为结果

```
public int kthSmallest(int[][] matrix, int k) {
        if(matrix==null||matrix.length==0) return -1;
        int M=matrix.length;
        int N=matrix[0].length;
        PriorityQueue<Integer> queue=new PriorityQueue<>(k,new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        });
        for(int i=0;i<M;i++){
            for(int j=0;j<N;j++){
                if(queue.size()<k){
                    queue.add(matrix[i][j]);
                }else {
                    if(matrix[i][j]<queue.peek()){
                        queue.remove();
                        queue.add(matrix[i][j]);
                    }
                }
            }
        }
        return queue.peek();
    }
```



---
title: 栈和队列
date: 2020-05-16 11:08:08
tags:
		- 栈和队列
		- java
categories:
		- 面试
---

# 高频面试题

## 查询最值

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。
（时间复杂度应为 O（1））

### 思路

**应用一个辅助栈**

压入规则：

1. 数据栈直接压入
2. 辅助栈增加判断，若栈为空直接压入；否则若将要压入的元素**小于等于**栈顶元素则压入

弹出规则：

数据栈弹出时对辅助栈顶进行判断，若栈顶元素与数据栈将要弹出的元素相同，则一起弹出。否则仅弹出数据栈顶。以保证两栈一致性。

### 实现

```java
public class GetMinDemo {
    Stack<Integer> dataStack = new Stack();
    Stack<Integer> minStack = new Stack();

    public void push(int node) {
        dataStack.push(node);
        if (minStack.isEmpty() || minStack.peek() >= node)
            minStack.push(node);
    }

    public void pop() {
        if (minStack.peek() == dataStack.peek())
            minStack.pop();
        dataStack.pop();
    }

    public int top() {
        return dataStack.peek();
    }

    public int min() {
        return minStack.peek();
    }
}
```

## 双栈模拟队列

编写一个类，只能用两个栈结构实现队列，支持队列的基本操作 (push，pop)。

给定一个操作序列 ope 及它的长度 n，其中元素为正数代表 push 操作，为 0 代表 pop 操作，
保证操作序列合法且一定含 pop 操作，请返回 pop 的结果序列。

```
测试样例: [1,2,3,0,4,0], 6
返回：    [1,2]
```

### 思路

关键点：

1. 如果 stackPush 要往 stackPop 中倒入数据，那么必须要把 stackPush 中的所有数据一次性全倒完
2. 如果 stackPop 中存在数据（非空），则不能发生倒数据的行为

### 实现

```java
public class Stack2Queue {
    Stack<Integer> stackPush = new Stack<>();
    Stack<Integer> stackPop = new Stack<>();

    public void push(int node) {
        stackpush.push(num);
    }

    public int pop() {
        if(!stackpop.isEmpty()) return stackpop.pop();
        else {
            while (!stackpush.isEmpty()){
                stackpop.push(stackpush.pop());
            }
            return stackpop.pop();
        }
    }
```

## 双队列模拟栈

### 思路

把非空队列的 n-1 个压人空对列，剩的第 n 个出队... 即总有一个队列为空。

可以一直保持第二个队列为空，在将第一个队列中的(n-1个)数据移到第二个队列中后，再移回来。

### 实现

```java
public class Queue2Stack {
    LinkedList<Integer> queue1 = new LinkedList<>();
    LinkedList<Integer> queue2 = new LinkedList<>();

    public void push(int val) {
        queue1.offer(num);
    }

    public int pop() {
        while (queue1.size()>1){
            queue2.offer(queue1.poll());
        }
        while (!queue2.isEmpty())
            queue1.offer(queue2.poll());
        return queue1.poll();
    }


    public int stackSize() {
        return queue1.size() + queue2.size();
    }

    public void putN_1ToAnother() {
        if (!queue1.isEmpty()) {
            while (queue1.size() > 1) {		// 移动 n-1 个元素，保留一个元素
                queue2.addLast(queue1.remove(0));
            }
        } else if (!queue2.isEmpty()) {
            while (queue2.size() > 1) {
                queue1.addLast(queue2.remove(0));
            }
        }
    }
}
```

## 栈的反转

实现一个栈的逆序，但是只能用递归函数和这个栈本身的 pop 操作来实现，
而不能自己申请另外的数据结构。

给定一个整数数组 A 即为给定的栈，同时给定它的大小 n，请返回逆序后的栈。

### 思路

利用递归函数传递值

1. 获取栈底元素函数
   1. 弹出并保存栈顶元素
   2. 判断栈此时是否为空
      1. 若为空：直接返回保存的栈顶元素
      2. 若非空：则递归调用本函数，并将步骤 1 获取的栈顶元素重新压入栈中，返回步骤 2.2 递归得到的返回值
2. 逆序栈函数
   1. 获取栈底元素
   2. 递归调用自身，逆序除栈底元素外的栈
   3. 将步骤 1 得到的栈底元素再次压入栈顶

### 实现

```java
// 解法 1
// 移除栈底元素并返回
public int getBottom(Stack<Integer> myStack) {
    int res = myStack.pop();
    if (myStack.isEmpty()) {
        return res;
    } else {
        int last = getBottom(myStack);
        // 压入上一个值
        myStack.push(res);
        return last;
    }
}

// 将栈中元素逆序
public void reverse(Stack<Integer> myStack) {
    if (myStack.isEmpty()) return;

    int i = getBottom(myStack);
    reverse(myStack);
    myStack.push(i);
}

// 主调用函数
public int[] reverseStack(int[] A, int n) {
    Stack<Integer> myStack = new Stack<>();
    for (int i = 0; i < n; i++) {
        myStack.push(A[i]);
    }

    reverse(myStack);
    for (int i = 0; i < n; i++) {
        A[i] = getBottom(myStack);
    }
    return A;
}

// 解法 2
public int[] reverseStack1(int[] A, int n) {
    if (n == 0)
        return null;
    int node = A[n - 1];
    reverseStack1(A, n - 1);
    A[A.length - n] = node;
    return A;
}
```

## 双栈排序

请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），
要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。

给定一个 int [] numbers，其中第一个元素为栈顶，请返回排序后的栈。
请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。

### 思路

利用辅助栈实现：

辅助栈压入规则：

1. 若辅助栈为空，直接弹出数据栈栈顶元素并压入到辅助栈
2. 若辅助栈非空，则比较辅助栈栈顶元素与数据栈栈顶元素的大小
   1. 若辅助栈栈顶元素小于数据栈栈顶元素，则将数据栈栈顶元素弹出并压入到辅助栈
   2. 否则先弹出数据栈栈顶元素并保存成临时变量，反复将辅助栈中元素弹出并压入到数据栈中直到满足 2.1 条件，此时将临时变量压入到辅助栈中

当数据栈为空时再将辅助栈中所有元素压入至数据栈，实现排序

### 实现

```java
// 解法 1： 利用栈实现
public ArrayList<Integer> twoStacksSort1(int[] numbers) {
    Stack<Integer> helpStack = new Stack<>();
    Stack<Integer> dataStack = new Stack();
    for (int i = 0; i < numbers.length; i++) {
        dataStack.push(numbers[i]);
    }

    while (!dataStack.empty()) {
        if (helpStack.empty() || dataStack.peek() > helpStack.peek()) {
            helpStack.push(dataStack.pop());
        }
        else {
            int temp = dataStack.pop();
            while (!helpStack.empty() && helpStack.peek() > temp) {
                dataStack.push(helpStack.pop());
            }
            helpStack.push(temp);
        }
    }

    for (Integer integer : helpStack) {
        dataStack.push(integer);
    }

    ArrayList<Integer> res = new ArrayList<>();
    while (!dataStack.isEmpty()) res.add(dataStack.pop());
    return res;
}

// 解法 2：利用数组实现
public ArrayList<Integer> twoStacksSort(int[] numbers) {
    int len = numbers.length;
    // 辅助
    int[] help = new int[len];
    int i = 0, j = len, current;

    while (i < len) {
        current = numbers[i++];
        if (j == len || current <= help[j]) {
            help[--j] = current;
        } else if (current > help[j]) {
            while (j < len && current > help[j]) {
                numbers[--i] = help[j++];
            }
            help[--j] = current;
        }

    }

    ArrayList<Integer> res = new ArrayList<>();
    int k = 0;
    while (k < len) res.add(help[len - k++ - 1]);
    return res;
}
```

## 滑动窗口

有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边，
窗口每次向右边滑一个位置。 返回一个长度为 n-w+1 的数组 res，
res [i] 表示每一种窗口状态下的最大值。 以数组为 [4,3,5,4,3,3,6,7]，w=3 为例。
因为第一个窗口 [4,3,5] 的最大值为 5，第二个窗口 [3,5,4] 的最大值为 5，第三个窗口 [5,4,3] 的最大值为 5。第四个窗口 [4,3,3] 的最大值为 4。第五个窗口 [3,3,6] 的最大值为 6。第六个窗口 [3,6,7] 的最大值为 7。
所以最终返回 [5,5,5,4,6,7]。

给定整形数组 arr 及它的大小 n，同时给定 w，请返回 res 数组。
保证 w 小于等于 n，同时保证数组大小小于等于 500。

### 思路

利用辅助队列（存放数组下标）实现：

入队规则：

1. 若队列为空或队尾对应元素大于当前元素直接插入
2. 若队尾元素小于当前元素，则反复出队直到队尾对应元素大于当前元素或队为空时插入当前元素，以保证**队头为最大值**

出队规则：

1. 若队头元素下标超出窗口范围则出队

结果保存：队头为最大值，每个窗口存一个结果

### 实现

```java
public int[] slide(int[] arr, int n, int w) {
    // 存放数组下标
    ArrayList<Integer> queue = new ArrayList<>();
    int[] res = new int[n - w + 1];
    int count = 0, j = 0;
    for (int i = 0; i < n; i++, count++) {
        // 若队列为空或队尾对应元素大于当前元素直接插入
        if (queue.isEmpty() || arr[queue.get(queue.size() - 1)] > arr[i]) {
            queue.add(i);
        } else {
            // 反复出队直到队尾对应元素大于当前元素或队为空时插入当前元素
            while (!queue.isEmpty() && arr[queue.get(queue.size() - 1)] <= arr[i])
                queue.remove(queue.size() - 1);
            queue.add(i);
        }

        // 若队头元素下标超出窗口范围则移出
        if (queue.get(0) == i - w)
            queue.remove(0);

        // 队头为最大值，每个窗口存一个结果
        if (count == w - 1) {
            res[j++] = arr[queue.get(0)];
            count = w - 2;
        }
    }
    return res;
}
```

---
title: 栈的压入和弹出序列
date: 2020-05-22 17:01:38
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）





- 用一个栈去模拟压栈和出栈的情况

```
public boolean IsPopOrder(int [] pushA,int [] popA) {
        Stack<Integer> stack=new Stack<>();
        int index=0;
        for(int i=0;i<pushA.length;i++){
            stack.push(pushA[i]);
            while (!stack.isEmpty()&&(stack.peek()==popA[index])){
                stack.pop();
                index++;
            }
        }
        return index==popA.length;
    }
```

**注意：**

1. 先push之后下面是pop()
2. pop需要加while循环---
title: 比特位计数
date: 2020-06-01 09:59:03
tags: leetcode
categories: leetcode
---

# [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。



## 动态规划

**算法思想：**

- n&(n-1)表示的是去掉n的最后一个1，所以有memo[n]=memo[n&(n-1)]+1;

```
public int[] countBits(int num) {
        int[] memo=new int[num+1];
        memo[0]=0;
        for(int i=1;i<memo.length;i++){
            memo[i]=memo[i&(i-1)]+1;
        }
        return memo;
    }
```

---
title: 海量数据处理
date: 2020-05-12 19:35:54
tags:	
		- 面试
		- 大数据
categories:
		- 面试
---

# 哈希函数

哈希函数又称作散列函数，哈希函数的输入域可以是非常大的范围，但是输出域是固定范围。假设为 s。

哈希函数的性质：

* 典型的哈希函数都拥有无限的输入值域
* 输入值相同时，返回值一样
* 输入值不同时，返回值可能一样，也可能不一样
* 不同输入值得到的哈希值，会整体均匀地分布在输出域 s 上（哈希函数优劣的关键，越均匀越优秀）

# 海量数据处理技巧

## 解题关键

1. 分而治之：通过哈希函数将大任务分流到机器，或分流为小文件。
2. 常用 HashMap 或 BitMap。

问题在于估算内存大小：

**注意：**1KB=2^10^B，1B=2^3^bit

Integer的最大值为 **2^31^-1**，约为21亿。

## 案例一：IP地址排序

**请对 10 亿个 IPv4 的 ip 地址进行排序，每个 ip 只会出现一次。**

可将 **ip 地址转化为 32 位无符号整数来处理，之后再转回**即可。

但是简单转换的话， 10 亿个 ip 地址转换为 10 亿个整数，每个整数 4 字节则需要约 **4G** 的存储空间。

因此，可以申请一个**长度为 $2^{32}$ 的 bit 类型数组**（每个位置为一个 bit，只能表示 0 或 1 两种状态），占用空间为 **512 MB**。

将该 bit 类型数组视作 bitmap，整数（1、2、……） 出现时将 bitmap 相应的位置**描黑**（0->1）.

最后，在 bitmap 数组中**从 0 开始遍历，提取出被描黑的整数（数组下标），并转换为 ip 地址**即可。

## 案例二：年龄排序

**对 10 亿人的年龄进行排序**

年龄范围可视作 0 ~200，则可设定长度为 200 的数组，分别对 10 亿个人的年龄进行**计数排序**即可。

## 案例三：寻找出现次数最多的数

**有一个包含 20 亿个全是 32 位整数的大文件，在其中找到出现次数最多的数。但是内存限制只有 2G。**

**通常做法：**

利用 Hashmap 对每个数做词频统计，key 指具体某一种数（4 字节整型），value 表示该数出现的次数（4 字节整型）。那么记录条数为 2 亿时则占用了 1.6G 内存。如果所有数都不一样，那么**哈希表可能产生 20 亿条记录**，内存不足。

**解决方法：**

首先，将包含 20 亿个 32 位整数的大文件使用哈希函数进行**分流**，分为多个小文件（假设 16 个）。根据哈希函数性质决定，同一种数不会被分流到不同文件中。对于不同的数，每个文件中含有整数的种数也几乎一样。所以小文件中数的**种类也存在上限**（哈希表条目数），不会产生内存不足的问题。

其次，针对每个小文件，利用哈希表进行数频统计。全部小文件处理完成后，会得到 16 个文件中各自的第一名，再从 16 个第一名中选出其中的第一名即可。

## 案例四：寻找没出现过的数

**32 位无符号整数的范围是 0 ~4294967295。现在有一个正好包含 40 亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多 10M 的内存，只用找到一个没出现过的数即可，该如何找？**

通常做法：

利用哈希表来记录所有的数，在最差的情况下将出现 40 亿个不同的数，每条记录占有 4 字节，那么大约需要 **16G** 的内存。

普通方法：

申请长度问 $2^{32}$ 的 bit 类型数组，依照案例一的思路实现，那也需要占用 **512MB** 的空间。

**解决方法：**

1. 将 $0$ ~$ 2^{32}-1$ 的**范围平均分为 64（10M 的 bitmap 大约可以表示的数量）个区间**，那么单个区间可以容纳 $2^{32}/64$ 个数
2. 总范围为 42 亿，但是文件中的数一共有 40 亿个，所以必然会有**区间计数不足 $2^{32}/64$**，假设该区间为 a。
3. 再次遍历 40 亿个数，此时**只关注区间 a 上的数**，并用 bitmat 统计区间 a 上的数的出现情况。此时需要占用的空间为 **521MB / 64 约等于 8M**，满足题意，沿用案例一思路，可用该数组寻找没出现过的数。

我的理解是将范围分成64份，每一次只统计其中一个范围内的数据出现情况，譬如第一次统计区间0\~2^26^,第二次统计2^26^+1\~2^27^，·····，然后就可以在某个区间中找到没出现的数。

**总结：**

1. 根据内存限制决定区间大小，根据区间大小，得到有多少个变量，来记录每个区间中的数出现的次数。
2. 统计区间上的数的出现次数，找到不足的区间。
3. 利用 bitmap 对不满的区间上的数进行词频统计。

## 案例五：求出每天最热100词

**某搜索公司一天的用户搜索词汇是海量的，假设有百亿的数据量，请设计一种求出每天最热 100 词的可行方法。**

1. 沿用**哈希分流**的思路处理百亿数量集的搜索词汇，将词汇分流到不同的机器上。若每台机器上的词汇量仍然超过了其可以处理的数量，则在每台机器上再次进行哈希分流操作，将文件分为若干个小文件来处理。

2. 处理每一个小文件，利用哈希表得到每个小文件中词汇的词频统计。
3. 建立记录后，利用**小根堆**来进行 Top100 的筛选，每次筛选最小的抛弃，当哈希表遍历完，堆里的数据就是top100。
4. 选出每个小文件的 Top100 之后利用**小根堆**或外排序合并来得到每台机器上的 Top100，同理得到最终的 Top100。



---
title: 深度学习与CV
date: 2021-02-28 16:35:50
tags: 深度学习 CV
categories: 深度学习 CV
---

# 深度学习

## tensorflow



## 深度神经网络

### 神经网络简介

**目前常用的神经网络包括：**

- **卷积神经网络(CNN)**
- **循环神经网络(RNN)**
- **生成对抗神经网络(GAN)**
- **深度强化学习(DRL)**---
title: 矩阵中的路径
date: 2020-05-28 22:42:04
tags: 剑指offer
categories: 剑指offer
---

# 题目描述

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。



# DFS递归

```
	private boolean[] memo;

    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {

        for(int i=0;i<matrix.length;i++){
            memo=new boolean[matrix.length];
            if(helper(matrix,rows,cols,str,i,0))
                return true;
        }
        return false;
    }


    private boolean helper(char[] matrix, int rows, int cols, char[] str,int i,int index){
        if(index==str.length) return true;
        if(i<0||i>=matrix.length) return false;
        if(memo[i]) return false;
        if(matrix[i]!=str[index]) return false;
        memo[i]=true;
        return helper(matrix,rows,cols,str,i-1,index+1)||helper(matrix,rows,cols,str,i+1,index+1)||
                helper(matrix,rows,cols,str,i-cols,index+1)||helper(matrix,rows,cols,str,i+cols,index+1);
    }
```

# DFS递归

第二次写忘了在出栈时，让index--

```
	public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        Stack<Integer> stack;
        int len=rows*cols;
        boolean[] memo;
        for(int i=0;i<len;i++){
        	//index记录当前str的访问位置，需要回溯
            int index=0;
            if(matrix[i]!=str[0]) continue;
            stack=new Stack<>();
            memo=new boolean[len];
            stack.push(i);
            memo[i]=true;
            index++;
            while(!stack.isEmpty()){
                if(index==str.length) return true;
                int num=stack.peek();
                if(num%cols!=0&&!memo[num-1]&&matrix[num-1]==str[index]){
                    stack.push(num-1);
                    memo[num-1]=true;
                    index++;
                    continue;
                }
                if((num+1)%cols!=0&&!memo[num+1]&&matrix[num+1]==str[index]){
                    stack.push(num+1);
                    memo[num+1]=true;
                    index++;
                    continue;
                }
                if((num-cols)>=0&&!memo[num-cols]&&matrix[num-cols]==str[index]){
                    stack.push(num-cols);
                    memo[num-cols]=true;
                    index++;
                    continue;
                }
                if((num+cols)<len&&!memo[num+cols]&&matrix[num+cols]==str[index]){
                    stack.push(num+cols);
                    memo[num+cols]=true;
                    index++;
                    continue;
                }
                num=stack.pop();
                //这里不要忘了index--
                index--;
            }
        }
        return false;
    }
```

---
title: 笔试汇总
date: 2020-06-07 16:06:22
tags: 面试
categories: 面试
---

# VIVO

## 6月7号笔试

### 第一题

数组值取1或0，1不能重复，给定一个满足条件的数组求最多可以添加多少个1使得数组依然满足条件。



### 第二题

总共有N层楼，K部手机，求确认收集摔坏楼层所需要的次数



### 第三题

K个排序链表的合并

---

哎，输入输出不会写



## 6月9号  一面

面试25分钟

1. 自我介绍

2. 怎么学的java

3. 本科学过Java吗

4. B+树和B树的区别

5. 项目架构，有什么难点，怎么解决的？(没想到秒杀别人也问这么多)

6. 长连接听过吗？(???，我以为http长连接，不太了解)

7. http了解哪些？  答：报文格式和一些状态码   (然后就不问了，你倒是接着问啊，感觉大家得自己主动讲)

8. 进程调度算法

9. 事务

10. 了解Linux指令吗？   答：了解。(然后就去问别的了  ？？？？ 都不接着往下问的吗)

11. 了解C吗(不了解)

12. 网络编程了解吗？(我就说知道BIO和NIO，简单讲了下NIO)

13. 数据库中的数据结构？(我就答了B+树和哈希索引)

14. 反问：

    - 怎么学安卓
    - 主动讲了一下笔试第三题

    

    

    总得来说没有问什么问题，可能主要得自己主动去回答，好多问题都是自己说了知道，然后等面试官问，然后面试官就不问了，可能也是安卓岗的原因---
title: 笔试输入输出总结
date: 2020-06-07 16:14:49
tags: 笔试
categories: 笔试
---

# 输入一个数组

```
Scanner reader = new Scanner(System.in) ;
        while(reader.hasNextInt())
        {
            int n=reader.nextInt();
            int[] nums=new int[n];
            for(int i=0;i<n;i++){
                nums[i]=reader.nextInt();
            }
            System.out.println(Arrays.toString(nums));
        }
        reader.close() ;
```



# 输入多个int数字，其中用空格间隔

```
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in) ;
        while (scanner.hasNextLine()){
            String line=scanner.nextLine();
            int[] ints = stringToInt(line);
        }
        scanner.close() ;
    }

    private static int[] stringToInt(String s){
        String[] strs = s.trim().split(" ");
        int[] res=new int[strs.length];
        for(int i=0;i<res.length;i++){
            res[i]=Integer.parseInt(strs[i].trim());
        }
        return res;
    }
```

**注意：**

1. String类中的trim()方法可以去掉字符串周围的空格
2. String类的split()方法可以将字符串按照其中的分割符分成一个String数组，如果是按照 `.`分割，则后面是 `"\\."`
3. 将字符串转换成int类型，可以用Integer.parseInt()方法也可以用Integer.valueOf()方法。---
title: 缓存
date: 2020-05-24 11:12:05
tags: 缓存
categories: 缓存
---

# 一.缓存特征

## 命中率

当某个请求能够通过访问缓存而得到响应时，称为缓存命中。

缓存命中率越高，缓存的利用率也就越高。

## 最大空间

缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。

当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。

## 淘汰策略

- FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。
- LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。
- LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。

# 二.缓存位置

## 浏览器

当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。

## ISP

网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。

## 反向代理

反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。

## 本地缓存

使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。

## 分布式缓存

使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。

相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。

## 数据库缓存

MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。

## java内部的缓存

Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。

## CPU多级缓存

CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。

# 三.CDN

内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。

CDN 主要有以下优点：

- 更快地将数据分发给用户；
- 通过部署多台服务器，从而提高系统整体的带宽性能；
- 多台服务器可以看成是一种冗余机制，从而具有高可用性。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15313ed8-a520-4799-a300-2b6b36be314f.jpg)

# 四.缓存问题

## 缓存穿透

指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。

解决方案：

- 对这些不存在的数据缓存一个空数据；
- 对这类请求进行过滤。

## 缓存雪崩

指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。

在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。

解决方案：

- 为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；
- 为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。
- 也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。

## 缓存一致性

缓存一致性要求数据更新的同时缓存数据也能够实时更新。

解决方案：

- 在数据更新的同时立即去更新缓存；
- 在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。

要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。

## 缓存无底洞

指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。

产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。

解决方案：

- 优化批量数据操作命令；
- 减少网络通信次数；
- 降低接入成本，使用长连接 / 连接池，NIO 等。

# 五.数据分布

## 哈希分布

哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。

**传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。**

## 顺序分布

将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，...，6001 ~ 7000。

顺序分布相比于哈希分布的主要优点如下：

- 能保持数据原有的顺序；
- 并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。

# 六.一致性哈希

Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。

## 基本原理

将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg)

一致性哈希**在增加或者删除节点时只会影响到哈希环中相邻的节点**，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66402828-fb2b-418f-83f6-82153491bcfe.jpg)

## 虚拟节点

上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。

数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。

解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。

# 七.LRU

以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：

- 访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。
- 为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。

```
public class LRU<K, V> implements Iterable<K> {

    private Node head;
    private Node tail;
    private HashMap<K, Node> map;
    private int maxSize;

    private class Node {

        Node pre;
        Node next;
        K k;
        V v;

        public Node(K k, V v) {
            this.k = k;
            this.v = v;
        }
    }


    public LRU(int maxSize) {

        this.maxSize = maxSize;
        this.map = new HashMap<>(maxSize * 4 / 3);

        head = new Node(null, null);
        tail = new Node(null, null);

        head.next = tail;
        tail.pre = head;
    }


    public V get(K key) {

        if (!map.containsKey(key)) {
            return null;
        }

        Node node = map.get(key);
        unlink(node);
        appendHead(node);

        return node.v;
    }


    public void put(K key, V value) {

        if (map.containsKey(key)) {
            Node node = map.get(key);
            unlink(node);
        }

        Node node = new Node(key, value);
        map.put(key, node);
        appendHead(node);

        if (map.size() > maxSize) {
            Node toRemove = removeTail();
            map.remove(toRemove.k);
        }
    }


    private void unlink(Node node) {

        Node pre = node.pre;
        Node next = node.next;

        pre.next = next;
        next.pre = pre;

        node.pre = null;
        node.next = null;
    }


    private void appendHead(Node node) {
        Node next = head.next;
        node.next = next;
        next.pre = node;
        node.pre = head;
        head.next = node;
    }


    private Node removeTail() {

        Node node = tail.pre;

        Node pre = node.pre;
        tail.pre = pre;
        pre.next = tail;

        node.pre = null;
        node.next = null;

        return node;
    }
}
```

---
title: 编辑距离
date: 2020-06-11 15:02:23
tags: leetcode
categories: leetcode
---

# [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

**题目描述：**

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

```
示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')


示例 2：

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```



## 动态规划

- 虽然上面规定了有三种操作，其实只有两种，因为给其中一个字符串添加一个字符可以等价于删除另一个字符串中的字符

```
public int minDistance(String word1, String word2) {
        if(word1==null||word2==null) return 0;
        int m=word1.length(),n=word2.length();
        int[][] memo=new int[m+1][n+1];
        for(int i=0;i<=m;i++){
            for(int j=0;j<=n;j++){
                if(i==0||j==0) memo[i][j]=i+j;
                else{
                    if(word1.charAt(i-1)==word2.charAt(j-1))
                        memo[i][j]=memo[i-1][j-1];
                    else
                    	//这里需要额外考虑上memo[i-1][j-1]，也就是替换的情况
                        memo[i][j]=Math.min(Math.min(memo[i-1][j],memo[i][j-1]),memo[i-1][j-1])+1;
                }
            }
        }
        return memo[m][n];
    }
```

---
title: 蓄水池算法
date: 2020-06-26 09:35:04
tags: 算法
categories: 算法
---

# 引论

对于例如**从100000 份调查报告中抽取 1000 份进行统计**的抽样问题，如果要保持概论均等，那么只需要从`random.nextInt(100000)+1`中选出1000个即可，并且保持不重复。

> 但是问题在于很多时候不知道总共有多少份报告，所以需要用到一下的蓄水池算法。

# 算法介绍

算法的过程：

1. 假设数据序列的规模为 n，需要采样的数量的为 k。

2. 首先构建一个可容纳 k 个元素的数组，将序列的前 k 个元素放入数组中。

3. 然后从第 k+1 个元素开始，以 k/n 的概率来决定该元素最后是否被留在数组中（每进来一个新的元素，数组中的每个旧元素被替换的概率是相同的）。 当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本。

# 实现

```
public static int[] sampling(int[] nums,int K){
        int[] pooling=new int[K];
        for(int i=0;i<K;i++){
            pooling[i]=nums[i];
        }
        Random random=new Random();
        for(int i=K;i<nums.length;i++){
            int index=random.nextInt(i+1);
            if(index<K){
                pooling[index]=nums[i];
            }
        }
        return pooling;
    }
```

# 证明

分两步证明：

1. 对于前k个元素，最终被留下来的概率是`1*(1-1/(k+1))*(1-1/(k+2))*(1-1/(k+3))*.....*1/n=k/n`，其中首先前k个元素被选中的概率为1，然后不被第k+1个元素替换的概率为1-1/(k+1)，然后同理得出不被第k+2个元素替换，.......，相乘即可得出结果。
2. 对于从第k+1个元素向后的任何一个元素M，首先其被选中的概率为k/M，然后不被第M+1替换，不被M+2替换，有`k/M*(1-1/(M+1))*(1-1/(M+2))*......*(1-1/n)=k/n`
3. 所以对于任何一个元素都有k/n的概率被选择---
title: 计算机网络
date: 2020-05-19 12:02:29
tags: 计算机网络
categories: 计算机网络
---

# 概述

## 主机之间的通信方式

- 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg) 



- 对等（P2P）：不区分客户和服务器。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg)

## 电路交换和分组交换

### 1.电路交换

电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。

### 2.分组交换

每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说**分组交换不需要占用传输线路**。

在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。

## 时延

总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg)

### 1.排队时延

分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。

### 2.处理时延

主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。

### 3.传输时延

主机或路由器传输数据帧所需要的时间。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dcdbb96c-9077-4121-aeb8-743e54ac02a4.png)



其中 l 表示数据帧的长度，v 表示传输速率。

### 4.传播时延

电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a1616dac-0e12-40b2-827d-9e3f7f0b940d.png)



其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。

## 计算机网络体系结构

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png)

### 1.五层协议

- **应用层** ：为特定**应用程序**提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
- **传输层** ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
- **网络层** ：**为主机提供数据传输服务**。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
- **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装**成帧**。
- **物理层** ：考虑的是**怎样在传输媒体上传输数据比特流**，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

### 2.OSI

其中表示层和会话层用途如下：

- **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- **会话层** ：建立及管理会话。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

### 3.TCP/IP

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png)

### 4.数据在各层之间的传递过程

在向下的过程中，需要添加下层协议所需要的**首部或者尾部**，而在向上的过程中不断拆开首部和尾部。

**路由器只有下面三层协议**，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。

# 物理层

## 通信方式

根据信息在传输线上的传送方向，分为以下三种通信方式：

- 单工通信：单向传输
- 半双工通信：双向交替传输
- 全双工通信：双向同时传输

# 数据链路层

## 基本问题

### 成帧

将网络层传下来的分组添加首部和尾部，**用于标记帧的开始和结束**。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/29a14735-e154-4f60-9a04-c9628e5d09f4.png)

### 透明传输

透明表示一个实际存在的事物看起来好像不存在一样。

帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入**转义字符**。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e738a3d2-f42e-4755-ae13-ca23497e7a97.png)

### 3.差错检测

目前数据链路层广泛使用了**循环冗余检验（CRC）**来检查比特差错。

## 信道分类

### 1.广播信道

一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。

所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。

主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 **CSMA/CD** 协议。

### 2.点对点信道

一对一通信。

因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。

## 信道复用技术

### 1.频分复用

频分复用的所有主机在相同的时间占用不同的频率带宽资源。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4aa5e057-bc57-4719-ab57-c6fbc861c505.png)

### 2.时分复用

时分复用的所有主机在不同的时间占用相同的频率带宽资源。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67582ade-d44a-46a6-8757-3c1296cc1ef9.png)



使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。

### 3.统计时分复用

是对时分复用的一种改进，**不固定每个用户在时分复用帧中的位置**，只要有数据就集中起来组成统计时分复用帧然后发送。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6283be2a-814a-4a10-84bf-9592533fe6bc.png)

### 4.波分复用

光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。

### 5.码分复用

为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 和 ![img](https://latex.codecogs.com/gif.latex?\vec{T}) 有

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/308a02e9-3346-4251-8c41-bd5536dab491.png)



为了讨论方便，取 m=8，设码片 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。

在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6fda1dc7-5c74-49c1-bb79-237a77e43a43.png)



![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e325a903-f0b1-4fbd-82bf-88913dc2f290.png)



其中 ![img](https://latex.codecogs.com/gif.latex?\vec{S%27}) 为 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 的反码。

利用上面的式子我们知道，当接收端使用码片 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。

码分复用需要发送的数据量为原先的 m 倍。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99b6060e-099d-4201-8e86-f8ab3768a7cf.png)

## CSMA/CD协议

CSMA/CD 表示载波监听多点接入 / 碰撞检测。

- **多点接入** ：说明这是总线型网络，许多主机以多点的方式连接到总线上。
- **载波监听** ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
- **碰撞检测** ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。

记**端到端的传播时延为 τ**，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 **争用期** 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。

当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 **截断二进制指数退避算法** 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/19d423e9-74f7-4c2b-9b97-55890e0d5193.png)

## PPP协议

互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1ab9f28-cb15-4178-84b2-98aad87f9bc8.jpg)



PPP 的帧格式：

- F 字段为帧的定界符
- A 和 C 字段暂时没有意义
- FCS 字段是使用 CRC 的检验序列
- 信息部分的长度不超过 1500

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/759013d7-61d8-4509-897a-d75af598a236.png)

## MAC地址

**MAC 地址是链路层地址**，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。

一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。

## 局域网

局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。

主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。

可以按照网络拓扑结构对局域网进行分类：

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/807f4258-dba8-4c54-9c3c-a707c7ccffa2.jpg)

## 以太网

以太网是一种星型拓扑结构局域网。

早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。

目前以太网使用**交换机**替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。

以太网帧格式：

- **类型** ：标记上层使用的协议；
- **数据** ：长度在 46-1500 之间，如果太小则需要填充；
- **FCS** ：帧检验序列，使用的是 CRC 检验方法；

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/164944d3-bbd2-4bb2-924b-e62199c51b90.png)

## 交换机

交换机具有**自学习能力**，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。

正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。

下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，**此时没有主机 B 的表项，那么主机 A 就发送广播帧**，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png)

## 虚拟局域网

虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。

例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。

使用 VLAN 干线连接来建立虚拟局域网，**每台交换机上的一个特殊接口被设置为干线接口**，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98e9d20-206b-4533-bacf-3448d0096f38.png)

# 网络层

## 概述

因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、**无连接的、尽最大努力**交互的数据报服务。

使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png)



与 IP 协议配套使用的还有三个协议：

- 地址解析协议 ARP（Address Resolution Protocol）
- 网际控制报文协议 ICMP（Internet Control Message Protocol）
- 网际组管理协议 IGMP（Internet Group Management Protocol）

## IP数据报格式

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg)



- **版本** : 有 4（IPv4）和 6（IPv6）两个值；
- **首部长度** : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。
- **区分服务** : 用来获得更好的服务，一般情况下不使用。
- **总长度** : 包括首部长度和数据部分长度。
- **生存时间** ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。
- **协议** ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。
- **首部检验和** ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。
- **标识** : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。
- **片偏移** : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png)

## IP地址编制方式

IP 地址的编址方式经历了三个历史阶段：

- 分类
- 子网划分
- 无分类

### 1.分类

由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。

IP 地址 ::= {< 网络号 >, < 主机号 >}

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png)

### 2.子网划分

通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。

IP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}

要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。

注意，外部网络看不到子网的存在。

### 3.无分类

无分类编址 **CIDR** 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

IP 地址 ::= {< 网络前缀号 >, < 主机号 >}

CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。

CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。

一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 **构成超网** 。

在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用**最长前缀匹配**来确定应该匹配哪一个。

## 地址解析协议ARP

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，**IP 数据报的源地址和目的地址始终不变**，而 **MAC 地址随着链路的改变而改变**。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg)



**ARP 实现由 IP 地址得到 MAC 地址**。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg)



每个主机都有一个 **ARP 高速缓存**，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过**广播的方式发送 ARP 请求分组**，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8006a450-6c2f-498c-a928-c927f758b1d0.png)

## 网际控制报文协议ICMP

ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg)

ICMP 报文分为**差错报告报文**和**询问报文**。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png)

### 1.Ping

Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。

Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

### 2.Traceroute

Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。

Traceroute 发送的 IP 数据报封装的是**无法交付的 UDP 用户数据报**，并由目的主机发送终点不可达差错报告报文。

- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP **时间超过**差错报告报文；
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP **终点不可达**差错报告报文。
- 之后源主机知道了到达目的主机**所经过的路由器 IP 地址以及到达每个路由器的往返时间**。

## 虚拟专用网VPN

由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。

有三个专用地址块：

- 10.0.0.0 ~ 10.255.255.255
- 172.16.0.0 ~ 172.31.255.255
- 192.168.0.0 ~ 192.168.255.255

VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。

下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后**重新加上数据报的首部**，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1556770b-8c01-4681-af10-46f1df69202c.jpg)

## 网络地址转换NAT

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 **NAT 来将本地 IP 转换为全球 IP**。

在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png)

## 路由器的结构

路由器从功能上可以划分为：路由选择和分组转发。

分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c3369072-c740-43b0-b276-202bd1d3960d.jpg)

## 路由器分组转发流程

- 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。
- 若 N 就是与此路由器直接相连的某个网络地址，则进行**直接交付**；
- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
- 报告转发分组出错。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1ab49e39-012b-4383-8284-26570987e3c4.jpg)

## 路由选择协议

路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。

互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。

可以把路由选择协议划分为两大类：

- 自治系统内部的路由选择：RIP 和 OSPF
- 自治系统间的路由选择：BGP

### 1.内部网关协议RIP

RIP 是一种基于**距离向量**的路由选择协议。距离是指跳数，直接相连的路由器**跳数**为 1。跳数最多为 15，超过 15 表示不可达。

RIP 按**固定的时间间隔**仅和**相邻路由器交换自己的路由表**，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。

距离向量算法：

- 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；
- 对修改后的 RIP 报文中的每一个项目，进行以下步骤：
  - 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；
  - 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。
- 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。

RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。

### 2.内部网关协议OSPF

开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。

开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 。

OSPF 具有以下特点：

- 向本自治系统中的所有路由器发送信息，这种方法是**洪泛法**。
- **发送的信息就是与相邻路由器的链路状态**，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
- **只有当链路状态发生变化时，路由器才会发送信息**。

所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程**收敛的很快**。

### 3.外部网关协议BGP

BGP（Border Gateway Protocol，边界网关协议）

AS 之间的路由选择很困难，主要是由于：

- 互联网规模很大；
- 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
- AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

BGP 只能寻找一条比较好的路由，**而不是最佳路由**。

每个 AS 都必须配置 **BGP 发言人**，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png)

# 传输层

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的**进程**。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

## UDP和TCP的特点

- 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
- 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

## UDP首部格式

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg)



首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

## TCP首部格式

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png)



- **序号** ：用于对**字节流**进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。**当 SYN=1，ACK=0 时表示这是一个连接请求报文段**。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

## TCP连接全过程状态

```
LISTEN：侦听来自远方的TCP端口的连接请求

SYN-SENT：再发送连接请求后等待匹配的连接请求（客户端）

SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（服务器）

ESTABLISHED：代表一个打开的连接

FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认

FIN-WAIT-2：从远程TCP等待连接中断请求

CLOSE-WAIT：等待从本地用户发来的连接中断请求

CLOSING：等待远程TCP对连接中断的确认

LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认

TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认

CLOSED：没有任何连接状态
```

### 建立连接时的状态变迁

一开始，建立连接之前服务器和客户端的状态都为CLOSED。服务器创建socket后开始监听，变为LISTEN状态。客户端请求建立连接，向服务器发送SYN报文，客户端的状态变为SYN_SENT。服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD。然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED，服务器收到客户端的ACK后也变为ESTABLISHED。此时，3次握手完成，连接建立！

### 断开连接时的状态变迁

由于tcp连接是全双工的，断开连接会比建立连接麻烦一点点。客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1。服务器收到FIN后向客户端发生ACK，服务器状态变为CLOSE_WAIT。客户端收到ACK后就进入FIN_WAIT2状态。此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送。直到发完了，就发送FIN报文，此时服务器进入LAST_ACK状态。客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态，再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。
至此，还有一个状态没有提及：CLOSING状态。CLOSING状态表示客户端发生了FIN，但没有收到服务器的ACK，却收到了服务器的FIN。这种情况发生在服务器发送的ACK丢包的时候，因为网络传输有时会有意外。

### 详细解释

**tcp连接建立（tcp三握手）**
TCP连接的建立采用客户-服务器模式：主动发起连接建立的应用进程叫做客户，被动等待连接建立的应用进程叫做服务器。
连接建立阶段：
第一次握手：客户端的应用进程主动打开，并向服务端发出请求报文段。其首部中：SYN=1,seq=x。
第二次握手：服务器应用进程被动打开。若同意客户端的请求，则发回确认报文，其首部中：SYN=1,ACK=1,ack=x+1,seq=y。
第三次握手：客户端收到确认报文之后，通知上层应用进程连接已建立，并向服务器发出确认报文，其首部：ACK=1,ack=y+1。当服务器收到客户端的确认报文之后，也通知其上层应用进程连接已建立。
在这个过程中，通信双方的状态如下图，其中CLOSED：关闭状态、LISTEN：收听状态、SYN-SENT：同步已发送、SYN-RCVD：同步收到、ESTAB-LISHED：连接已建立
至此，TCP连接就建立了，客户端和服务器可以愉快地玩耍了。只要通信双方没有一方发出连接释放的请求，连接就将一直保持。
![这里写图片描述](https://img-blog.csdn.net/20180328001537836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hraGxfMjM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## TCP的三次握手

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png)

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

**三次握手的原因**

第三次握手是为了**防止失效的连接请求到达服务器**，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

## TCP的四次挥手

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。

### 四次挥手的原因

因为TCP连接是全双工的，当一方数据发送完之后，另一方数据可能还没有发送完，所以需要两次连接的释放和确认。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么的理由：

- 确保最后一个确认报文能够到达。**如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文**，A 等待一段时间就是为了处理这种情况的发生。

## TCP可靠传输

TCP 使用**超时重传**来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

![img](https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT)


其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：

![img](https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d)


其中 RTTd 为偏差的加权平均值。

## TCP滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的**窗口字段**告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg)

## TCP流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的**窗口字段**可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

## TCP拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg)



TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png)

### 1.满开始和拥塞避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

### 2.快重传和快恢复

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png)

# 应用层

## 域名系统

DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。

域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b54eeb16-0b0e-484c-be62-306f57c40d77.jpg)

## 文件传输协议

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：

- **控制连接**：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
- **数据连接**：用来传送一个文件数据。

根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：

- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/03f47940-3843-4b51-9e42-5dcaff44858b.jpg)



- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg)



主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。

## 动态主机配置协议

DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。

DHCP 工作过程如下：

1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被**广播**到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。
2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。
3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。
4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg)

**简单描述过程**：客户端发送广播去寻找DHCP服务器，DHCP服务器收到后发送确认报文，其中包括客户端所需要的信息，由于客户端可能收到了多个DHCP服务器提供的信息，所以客户端还需要选择其中一个，然后发送确认报文，DHCP服务器收到后还要确认。

## 远程登陆协议

TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。

TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。

## 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b3efa99-d306-4982-8cfb-e7153c33aab4.png)

### 1.SMTP

SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed5522bb-3a60-481c-8654-43e7195a48fe.png)

### 2.POP3

POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。

### 3.IMAP

IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。

## 常用端口

|                  |            |         |            |                             |
| ---------------- | ---------- | ------- | ---------- | --------------------------- |
| 应用             | 应用层协议 | 端口号  | 传输层协议 | 备注                        |
| 域名解析         | DNS        | 53      | UDP/TCP    | 长度超过 512 字节时使用 TCP |
| 动态主机配置协议 | DHCP       | 67/68   | UDP        |                             |
| 简单网络管理协议 | SNMP       | 161/162 | UDP        |                             |
| 文件传送协议     | FTP        | 20/21   | TCP        | 控制连接 21，数据连接 20    |
| 远程终端协议     | TELNET     | 23      | TCP        |                             |
| 超文本传送协议   | HTTP       | 80      | TCP        |                             |
| 简单邮件传送协议 | SMTP       | 25      | TCP        |                             |
| 邮件读取协议     | POP3       | 110     | TCP        |                             |
| 网际报文存取协议 | IMAP       | 143     | TCP        |                             |

## Web页面请求过程

总体来说分为以下几个过程:

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

### 具体过程

#### DNS解析过程

![DNS解析过程](https://segmentfault.com/img/bVDM45?w=1928&h=1248)

上述图片是查找**www.google.com**的IP地址过程。首先在**本地域名服务器**中查询IP地址，如果没有找到的情况下，本地域名服务器会向**根域名服务器**发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com**顶级域名服务器**发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -> google.com -> www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -> .com -> google.com. -> www.google.com.。

#### DNS解析的迭代和递归的区别

- DNS解析的递归过程：主机查询本地域名服务器，如果没有查询到，本地域名服务器就作为DNS客户向根域名服务器发送请求报文，直到查询到之后返回。
- DNS解析的迭代过程：主机查询本地域名服务器，如果没有查询到，本地域名服务器会返回下一个到哪个服务器去查询的地址。

### DNS劫持

**劫持流程：**

DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则**返回假的IP地址**或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对DNS解析服务器做手脚，或者是使用伪造的DNS解析服务器可以通过下图来展示

![DNS劫持原理](https://user-gold-cdn.xitu.io/2017/9/14/eadef534e6c4347b6e2e6feb91e97b89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。

**解决办法：**

DNS的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的DNS解析而使用自己的解析服务器或者是提前在自己的App中将解析好的域名以IP的形式发出去就可以绕过运营商DNS解析，这样一来也避免了DNS劫持的问题。---
title: 设计模式
date: 2020-05-04 20:51:21
tags: 
	- java
	- 面试
categories:
	- 设计模式	
---

# 六大原则

**1、开闭原则（Open Close Principle）**

开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，**任何基类可以出现的地方，子类一定可以出现**。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成 / 聚合的方式，而不是使用继承。

# 创建型

## 单例模式

- 确保一个对象只有一个实例



使用一个**私有构造函数、一个私有静态变量以及一个公有静态函数来实现**。

私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

### 懒汉式-线程不安全

私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。

```
public class Singleton {
    private static Singleton uniqueInstance;
    private Singleton(){}
    public static Singleton getUniqueInstance(){
        if(uniqueInstance==null)
            uniqueInstance=new Singleton();
        return uniqueInstance;
    }
}
```

这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 `if (uniqueInstance == null)` ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 `uniqueInstance = new Singleton();` 语句，这将导致实例化多次 uniqueInstance。



### 饿汉式-线程安全

```
public class Singleton1 {
    private static Singleton1 uniqueInstance=new Singleton1();
    private Singleton1(){}
    public static Singleton1 getUniqueInstance(){
        return uniqueInstance;
    }
}
```

其是通过类初始化时，JVM会正确的加锁，使得只有一个线程正确的指向clinit()方法



### 懒汉式-线程安全

对 getUniqueInstance() 方法**加锁**

```
private static Singleton2 uniqueInstance;
    private Singleton2(){}
    public synchronized static Singleton2 getUniqueInstance(){
        if(uniqueInstance==null)
            uniqueInstance=new Singleton2();
        return uniqueInstance;
    }
```



### 双重检查锁-线程安全

```
	private static volatile Singleton3 uniqueInstance;
    private Singleton3(){}
    public static Singleton3 getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton3.class) {
                if(uniqueInstance==null)
                    uniqueInstance = new Singleton3();
            }
        }
        return uniqueInstance;
    }
```

uniqueInstance 采用 volatile 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：

1. 为 uniqueInstance 分配内存空间
2. 初始化 uniqueInstance
3. 将 uniqueInstance 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1>3>2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。

**使用 volatile 可以禁止 JVM 的指令重排**，保证在多线程环境下也能正常运行。



### 静态内部类

当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance()` 方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。

这种方式不仅具有**延迟初始化**的好处，而且由 JVM 提供了对线程安全的支持。

```
public class Singleton4 {
    private Singleton4(){}
    private static class SingletonHolder{
        private static final Singleton4 uniqueInstance=new Singleton4();
    }
    public static Singleton4 getUniqueInstance() {
        return SingletonHolder.uniqueInstance;
    }
}
```

**注意这里是使用的静态内部类，而不能是成员内部类，因为成员内部类不能有static字段。**

### 源码中的RunTime

Runtime 类封装了 Java 运行时的环境。每一个 Java 程序实际上都是启动了一个 JVM 进程，那么每个 JVM 进程都式对应这一个 Runtime 实例，此实例是由 JVM 为其实例化的。每个 Java 应用程序都有一个 Runtime 类实例，应使用程序能够与其运行的环境相连接。

由于 Java 是单进程的，所以，在一个 JVM 中，Runtime 的实例应该只有一个，所以应该使用单例来实现。

**源码中的实现使用了饿汉式**。



## 工厂模式

### 简单工厂

简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让**简单工厂类来决定应该用哪个具体子类来实例化**。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png)

```
public interface Product {
}

public class ConcreteProduct implements Product {
}

public class ConcreteProduct1 implements Product {
}

public class ConcreteProduct2 implements Product {
}
```

以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。

```java
public class SimpleFactory {

    public Product createProduct(int type) {
        if (type == 1) {
            return new ConcreteProduct1();
        } else if (type == 2) {
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}

public class Client {

    public static void main(String[] args) {
        SimpleFactory simpleFactory = new SimpleFactory();
        Product product = simpleFactory.createProduct(1);
        // do something with the product
    }
}
```



### 工厂方法

定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png)

```
public abstract class Factory {
    abstract public Product factoryMethod();
    public void doSomething() {
        Product product = factoryMethod();
        // do something with the product
    }
}


public class ConcreteFactory extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct();
    }
}


public class ConcreteFactory1 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct1();
    }
}


public class ConcreteFactory2 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct2();
    }
}
```

### 抽象工厂

提供一个接口，用于创建 **相关的对象家族** ，其与工厂方法的不同是其针对的是一个对象族。

**抽象工厂提供 一个父类接口，子类去实现其中的方法来决定到底创建哪个对象**

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png)

```
public class AbstractProductA {
}


public class AbstractProductB {
}


public class ProductA1 extends AbstractProductA {
}


public class ProductA2 extends AbstractProductA {
}


public class ProductB1 extends AbstractProductB {
}


public class ProductB2 extends AbstractProductB {
}


public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();
}


public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA1();
    }

    AbstractProductB createProductB() {
        return new ProductB1();
    }
}


public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA2();
    }

    AbstractProductB createProductB() {
        return new ProductB2();
    }
}


public class Client {
    public static void main(String[] args) {
        AbstractFactory abstractFactory = new ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        // do something with productA and productB
    }
}
```



# 行为型

## 状态模式

允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。



下面以电梯的例子为例：

首先想象电梯的动作：开门，关门，上行，下行，先看一种类图设计：

![img](https://box.kancloud.cn/2016-08-14_57b0036ab3f53.jpg)

一个简单的ILift接口，然后是电梯实现类Lift，在Lift中去实现特定的动作。

但是上面存在的问题是比如电梯门的打开是有条件的，不能在电梯运行中开门，也就是说这四个动作是有前置条件的，具体点就是**在特定的状态下才能做特定的事**。

那么就定义几个状态：

- 开门状态
- 闭门状态
- 运行状态
- 停止状态

那么想到首先可以通过设计几个静态常量来表示状态，比如1表示开门状态....，然后在特定的方法中，去判断当前的状态，采取不同的动作，类图如下：

![img](https://box.kancloud.cn/2016-08-14_57b0036adf841.jpg)

但是上面的修改还有一定的问题：

1. 电梯实现类Lift过长，因为方法里面要用很多的判断
2. **扩展性差**，比如电梯增加两个状态，通电状态和断电状态，只能再去修改代码，多添加两个状态，然后每个方法都要再多去判断这两个条件，或者电梯需要去维修，关闭状态肯定不能实现，不能在维修的时候电梯还能移动。**违背了开闭原则**。



下面是状态模式的设计类图：

![img](https://box.kancloud.cn/2016-08-14_57b0036b02d19.jpg)

定义一个LiftState的抽象类。其中包含一个protected的Context变量。

```
public class OpenningState extends LiftState {
     //开启当然可以关闭了，我就想测试一下电梯门开关功能
     @Override
     public void close() {
             //状态修改
             super.context.setLiftState(Context.closeingState);
             //动作委托为CloseState来执行
             super.context.getLiftState().close();
     }
     //打开电梯门
     @Override
     public void open() {
             System.out.println("电梯门开启...");
     }
     //门开着时电梯就运行跑，这电梯，吓死你！
     @Override
     public void run() {
             //do nothing;
     }
     //开门还不停止？
     public void stop() {
             //do nothing;
     }
}
```

```
public class ClosingState extends LiftState {
     //电梯门关闭，这是关闭状态要实现的动作
     @Override
     public void close() {
             System.out.println("电梯门关闭...");
     }
     //电梯门关了再打开
     @Override
     public void open() {
             super.context.setLiftState(Context.openningState);  //置为敞门状态
             super.context.getLiftState().open();
     }
     //电梯门关了就运行，这是再正常不过了
     @Override
     public void run() {
             super.context.setLiftState(Context.runningState); //设置为运行状态
             super.context.getLiftState().run();
     }
     //电梯门关着，我就不按楼层
     @Override
     public void stop() {
             super.context.setLiftState(Context.stoppingState);  //设置为停止状态
             super.context.getLiftState().stop();
     }
}
```

```
public class Context {
     //定义出所有的电梯状态
     public final static OpenningState openningState = new OpenningState();
     public final static ClosingState closeingState = new ClosingState();
     public final static RunningState runningState = new RunningState();
     public final static StoppingState stoppingState = new StoppingState();
     //定义一个当前电梯状态
     private LiftState liftState;
     public LiftState getLiftState() {
             return liftState;
     }
     public void setLiftState(LiftState liftState) {
             this.liftState = liftState;
             //把当前的环境通知到各个实现类中
             this.liftState.setContext(this);
     }
     public void open(){
             this.liftState.open();
     }
     public void close(){
             this.liftState.close();
     }
     public void run(){
             this.liftState.run();
     }
     public void stop(){
             this.liftState.stop();
     }
}
```

> 参考：http://www.kancloud.cn:8080/sstd521/design/193606



## 策略模式

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

![策略模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg)

## 策略模式 VS 状态模式

都是通过Context类封装一个具体的行为，都提供了一个封装的方法，是高扩展性的设计模式。但根据两者的定义，我们发现两者的区别还是很明显的：策略模式封装的是不同的算法，**算法之间没有交互，以达到算法可以自由切换的目的**；而**状态模式封装的是不同的状态，以达到状态切换随行为发生改变的目的**。这两种模式虽然都有变换的行为，但是两者的目标却是不同的。



## 模板方法

定义**算法框架**，并将一些步骤的实现延迟到子类。

通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。



![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png)

比如AQS中的acquire()方法，以及ClassLoader中的loadClass()方法

## 观察者模式

定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。

主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg)

主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。

观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png)

天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg)



```java
public interface Subject {
    void registerObserver(Observer o);

    void removeObserver(Observer o);

    void notifyObserver();
}

public class WeatherData implements Subject {
    private List<Observer> observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherData() {
        observers = new ArrayList<>();
    }

    public void setMeasurements(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        notifyObserver();
    }

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        int i = observers.indexOf(o);
        if (i >= 0) {
            observers.remove(i);
        }
    }

    @Override
    public void notifyObserver() {
        for (Observer o : observers) {
            o.update(temperature, humidity, pressure);
        }
    }
}


public interface Observer {
    void update(float temp, float humidity, float pressure);
}


public class StatisticsDisplay implements Observer {

    public StatisticsDisplay(Subject weatherData) {
        weatherData.reisterObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println("StatisticsDisplay.update: " + temp + " " + humidity + " " + pressure);
    }
}


public class CurrentConditionsDisplay implements Observer {

    public CurrentConditionsDisplay(Subject weatherData) {
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println("CurrentConditionsDisplay.update: " + temp + " " + humidity + " " + pressure);
    }
}


public class WeatherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);

        weatherData.setMeasurements(0, 0, 0);
        weatherData.setMeasurements(1, 1, 1);
    }
}


CurrentConditionsDisplay.update: 0.0 0.0 0.0
StatisticsDisplay.update: 0.0 0.0 0.0
CurrentConditionsDisplay.update: 1.0 1.0 1.0
StatisticsDisplay.update: 1.0 1.0 1.0
```

# 结构型

## 适配器模式

把一个类接口转换成另一个用户需要的接口。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png)



![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ff5152fc-4ff3-44c4-95d6-1061002c364a.png)

鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。

要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！

```java
public interface Duck {
    void quack();
}

public interface Turkey {
    void gobble();
}

public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println("gobble!");
    }
}

public class TurkeyAdapter implements Duck {
    Turkey turkey;

    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }

    @Override
    public void quack() {
        turkey.gobble();
    }
}

public class Client {
    public static void main(String[] args) {
        Turkey turkey = new WildTurkey();
        Duck duck = new TurkeyAdapter(turkey);
        duck.quack();
    }
}
```



## 代理模式

为其他对象提供一种代理以控制对这个对象的访问。

![img](https://box.kancloud.cn/2016-08-14_57b00362871a1.jpg)

```
public interface Subject {
     //定义一个方法
     public void request();
}
```



```
public class RealSubject implements Subject {
     //实现方法
     public void request() {
             //业务逻辑处理
     }
}
```



```
public class Proxy implements Subject {
     //要代理哪个实现类
     private Subject subject = null;    
     //默认被代理者
     public Proxy(){
             this.subject = new Proxy();
     }
     //通过构造函数传递代理者
     public Proxy(Object...objects ){
     }
     //实现接口中定义的方法
     public void request() {
             this.before();
             this.subject.request();
             this.after();
     }
     //预处理
     private void before(){
             //do something
     }
     //善后处理
     private void after(){
             //do something
     }
}
```



## 装饰者模式

为对象动态添加功能。



**装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component）**，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。

 ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png)

设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。

下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg)



```java
public interface Beverage {
    double cost();
}


public class DarkRoast implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}


public class HouseBlend implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}


public abstract class CondimentDecorator implements Beverage {
    protected Beverage beverage;
}


public class Milk extends CondimentDecorator {

    public Milk(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}


public class Mocha extends CondimentDecorator {

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public double cost() {
        return 1 + beverage.cost();
    }
}


public class Client {

    public static void main(String[] args) {
        Beverage beverage = new HouseBlend();
        beverage = new Mocha(beverage);
        beverage = new Milk(beverage);
        System.out.println(beverage.cost());
    }
}


3.0
```



例如：java中的IO类



# 面向对象思想

## 一.三大特性

### 封装

利用抽象数据类型将**数据**和**基于数据的操作**封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。

优点：

- 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
- 减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块
- 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
- 提高软件的可重用性
- 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的

以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。

注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。

```java
public class Person {

    private String name;
    private int gender;
    private int age;

    public String getName() {
        return name;
    }

    public String getGender() {
        return gender == 0 ? "man" : "woman";
    }

    public void work() {
        if (18 <= age && age <= 50) {
            System.out.println(name + " is working very hard!");
        } else {
            System.out.println(name + " can't work any more!");
        }
    }
}
```

### 继承

继承实现了 **IS-A** 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。

继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 **向上转型** 。

```java
Animal animal = new Cat();
```

### 多态

多态分为编译时多态和运行时多态：

- 编译时多态主要指方法的重载
- 运行时多态指**程序中定义的对象引用所指向的具体类型在运行期间才确定**

运行时多态有三个条件：

- 继承
- 覆盖（重写）
- 向上转型

下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。

```java
public class Instrument {

    public void play() {
        System.out.println("Instument is playing...");
    }
}

public class Wind extends Instrument {

    public void play() {
        System.out.println("Wind is playing...");
    }
}

public class Percussion extends Instrument {

    public void play() {
        System.out.println("Percussion is playing...");
    }
}
public class Music {

    public static void main(String[] args) {
        List<Instrument> instruments = new ArrayList<>();
        instruments.add(new Wind());
        instruments.add(new Percussion());
        for(Instrument instrument : instruments) {
            instrument.play();
        }
    }
}

Wind is playing...
Percussion is playing...
```

---
title: 调整数组顺序使奇数位于偶数前面
date: 2020-05-22 15:38:32
tags: 剑指offer
categories: 剑指offer
---

## 题目描述

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。





类似于直接插入排序的思想：

第一个数肯定满足条件；

两个数时，判断第二个数是不是偶数，如果是则不动；否则将其与前面的偶数互换。

```
public void reOrderArray(int [] array) {
        if(array==null||array.length==0) return;
        for(int i=1;i<array.length;i++){
            if(array[i]%2==0) continue;
            for(int j=i;j>0;j--){
                if(array[j-1]%2==0&&array[j]%2==1){
                    int temp=array[j-1];
                    array[j-1]=array[j];
                    array[j]=temp;
                }
            }
        }
    }
```

---
title: 贪心算法
date: 2020-05-29 20:07:07
tags: 算法
categories: 贪心算法
---

# [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。



**给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。**

```
public int findContentChildren(int[] g, int[] s) {
        if(g==null||s==null) return 0;
        Arrays.sort(g);
        Arrays.sort(s);
        int gi=0,si=0;
        while(gi<g.length&&si<s.length){
            if(g[gi]<=s[si]){
                gi++;
                si++;
            }else si++;
        }
        return gi;
    }
```

---
title: 重建二叉树
date: 2020-05-21 15:36:19
tags: 剑指offer
categories: 剑指offer
---

**题目描述：**

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。





可以用一个map来存储in数组中的元素和索引的对于关系。

```
public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
               if(pre==null||in==null){
            return null;
        }
 
        HashMap<Integer,Integer> map= new HashMap<Integer, Integer>();
        for(int i=0;i<in.length;i++){
            map.put(in[i],i);
        }
        return preIn(pre,0,pre.length-1,in,0,in.length-1,map);
    }
     
      public TreeNode preIn(int[] p,int pi,int pj,int[] n,int ni,int nj,HashMap<Integer,Integer> map){
        if(pi>pj){
            return null;
        }
        TreeNode head=new TreeNode(p[pi]);
        int index=map.get(p[pi]);
        head.left=preIn(p,pi+1,pi+index-ni,n,ni,index-1,map);
        head.right=preIn(p,pi+index-ni+1,pj,n,index+1,nj,map);
        return head;
    }
```

---
title: 集群
date: 2020-05-24 14:32:23
tags: 集群
categories: 集群
---

# 一.负载均衡

集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。

负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。

负载均衡器可以用来实现高可用以及伸缩性：

- 高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；
- 伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。

负载均衡器运行过程包含两个部分：

1. 根据负载均衡算法得到转发的节点；
2. 进行转发。

## 负载均衡算法

### 1.轮询

**轮询算法把每个请求轮流发送到每个服务器上**。

下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9daa3616-00a4-48c4-9146-792dc8499be3.jpg)

该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bfea8772-d01b-4a51-8adc-edfd7d3dce84.jpg)

### 2.加权轮询

加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。

例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4ab87717-e264-4232-825d-8aaf08f14e8b.jpg)

### 3.最少连接

由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。

例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98deb5a-d5d4-4294-aa9b-9220d4483403.jpg)

**最少连接算法就是将请求发送给当前最少连接数的服务器上。**

例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/43d323ac-9f07-4e4a-a315-4eaf8c38766c.jpg)

### 4.加权最少连接

在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。

### 5.随机算法

把请求随机发送到服务器上。

和轮询算法类似，该算法比较适合服务器性能差不多的场景。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a42ad3a7-3574-4c48-a783-ed3d08a0688a.jpg)

### 6.源地址哈希法

源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。

可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0f399a9f-1351-4b2d-b8a4-2ebe82b1a703.jpg)

## 转发实现

### 1.HTTP重定向

HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，**状态码为 302**。客户端收到重定向报文之后，需要重新向服务器发起请求。

缺点：

- 需要两次请求，因此访问延迟比较高；
- HTTP 负载均衡器处理能力有限，会限制集群的规模。

该负载均衡转发的缺点比较明显，实际场景中很少使用它。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/02a1fbfd-7a9d-4114-95df-ca2445587a1f.jpg)

### 2.DNS域名解析

**在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。**

优点：

- DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。

缺点：

- 由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。

大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2c072cc-8b17-480c-813e-18cdb3b4b51f.jpg)

### 3.反向代理服务器

反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。

在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。

优点：

- 与其它功能集成在一起，部署简单。

缺点：

- 所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。

### 4.网络层

在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。

源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。

优点：

- 在内核进程中进行处理，性能比较高。

缺点：

- 和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。

### 5.链路层

在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。

通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。

这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。

这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。

# 二.集群下的Session管理

一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。

## Sticky Session

需要**配置负载均衡器**，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。

缺点：

- 当服务器宕机时，将丢失该服务器上的所有 Session。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1623f524-b011-40c8-b83f-eab38d538f76.png)

## Session Replication

**在服务器之间进行 Session 同步操作**，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。

缺点：

- 占用过多内存；
- 同步过程占用网络带宽以及服务器处理器时间。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c6570d-c1d7-4c38-843e-ba991b2328c2.png)

## Session Server

**使用一个单独的服务器存储 Session 数据**，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。

优点：

- 为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。

缺点：

- 需要去实现存取 Session 的代码。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fdc45a09-f838-4348-8959-d2c793727788.png)---
title: 零钱兑换II
date: 2020-06-17 10:16:58
tags: leetcode
categories: leetcode
---

# [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

**题目描述：**

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 



```
示例 1:

输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

示例 2:

输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。

示例 3:

输入: amount = 10, coins = [10] 
输出: 1
```





## 动态规划

**算法思想：**

- 本题是每一种硬币可以无限选取的01背包问题，递归式有点不同，其中dp\[i][j]=dp\[i][j-num]+dp\[i-1][j]，简单解释一下就是根据num这枚硬币用0次还是用很多次分为两种情况：
  1. 用0次，就是dp\[i-1][j]
  2. 用很多次，就是dp\[i][j-num]，其中之所以是i，表示对于j-num还可以继续使用num面值的

```
public int change(int amount, int[] coins) {
        if(amount<0)
            return 0;
        int[][] dp=new int[coins.length+1][amount+1];
        int m=dp.length,n=dp[0].length;
        dp[0][0]=1;
        for(int i=1;i<m;i++){
            for(int j=0;j<n;j++){
                if(j==0) dp[i][j]=1;
                else{
                    if(j>=coins[i-1]){
                        dp[i][j]=dp[i][j-coins[i-1]]+dp[i-1][j];
                    }else
                        dp[i][j]=dp[i-1][j];
                }
            }
        }
        return dp[m-1][n-1];
    }
```

---
title: 面经
date: 2020-05-10 22:32:05
tags: 面经
categories: 面经
---

# 美团

## 1.了解Java运行时数据区域吗

java运行时区域分为**堆，虚拟机栈，本地方法栈，程序计数器和方法区**，其中堆和方法区是线程共有的。其中堆是存放对象实例的区域，虚拟机栈是存放栈帧的区域，栈帧中存放着方法中的相关信息，本地方法区和方法区相似，但其是存放本地方法的栈帧，程序计数器指向当前线程程序执行的行号，方法区存放的是**已被虚拟机加载的类信息。**

## 2.了解垃圾回收机制吗

垃圾回收是Java虚拟机(JVM)提供的一种用于回收无用对象占据的内存空间的一种机制，其中设计两个问题：一是如何判断对象已经死亡，二是采取什么样的回收算法。

## 3.static关键字

static关键字可以修饰类，方法和字段。

- static修饰类只能修饰内部类，static修饰内部类表示嵌套类(静态类)，与之相对应的是成员内部类，成员内部类对象需要外部类对象一一对应，所以成员内部类里面可以访问外部类的所有字段，但是嵌套类不用和外部类对象一一对应，所以其不能访问外部类的普通成员和普通方法，只能访问静态成员和静态方法。
- static修饰方法，表示方法是一个静态方法，可以直接通过类名.方法名调用。
- static修饰字段只能修饰成员变量，表示类变量，其与对象无关，类常量会在类加载过程中的初始化过程中通过调用clinit()方法赋值。

## 4.什么时候会报StackOverFlowError/OutOfMemoryError

- 如果线程请求的栈深度大于虚拟机允许最大深度，会抛出StackOverFlowError。
- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OOM(可以通过不停的开启新线程实现)。

## 5.你是怎么对sql语句优化的

1. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

2. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

3. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

   ```
   select id from t where num is null
   ```

   可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：

   ```
   select id from t where num=0
   ```

4. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：

   ```
   select id from t where num=10 or num=20
   ```

   可以这样查询：

   ```
   select id from t where num=10
   
   union all
   
   select id from t where num=20
   ```

   **注意：**or两边如果有一个不是索引索引则会引起全表扫描。

5. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：

   ```java
   select id from t where num/2=100
   ```

   应改为:

   ```java
   select id from t where num=100*2
   ```

## 6.同样是走索引，走索引A为什么比走索引B效果要好，你是怎么进行判断的

两个索引的选择性不同，索引的选择性等于不重复的索引值与数据表中记录的比值，选择性越大，索引效果越好。

## 7.手撕算法题：不用考虑输入输出，不用编译，两个数M和N，N个数相加得到M，输出所有可能。例如M=7，N=2，输出1，6；2，5；3，4。

为了防止重复，可以假定求和时，例如7=6+1=5+2=4+3，一定有前面的元素大于等于后面的元素，所以可以分成两种情况来看，一是最后一个元素为1，二是最后一个元素不是1，则前面所有的元素都大于1，所以有f(m,n)=f(m-1,n-1)+f(m-n,n)，这可以用来计算所有可能的个数。

如果要将所有的可能列出来可以用回溯法：

```
	private List<List<Integer>> res;
    public List<List<Integer>> count(int M,int N){
        res=new ArrayList<>();
        count(M,N,new ArrayList<>());
        return res;
    }

    private void count(int M,int N,List<Integer> list){
        if(N==1){
            list.add(M);
            res.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            return;
        }
        //最小为M/N，注意除为整的时候要带上
        double left=Double.valueOf(M)/Double.valueOf(N);
        //要比前面的元素小
        int right=list.isEmpty()?M-N+1:Math.min(M-N+1,list.get(list.size()-1));
        for(int i=right;i>=left;i--){
            list.add(i);
            count(M-i,N-1,list);
            list.remove(list.size()-1);
        }
    }
```

## 抽象类和接口的区别

1. 抽象类中可以有普通成员方法，接口中不行，接口中只能有抽象方法，默认方法，静态方法。
2. 一个类可以实现多个接口，但只能继承一个类
3. 接口中所有的字段和方法默认都是public修饰的，抽象类中可以自己定义
4. 接口中的字段默认是public static final修饰的常量，抽象类中可以额包括非final的

## 一些场景下索引的设计。例如：需求是select A, B, C from T where A = 'a'，此时怎么设计索引，当需求改为select A, B, C from T where A = 'a' and B = 'b'，你会怎么办

第一个如果A是主键，则直接走聚集索引即可，如果不是主键，可以只建立列A上的索引。第二个可以建立(A,B,C)的联合索引，可以索引覆盖。





# 腾讯

## Redis和mysql的区别

最大的区别在于Redis是非关系数据库，mysql是关系型数据库。

## Redis单线程为什么快

1. Redis是基于内存的，内存的读写非常快。
2. 单线程下，可以省去很多上下文切换的时间
3. Redis使用的多路复用技术，可以处理并发的连接

## mysql索引

mysql包括B+树索引，哈希索引，全文索引和空间索引。

## explain有哪些字段，type有哪些类型

- **select_type** : 查询类型，有简单查询、联合查询、子查询等
- **type**：连接类型
- **key** : 使用的索引
- **rows** : 扫描的行数



其中type类型有：

1. **system：**表只有一行，这是一个`const` type 的特殊情况。

2. **const：**最多只有一行匹配。当使用**主键或者唯一索引**的时候，就是`const`类型

3. **eq_ref：**主键索引(primary key)或者非空唯一索引(unique not null)等值连接查询

4. **ref：**非主键非唯一索引等值连接查询

5. **range：**范围扫描

6. **index：**索引树扫描。index类型，需要扫描全部的索引，它仅比全表扫描快一点。例如：

   `select count(1) from user`

7. **ALL：**全表扫描

## Mysql慢查询

慢查询日志会记录下查询时间超过指定时间的语句。

## 手撕算法：将栈中元素从栈顶降序排列，允许使用一个额外的栈

在另一个栈中，将其从栈顶升序排列，然后再依次出栈入栈即可得到结果。

需要额外处理的是传过来的元素大于栈顶元素时，要一直出队直到栈为空或者栈顶元素小于传过来的元素。

## 手撕算法：将栈中的元素反转，不能申请新的空间。

需要写一个辅助函数，其移除栈的栈底元素并返回。

```
public void reverse(Stack<Integer> stack){
        int bottom = getBottom(stack);
        reverse(stack);
        stack.push(bottom);
    }

    private int getBottom(Stack<Integer> stack){
        Integer pop = stack.pop();
        if(stack.isEmpty()) return pop;
        else {
            int bottom = getBottom(stack);
            stack.push(pop);
            return bottom;
        }
    }
```

## 如何设计表结构

一般设计表满足3NF，下面应该要回答从1NF到3NF

## 手撕算法：第k大的数

直接手撕堆排序。

## 系统态，用户态，什么时候会进入系统态

从特权级来区分用户态和内核态：

CPU指令分为**特权指令**和**非特权指令**，特权指令运行在内核态，非特权指令运行在用户态。系统调用时会进入内核态。

用户态就是用户自定义的程序运行的空间。

## 32位操作系统，单个进程空间的大小

3GB

## 虚拟内存

**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

## 进程调度算法

1. **先来先服务（FCFS）算法**，从**就绪队列**中选择一个**最先进入该队列**的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

   缺点：对长作业有利，对短作业不利

2. **短作业优先（SFS）算法**，从就绪队列中选出一个**估计运行时间最短**的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

   缺点：对长作业不利，如果一直有短作业进入就绪队列，则会导致长作业一直得不到调度

3. **优先级调度算法**， 为每个流程分配优先级，首先执行具有**最高优先级**的进程，依此类推。**具有相同优先级的进程以 FCFS 方式**执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

4. **时间片轮转调度算法**，进程调度总是选择就绪队列中的第一个进程执行，即 **先来先服务**的原则，但仅能运行**一个时间片**。当时间片用完时，由计时器发出时钟中断，**调度程序便停止该进程的执行，并将它送往就绪队列的末尾**，同时继续把 CPU 时间分配给队首的进程。

5. **多级反馈队列调度算法**，通过**动态调整进程优先级和时间片大小**，多级反馈队列调度算法可以兼顾多方面的系统目标。

   其实现思想如下：

   1. 应设置**多个就绪队列**，并为各个队列赋予不同的优先级，**第1级队列的优先级最高**，第2级队列次之，其余队列的优先级逐次降低。

   2. 赋予各个队列中进程执行**时间片的大小也各不相同**，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍，以此类推。
   3. 当一个新进程进入内存后，首先将它放入第1级队列的末尾，按**FCFS**原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统，否则，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行。如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。
   4. 仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ i-1中的任何一个队列），则此时新进程将**抢占**正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。

   ![image-20200417145656581.png](https://i.loli.net/2020/05/11/qpzXtiD5BhQRAE1.png)

## 进程通信的方式

1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。**
5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

## 网络传输过程

从五层模型开始讲，应用层将数据传输给传输层后，传输层加上头部，再传递给网络层加上头部，一直向下直到物理层，加上头部后，传输到物理链路上，当传送到目的主机后，一层层向上拆除头部就可以得到最终的数据。

## TCP，UDP的区别

两者都是传输层协议，TCP面向连接可以保证可靠传输，UDP没有连接不能保证可靠传输。

## TCP四次挥手为什么是四次，不能是两次

首先TCP连接是全双工的，连接双方都可以发送数据，所以在客户端数据发送完时，服务的数据可能还未发送完毕，所以要在服务端数据发送完后，发送一个**连接释放报文**，在收到这个报文后，客户端需要回复这个报文，并且在等待**2MSL(报文最大存活时间)**后再关闭连接，在回复报文到达服务端后服务端才会正式关闭连接。

## 如果a给b发送FIN，b给a发送ACK，a给b发送FIN但是网络断了，这时候双方会做什么

FIN在超时后会重传，b收到后如果数据还没有发送完，就会回复ACK报文，然后接着发送数据，在数据发送完后，发送FIN报文，接着a收到后会回复一个ACK报文。



# 招银网络

## java类加载过程

1. 加载：获取二进制流，并生成Class对象
2. 验证：验证二进制流是否符合虚拟机要求
3. 准备：为类变量赋初值的过程
4. 解析：将常量池中的符号引用转换为直接引用
5. 初始化：执行clinit()方法的过程

## 数据库的索引怎么实现的

数据库的索引包括B+树索引，哈希索引，全文索引和空间索引

## B树和B+树的区别

1. B树的非叶节点包括索引和数据，而B+树的非叶节点只有索引
2. B+树的叶节点用链表连接在一起，而B树没有
3. B+树和B树的查找过程不同，B+树的查找一定会深入到叶节点，而B树可能会在某个非叶节点就查找到结果

## 画个B+树

熟悉熟悉

## 讲一下你知道的java.util.concurrent包下的类

AQS，原子类AtomicInteger，ConcurrentHashMap，ThreadPoolExecutor

AQS：队列同步器，其中封装了获取同步状态和释放同步状态的逻辑，可以自己去实现tryAcquire()或tryAcquireShared()来实现不同的锁。

AtomicInteger：可以保证通过原子操作来更新Integer值，通过volatile和CAS操作来完成

ConcurrentHashMap：是线程安全的map容器，1.7是基于segment的分段锁实现，1.8是基于CAS+synchronized实现。

ThreadPoolExecutor：线程池，其中重要参数讲一讲

## TreeMap了解吗

没有深入源码，只了解其是基于**红黑树**实现的有序的key-value结构。

红黑树的五个特性：

- **1.每个节点要么是黑色要么是红色**
- **2.根节点是黑色**
- **3.每个叶子节点是黑色，并且为空节点(nil节点)**
- **4.如果一个节点是红色，则它的子节点必须是黑色**
- **5.对于任一节点而言，其到叶节点(nil节点)的路径上包含相同数目的黑节点**

## 用数组实现一个队列

我写一个循环队列吧(一般舍弃一个存储单元来判断是否为满)。

## 如果保证缓存和数据库的双写一致性

数据库和缓存更新，就容易出现**缓存(Redis)和数据库（MySQL）间的数据一致性问题**。

不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：

1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。

2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。

因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。

**第一种方案：延时双删**

在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。

伪代码如下

```
public void write( String key, Object data )
{
	redis.delKey( key );
	db.updateData( data );
	Thread.sleep( 500 );
	redis.delKey( key );
}复制代码
```

**具体的步骤就是：**

1. 先删除缓存
2. 再写数据库
3. 休眠500毫秒
4. 再次删除缓存

**那么，这个500毫秒怎么确定的，具体该休眠多久呢？**

需要评估自己的项目的**读数据业务逻辑的耗时**。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。

**该方案的弊端**

结合双删策略+缓存超时设置，这样**最差的情况就是在超时时间内数据存在不一致**，而且又增加了写请求的耗时。



**第二种方案：异步更新缓存(基于binlog的同步机制)**

**1.技术整体思路：**

MySQL binlog增量订阅消费+消息队列+增量数据更新到redis

- **读Redis**：热数据基本都在Redis
- **写MySQL**:增删改都是操作MySQL
- **更新Redis数据**：MySQ的数据操作binlog，来更新到Redis

**2.Redis更新**

**(1）数据操作主要分为两大块：**

- 一个是全量(将全部数据一次写入到redis)
- 一个是增量（实时更新）

这里说的是增量,指的是mysql的update、insert、delate变更数据。

**(2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。**

这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。

其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。

这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。

当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!

# 百度

## 算法：给你n个数，找到最大的m个数

用**小根堆**，或者直接写堆排序。

## equals和hashcode说一下

两个方法都是Object中带的方法，在Object中其是根据对象的地址得到的一个散列值，equals方法判断的是两个对象的地址是否相等，在自定义的类一般要重写这两种方法。

## 线程创建的方法？线程池原理说一下？线程同步的方法？

线程创建两种方法：

1. 实现Runnable接口
2. 继承Thread类



线程池的原理：

线程池中有三个参数，corePoolSize，maximumPoolSize和BlockingQueue分别表示核心线程池大小，最大线程数量和阻塞队列。

在线程池运行时，如果当前线程数小于corePoolSize，那么新的任务会创建一个线程。当等于之后，新的任务会放在阻塞队列中，在队列满后，则会尝试再去创建线程直到线程数等于maximumPoolSize。



线程同步的方法：

1. synchronized
2. Lock
3. CAS
4. volatile

## HashMap讲一下

HashMap是基于哈希表实现的key-value结构，其中采用链地址法来解决哈希冲突，在jdk1.8之后还引入了红黑树，在同一个桶中如果节点大于等于8，则会转换为红黑树。

## HashMap的put()过程讲一下

我基于jdk1.7来讲吧。put()方法首先会判断key是否为null，如果为null则会调用特定的putForNullKey()方法，该方法会遍历第一个桶，也就是table[0]来寻找是否已经有key为null的节点，如果有就覆盖，没有就新建一个节点；如果不是null，则会调用hash()方法来计算其hash值，并与数组长度减一进行按位与运算将其映射在数组区间内，然后遍历这个桶看是否有这个key存在，如果有就覆盖，没有就添加一个新节点，添加新节点时要判断map中的键值对数目也就是**size**是否大于等于阈值，如果大于等于的话，就是扩容为原map的两倍。

## LinkedHashMap和HashMap的区别

LinkedHashMap里面用一个双向链表来实现排序的功能，其可以基于插入顺序也可以基于访问顺序，而HashMap是无序的。

**底层原理：**

- 其内部Entry结构在HashMap的基础上增加了一个before和after域来实现双链表。
- 在put()操作时会将其放在链表尾部
- 在get()方法时，如果 **accessOrder 为 true**，则会将该节点移到链表**尾部**。

## 算法：给你一个字符串，判断是不是标准的ip地址。

Ip地址范围是1\~255.0\~255.0\~255.0\~255

```
public boolean testIpTrue(String str){
        int dot=0;
        int num=0;
        for(int i=0;i<str.length();i++){
            if(str.charAt(i)=='.'){
                if(dot==0){
                    if(num==0||num>255) return false;
                }else {
                    if(dot==3) return false;
                    if(num>255) return false;
                }
                dot++;
                num=0;
            }else {
                int var=str.charAt(i)-'0';
                if(var<0||var>9) return false;
                num=10*num+var;
            }
        }
        //最后返回是否有三个dot
        return dot==3;
    }
```

## TCP的三次握手说一下，为什么？

三次握手流程是客户端首先发送一个SYN=1的连接请求报文过去，服务端收到后响应一个SYN=1，ACK=1的报文，然后客户端收到后再回复一个ACK=1的报文。

三次握手的原因是为了防止失效的连接请求到达服务器，让服务器打开错误的连接。例如客户端发送的请求在网络中滞留，在达到超时时间后，客户端重传请求，但是最后两个请求都到了服务端，如果不进行第三次握手，就会打开两个连接。如果有第三次握手，客户端就会忽略**服务器之后发送的对滞留连接请求**的**连接确认**，不进行第三次握手，因此就不会再次打开连接。

## TCP的滑动窗口原理

原理不太清楚，但是我知道用滑动窗口来进行流量控制和拥塞控制的原理。

流量控制的原理是，发送方根据接收方返回的窗口字段来控制自己的窗口大小。

拥塞控制的原理是发送方基于成功收到确认报文或者超过重传时间来控制自己拥塞窗口的大小，有不同的算法，满开始，拥塞避免，快重传和快恢复。

## hashMap是线程安全的吗？如何实现线程安全？

不是线程安全的。

可以使用 `Collections.synchronizedMap(map)`方法。

或者使用ConcurrentHashMap

## 了解生产者消费者模式吗？他主要解决的是什么问题？队列数目为0的时候是怎样的？描述一下整体过程中线程的状态，怎么实现的是线程同步

主要解决的是两个线程分别向固定大小的优先缓冲区内读和写的同步问题。

当队列数目为0时，消费者会判断出当前队列长度为0，然后调用wait()方法阻塞，直到生产者放入一个元素后，并调用notify()方法将其唤醒。

首先拿到锁的线程会进入就绪态，没有拿到的会进入阻塞态，就绪态的线程运行中，可能会达到阻塞条件后，调用wait()方法进入Waiting状态，并释放锁，阻塞态的线程获取锁后，会变成就绪态，运行中会生产或消费元素，并唤醒Waiting状态下的线程，被唤醒的线程就从Waiting状态醒来后尝试去获取锁，如果获取到就会进入就绪态，否则就是阻塞态。

用synchronized实现。

下面是一个生产者消费者模式的例子，有的面试会要求手写。

```
class Productor implements Runnable{

        private List<Integer> list;
        private int maxSize;
        public Productor(LinkedList<Integer> list,int maxSize){
            this.list=list;
            this.maxSize=maxSize;
        }
        @Override
        public void run() {
            while (true) {
            	//注意充当锁的是list对象。
                synchronized (list) {
                    try {
                    	//注意这里是while
                        while (list.size() == maxSize) {
                            list.wait();
                        }
                        list.add(10);
                        list.notifyAll();
                    }
                    catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
        
        class Consumer implements Runnable{
            private List<Integer> list;
            private int maxSize;
            public Consumer(LinkedList<Integer> list,int maxSize){
                this.list=list;
                this.maxSize=maxSize;
            }
            @Override
            public void run() {
                while (true){
                    synchronized (list){
                        try {
                            while (list.size() == 0) list.wait();
                            list.remove(0);
                            list.notifyAll();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
```



# 拼多多

## 有一个10G的文件，里面是数字，怎么排序？

**外部排序**。分为多个文件，对这些文件依次读入内存进行排序，可以使用归并。得到多个排序好的文件以后将这些文件合并。具体比如分为10个文件，那么就维护10个指针，每次取最小值写入新文件中，最终可以得到。

## Lock和synchronized的区别

1. Lock可以响应中断(lockInterruptibly()方法)，synchronized不能响应中断
2. synchronized不能用于跨方法加锁和解锁

## 线程池的拒绝策略

- **AbortPolicy**：丢弃任务，抛运行时异常
- **CallerRunsPolicy** ：调用者所在线程来执行任务
- **DiscardPolicy**：直接丢弃任务，不进行任何处理也不抛出异常
- **DiscardOldestPolicy**：从队列中踢出最先进入队列（等待最久）的任务，将当前任务加入队列尝试再次提交

## 数据库调优

慢查询日记和explain分析

## 数据库隔离级别

读未提交，读已提交，可重复读，串行化

## 可重复读主要解决了什么问题？幻读？

可重复读级别解决了不可重复读问题。但是在mysql的InnoDB存储引擎中的可重复读级别使用了MVCC+Next-KeyLock解决了幻读问题。在可重复读的隔离级别下，Mysql不仅会对相应的行进行加锁，还会对间隙加锁。

## Redis持久化

RDB和AOF，save和bgsave命令，save当前进程持久化，这段时间不能接受新请求。bgsave创建子进程，不影响当前进程。

AOF会在根据不同的AOF持久化方式，将指令追加到AOF文件中。

AOF重写：**BGREWRITEAOF**指令，Redsi服务器会维护一个**AOF重写缓冲区**，在重写进行过程中，该缓冲区会记录这段时间内的所有指令，然后等重写完成后，将其追加到新的AOF文件中，并替换旧的文件。



# 头条



## 给你一个已经排序的数组，找到一个元素第一次出现的位置，{1,2,3,3,3,3,4}，输出2

二分查找，注意取等的情况要判断以下左边元素。

## TCP介绍

可靠传输，三次握手，四次挥手，流量控制，拥塞控制

## 什么是B树

B树就是一个平衡的多路查找树，其与平衡二叉树的区别就是每个节点的关键字个数增多了。

## 手写单例

双重循环锁

## volatile

volatile关键字可以保证内存的可见性，对于volatile变量的写操作happens-before对volatile变量的读操作，其是通过内存屏障来禁止指令重排序实现的。

## 给你一个User，包含id，name，parentId。然后给你一个List\<User>，要求将它转换成一棵树的结构。只有一个根节点，parentId=-1

递归法，写一个buildTree(list,TreeNode parent)方法，以parent为父节点构造树，然后再递归向下调用。

```
public TreeNode buildTree(List<User> list){
        return buildTree(list,null);
    }

    private TreeNode buildTree(List<User> list,TreeNode parent){
        if(parent==null){
            for(User user:list){
                if(user.parentId==-1){
                    TreeNode root = new TreeNode(user);
                    buildTree(list,root);
                    return root;
                }
            }
        }else {
            boolean flag=true;
            for(User user:list){
                if(user.parentId==parent.user.id){
                    TreeNode node = new TreeNode(user);
                    if(flag){
                        parent.left=node;
                        buildTree(list,node);
                        flag=false;
                    }else {
                        parent.right=node;
                        buildTree(list,node);
                    }
                }
            }
        }
        return null;
    }
```

## 一张表有ABC三个字段，现在要查BA，BC，B，问怎么建立索引？

最左匹配原则。BA，BC

## System.out.println()

System是类，out是成员变量，println()成员方法。

## 微博好友列表如何创建数据库

用户信息单独一个表，**关注信息单独一个表，里面可以包括关注者ID和被关注者ID，还有关注类型等等**。

## 给定int RandomA()， 生成一个随机数1-5. 每个数的概率0.2。实现 int RandomB(), 范围为1-25. 每个数概率为0.04

**5*RandomA()-RandomA()+1**

## 单拎出来的缓存问题，结合状态码 304 可能问到，相关头字段，If-Modified-Since 和 Last-Modified，If-None-Match 和 ETag，它们的区别等

URL不能用来唯一表示资源，Etag可以用来唯一标识资源。

```
ETag: "82e22293907ce725faf67773957acd12"
```

可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。

```
If-None-Match: "82e22293907ce725faf67773957acd12"
```

If-Modified-Since是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。

## SSL连接过程已经证书验证过程

SSL握手过程：

1. 客户端发送一个报文，其中包括**它支持的算法列表**
2. 服务端从**算法列表中选择一种加密算法**，并且同时发送一个**包含服务器公钥的证书**给客户端
3. 客户端对证书进行验证，并且得到服务端的公钥，然后生成一个**密钥**，用服务端的公钥加密后传输给服务端
4. 服务端收到后用私钥解密就可以得到对称密钥，之后的消息传输都是基于这个对称密钥

证书认证过程：

**数字证书认证机构**（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 **CA** 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png)

## SYN洪泛攻击

**原因：**大量的连接请求只完成第一次握手，不完成第三次握手，使得服务端的资源被消费掉。

**解决方法：**SYN-Cookie。服务器收到 SYN 报文段时不生成半开连接，而是生成一个初始的 TCP 序列号，即 cookie，该序列号是 SYN 报文段的源和目的IP地址与端口号以及仅有该服务器知道的秘密数的一个复杂函数( 散列 函数) 。为了验证SYN cookies，首先要将收到的**ACK报文段中的确认号减1**以便重新生成SYN cookies

## 红黑树和平衡二叉树的区别

- 平衡二叉树是完全平衡的，而红黑树不一定
- 平衡二叉树查找性能比红黑树高，但插入效率低

## 反射

定义：动态的获取类的信息以及动态调用对象的方法的功能称为反射

原理：Class对象里面包含了对象的所有信息

## 如何理解多态

多态就是引用变量指向的具体类型和通过该引用变量调用的方法在运行时才能确定；通过这一点就可以在不修改代码的基础上，将引用变量绑定到各种不同的实现类上，从而导致该引用所调用的方法随之改变。

多态的实现：

1. 继承
2. 重写
3. 向上转型

## 有A，B两个人，双方轮着数数。每次说出的数字，只能在对方的基础上加一或者加二，当最后谁先数到30及以上谁输。如果A先从0开始数，那你有什么方法使得A必赢？能否用具体算法实现

从后向前推，也就是29必须是A说的，那么B可能说27或者28，因此26必须是A说的，同理23必须是A说的，所以得出结论3*k-1必须是A说，最小为2，让A能说到某个3*k-1则A必胜

## DNS解析的迭代和递归的区别

- DNS解析的递归过程：主机查询本地域名服务器，如果没有查询到，本地域名服务器就作为DNS客户向根域名服务器发送请求报文，直到查询到之后返回。
- DNS解析的迭代过程：主机查询本地域名服务器，如果没有查询到，本地域名服务器会返回下一个到哪个服务器去查询的地址。

## 写一个二叉树的先序遍历的迭代器

```
class TreeIterator implements Iterator<TreeNode>{

        private TreeNode curr;
        private Stack<TreeNode> stack;

        public TreeIterator(){
            curr=root;
            stack=new Stack<>();
        }


        public boolean hasNext() {
            return curr!=null||!stack.isEmpty();

        }

        public TreeNode next() {
            TreeNode res=null;
            if(curr!=null){
                res=curr;
                stack.push(curr);
                curr=curr.left;
            }else{
                while(curr==null){
                    curr=stack.pop().right;
                }
                res=curr;
                curr=curr.left;
            }
            return res;
        }
    }
```

也就是将先序遍历的非递归情况拆分成两部分。

## array，先递增后递减，可能有重复，找到一个数

先通过一次二分查找找到最高点，然后分别在左边和右边进行二分查找即可。

## 进程通信中的管道

管道本质是内核的一块缓冲区，通过pipe()方法创建

## 操作系统的fork()指令

用于创建一个和原来进程几乎相同的进程。

## finalize()

是Object的一个方法，用于在GC的时候，做一些事情。

## zookeeper基于什么模式，观察者模式讲一下

观察者模式就是当一个对象的状态发生变化时，通知其他对象

## 为什么设置String是不可变的

1. 不可变首先是线程安全的
2. String中的拷贝构造函数，是使用的浅拷贝，将新字符串的byte数组指向旧字符串，由于字符串不可变，所以这样也可以实现深拷贝的效果，就是不会因为一方的修改，而导致另一方也被修改
3. 字符串常量池的设计，加入有两个引用s1和s2指向常量池中的字符串"abc"，假如s1将字符串改了，那s2的值就也被修改了，那这个常量池相当于只能服务于一个引用，那和堆就没有什么区别。

## 分库分表

### 垂直分表

**定义：将一个表按字段分成多个表，每个表存储其中一部分字段**

比如商城中的商品列表，其中只需要商品价格，描述和图片即可，而商品详细信息则包括更多，可以将这部分从中分离出来。

### 垂直分库

**定义：垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。**

### 水平分库

**定义：水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。**

### 水平分表

**定义：水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。**

## drop，truncate和delete的区别

**相同点：**

1.truncate和不带where子句的delete、以及drop都会删除表内的数据。

2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。

**不同点：**

1. drop会删除整个表，delete和truncate只会删除数据。

2. delete 语句是**数据库操作语言(dml)**，这个操作会放到rollbacksegement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。

   truncate、drop 是**数据库定义语言(ddl)**，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。

## 索引类型

聚集索引，普通索引，唯一索引，联合索引

## Class.forName()和ClassLoader.loaderClass()有什么区别

class.forName()方法会默认会走完初始化的过程，但是ClassLoader.loaderClass()方法只会完成类加载过程的加载阶段。

## 为什么http协议是无状态的？

维护状态需要耗费时间，可以通过cookie和session使得http有状态。

## 怎么用zset实现排行榜，其中相同的分数按照时间排序

score字段将分数和时间戳拼接在一起。

## AQS讲一下？

AQS的设计是基于模板方法的，里面封装了对于锁中的同步队列的管理，子类只需要去实现tryAcquire()和tryRelease()方法即可。

## 什么是视图？视图的使用场景

视图是一种基于数据表的一种**虚表**

- 1）视图是一种虚表
- （2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表
- （3）**向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句**
- （4）视图向用户提供基表数据的另一种表现形式
- （5）**视图没有存储真正的数据，真正的数据还是存储在基表中**
- （6）**程序员虽然操作的是视图，但最终视图还会转成操作基表**
- （7）一个基表可以有0个或多个视图

## 数据库的乐观锁和悲观锁是什么？

确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，**乐观锁和悲观锁是并发控制主要采用的技术手段。**

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

- - **在查询完数据的时候就把事务锁起来，直到提交事务**
  - 实现方式：使用数据库中的锁机制

- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

- - **在修改数据的时候把事务锁起来，通过version的方式来进行锁定**
  - 实现方式：使用version版本或者时间戳

悲观锁：

![img](https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib2SSMibdXtsswuJhaib0lHkU9JSAKZYmUoakV1y7HcOb60rWWXHQ4Mh07Q3PjKcPbfScBmWGeI3aEEQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

乐观锁：

![img](https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib2SSMibdXtsswuJhaib0lHkU9kqL4M9bRIgnq1GDPsnSNyYznicnib0MsicaAFfRChZX4bBvFQhsuY2mPw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。

## 可达性分析怎么解决循环引用的问题

找一个例子来讲的话，假如有一个类A，里面有一个成员变量B，类B里面有一个成员变量A，那么假如new一个A，new一个B，让对象a的B域指向b，对象b的A域指向a，那么就存在循环引用了，这个时候由于存在栈上对这两个对象的直接引用，也就是new出来的对象a，b，这种情况下无论是引用计数还是可达性分析都无法回收这个对象，但是如果令a=null，b=null，也就是丢失栈上对其的直接引用，那么如果用引用计数，那还是无法回收的；但是如果用引用计数法，我们分析一下现在的GC roots有哪些，栈上a，b已经指向null了，丢失了对堆中对象的引用，而方法区中的类变量，类常量也没有对他的引用，因为这里他们是成员变量，所以没有引用链会指向他们，所以就会被回收掉。

## priorityQueue的原理，增删查的时间复杂度

PriorityQueue的contains()方法，里面会调用indexOf()方法，这个方法的实现是遍历了一遍数组，所以时间复杂度是O(n)

# 阿里

## IOC的流程

后面补充

## 熟悉啥数据库？设计一个树型结构的组织。

表结构{id,name,parentId}，其中parentId指向父节点的id

## 写过注解吗

注解关键字为**@interface**，然后在上面修饰几个元注解，@Target表明注解使用范围，@Retention定义了该Annotation被保留的时间长短。

注解里面可以有自定义的域，例如

```
public @interface MyAnnotation {
    int value() default 1;
}
```

在使用域的时候可以给其赋值。

## 秒杀项目的构架

项目写了以后来完善

## 什么时候会触发full GC

对于Minor GC的触发条件比较简单**当 Eden 空间满时，就将触发一次 Minor GC**。**Full GC**则比较复杂：

1. **调用 System.gc()**

   只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

2. **老生代空间不足**

   老生代空间不足的常见场景为前文所讲的大对象直接进入老生代、长期存活的对象进入老生代等。

   为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老生代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老生代的年龄，让对象在新生代多存活一段时间。

3. **空间分配担保失败**

   使用复制算法的 Minor GC 需要老生代的内存空间作担保，如果担保失败会执行一次 Full GC。

4. **JDK 1.7 及以前的永久代空间不足**

   在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 信息、Meta 信息、常量、静态变量等数据。GC 不会在主程序运行期对永久代区域进行清理。

   当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

   为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

5. **Concurrent Mode Failure**

   执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

## 空间分配担保失败

采用复制算法的新生代一般会分为一个Eden区和两块较小的survivor区，每次只是用一个Eden区和一个survivor区，在young gc时会将还存活的对象复制到另一个survivor区中，如果这个survivor区中空间不够用时，就需要其他内存进行分配担保。

## 堆和栈的区别

堆和栈都可以用数组来实现，并且都是从同一端进出的结构，但是栈是一个线型结构，而堆是一个树结构，而且是一个完全二叉树。

栈不能保证栈内元素有序，而堆可以以小根堆或者大根堆来保存堆中元素有序。

## Callable和Runnable的区别

Callable有返回值，Runnable没有返回值

## 反射的原理

每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件保存着 Class 对象。

## 成员变量i，用sychronized包括的i++线程安全吗

安全

## 如何保证i++安全

锁，或者volatile+CAS操作

## volatile的作用和原理

volatile可以实现**可见性**和**有序性**。

可见性的原理是当写一个volatile变量时，会把线程对应的本地内存中的共享变量刷新到主内存中；当读一个volatile变量是，会将本地内存中的变量置为无效，然后从主内存中读取。

有序性是通过插入内存屏障来禁止指令重排序实现的。

## 讲讲JUC包下的CountDownLatch，CyclicBarrier和Semaphore

**CountDownLatch(计数器)**：维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

**CyclicBarrier(循环屏障)**：和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await () 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await () 方法而在等待的线程才能继续执行。

**Semaphore(信号量)：**控制对**互斥资源**的访问线程数，通过acquire()和release()方法来获取或释放信号量。

## 讲一下ArrayBlockingQueue

其是用数组实现的一个有界阻塞队列，默认情况下是不公平的，访问的公平性是通过重入锁实现的

## 讲讲一个对象在内存中的变化过程。

对象优先分配在Eden区，每经历一个minor gc并存活下来后，年龄就会加1，到达指定年龄上限后就会进入老生代。大对象直接进入老生代。

## 垃圾回收算法

**标记-清除算法：**分为标记阶段和清除阶段，在标记完成后统一回收所有被标记的对象。会产生不连续的内存碎片。

**复制算法：**以新生代来说，就是将区域分成一个大的Eden区和两个小的survivor区，每次使用其中的一个survivor区，当Eden区用完后，就会触发minor gc，会将Eden区和其中一个survivor区中存活的对象复制到另一个survivor区，然后将其他内存空间清除掉。

**标记-整理算法：**标记过程和标记-清除算法一样，但是后面会让所有存活的对象向着一端移动，然后清除掉边界以外的空间。

## 如何保证缓存一致性

从两个方面去讲：1. 过期key删除(定期删除+过期删除)；2. 内存淘汰策略。

一般采取先更新数据库，再删除缓存。

如果细问为什么，就大致讲一下为什么不能更新缓存，以先更新数据库，后更新缓存为例：

如果有两个并发的请求A和B几乎同时到达，A先修改数据库，B也修改了数据库，B修改了缓存，A修改了缓存；就会导致不一致。

## 讲讲平衡树

以二叉平衡树为例，插入过程和二叉排序树一样，但是后面如果违反了平衡条件，还需要左旋右旋来保存树的平衡性。

## 代码测评

1. 判断回文字符串

2. 最长回文字符串

   动态规划，用memo\[i][j]表示从i到j的子字符串是否为回文串，则memo\[i][j]=memo\[i+1][j-1]&&s.charAt(i)==s.charAt(j)，其中长度为1和2的要单独拿出来计算。

   ```
   public String longestPalindrome(String s){
           int length=s.length();
           //P记录子字符串是否为回文字符串
           boolean[][] P=new boolean[length][length];
           //最长回文字符串长度
           int maxLen=0;
           //最长回文字符串
           String maxPal="";
           //对于所有可能的长度
           for(int len=1;len<=length;len++){
           	//对于每一个起点
               for(int start=0;start<length;start++){
                   int end=start+len-1;
                   //end越界
                   if(end>=length) break;
                   //对P数组进行赋值
                   P[start][end]=(len==1||(len==2||P[start+1][end-1])&&s.charAt(start)==s.charAt(end));
                   //如果当前字符串为回文字符串且长度大于记录的最长回文字符串
                   if(P[start][end]&&len>maxLen){
                       maxPal=s.substring(start,end+1);
                   }
               }
           }
           return maxPal;
       }
   
   ```

3. 快排

   ```
   public void quickSort(int[] array){
           quickSort(array,0,array.length-1);
       }
   	
   	//注意记得写这个方法来实现递归
       private void quickSort(int[] array,int left,int right){
           if(left>=right) return;
           int partition = partition(array, left, right);
           quickSort(array,left,partition-1);
           quickSort(array,partition+1,right);
       }
   
       private int partition(int[] array,int left,int right){
           if(left==right) return left;
           int paratiton=array[left];
           while (left<right){
               while (left<right&&array[right]>=paratiton) right--;
               array[left]=array[right];
               while (left<right&&array[left]<=paratiton) left++;
               array[right]=array[left];
           }
           array[left]=paratiton;
           return left;
       }
   ```


## Redis集群的架构

在redis cluster集群架构中，可以由N个redis master node组成，每个master node都可以挂载多个slave node。
可以自动将数据进行分片，每个master上放一部分数据。

**实现原理：**Redis 集群中内置了 **16384**个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 **0-16383** 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。

## 哈希一致性算法

一致性Hash算法将整个哈希值空间组织成一个**虚拟的圆环**，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：

![img](https://pic1.zhimg.com/80/v2-fd44ab71c834f3fe458a6f76f3997f98_720w.jpg)

下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：

![img](https://pic1.zhimg.com/80/v2-509993a49d447b378273e455a095de3c_720w.jpg)

接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！

## ThreadLocal的作用和场景

ThreadLocal可以让每个线程拥有自己专属的本地变量。

使用场景：可以用来实现**数据库连接**和**Session管理**。

#### 数据库连接的步骤

1. 加载数据库连接驱动
2. 获取数据库连接
3. 创建Statement对象
4. 执行sql语句

## ThreadLocal的原理

Thread类中有一个ThreadLocalMap的结构，其是以ThreadLocal为key，set传递的值为value的map结构。ThreadLocal的set操作会首先获取当前线程，然后获取当前线程的ThreadLocakMap，调用map的set方法。

## 单例模式有哪些创建方式

三种：饿汉式，懒汉式+synchronized，懒汉式+双重检查锁定

## 懒汉式和饿汉式各有什么优点

懒汉式采取的是延迟加载的策略，可以在调用get()方法时再去加载，但同时也要去处理并发读取的问题；

饿汉式在类加载完后就会初始化单例对象，初始化对象完成后就不用考虑并发的问题。

## synchronized和Reentrantlock的区别，如何选择

​	1. synchronized是JVM实现的，ReentrantLock是JDK实现的

2. ReentrantLock可以响应中断，synchronized不行

3. synchronized是非公平的，ReentrantLock默认是非公平的，可以变成公平的
4. ReentrantLock可以绑定多个Condition对象

**除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。**

## mysql如何性能调优？比较缓慢的话，从哪个方面优化？

慢查询日志和Explain分析。

1. **独立的列：**where语句中不能用列的表达式，否则不会走索引
2. **多列索引：**在进行多列查询时，使用多列索引比多个单列索引更高效
3. **索引列的顺序：**将选择性强的索引放在前面
4. **覆盖索引**

## 什么叫幻读，什么叫脏读

幻读是指在一个事务前后读取的数据不一致，一般是指读取某个区间的值不一致；脏读是指读到了其他事务中没有提交的数据。本质区别在于幻读读到的是其他事务提交的数据，脏读读到的是其他事务未提交的数据。

## 有序矩阵的查找

从左下角开始

## 一条mysql查询经历了什么

首先会经过连接器进行权限验证，然后分析器去分析这条语句是对那个表进行操作，执行的是什么操作，语法是否正确；后面是优化器选择一条mysql认为最优的路线去执行，最后执行器去执行sql语句。

## 一条mysql查询经历了什么

上面过程类似，后面还需要记录日志。

## 四个字形容个人性格

年轻好学

## 打印空心菱形

大致讲一下，用left和right指向一行中菱形所在的列，然后怎么变化讲一讲。

## 递归的缺点？如何弥补缺点

递归效率不够高，因为存在着重复调用的问题。用一个记忆表来改进，去存储每次递归之后的结果，每次递归时先去判断能否获取到，能获取到就直接返回，可以避免重复调用的过程。

## 秒杀系统的架构

## 秒杀系统压力最大的是哪部分呢？

## 为什么要有RDB和AOF两种持久化方式

我从两者的优缺点讲起，RDB是快照文件，生成RDB耗资源多，所以不太可能频繁的生成RDB文件，也就是单纯靠RDB可能会丢失内容；AOF是指令追加的方式，一般是每一秒更新一次，所以不会丢失太多数据，但是基于AOF去还原需要的时间会很长，因为AOF存储的是指令，没有RDB高效。

## AOF重写

由于AOF文件会随着时间慢慢变大，所以需要AOF重写。

AOF重写实现：不会读取之前的AOF文件，反而去读取当前服务器中数据库的状况，然后用指令去记录键值对。

AOF重写流程：

1. 在AOF重写的过程中，服务器执行的指令会存入到一个重写缓冲区中；
2. 在AOF重写完成后，会将重写缓冲区的指令追加到AOF文件中；
3. 然后用新的AOF文件替换旧的AOF文件。

## B+树的叶子节点连接起来的好处？

方便范围查询，排序。

## InnoDB和MyisAm的区别

1. **事务：**InnoDb支持事务，MyISAM不支持事务
2. **锁：**InnoDB是行级锁，MyISAM是表级锁

## CAS的原理

CAS是乐观锁的思想。实现原理不太清楚。

## java里面哪里用到了CAS？

1. 原子类。
2. AQS中使用CAS操作来将新的节点加入同步队列或删除同步队列。
3. jdk1.8之后的ConcurrentHashMap。



# VIVO

## 介绍一下AQS

AQS是队列同步器，用来管理同步队列，是锁的核心组件，通过重写tryAcquire()或tryAcquireShared()方法来扩展队列同步器。

## 说一下公平锁和非公平锁的原理

公平锁是按照线程入队的顺序来获取锁的，保证公平；非公平锁则不保证。

一般非公平锁效率更高，因为会伴随着更少的线程切换。

在实现上，公平锁会判断其是否有前驱节点，如果有则不会去获取同步状态，而非公平锁没有这个约束。

## hashMap为什么线程不安全，讲讲Chm

如果两个线程同时进行put()操作，并且散列到了同一个数组下标处，采用头插法插在头部，两个线程同时获取到旧的头部，然后设置自己作为新的头部，则会有一个数据丢失。

ConcurrentHashMap是线程安全的，我分别基于1.7和1.8来讲解：

1.7中Chm是Segment数组的结构，其中Segment继承者ReentrantLock，充当锁的角色，每个Segment中包含一个HashEntry数组，HashEntry的机构和HashMap中的Entry结构相同，只不过next域和value域用volatile修饰，可以看到1.7中是基于分段锁实现的。

1.8中Chm就是简单的Node数组的结构，其中Node就是1.7的HashEntry，使用CAS操作和synchronized来实现，put()操作首先会判断key和value是否为null，如果是则返回异常，然后看table数组是否为null，如果为null，还需要调用initTable()方法初始化数组，这个方法里会用一个双重检查包裹着一个CAS操作，CAS操作获取同步状态sizeCtl，首先判断table数组是否为null，如果是则获取同步状态，如果小于0表示有其他线程正在初始化table数组，就会调用Thread.join()方法放弃处理机调度，否则尝试用CAS操作获取同步状态，获取成功后还需要判断一次table是否为null，也就是双重检查包裹着CAS操作，数组初始化完之后，首先获取其在数组中的下标index，如果index处的值为null，则用CAS操作将其设置为目标数据所创建的节点，成功就返回，不成功的话，就会用synchronized锁定后再去添加，锁对象是table[index]。

## CAS操作是什么，以及可能出现的问题

CAS操作输入两个值，旧值的期待值和新值，如果旧值等于旧值的期待值就将其值设置为新值。

可能出现ABA问题

## 输入一个url后的过程

1. DNS解析
2. 建立TCP连接
3. 发送HTTP请求
4. 服务端收到后会送响应
5. 受到响应后解析出相应资源然后加载页面

DNS解析流程：首先主机会找本地DNS服务器请求解析，如果不行就去找根域名服务器，再不行就去找顶级域名服务器一直往下，将得到的结果设置在本地缓存中。

## Redis中的zset，跳跃表的插入和删除

zset包括一个sorce字段，可以按照sorce排序，是使用跳跃表实现的。

跳跃表的插入过程：

1. 将新节点与各层索引相比，确定链表的插入位置。(O(logn))
2. 把数据插入原链表。
3. 采用随机方式确定新节点是否要提升为上一级索引。

跳跃表的删除：

查找到每一层中该节点出现的索引，并将其删除。

## Java异常了解吗？说说平时遇到的异常？

异常的顶级父类是Throwable，下面包括Exception和Error，平时遇到比较多的是StackOverFlowError，ArrayIndexOutOfBoundException和InterruptedException

## 说说垃圾收集器

## 类加载机制？如何实现类加载器？

类加载器包括启动类加载器，扩展类加载器和应用程序类加载器。

继承ClassLoader，然后实现其中的findClass()方法。

## TCP报文结构，HTTP结构

讲一下TCP首部，我记得有源端口号，目的端口号，序号，确认号，SYN，FIN，ACK还有窗口字段。

## 设计一个应用层协议

RPC

## https加密过程

https使用的对称加密，其中对称密钥使用非对称密钥传输的。如果客户端想给服务端发送http请求，那就先用服务端的公钥对对称密钥加密，服务端用密钥解密就可以得到对称密钥，然后就可以用对称密钥传输数据。

# 快手

## 分页查找，如果要查找很靠后的页面如何，比如100万之后查10条怎么优化

1. 可以使用子查询优化。

```
select * from orders_history where type=8 and id>=(select id from orders_history where type=8 limit 100000,1) limit 100; 
```

2. 如果id是连续递增的。

   ```
   select * from orders_history where type=2 and id between 1000000 and 1000100 limit 100; 
   ```




# HR面

问能不能接受字节大小周 

 base地点杭州or上海 

 最近还投了别的公司没有，为什么投 

 秋招想投什么公司，必须说哦，哈哈哈我说了网易，因为喜欢游戏想去互娱雷火，hr小姐姐就开始了，为什么想投网易，网易和字节哪个好 

 用过西瓜视频吗，西瓜视频和b站哪个好，咱老二次媛了，只能硬着头皮夸b站hhhhhhh 

 为什么想去南方工作，北方人而且还读了北方的大学

---
title: 面试总结
date: 2020-07-08 16:03:17
tags: 面试
categories: 面试
---

# 7.06字节客户端一面二面三面

一面二面三面一起的，一二面录音了，三面忘了，算法题放一起

**算法题：**

1. 旋转数组的查找
2. 两个线程轮流打印奇数偶数
3. 有序数组查找一个元素第一次出现的位置
4. 单例
5. 域名反转(www.toutiao.com->com.toutiao.www)
6. 三面算法题在下面

## 一面(41min)

1. 自我介绍
2. 问性格，怎么不做算法？？？
3. 计算机基础咋学的？
4. HTTP有哪些方法？
5. get和post的区别？有说到get是幂等的，然后面试官问如果在两个get期间数据库发生改变了那结果还是一样吗？(不一样)。那怎么是幂等的。说我是不是在网上哪随便看到的(对对对，不敢反驳)
6. 比如我要去换一个头像是用get还是post？
7. HTTP和HTTPS
8. SSL握手过程，然后问我第一次握手是什么加密，第二次握手怎么加密
9. 对称加密的安全性
10. 操作系统层面的线程同步
11. 信号量和互斥量的区别
12. synchronized介绍
13. 两个线程轮流打印奇数和偶数(我讲了通过信号量去实现，可能没讲太清楚，面试官就让我写一下，说用信号量写也可以，但我更希望你用锁去实现，然后用锁写的)。
14. wait()和sleep()的区别
15. hashcode场景，然后问了hashMap
16. 数据库
17. 事务
18. 脏读，怎么解决脏读(怎么加锁)
19. 类加载过程
20. ClassLoader的作用，双亲委派
21. 算法怎么样(果然认怂，基础一点的还行)
22. 反问

## 二面(35min)

1. 问项目，项目细节，项目背景
2. ArrayList和LinkedList的区别
3. HashMap的put()流程，扩容
4. 设计模式知道哪些，讲一下单例，写一下(双重检查)
5. volatile的作用
6. 双重检查的用处，假如不要第一次if判断会有什么问题
7. 夸我讲的好！问我咋学的这些
8. 快速排序讲一哈，时间复杂度，怎么使得快排避免O(n^2^)复杂度
9. 写题，两道，自己写例子测试测试

## 三面(记得多少写多少吧)

三面面试官口头禅：好的OK了解

1. 前面都是聊天，问团队合作，实验室情况，问了实验室的项目
2. 然后画风突转就问技术问题了，输入网址访问的过程，然后一点一点详细问
3. DNS解析过程，DNS劫持了解吗，浏览器渲染页面的过程(???)，HTML和JS讲一下(???)
4. 然后就是一道算法题

![image-20200708165103773.png](https://i.loli.net/2020/07/08/Rk36PjlhVm1D94q.png)

给定一个只有数字的字符串，输出一共有多少种可能的结果

一直想着在整个字符串上dp

面试官提示1：不同的字符之间有什么关系(感觉面试官前面的提示都太隐晦了，在这浪费了一些时间)

拆分之后我给出了一个dp递推式，但是不太对，有重复。

面试官提示2：怎么解决重复(这里又卡了一会)

最后给出了dp关系式，但是没给多少时间写，没写完，只能写个大致，给出dp递推式后主要问题就是怎么去解决越界的问题，是每次都判断还是多申请几个空间这样，当时应该想一想再写的，有点慌。

**最后面试官评价：**

1. 这题本身有难度，你有在和我一起思考
2. 代码能力需要加强。





**算法思想：**

- 首先第一点，字符串拆分成相同字符的集合，例如"2222333477"拆分成“2222”，“333”，“4”，“77”，则最终结果为这四个字符串的可能的乘积。

- 然后就是对于只有一种字符的字符串怎么计算结果，先只考虑3个的情况，以’2‘为例，则最后的结尾字符只能是A，B或C，如果以A结尾，则字符串可以看成前i-1个和最后一个的组合；如果以B结尾，则可以看成前i-2和最后两个的组合；如果以C结尾，则可以看成前i-3和最后三个的组合：

  例如：“22222222”，可能的情况如果以A结尾，则为”2222222“+A；

  如果以B结尾，则为”222222“+B；如果以C结尾，则为”22222“+C

  所以有递推关系式dp[i]=dp[i-1]+dp[i-2]+dp[i-3]

  那么对于四种字符的情况就是dp[i-1]+dp[i-2]+dp[i-3]+dp[i-4]

- 实现上来看，各种字符之前没有区别，结果只和长度有关，但是7和9例外，所以只需要确定长度和mode即可确定结果，在实现上用了dp_3表示三种字符的递推结果，dp_4表示四种字符，同时为了避免重复计算，用i_3计算当前dp_3计算到哪了，i_4表示当前dp_4计算到哪了

```
	private static int[] dp_3;

    private static int i_3;

    private static int[] dp_4;

    private static int i_4;

    private static int convert(String str){
        dp_3=new int[Math.max(str.length(),3)];
        dp_4=new int[Math.max(str.length(),4)];
        //前几位直接给出
        dp_3[0]=1;
        dp_3[1]=2;
        dp_3[2]=4;
        i_3=3;
        dp_4[0]=1;
        dp_4[1]=2;
        dp_4[2]=4;
        dp_4[3]=8;
        i_4=4;
        char[] chars=str.toCharArray();
        int l=0,r=0,res=1;
        while(r<chars.length){
        	//寻找相同字符的区间
            while(r<chars.length&&chars[r]==chars[l]) r++;
            int num=getDp(r-1-l,chars[l]=='7'||chars[l]=='9'?1:0);
            res*=num;
            l=r;
        }
        return res;
    }

	//mode用来表示哪种情况，如果是'7'或'9'则为1
    private static int getDp(int len,int mode){
        if(mode==0){
            if(dp_3[len]!=0) return dp_3[len];
            //从i_3开始向后算
            for(int i=i_3;i<=len;i++){
                dp_3[i]=dp_3[i-1]+dp_3[i-2]+dp_3[i-3];
            }
            i_3=len;
            return dp_3[len];
        }else {
            if(dp_4[len]!=0) return dp_4[len];
            for(int i=i_4;i<=len;i++){
                dp_4[i]=dp_4[i-1]+dp_4[i-2]+dp_4[i-3]+dp_4[i-4];
            }
            i_4=len;
            return dp_4[len];
        }
    }
```

---
title: 面试时间汇总
date: 2020-07-08 15:19:19
tags: 面试
categories: 面试
---

# VIVO(一面跪)

- 笔试：6.07
- 一面：6.09

# 招银网络（等offer）

- 笔试：6.22
- 一面(跳过)
- 二面：7.07
- 三面：7.14
- hr面：7.22

## 笔试

笔试很多帖子都做了记录就不回馈了。

## 一面

笔试过后通知可以跳过电话一面。

## 二面

没有做太多的记录，反馈一下二面的算法题吧：

给一个有序的数组，其中每个元素可能出现多次，对数组进行操作使得每个元素出现的次数最多不超过两次：

例如：[0,1,1,1,2,2,3]->[0,1,1,2,2,3]

**其他问题基本都是基础问题了**

## 三面(12min)

全程在聊天，问了一下实验室的项目

## HR面(10min)

差不多也是聊天，常规hr问的问题。

# 字节抖音(已意向书)

- 一面二面三面：7.06

# 京东(简历挂)

# 阿里(等面试)

笔试0AC

# 百度(等HR面)

## 一面 7.22(45min)

**又忘了录音了，大致记录一下**

1. 项目，大致讲一讲
2. hashmap讲一下，线程安全吗，然后聊到了concurrentHashMap
3. java GC
4. 一个大数处理的题，43亿个32位整数，找到哪些数出现了两次以上
5. 算法题3道：
   1. 二分查找
   2. 链表是否存在环，找到环入口。以及结论的推导
   3. 给一个整数，输出所有可能的IP地址的结果(百度老喜欢考这些，之前面经就看到过了，不过没注意)
6. 反问

# OPPO(拒了面试)

# 作业帮(待投)

# 美团(等三面)

# 华为(等一面)

# 猿辅导(拒了笔试)

# 网易(等笔试)

# 拼多多(等一面)

笔试接近2AC

# 腾讯

## 20200807 腾讯PCG一面

1. ArrayList在尾部插入时的时间复杂度(考虑到扩容)

2. ArrayList和LinkedList的区别

3. HashMap

4. 具体业务下的线程池参数的设计，比如100qps，200ms的业务响应，2~3倍的容忍

   大致思路是：一个线程处理一个请求要200ms，那么1s可以处理5个请求，所以100/5=20，大致需要20个线程，如果再算上两倍的容忍，那就是40个线程

5. TCP四次挥手中的close_wait会有什么问题？？？

6. 输入域名并访问中，返回的是服务器的什么内容，html页面和图片吗

7. 32bit对应的最大内存空间为多少？答4G。。。那如果内存只有3G呢？答虚拟内存，页面置换。。。

8. ZAB协议

9. LRU怎么实现，如何保证线程安全呢

10. 数据库的范式

11. Linux指令中查找第二列的数据

12. top指令中如果有一个进程cpu占用率为100%，那么说明他占用了全部的cpu资源吗

**算法题：类似与leetcode322，但是硬币不可重复**---
title: 面试题02.04.分割链表
date: 2020-07-09 14:21:46
tags: leetcode
categories: leetcode
---

# [面试题 02.04. 分割链表](https://leetcode-cn.com/problems/partition-list-lcci/)

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。



```
示例:

输入: head = 3->5->8->5->10->2->1, x = 5
输出: 3->1->2->10->5->5->8
```



## 方法一

**算法思想：**

- 题目只要求所有小于 x 的节点排在大于或等于 x 的节点之前，而分割元素x在右半部分即可，并不强制要求x一定在中间。
- 一次遍历即可，从头向尾部遍历，如果当前节点值小于x，则不动，否则将其移出链表后再插到尾部即可。

```
public ListNode partition(ListNode head, int x) {
        if(head==null||head.next==null) return head;
        ListNode tail=head;
        //首先找到尾节点
        while(tail.next!=null)
            tail=tail.next;
        //给尾节点复制一下，因为下面会一直在尾部插值，所以不能以p!=null为出口
        ListNode ttail=tail;
        ListNode Head=new ListNode(0),t=Head;
        ListNode p=head,next=p.next,pre=Head;
        //出口不能是p!=ttail
        while(p!=ttail){
            if(p.val<x){
                t.next=p;
                t=t.next;
                pre=p;
                p=next;
                if(p==null) break;
                next=next.next;
            }else{
                pre.next=next;
                p.next=null;
                //这里pre不需要向后走一步
                tail.next=p;
                tail=p;
                p=next;
                if(p==null) break;
                next=next.next;
            }
        }
        return Head.next;
    }
```



## 方法二

**算法思想：**

- 将链表拆分成两个链表，然后再合并即可，将小于x的分到Head1中，其他分到Head2中

```
public ListNode partition(ListNode head, int x) {
        if(head==null||head.next==null) return head;
        ListNode Head1=new ListNode(0),Head2=new ListNode(0),tail1=Head1,tail2=Head2,p=head;
        while(p!=null){
            if(p.val<x){
                tail1.next=p;
                tail1=tail1.next;
            }else{
                tail2.next=p;
                tail2=tail2.next;
            }
            p=p.next;
        }
        //这一步不能丢，否则链表会有环路
        tail2.next=null;
        tail1.next=Head2.next;
        return Head1.next;
    }
```

---
title: 面试题17.13.恢复空格
date: 2020-07-09 11:01:11
tags: leetcode
categories: leetcode
---

# [面试题 17.13. 恢复空格](https://leetcode-cn.com/problems/re-space-lcci/)

**题目描述：**
哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子"I reset the computer. It still didn’t boot!"已经变成了"iresetthecomputeritstilldidntboot"。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。

注意：本题相对原题稍作改动，只需返回未识别的字符数



```
示例：

输入：
dictionary = ["looked","just","like","her","brother"]
sentence = "jesslookedjustliketimherbrother"
输出： 7
解释： 断句后为"jess looked just like tim her brother"，共7个未识别字符。
```



## 哈希+动态规划

**算法思想：**

- 用哈希表来判断一个字符串书否在原字典中
- dp[i]表示字符串到第i个下标处最少未识别的字符数，则如果从j到i处的子串在字典中，则有dp[i]=min(dp[j-1])，否则的话dp[i]=dp[j]+i-j

```
public int respace(String[] dictionary, String sentence) {
        if(sentence==null||sentence.length()==0) return 0;
        int[] dp=new int[sentence.length()];
        //哈希表用于判断
        Set<String> set=new HashSet<>();
        for(String s:dictionary){
            set.add(s);
        }
        for(int i=0;i<dp.length;i++){
        	//初始化为i+1，表示每个元素都不匹配
            dp[i]=i+1;
            //这里j从i开始才行
            for(int j=i;j>=0;j--){
                dp[i]=Math.min(dp[i],dp[j]+i-j);
                if(set.contains(sentence.substring(j,i+1))){
                    dp[i]=Math.min(dp[i],j>0?dp[j-1]:0);
                }
            }
        }
        return dp[dp.length-1];
    }
```

**时间复杂度：**O(n^2^)

**空间复杂度：**O(n)



**错误点：**

1. 没有加上14行，也就是少了在不匹配时的递推；
2. 13行处的j从i-1开始导致取子串substring(j,i+1)时，丢掉了长度为1的子串---
title: 秒杀系统
date: 2020-05-13 20:00:52
tags:	

		- 项目
categories: 项目
---

# 学生选课系统

## 数据库设计

学生信息表，课程表，选课表

- 学生信息表主要包括：学生Id和密码，姓名，性别，学分这些
- 课程表包括课程信息：课程Id，课程名，课程教室，学分这些
- 选课表包括：学生Id和课程Id

## 项目架构

主要有三大模块：

1. 登录模块
2. 课程列表模块
3. 课程具体信息
4. 学生个人信息模块
5. 选课模块

## 课程列表模块怎么分页的

有一个page记录当前访问的是第几页，然后每页10个信息，那就是 `limit(10*(page-1),10)`

## 选课流程

1. 如果学生当前剩余学分小于等于0，选课失败
2. 否则的话，就扣减学分，然后插入选课记录

## 怎么处理重复选课的情况

选课表上在课程id和学生id上加联合唯一索引

## 项目难点

难点主要在于框架使用上，自己不太熟悉

## 项目改进

功能不够全，还可以加上成绩系统。

## Spring的IOC和AOP讲一下

**IoC ：控制反转/反转控制**

**使用 IoC 思想的开发方式** ：不通过 new 关键字来创建对象，而是通过 **IoC 容器**(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。

**AOP： 面向切面编程**，可以在不改变原有业务逻辑的基础上，加上一些**横切逻辑代码**，例如：事务控制，权限控制。

# RPC

本项目使用netty搭建服务端和客户端，使用zookeeper实现服务注册和发现，完成了客户端对多个服务端的负载均衡。



## 大致流程

服务端上线时将自己的IP地址和端口号注册到zookeeper上，客户端通过发现zookeeper上的服务变化，如果有新的节点上线就建立新的连接，并且将连接中pipLine上的handler存入一个CopyOnWriteArrayList中，还有一个ConcurrentHashMap存储服务端的地址和handler的对于关系，当调用方法时，代理对象会从handler中轮询选择一个handler去发送请求报文，服务端收到后反射调用方法，将结果返回。

## 用到的设计模式

**单例模式：**

- 由于客户端需要存储所有的连接handler，所以需要一个类ConnectMessage记录连接信息，这个类必须是单例的。

**观察者模式：**

- Zookeeper是基于观察者模式的，在服务端有新的节点上线时，通知客户端

**代理模式：**

- 使用了JDK的动态代理

## 负载均衡怎么实现的

我使用的是轮询，用一个AtomicInteger来记录当前要使用哪个handler，也就是使用哪个连接

## 方法调用的返回怎么实现的

使用的等待通知，当调用方法时，handler将消息发送出去，然后wait()等待，收到消息后，通知，没有使用异步的方式。

## 请求报文和响应报文包含哪些信息

因为服务端要反射调用，所以请求报文首先得有类名，方法名，方法参数类型列表，具体的参数。

响应报文就返回结果，如果有异常就返回异常的打印信息。

## 怎么标注服务端的服务

自定义了一个注解标注在类上，服务端实现了ApplicationContextAware接口，在容器初始化后将用这个注解标注的类放在一个map里面，当请求到达时直接从这个map中根据类名获取对象即可。

## 序列化使用的是什么

protostuff

## 项目中遇到什么难点

难点应该在每一次对项目的优化，首先考虑的是使用jdk自带的IO，然后请求到达服务端后每次去获取bean，再调用方法，后面就改进了使用netty实现网络通信，通过spring的后置处理器直接把服务存储起来，后面又考虑了多个服务器的情况，就是用了zookeeper做服务注册，然后多个服务器又要考虑负载均衡，就简单做了个轮询。

## 如何解决TCP粘包和拆包

使用了netty自带的**LengthFieldBasedFrameDecoder**，在每次发送时，先发一个int的长度字段。

**LengthFieldBasedFrameDecoder**是一个可以自定义长度的解码器，第一个参数表示发送的数据帧最大长度，第二个参数表示定义长度域的下标，第三个参数表示定义长度域的大小

## 同步怎么做的

方法的调用和返回加了锁来完成等待通知，客户端使用了线程池来提交任务，提交任务时从装有handler的集合中轮询取出一个来发送消息，所以用来表示轮询的必须时atomicInteger

## 项目还有什么改进

客户端可以改成异步调用，现在是同步调用，调用方法后需要等待结果返回。

## 项目中哪里用到了多线程

1. 客户端提交任务的时候用了多线程，我是让handler实现了callable接口，其中的call()方法发送数据，并等待消息回复，每次执行方法调用时，会从线程池中拿出一个线程执行handler中的任务，在此之前是通过轮询的方式获得一个handler。
2. 在有新的服务上线的时候，我用到了多线程去连接服务器，然后将对应的handler放到LIst里面，以及套接字和handler的对应关系放到里面。

# zookeeper常见面试点

## zookeeper集群中有哪些角色

leader和follower，leader的选举采用的是半数原则，如果超过半数节点选择自己，则称为leader节点。

- Leader既可以提供**读**也可以提供**写服务**。
- Follower只能提供**读服务**。

同样集群中的机器数目一般是奇数，因为当认为集群中至少有一半以上机器工作时即为有效

## zookeeper数据存在哪里

存储在内存中，保证了很高的效率

## 会话(Session)

在为客户端创建会话之前，服务端首先会为每个客户端都分配一个**sessionID**。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。

## Znode

zookeeper的数据模型是一个树型结构。节点类型大致可以分为两种：

1. **持久的**。除非主动删除，否则不会被移除。
2. **临时的。**一旦会话断开就会失效。

其中每一种下面都可以有加上序号的情况。

# 股骨解剖轴定位

## 介绍一下这个项目

这个项目是实验室的项目，主要包括股骨干和股骨颈解剖轴的定位，其中股骨颈解剖轴的定位可以通过先定位股骨中心点和小转子中心点，然后取连线即可；股骨干的定位需要去定位股骨干中横截面最小处的中心点，然后这个点和小转子中心点就是股骨干解剖轴，我主要负责的就是定位这个点。

## 讲一下这个点你怎么定位的

首先是如何标注的问题，这个点要自己标注，这个合作公司那边给了股骨分割的结果，我是在股骨分割的基础上，首先横切，确定每一层被分割出来的体素的和，和最小的就是横截面最小的，这样可以确定z坐标，然后x，y坐标的确定是通过求这一层体素的平均值。

## 网络模型

这个因为自己来实验室没有多久，所以不太清楚，我只知道是根据UNet改过来的一个网络。

## UNet的结构

UNet整体结构像一个U一样，左边是下采样和卷积，右边是上采样和卷积

## 项目难点

因为深度学习我不太了解，所以可能对我网络那一块会比较难。

---
title: 验证回文字符串II
date: 2020-06-28 15:33:16
tags: leetcode
categories: leetcode
---

# [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

**题目描述：**

给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。

```
示例 1:

输入: "aba"
输出: True


示例 2:

输入: "abca"
输出: True
解释: 你可以删除c字符。
```







**算法思想：**

- 在出现不匹配时可能有两种情况，删除左边的，或者删除右边的，所以需要分别计算两种情况下是否为回文串

```
public boolean validPalindrome(String s) {
        if(s==null||s.length()==0) return true;
        int l=0,r=s.length()-1;
        while(l<r){
            if(s.charAt(l)==s.charAt(r)){
                l++;
                r--; 
            }else{
                boolean flag1=true,flag2=true;
                int i=l+1,j=r;
                //删除左边的
                while(i<j){
                    if(s.charAt(i)==s.charAt(j)){
                        i++;
                        j--;
                    }else{
                        flag1=false;
                        break;
                    }
                }
                i=l;
                j=r-1;
                //删除右边的
                while(i<j){
                    if(s.charAt(i)==s.charAt(j)){
                        i++;
                        j--;
                    }else{
                        flag2=false;
                        break;
                    }
                }
                return flag1||flag2;
            }
        }
        return true;
    }
```



同样可以改成如下实现的：

```
public boolean validPalindrome(String s) {
        if(s==null||s.length()==0) return true;
        int l=0,r=s.length()-1;
        boolean flag=true;
        while(l<r){
            if(s.charAt(l)==s.charAt(r)){
                l++;
                r--;
            }else{
                return helper(s,l+1,r)||helper(s,l,r-1);
            }
        }
        return true;
    }

    private boolean helper(String s,int l,int r){
        if(l>=r) return true;
        while(l<r){
            if(s.charAt(l)!=s.charAt(r))
                return false;
            l++;
            r--;
        }
        return true;
    }
```

