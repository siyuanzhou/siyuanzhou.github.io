---
layout: post
title: "Java基础复习"
date: 2021-03-10 10:36
toc: true
comments: true
categories: 技术学习
tags:
	- 基础
	- 复习 
---

### JavaSE

#### 基础

##### JDK、JRE、JVM

<!--more-->

![image-20200207122805940](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104735.png)

##### java程序执行

![image-20210308103111593](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104736.png)

##### ==与equals()

== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
 情况 1：类没有覆盖 equals() 方法。等价于通过“==”比较这两个对象。
 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true 。

##### 方法参数传值

方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.

##### final和static

![image-20210305205122482](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104737.png)

final 的好处：

```
1. final 关键字提高了性能。JVM 和 Java 应用都会缓存 final 变量。
2. final 变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
3. 使用 final 关键字，JVM 会对方法、变量及类进行优化。
```

##### 数据类型

![image-20200207131438485](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104738.png)

**类型转换**：byte、short、char‐‐>int‐‐>long‐‐>float‐‐>double

**b3=1 + 2 是正确的。但b3=1+200报错**

b3 = 1 + 2 ， 1 和  2 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 1+2 的结果并没有超过byte类型的取值范围，可以赋值给变量 b3 。

**short s1 = 1; s1 = s1 + 1;错。 short s1 = 1; s1 +=1;对**

```
1) 对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。

2) 对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。+= 操作符会进行隐式自动类型转换,
```

**switch语句能否作用在byte上，能否作用在long上，能否作用在string上？**

```
在switch(expr1)中，expr1只能是一个整数表达式或者枚举常量，
整数表达式可以是int基本类型或Integer包装类型。
由于，byte,short,char都可以隐式转换为int，所以，这些类型以及这些类型的包装类型也是可以的。

long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，
所以，它们不能作用于swtich语句中。
不过，在1.7版本之后switch就可以作用在string上了。
```

**包装类**分成引用和实例，引用在栈（stack）中，具体实例在堆（heap）中，jdk5.0开始增加自动装箱/拆箱。

```java
Integer i = Integer.valueOf(1); //手动装箱
Integer j = 1; //自动装箱
Integer i0 = new Integer(1);
int i1 = i0; //自动拆箱
int i2 = i0.intValue(); //手动拆箱
```

![image-20210305202513862](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104739.png)

**valueOf陷阱：**

```java
Double i1 = Double.valueOf(0.1);
Double i2 = Double.valueOf(0.1);
System.out.println(i1 == i2); //false valueOf方法内部实际上也是new
```

**valueOf内部也是用的new方法来构造对象的**。2个new出来的对象，内存地址肯定是不一样的。

![image-20200207145702858](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104740.png)

##### 包装类缓存机制

下面的代码运行结果却让人大跌眼镜：（**缓存机制**）

Java对部分经常使用的数据采用缓存技术，在类第一次被加载时换创建缓存和数据。当使用等值对象时直接从缓存中获取，从而提高了程序执行性能。（通常只对常用数据进行缓存）

```java
System.out.println(Integer.valueOf(1) ==Integer.valueOf(1)); //true 
System.out.println(Integer.valueOf(999) ==Integer.valueOf(999)); //false 
```

查看Integer.valueOf方法的源码：

![image-20200207150009985](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104741.png)

```
1. Integer类型有缓存-128-127的对象。缓存上限可以通过`-XX:AutoBoxCacheMax=size`修改
2. Byte,Short,Long类型有缓存(-128-127)
3. Character缓存0-127
4. Boolean缓存TRUE、FALSE
```

 **自动包装时实际上还是调用的valueOf方法**。而上面我们讲过的，valueOf方法用到了缓存池。

```java
Integer i4 = Integer.valueOf(1);
Integer i5 =1;
System.out.println(i4 == i5); //true
```

##### Java内存计算

**内存公式**：Java对象的内存布 = 对象头(Header) + 实例数据(Instance Data) + 补齐填充(Padding)。

在64位机器上，对象头不开压缩（-XX:-UseCompressedOops）16字节（默认），开压缩12字节；对象引用不开压缩8字节，开压缩4字节；填充到8字节的倍数；数组对象头24字节，压缩后16字节；String包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode



**对象头：Instance Header**，Java对象最复杂的一部分，采用C++定义了头的协议格式，存储了Java对象hash、GC年龄、锁标记、class指针、数组长度等信息。

**实例数据：Instance Data**，这部分数据才是真正具有业务意义的数据，实际上就是当前对象中的实例字段。在VM中，对象的字段是由基本数据类型和引用类型组成的。**对象引用（ref）类型在64位机器上，关闭指针压缩时占用8bytes， 开启时占用4bytes。**

**补齐填充**：Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数



**包装类（Boolean/Byte/Short/Character/Integer/Long/Double/Float）占用内存的大小 = 对象头大小 + 底层基础数据类型的大小**。包装类和其他引用类一样，会产生一个引用（reference）

![image-20200207152330555](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104742.png)

**数组内存占用**

**64位机器上，数组对象的对象头占用24 bytes，启用压缩后占用16字节。**对象数组本身的大小=数组对象头+length * 引用指针大小，总大小为对象数组本身大小+存放的数据的大小之和。

```c
int[10]:
开启压缩：16 + 10 * 4 = 56 bytes；
关闭压缩：24 + 10 * 4 = 64bytes。
new Integer[3]:
关闭压缩：
    Integer数组本身：24(header) + 3 * 8(Integer reference) = 48 bytes;
    总共：48 + 3 * 24(Integer) = 120 bytes。
开启压缩：
    Integer数组本身：16(header) + 3 * 4(Integer reference) = 28(padding) -> 32 (bytes)
    总共：32 + 3 * 16(Integer) = 80 (bytes)
```

**String内存占用**

在JDK1.7及以上版本中，String包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode。字符串"abcde"在开启指针压缩时的大小为：

```
String本身：12(Header) + 4(char[] reference) + 4(int hash) = 20(padding) -> 24 (bytes); 
存储数据：16(char[] header) + 5*2 = 26(padding) -> 32 (bytes)         
总共：24 + 32 = 56 (bytes) 
```

**复杂对象**

```java
class Parent {
    protected int x; // 4字节
    protected int y; // 4字节 
    protected boolean flag; // 1字节
}
class Child extends Parent {
    private int z; // 4字节
}
```

不开压缩40字节 = 16 + (4 + 4 + 1 + 7) + 4 + 7

![image-20200207161601497](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104743.png)

##### String，StringBuffer，StringBuider

```
1. 操作少量的数据 = String
2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer
```

**1. 是否可变** 

- String 不可变: 类为 final，类中 char[] 为final
- StringBuffer 和 StringBuilder 可变，继承自 AbstractStringBuilder 类，char[] value 没有用 final 关键字修饰

![image-20210305203955846](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104744.png)

![image-20210305204136342](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104745.png)

##### String 不可变的原因

**1. 可以缓存 hash 值** 

因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 等情况。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。

**2. String Pool 的需要** 

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。如果可变，多个引用指向一个String，修改会影响。

**3. 安全性** 

String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。
String 经常作为 HashMap 的 key，key 对象需要是不可变的。

**4. 线程安全** 

String 不可变性天生具备线程安全，可以在多个线程中使用。

##### 重写equals还要重写hashcode？

![image-20210305204307273](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104746.png)

```
重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上。
重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。
```

##### String#intern()

使用 String.intern() 可以保证所有相同内容的字符串变量引用相同的内存对象。

直接使用双引号声明出来的`String`对象会直接存储在常量池中，字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。

当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中**添加一个新的字符串**，并返回这个新字符串的引用。

##### new String("abc")

使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。

- "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
- 而使用 new 的方式会在堆中创建一个字符串对象。

以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并**不会完全复制 value 数组内容**，而是都会指向同一个 value 数组。

```java
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
```

##### Runtime 类

Runtime:运行时，是一个封装了 JVM 的类。每一个 JAVA 程序实际上都是启动了一个JVM 进程，每一个 JVM 进程都对应一个 Runtime 实例，此实例是由 JVM 为其实例化的。
所以我们不能实例化一个 Runtime 对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前 Runtime 运行时对象的引用。一旦得到了一个当前的Runtime 对象的引用，就可以调用 Runtime 对象的方法去控制 Java 虚拟机的状态和行为。

##### Enum类

使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应public static final Day MONDAY;，同时编译器会为该类创建两个方法，分别是values()和valueOf()

```java
public class EnumDemo {
    public static void main(String[] args){
        //直接引用
        Day day =Day.MONDAY;
    }
}
//定义枚举类型
enum Day {
    MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

//反编译Day.class
final class Day extends Enum
{
    //编译器为我们添加的静态的values()方法
    public static Day[] values()
    {
        return (Day[])$VALUES.clone();
    }
    //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法
    public static Day valueOf(String s)
    {
        return (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);
    }
    //私有构造函数
    private Day(String s, int i)
    {
        super(s, i);
    }
     //前面定义的7种枚举实例
    public static final Day MONDAY;
    public static final Day TUESDAY;
    public static final Day WEDNESDAY;
    public static final Day THURSDAY;
    public static final Day FRIDAY;
    public static final Day SATURDAY;
    public static final Day SUNDAY;
    private static final Day $VALUES[];

    static 
    {    
        //实例化枚举实例
        MONDAY = new Day("MONDAY", 0);
        TUESDAY = new Day("TUESDAY", 1);
        WEDNESDAY = new Day("WEDNESDAY", 2);
        THURSDAY = new Day("THURSDAY", 3);
        FRIDAY = new Day("FRIDAY", 4);
        SATURDAY = new Day("SATURDAY", 5);
        SUNDAY = new Day("SUNDAY", 6);
        $VALUES = (new Day[] {
            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
        });
    }
}
```

##### finally  代码块和 finalize()方法有什么区别？

无论是否抛出异常，finally 代码块都会执行，它主要是用来释放应用占用的资源。

finalize()方法是 Object 类的一个 protected 方法，它是在对象被垃圾回收之前由 Java 虚拟机来调用的。它最主要的用途是回收特殊渠道申请的内存。如 JNI(Java Native Interface)调用 non-Java程序（C 或 C++），finalize()的工作就是回收这部分的内存。

##### comparable和 comparator 接口区别

Comparable和Comparator接口被用来对对象集合或者数组进行排序。
Comparable接口被用来提供对象的自然排序，可使用它来提供基于单个逻辑的排序。
Comparator接口被用来提供不同的排序算法，可根据制定字段选择需要使用的Comparator来对指定的对象集合进行排序。

##### 接口和抽象类的区别

1，抽象类里可以有构造方法，而接口内不能有构造方法。
2，抽象类中可以有普通成员变量，而接口中不能有普通成员变量。
3，抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法。
4，抽象类中的抽象方法的访问类型可以是public ，protected和private，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
5，抽象类中可以包含静态方法，接口内不能包含静态方法。
6，抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static类型，并且默认为public static final类型。
7，一个类可以实现多个接口，但只能继承一个抽象类。

##### session与cookie

![image-20210305205425880](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104747.png)

cookie 是 Web 服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个 Web服务器存储 cookie。以后浏览器在给特定的 Web 服务器发请求的时候，同时会发送所有为该服务器存储的 cookie。

##### hash算法

![image-20210307200727001](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104748.png)

##### Java动态代理

通过 Proxy 的 ProxyInstance 类创建出一个代理类，这个代理类执行的关于它代理的对象（真正的对象）的方法（代理类可以自己定义自己的方法，要区别）

InvocationHandler 是一个接口，接口中有 invoke 方法，invoke 方法关联到一个真正的对象，然后去执行真正对象的方法，来实现代理。

![image-20210307221526701](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104749.png)

#### 面向对象

##### Java创建对象四种方法

![image-20210305203852177](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104750.png)

![image-20210307193025213](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104751.png)

##### 强、软、弱和虚引用

![1567505930559](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104752.png)

```java
//强引用 即使该对象永远不会被用到，JVM 也不会回收。强引用是造成 Java 内存泄漏的主要原因之一。
String str = new String("str");

// 软引用 
// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T
//创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。
//运用：用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效避免内存溢出的问题。
SoftReference<String> wrf = new SoftReference<String>(new String("str"));

//弱引用 
WeakReference<String> wrf = new WeakReference<String>(str);   

//虚引用
PhantomReference<String> prf = new PhantomReference<String>(newString("str"), new ReferenceQueue<>());
```

##### 封装

封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。
封装的一些好处：
1) 通过隐藏对象的属性来保护对象内部的状态;
2) 提高了代码的可用性和可维护性;
3) 禁止对象之间的不良交互提高模块化。

![image-20200210161241969](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104753.png)

##### 继承

类似于this，子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量

在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。

super与this的内存图

![03-super与this的内存图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104754.png)

##### 多态

相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。多态分两种类型：
**编译时多态**：在编译时能够确定执行多态方法中的哪一个，称为编译时多态； 方法重载是编译时多态。
**运行时多态**：在执行期间根据实际类型判断并调用相应的属性和方法。主要用于继承父类和实现接口时，父类引用指向子类对象。

![05-抽象的概念](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104755.png)

##### 重载与重写

![image-20210305202652712](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104756.png)

#####  内部类

内部类可以直接访问外部类的成员，包括私有成员。
外部类要访问内部类的成员，必须要建立内部类的对象。

```
外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；
```

内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的 .class文件，但是前面冠以外部类的类名
和$符号 。比如，Person$Heart.class

**匿名内部类**
匿名内部类就是没有名字的内部类；
匿名内部类不能定义任何静态成员、方法。
匿名内部类中的方法不能是抽象的；
匿名内部类必须实现接口或抽象父类的所有抽象方法。
匿名内部类访问的外部类成员变量或成员方法必须用 static 修饰
1、匿名内部类因为没有类名，可知匿名内部类不能定义构造器。
2、因为在创建匿名内部类的时候，会立即创建它的实例，可知匿名内部类不能是抽象类，必须实现接口或抽象父类的所有抽象方法。
3、匿名内部类会继承一个父类（有且只有一个）或实现一个接口（有且只有一个），实现父类或接口中所有抽象方法，可以改写父类中的方法，添加自定义方法。
5、当匿名内部类和外部类有同名变量（方法）时，默认访问的是匿名内部类的变量（方法），要访问外部类的变量（方法）则需要加上外部类的类名。

##### 类加载器初始化

类加载（先父后子,静态代码块（执行一次）---->非静态代码块(执行多次）---->成员变量---->构造函数)

static在涉及到继承的时候，会先初始化父类的static变量，然后是子类的，依次类推。

存在继承的情况下，初始化顺序为：

1. 父类（静态变量、静态语句块块 执行一次）
2. 子类（静态变量、静态语句块 执行一次）
3. 父类（实例变量、普通语句块）
4. 父类（构造函数）
5. 子类（实例变量、普通语句块）
6. 子类（构造函数）

```java
对类的主动使用：
    1. 创建类的实例
    2. 访问某个类或者接口的静态变量，或者对该静态变量赋值。
    3. 调用类的静态方法。
    4. 反射（Class.forName）
    5. 初始化类的子类
    6. java虚拟机启动时被标明为启动类的类
public class Test {
    Person person = new Person("Test");
    static{
        System.out.println("test static");
    }
    public Test() {
        System.out.println("test constructor");
    }
    public static void main(String[] args) {
        new MyClass();
    }
}

class Person{
    static{
        System.out.println("person static");
    }
    public Person(String str) {
        System.out.println("person "+str);
    }
}

class MyClass extends Test {
    Person person = new Person("MyClass");
    static{
        System.out.println("myclass static");
    }
    public MyClass() {
        System.out.println("myclass constructor");
    }
}
输出结果为：
test static
myclass static
person static
person Test
test constructor
person MyClass
myclass constructor

为什么输出结果是这样的？我们来分析下这段代码的执行过程：
找到main方法入口，main方法是程序入口，但在执行main方法之前，要先加载Test类
加载Test类的时候，发现Test类有static块，而是先执行static块，输出test static结果
然后执行new MyClass(),执行此代码之前，先加载MyClass类，发现MyClass类继承Test类，而是要先加载Test类，Test类之前已加载
加载MyClass类，发现MyClass类有static块，而是先执行static块，输出myclass static结果
然后调用MyClass类的构造器生成对象，在生成对象前，需要先初始化父类Test的成员变量，而是执行Person person = new Person("Test")代码，发现Person类没有加载
加载Person类，发现Person类有static块，而是先执行static块，输出person static结果
接着执行Person构造器，输出person Test结果
然后调用父类Test构造器，输出test constructor结果，这样就完成了父类Test的初始化了
再初始化MyClass类成员变量，执行Person构造器，输出person MyClass结果
最后调用MyClass类构造器，输出myclass constructor结果，这样就完成了MyClass类的初始化了
```

#### 泛型

```java
public class Box<T> {
    // T stands for "Type"
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

##### 为什么使用泛型

使代码可以被不同类型的对象重复使用。典型的使用场景是集合，如果没有泛型，我们要么需要为不同的对象编写集合类，这样存在大量重复代码。或者编写通用的Object集合类，但这样做需要在使用之前进行强制类型转换。另外，在放入元素的时候也没有类型检查，任何类型的对象都可以放入集合，在使用时进行类型转换可能会发生 ClassCastException 类型转换异常。

泛型的好处：

增强代码可读性和安全性（提供编译期类型检查）。

##### 泛型的实现

java 泛型是伪泛型，是在编译器层面通过**泛型擦除**实现的。在编译期间，所有的泛型信息都会被擦除掉，以类型界限代替。在使用泛型的时候，编译器也会帮我们自动进行类型转换。

##### 通配符

**限定通配符**：对类型进行了限制。

&lt;? extends T&gt; 确保类型必须是T的子类来设定类型的上界。<br>
&lt;? super T&gt; 确保类型必须是T的父类来设定类型的下界。

**非限定通配符**：&lt;?&gt;

#### 文件与IO

![image-20200220140633788](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104757.png)

1.Java IO是采用的是装饰模式，即采用**处理流**来包装**节点流**的方式，来达到代码通用性。

2.处理流和节点流的区分方法，**节点流**在新建时需要一个数据源（文件、网络）作为参数，而**处理流**需要一个节点流作为参数。

3.**处理流**的作用就是提高代码通用性，编写代码的便捷性，提高性能。

4.**节点流**都是对应抽象基类的实现类，它们都实现了抽象基类的基础读写方法。其中read（）方法如果返回-1，代表已经读到数据源末尾。

![image-20210305213044888](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104758.png)

##### IO  NIO BIO  AIO 

什么是阻塞和非阻塞，什么是同步和异步

同步和异步是针对应用程序和内核的交互而言的，
同步指的是用户进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否就绪

而异步是指用户进程触发 IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知。

阻塞和非阻塞是针对于进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式

阻塞方式下读取或者写入函数将一直等待

非阻塞方式下，读取或者写入函数会立即返回一个状态值。

![image-20210305205609457](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104759.png)

```
一般来说 I/O 模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞 IO
同步阻塞 IO：在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。JAVA 传统的 IO 模型属于此种方式！

同步非阻塞 IO:在此种方式下，用户进程发起一个 IO 操作以后边可返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 JAVA 的 NIO 就属于同步非阻塞 IO。

异步阻塞 IO：此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！

异步非阻塞 IO:在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为真正的 IO 读取或者写入操作已经由内核完成了。
```

##### NIO原理

![image-20210316115415231](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104800.png)



![image-20210305210736184](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104801.png)

![image-20210305210750572](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104802.png)

##### select/epoll 

![image-20210305210453472](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104803.png)

#### 异常

![image-20210305210951921](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104804.png)

![image-20210305210931353](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104805.png)

#### 序列化

![image-20210305211157202](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104806.png)

![image-20210305211140190](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104807.png)

![image-20210305211219663](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104808.png)

![image-20210305211242847](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104809.png)

#### 反射

![image-20210305204941639](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104810.png)

![image-20210305204959895](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104811.png)

#### java各版本的特性

##### JDK1.5

1.**泛型**、2. 自动装箱/拆箱、3. for-each、4. static、import、5. 变长参数、协变返回类型（实际返回类型可以是要求的返回类型的一个子类型）、6. 枚举

##### JDK1.6

1.**增强的 for 循环**、2. 监视和管理、3. 插入式注解处理、4. 安全性

##### JDK1.7

1.模块化新特性、2. 多语言支持、3. 改善开发效率、4. 改善执行效率、5. **提供了新的垃圾回收器 G1**

##### JDK1.8

1. 接口允许默认方法 / 扩展方法

   default 关键字

2. 方法与构造函数引用

   允许使用 :: 关键字来传递方法或者构造函数引用

3. Lambda

   - 表达式：无需再使用传统匿名对象方式

   - 函数式接口

     每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 

   - 访问局部变量：可以直接在lambda表达式中访问外层的局部变量

   - 访问对象字段与静态变量

     和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的。

   - 访问接口的默认方法

     JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。

### Java集合

#### 集合总览

arraylist数组实现，随机访问快；linklist链表实现，插入删除快

hashset使用hash散列,获取元素很快，Treeset使用红黑树，按照比较结果升序保存，linkedhashset用来链表按照被添加的顺序保存，用hash保留查找速度(set中元素不可重复)

hashmap没有顺序，查找快，Treemap按照比较结果升序保存key ,LinkedHashMap按照插入结果保存Key，保留查找速度

Vector ,Hashtable,Stack弃用

点框表示接口，实框表示具体类，空心箭头表示特定类实现接口，实心箭头表示某类可以生成箭头所指类的对象

![image-20200210163111068](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104812.png)

#### ArrayList

实现了 RandomAccess 接口，因此**支持随机访问**，这是理所当然的，因为 ArrayList 是基于数组实现的。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

基于数组实现，保存元素的**数组使用 transient 修饰**，该关键字声明数组默认不会被序列化。这是 ArrayList 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。ArrayList 重写了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那么部分内容。

```java
transient Object[] elementData; // non-private to simplify nested class access
```

数组的**默认大小为 10**。

```java
private static final int DEFAULT_CAPACITY = 10;
```

删除元素时需要调用 System.arraycopy() 对元素进行复制，因此**删除操作成本很高**。

```java
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
```

添加元素时使用 ensureCapacity() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，使得新容量为**旧容量的 1.5 倍**（oldCapacity + (oldCapacity >> 1))。扩容操作需要把原数组整个复制到新数组中，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。

```java
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

##### Iterator和ListIterator区别

Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

##### ArrayList、LinkedList、Vector

![image-20210307201033444](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104813.png)

![image-20210307201305145](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104814.png)

##### 快速失败(fail-fast) 和安全失败(fail-safe)

![image-20210307201414967](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104815.png)

##### Collections.sort  原理

![image-20210307200607804](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104816.png)

#### HashMap

在JDK1.8之前，哈希表底层采用**数组+链表**实现，而JDK1.8中，哈希表存储采用**数组+链表+红黑树**实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

![image-20210305214229565](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104817.png)

![哈希流程图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104818.png)

```java
public class HashMap<K,V> extends AbstractMap<K,V> 
	implements Map<K,V>, Cloneable, Serializable {

	 /**
     * HashMap的默认初始容量大小 16
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

    /**
     * HashMap的最大容量 2的30次方
     */
    static final int MAXIMUM_CAPACITY = 1 << 30;

    /**
     * 负载因子，代表了table的填充度有多少，默认是0.75。当数组中的数据大于总长度的0.75倍时
     * HashMap会自动扩容，默认扩容到原长度的两倍。为什么是两倍，而不是1.5倍，或是3倍。length=2的n次方，h&(length-1)==h%length
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * 默认阈值，当桶(bucket)上的链表长度大于这个值时会转成红黑树，put方法的代码里有用到
     * 在jdk1.7中链表就是普通的单向链表，很多数据出现哈希碰撞导致这些数据集中在某一个哈希桶上，
     * 因而导致链表很长，会出现效率问题，jdk1.8对此做了优化，默认当链表长度大于8时转化为红黑树
     */
    static final int TREEIFY_THRESHOLD = 8;
    
    /**
     * 和上一个的阈值相对的阈值，当桶(bucket)上的链表长度小于这个值时红黑树退化成链表
     */
    static final int UNTREEIFY_THRESHOLD = 6;
    
    /**
     * 用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap  * 的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException
     */
    transient int modCount;
    
}
```

##### hashcode 的计算

![image-20210305214636891](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104819.png)

![image-20210305214838703](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104820.png)

```java
//计算hash，扰动函数
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
//计算索引位置：
static int indexFor(int h, int length) {
    return h & (length-1);
}
int hash = hash(key.hashCode());
int i = indexFor(hash, table.length);
```

##### 扩容机制

![image-20210305214934547](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104821.png)

![image-20210305220438552](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104822.png)

**jdk1.8 扩容元素的位置要么是在原位置，要么是在原位置加原数组长度的位置**。

##### 负载因子0.75

泊淞分布啊

简单翻译一下就是在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布，注释同时给出了桶中元素个数和概率的对照表。

从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。0.00000006，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。

##### get方法（不加锁）

![image-20210305215442825](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104823.png)

##### put方法

![哈希流程图](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104818.png)

```java
public V put(K key, V value) {
    //调用putVal()方法完成
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    //判断table是否初始化，否则初始化操作
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    //计算存储的索引位置，如果没有元素，直接赋值
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        //节点若已经存在，执行赋值操作
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        //判断链表是否是红黑树
        else if (p instanceof TreeNode)
            //红黑树对象操作
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            //为链表，
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    //链表长度8，将链表转化为红黑树存储
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                //key存在，直接覆盖
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    //记录修改次数
    ++modCount;
    //判断是否需要扩容
    if (++size > threshold)
        resize();
    //空操作
    afterNodeInsertion(evict);
    return null;
}
```

##### 对key为NULL的特别处理

![image-20210305215635335](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104824.png)

![image-20210305215617963](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104825.png)

```java
private V putForNullKey(V value) {
    // 若key==null，则将其放入table的第一个桶，即 table[0]
    for (Entry<K,V> e = table[0]; e != null; e = e.next) {   
        if (e.key == null) {   // 若已经存在key为null的键，则替换其值，并返回旧值
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;        // 快速失败
    addEntry(0, null, value, 0);       // 否则，将其添加到 table[0] 的桶中
    return null;
}
```

##### 线程不安全

添加删除和扩容时有问题

要想实现线程安全，那么需要调用 collections 类的静态方法 synchronizeMap（）实现

![image-20210305215705647](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104826.png)

#####  key 可以为任意对象或数据类型吗？

![image-20210305220242863](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104827.png)

![image-20210305220252516](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104828.png)

##### HashMap - JDK 1.8

**链表转红黑树**

一个桶存储的链表长度大于 8 时会将链表转换为红黑树。

**解决扩容时的死循环问题**

使用lo和hi分别指向两个新的链表。原来的链表中的元素扩容后位置不变，就放到lo中，位置改变，就放到hi中。采用尾插法进行移动，因此扩容之后元素顺序不改变，也不会发生死循环。而JDK1.7采用头插法则会改变元素顺序。最后分别将lo和hi放入新hashMap的桶中。

#### ConcurrentHashMap

一个 ConcurrentHashMap 维护一个 **Segment 数组,**一个 Segment 维护一个 **HashEntry 数组**。Segment 继承了 **ReentrantLock**，表明每个 segment 都可以当做一个锁。这样对每个 segment 中的数据需要同步操作的话都是使用每个 segment 容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的 segment。

![image-20210305222249650](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104829.png)

![image-20210305222139377](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104830.png)

![image-20210305222500466](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104831.png)

#####  size 操作

每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。

```java
/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;
```

在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。

ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。

尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。

如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。

##### Get 原理

![image-20210307195131476](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104832.png)先判断一下 count != 0；count 变量表示 segment 中存在 entry的个数。如果为 0 就不用找了。

假设这个时候恰好另一个线程 put 或者 remove了这个 segment 中的一个 entry，会不会导致两个线程看到的 count 值不一致呢？ **依赖 volatile 关键字保证可见**。看一下 count 变量的定义： transient volatile int count;

![image-20210307195102182](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104833.png)

##### Put原理

- 如果没有初始化就先进行初始化过程
- 如果没有hash冲突就直接CAS插入
- 如果存在hash冲突，就加锁来保证线程安全，链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入

下图大致描述了 put 一个新的 entry 的过程

![image-20210307195250159](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104834.png)

删除

![image-20210307195521157](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104835.png)

##### HashMap与HashTable区别

![image-20210307195855649](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104836.png)

##### HashMap与ConcurrentHashMap区别

![image-20210307195927117](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104837.png)

##### ConcurrentHashMap与HashTable区别

![image-20210307200123574](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104838.png)

#### LinkedHashMap

![image-20210307200236633](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104839.png)

##### LinkedHashMap 实现LRU 缓存

- 设定最大缓存空间 MAX_ENTRIES  为 3；
- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；
- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。

```java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}
public static void main(String[] args) {
    LRUCache<Integer, String> cache = new LRUCache<>();
    cache.put(1, "a");
    cache.put(2, "b");
    cache.put(3, "c");
    cache.get(1);
    cache.put(4, "d");
    System.out.println(cache.keySet());
}
//[3, 1, 4]
```

#### HashSet

对于 HashSet 而言，它是基于 HashMap 实现的,可以看出 hashset 底层是 hashmap 但是存储的是一个对象，hashset 实际将该元素 e 作为 key 放入 hashmap,当 key 值(该元素 e)相同时，只是进行更新 value，并不会新增
加，所以 set 中的元素不会进行改变。

![image-20210307200433269](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104840.png)

![image-20210307200449786](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104841.png)

![image-20210307200457322](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104842.png)

#### PriorityQueue

Java中PriorityQueue通过二叉小顶堆实现，可以用一棵完全二叉树表示。PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素
排序的比较器。PriorityQueue 不允许 null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))。

![image-20210305203257400](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104843.png)

**添加元素 add()和 offer()**
原理：添加元素位于末尾，同时队列长度加 1，然后这个元素与它的父节点进行比较，

如果比父节点小那么就与父节点进行交换，然后再与交换后的位置的父节点进行比较，
重复这个过程，直到该元素的值大于父节点结束这个过程。
区别: add(E e)和 offer(E e)的语义相同，都是向优先队列中插入元素，只是 Queue 接口规
定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回 false。

![image-20210305203430221](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104844.png)

**寻找队列的头部元素 element()和 peek()头部元素**
element()和 peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回 null。 时间复杂度为 1，根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0 下标处的那个元素既是堆顶元素。所以直接返回数组 0 下标处的那个元素即可。

**最大堆 获取数组中最小的几个数 最小堆  获取数组中最大的几个数**

**删除元素 remove() 和 poll()**
区别:remove()和 poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回 null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。
原理：该方法的作用是从 k 指定的位置开始，将 x 逐层向下与当前点的左右孩子中较小的那个交换，直到 x 小于或等于左右孩子中的任何一个为止

![image-20210305203627842](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414104845.png)

#### WeakHashMap

##### 存储结构

WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。

WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。

```java
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V>
```

##### ConcurrentCache

Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。

ConcurrentCache 采取的是分代缓存：

- 经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；
- 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。
- 当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。
- 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。

```java
public final class ConcurrentCache<K, V> {

    private final int size;

    private final Map<K, V> eden;

    private final Map<K, V> longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap<>(size);
        this.longterm = new WeakHashMap<>(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() >= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
```
