---
layout: post
title: "网安复习"
date: 2021-03-09 10:36
toc: true
comments: true
categories: 技术学习
tags:
	- 基础
	- 复习 
---

### 网安

整个课就三个部分：对称密码，非对称密码，和几种安全服务(消息认证，数字签名，认证，证书等等都是为了安全服务)

<!--more-->

#### 相关概念

##### 安全服务

> RFC2828中定义的，是一种由系统提供的对系统资源进行特殊保护的处理或通信服务，安全服务通过安全机制来实现安全策略。
>
> ITU-T（即X.800）定义了五种服务：【身份认证】、【访问控制】、【数据保密】、【数据完整性】、【不可否认】

- 【身份认证】：认证发送方和接收方的身份（对等实体身份认证）确保通信实体是合法和真实的
- 【访问控制】：保护信息免于被未经授权的实体访问
- 【数据机密性】：保护数据免于非授权泄露，并防止流量分析
- 【数据完整性】：确保接收到的数据是由授权用户发出的或者是未被修改过的
- 【不可否认性】：防止通信方对通信行为的否认，包括源不可否认性和宿不可否认性
- Availiable Service: 系统或系统资源能够按照要求根据系统性能规范被授权访问和使用

##### 安全机制

> 安全机制是用来检测、防止安全攻击，或从安全攻击中恢复的机制。单一的安全机制不能保证所需的所有安全服务。最重要的安全机制之一就是密码编码规则（重点）

- 加密：隐藏或覆盖信息以使其具有机密性。
- 完整性：消息后面附加于一个短的键值。接收方接收信息和键值，再从接收的信息中创建一个新的键值，并把新创建的键值和原来的进行比较，如果两个键值相同，则说明数据的完整性被保全。==举个栗子==比如我发个消息，除了消息本身以外还发了一个消息的总长度，然后发出去了。接收方先收到消息，然后计算一下消息的总长度，和他收到的总长度对比，如果一样，就说明信息完整性被破坏的可能性不高。
- 数字签名：信息发送方可以对信息进行电子签名，信息接收方可以对签名进行电子校验。
- 身份认证交换：两个实体交换信息以互相证明身份，比如一方可以证明只有另一方才知道的小秘密。
- 流量填充：指在数据流中嵌入一些虚假信息，阻止对手企图使用流量分析。
- 路由控制：指在发送方和接收方之间选择并【不断改变有效路由】，以避免对手在特定的路由上偷听。
- 公证：找一个可靠的第三方控制双方通信。
- 访问控制：用各种方法，证明某个用户具有访问该信息或该系统所拥有的资源的权力。

安全服务可以由一些安全机制去实现，例如：

| 安全服务   | 安全机制                   |
| ---------- | -------------------------- |
| 信息机密性 | 加密和路由控制             |
| 信息完整性 | 加密、数字签名、信息完整性 |
| 身份认证   | 加密、数字签名             |
| 不可否认性 | 数字签名、信息完整性和公证 |
| 访问控制   | 访问控制机制               |

##### 对安全的攻击  

```
Interruption: 对availability的攻击
Interception: 对confidentiality的攻击
Modification: 对integrity的攻击
Fabrication: 对authenticity的攻击
```

![1574576554598](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211633.png)

##### 主动攻击和被动攻击

被动攻击：对传输进行窃听和监测，通信和信息不受影响，用户感觉不到攻击存在，攻击通常是窃听或流量分析，判断通信性质

主动攻击：攻击者破坏通信过程，拦截、修改、伪造、丢弃信息、拒绝服务或假冒合法用户

##### 简单加密系统模型 

![1574576797543](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211634.png)

##### 理论安全和实际安全

理论安全，或无条件安全Theoretical Secure (or Perfect Secure)：攻击者无论截获多少密文，都无法得到足够的信息来唯一地决定明文。Shannon用理论证明：欲达理论安全，加密密钥长度必须大于等于明文长度，密钥只用一次，用完即丢，即一次一密，One-time Pad，不实用。

实际安全，或计算上安全Practical Secure (or Computationally Secure)：如果攻击者拥有无限资源，任何密码系统都是可以被破译的；但是，在有限的资源范围内，攻击者都不能通过系统的分析方法来破解系统，则称这个系统是计算上安全的或破译这个系统是计算上不可行(Computationally Infeasible)。 

##### 对称密码体制和非对称密码体制

对称密码体制(Symmetric System, One-key System, Secret-key System)：加密密钥和解密密钥相同，或者一个密钥可以从另一个导出，能加密就能解密，加密能力和解密能力是结合在一起的，开放性差。

非对称密码体制(Asymmetric System, Two-key System, Public-key System)： 加密密钥和解密密钥不相同，从一个密钥导出另一个密钥是计算上不可行的，加密能力和解密能力是分开的，开放性好。

##### 序列密码体制和分组密码体制

序列密码：如果密文不仅与最初给定的算法和密钥有关，同时也与明文位置有关(是所处位置的函数)，则称为序列密码体制。加密以明文比特为单位，以伪随机序列与明文序列模2加后，作为密文序列。

分组密码：如果经过加密所得到的密文仅与给定的密码算法和密钥有关，与被处理的明文数据在整个明文中的位置无关，则称为分组密码体制。通常以大于等于64位的数据块为单位，加密得相同长度的密文。

##### 确定型密码体制和概率密码体制

确定型：当明文和密钥确定后，密文也就唯一地确定了。

概率型：当明文和密钥确定后，密文通过客观随机因素从一个密文集合中产生，密文形式不确定，称为概率型密码体制。

##### 单向函数型密码体制和双向变换型密码体制

单向函数型密码体制适用于不需要解密的场合，容易将明文加密成密文，如哈希函数；

双向变换型密码体制可以进行可逆的加密、解密变换。

##### confusion和diffusion(混淆和扩散)

Shannon认为，为了对付基于统计分析的密码破译，必须对明文作confusion(混淆)和diffusion(扩散)处理，以减少密文的统计特性，为统计分析制造障碍。

diffusion ——明文统计结构扩散消失到大批密文统计特性中，使明文和密文之间统计关系尽量复杂；

confusion ——混淆，使密文和加密密钥之间的关系尽量复杂。

##### 现代密码学基本原则及理论

设计加密系统时，总是假定密码算法是可以 公开的，需要保密的是密钥。一个密码系统的安全性不在算法的保密，而在于密钥。

对称加密系统的五个组成部分：明文、加密算法、密钥、密文、解密算法

所有加密算法都基于两个原理： 代替和置换。代替是将明文中的每个元素映射成另一个元素，置换是将明文元素重新排列。

密码攻击的两种方式：密码分析学攻击(差分分析和线性分析)和穷举攻击

另一种密码攻击的分类：唯密文攻击、已知明文攻击、选择明文攻击、选择密文攻击、选择文本攻击，一般的，加密算法起码要能经受得住已知明文攻击。

一次一密的两个限制：产生大规模随机密钥有实际困难、密钥的分配和保护无法保证。

隐写术不是加密技术。

多次加密的最简单形式是进行两次加密，每次使用不同的密钥，但存在中间相遇攻击。

使用两个密钥进行三次加密：E-D-E，即 C=E K1 [D K2 [E K1 [P]]；三个密钥加密，C = E K3 [D K2 [E K1 [P]]]

应用最广泛的公钥密码体制是 RSA，破解 RSA 的困难，是基于分解大合数的素因子的困难

公钥密码体制中， 穷举消息攻击是第三种攻击形式，攻击者用公钥对所有可能的消息加密，并与传送的密文匹配，从而解密任何消息；抵抗的方法是在要发送的消息后附加随机数(即对传送的明文进行穷举攻击)。

#### 离散复习(群、环、域)与模运算

##### 群G, 记作{G, •}

定义一个二元运算•的集合，G中每一个序偶(a, b)通过运算生成G中元素(a•b)，满足下列公理：

(A1) 封闭性Closure: 如果a和b都属于G, 则a•b也属于G.

(A2) 结合律Associative: 对于G中任意元素a, b, c，都有a•(b•c)=(a•b)•c成立

(A3) 单位元Identity element: G中存在一个元素e，对于G中任意元素a，都有a•e=e•a=a成立

(A4) 逆元Inverse element: 对于G中任意元素a, G中都存在一个元素a’，使得a•a’=a’•a=e成立

##### 交换群Abelian Group：

还满足以下条件的群称为交换群(又称阿贝尔群)

(A5) 交换律Commutative ：对于G中任意的元素a, b，都有a•b=b•a成立

当群中的运算符是加法时，其单位元是0；a的逆元是-a, 并且减法用以下的规则定义: a – b = a + (-b)

##### 循环群Cyclic Group

l如果群中的每一个元素都是一个固定的元素a (a ∈G)的幂ak(k为整数)，则称群G为循环群。元素a生成了群G，或者说a是群G的生成元。

##### 环R, 由{R, +, x}表示

是具有加法和乘法两个二元运算的元素的集合，对于环中的所有a, b, c, 都服从以下公理：

(A1-A5), 单位元是0，a的逆是 -a.

(M1), 乘法封闭性, 如果a和b属于R, 则ab也属于R

(M2), 乘法结合律,对于R中任意a, b, c有a(bc)=(ab)c.

(M3), 乘法分配律, a(b+c)=ab+ac or (a+b)c=ac+bc

(M4), 乘法交换律, ab=ba，交换环 

(M5), 乘法单位元, R中存在元素1使得所有a有 a1=1a.

(M6), 无零因子, 如果R中有a, b且ab=0, 则 a=0 or b=0.

满足M4的是交换环；满足M5和M6的交换环是整环

##### 域F, 可以记为{F, +, x}

是有加法和乘法的两个二元运算的元素的集合，对于F中的任意元素a, b, c, 满足以下公理：

(A1-M6), F是一个整环

(M7), 乘法逆元, 对于F中的任意元素a(除0以外), F中都存在一个元素a-1, 使得aa-1=(a-1)a=1.

域就是一个集合，在其上进行加减乘除而不脱离该集合, 除法按以下规则定义: a/b=a(b-1).

有理数集合, 实数集合和复数集合都是域；整数集合不是域，因为除了1和-1有乘法逆元，其他元素都无乘法逆元

##### 模算术运算

```
(a1 op a2) mod n =[(a1 mod n ) op (a2 mod n)] mod n
```

##### 欧几里得算法

gcd(a, b) = gcd(b, a%b) .辗转相除直到第一个参数能够整除第二个参数即可

##### 同余

```
a mod n = b mod n，则a和b模n同余
同余是一种等价关系，满足自反，对称，可传递
```

##### 加法逆元和乘法逆元

```
对每一个w，存在一个z能够让(w+z) mod n = 0，则z是加法逆元
如果wz mod n = 1，注意不是0，则z是乘法逆元
```

##### 计算乘法逆元，扩展欧几里得算法

计算乘法逆元表示为：ax mod n = 1, 已知a，求x

引理：如果gcd(a, n) = 1，对每个i, j, 有i < j < n，则ai mod n 不会等于 aj mod n

定理：如果gcd(a, n) = 1, 一定存在整数x，满足ax mod n = 1，可以用扩展欧几里得算法求逆

```
ax + by = d = gcd(a, b)
如果gcd(a, b) = 1，则有ax + by = 1
将 1 mod a = 1 mod a的1用上式进行替换
    ( (ax mod a) + (by mod a) mod a) = 1 mod a
ax mod a = 0，所以：
    (by mod a) mod a = 1 mod a，所以：
    by mod a = 1
如果by mod a = 1，则y = b^-1
```

线性O(n)内求逆元代码：

```
for(int i = 2; i < MAXN; ++i){
    inv[i] = mul(inv[mod%i], mod - mod / i, mod);
}
```

#### 数论三大定理的概念与证明

##### 数论基本知识

**单向函数(One-way Function)**

 一函数*f* 若满足下列条件, 则称*f* 为单向函数：

 (1)对于所有属于*f* 域的任一*x*, 容易计算*y*= *f*(*x*)

 (2)对于几乎所有属于*f* 域的任一*y*, 求得*x*, 使*y*= *f*(*x*), 在计算上不可行。

**单向陷井门函数(One-way Trapdoor Function)**

 一“可逆”函数*F*若满足下列二条件, 则称*F*为单向陷井门函数:

(1)对于所有属于*F*域的任一*x*, 容易计算*F*(*x*)=*y*；

(2)对于几乎所有属于*F*域的任一*y*, 除非获得暗门信息(trapdoor), 否则求出*x*, 使得 *x* = *F*-1(*y*)在计算上不可行, *F*-1为*F*之逆函数; 如有额外信息(暗门), 则容易求出    *x* = *F*-1(*y*)。

##### 费马定理

![image-20200113150943674](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211635.png)

##### 费马小定理和欧拉定理

欧拉函数φ(n)是比n小且与n互素的正整数的个数，即模n的缩剩余系中元素之个数。

![image-20200113151112824](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211636.png)

![image-20200113151138849](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211637.png)

##### 中国剩余定理

![image-20200113151240618](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211638.png)

![image-20200113151310255](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211639.png)

##### 离散对数问题

幂运算是相对容易的, 求解离散对数通常是难解问题。离散对数是包括Diffie-Hellman密钥交换和数字签名(DSA)在内的许多公钥算法的基础。

#### 对称密码

对称密码又称传统加密算法，加密密钥能够从解密密钥中推算出来。反过来也成立。在大多数对称算法中，加密和解密的密钥是一样的。 

要求：要求发送者和接受者在安全通信之前，商定一个密钥，对称算法的安全性依赖于密钥，泄露密钥意味着所有的人都能够对消息进行了加密解密，这个密码也就没有用了。 

对称密码可以分成两类：

> 序列算法（流算法）：逐字的读入明文，一个字一个字的进行单独的加密。比如将a替换成z，b替换成y，这种只针对一个字一个字的替换密码，所以又称流密码。

> 分组密码：对明文的一组进行加密，比如64个字一组，一起进行加密，这个计算机中经常用到，因为64大到足够防止破译，又小到可以方便使用。

##### DES（数据加密标准）

分组密码是一种加密解密算法，将输入明文分组当做一个整体处理，输出一个等长的密文分组。

许多分组密码都采用Feistel结构，这样的结构由许多相同的轮函数组成。每一轮里，对输入数据的一半进行代换，接着用一个置换来交换数据的两个部分，扩展初始的密钥使得每一轮使用不同的子密钥。

DES是应用最为广泛的分组密码，它扩展了经典的Feistel结构。DES 的 分组和 密钥分别是 64  位和 56  位，整个加密包含 16  轮迭代。

S 盒：8  个，将 6  位数据映射成 4  位数据(即 6 位输入，4 位输出) 。

![image-20200113151343976](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211640.png)

##### DES加解密过程

先直接看一遍加密性质：

- 分组密码：明文密文都是64位
- 字符都变成二进制，即每一位都是一个二进制，0或者1
- 密钥长度56位(64-8)，生命周期短，运算速度慢

然后是加密的过程，分为两步，第一步是密钥生成，第二步才是加密。

总概述过程如下：

- 密钥生成

  ![image-20200113151626771](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211641.png)

  加密

  - Step1：输入64位数据块，进行初始置换，输出32位R0和L0
  - Step2：将L0和R0进行16次f函数运算，每一次要用到相应的密钥K_i(f函数在下面会详细说道)，输出最后的32位R0和32位L0
  - Step3：将最后的R0和L0进行逆置换，输出64位密文，结束，总过程如下图![image-20200113151432697](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211642.png)

加密过程详细

密钥生成不再叙述，这里从头详细说一遍加密过程

> 开始之前：我们有64位明文数据块，16个子密钥K0-K15

Step1、初始置换

将64位数据块按照下面的表打乱顺序

![image-20200113151456894](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211643.png)

打乱后从中切开，左32位提出叫做L0，后32位提出叫做R0，【只输入R0】进入下个步骤

Step2、f函数

f函数分为三个步骤

第一步、扩展32位R0数据块

按照下面的表进行扩展，将32位R0扩展成48位

![image-20200113151705500](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211644.png)

第二步、与子密钥模二相加

将这个48位和对应的子密钥(第一次运算f函数就是K0，第十六次就是K15)模二相加，得到新的48位。

第三步、S盒替代

将这个新的48位按照每6位分成8个块，每个块是6位。

对每个块来说，将第一位和第六位合在一起的两位，计算出一个0-3的数字，叫做行，再将剩余的四位合在一起计算出一个0-15的数字，叫做列，一共得到8对行和列，然后在下面8个表S1-S8中，分别按照行列，找出8个十进制数字。这个过程叫做S盒替代。

![image-20200113151731406](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211645.png)

将得到的8个十进制数字全部转成四位二进制合成，得到32位。

第四步、P盒置换

将这个32位再按照下面的表打乱顺序

![image-20200113151754935](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211646.png)

第五步、得到R1

这样得到了最终的32位，现在，我们将这个32位叫做新的R0，即R1，将R1与之前一直没有改动的L0模二相加，得到新的R1。

第六步、得到新的L1和R1，回到第一步，重复f函数

将之前的没有变动的32位R0改成L1，现在我们有了新的L1和R1，可以重复这六步，得到L2和R2，重复16次，得到L15和R15

Step3、合并L15和R15，逆置换

合并L15和R15，得到64位数据，按照下表进行逆置换打乱顺序

![image-20200113152002327](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211647.png)

结束，得到64位密文

##### 多重DES

多重加密是将一个加密算法多次使用的技术，明文通过加密算法转化为密文，然后将该密文作为输入重新执行加密算法，该过程可以重复多次。

三重DES(3DES)在三个阶段使用DES算法，共用到两组或三组密钥。

##### 分组密码的五种工作模式：

选择工作模式是一项增强密码算法或者使算法适应具体应用的技术。就是把明文分组后如何进行加密，有五种方法

·电子密码本模式（ECB）：明文分成 64 的分组进行加密，必要时填充，每个分组用同一密钥加密，同样明文分组加密得相同密文。
·密文分组链接模式（CBC）：加密输入是当前明文分组和前一密文分组的异或，形成一条链，使用相同的密钥，这样每个明文分组的加密函数输入与明文分组之间不再有固定的关系
·密文反馈模式（CFB）：是一种将 DES 转化成流密码的技术。加密函数高端 j 位与明文 P1 的第一单元异或，产生 j 位密文 C1 进入移位寄存器低端，继续加密，与 P2 输入异或，如此重复直到所有明文单元都完成加密。
·输出反馈模式（OFB）：结构上类似 CFB，但是 OFB 中加密函数输出被反馈回移位寄存器。
·计数器模式（CRT）：每一个明文分组都必须使用一个不同的密钥和计数器值，决不要重复使用

![image-20200113152021877](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211648.png)

#### 公钥密码学(也叫非对称密码)

非对称密码是一种密码体制，其加密算法和解密算法使用不同的密钥，一个是公钥，一个是私钥。

##### 公钥密码应用

- 加密/解密：发送方用接收方的公钥对消息加密
- 数字签名：发送方用其私钥对消息签名，可以对整体消息签名或对消息的摘要签名
- 密码交换：通信双方交换会话密钥

##### 加密过程

![1574580137669](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211649.png)

##### 认证过程

![1574580173589](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211650.png)

##### 非对称相关概念

**对称密码的局限：**

- 密钥管理困难：两两用户分别用一对密钥，需要n∗(n−1)/2个密钥，复杂度是n2
- 数字签名无法实现：无法实现抗抵赖
- 密钥必须经过安全的信道分配（密钥只用于DES加密的密钥，有时也叫会话秘钥）

**公钥密码体制的组成**

​	明文：算法的输入，可读信息或数据

​	加密算法：对明文进行各种转换

​	公钥和私钥：算法的输入，分别用于加密和解密

​	密文：算法的输出，依赖于明文和密钥

​	解密算法：根据密文和密钥，还原明文

**公钥密码：**

- 算法是非对称算法，密钥分为公钥和私钥
- 公钥可以公开
- 基于数学函数（单向陷阱门函数）而不是替代置换

**公钥算法的条件**

- 产生一对密钥计算可行
- 已知公钥和明文，产生密文是计算可行的
- 接收方用私钥来解密密文是计算可行的
- 通过公钥判断私钥是计算不可行的
- 只知道公钥和密文是无法恢复明文的

**单向陷阱门函数f**

- 已知x，求y=f(x)容易
- 给定y，计算y=f(x)的x是困难的
- 存在z，当z已知的时候，已知y，计算y=f(x)的x是容易的

寻找单向陷阱门函数是公钥密码体制应用的关键。也是那些经典算法的源头。

##### RSA算法

理论基础：两个大素数相乘容易，分解成两个大素数很难

**获得密钥**

待获得的密钥：公钥(n, e1), 私钥(n, e2)

**算法流程**

随机选择两个秘密大素数p和q；

计算公开模数n=p*q；

计算秘密的欧拉指数函数φ(n)=(p-1)(q-1)；

选择一个与φ(n)互素的数，作为e或d；

用Euclid算法计算模φ(n)的乘法逆元素，即根据

​              ed mod φ(n)=1, 求d或e；

加密：C = Me mod n

解密：M= Cd mod n = (Me mod n)d mod n = M

这里，φ(n)为欧拉函数,  即集合(1, 2, ..., n-1)中与n互素的数的个数。

##### RSA证明

![image-20200113152053260](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211651.png)

##### RSA计算

![image-20200113152110799](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211652.png)

##### RSA的缺点

- 速度慢，比DES慢了至少100倍
- 产生密钥太麻烦
- 分组长度太大

##### 对RSA的攻击方法

强行攻击：尝试所有可能的密钥

数学攻击：对两个素数乘积的因子分解(FAC问题)

计时攻击：依赖于解密算法的运行时间

#### 公钥密码学之密钥管理

为了保证公钥的正确性，即A确实能得到B的公钥，也就是当公钥的真实性能够得到保证。

##### 几种公钥分配方法：

公开发布（随便发，任何人都可以伪造这种公钥的发布）、公开可访问的目录（一个管理员管理所有的公钥，但攻击者获得目录管理员私钥，就可以随意更改记录）、公钥授权、公钥证书

##### 公钥授权

A发送带有时间戳的消息给公钥管理员, 请求B的当前公钥

管理员给A发送用其私钥KRauth加密的消息, A用管理员的公钥解密，可以确信该消息来自管理员：

​	B的公钥KUb，用来加密；

​	原始请求，A可以验证其请求未被修改；

​	原始时间戳, A可以确定收到的不是来自管理员的旧消息。

A保存B的公钥, 并用它对包含A的标识IDA和Nonce1的消息加密, 然后发送给B

B以同样方式从管理员处得到A的公钥

B用KUa对A的N1和B的N2加密, 发送给A

A用B的公钥对N2加密并发送给B, 使B相信其通信伙伴是A

![image-20200113152141654](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211653.png)

##### 公钥证书

有了公钥证书使得不通过实时访问公钥授权部门而实现公钥交换成为可能

公钥证书将一个通信方的身份与他的公开密钥绑定在一起，通常还包括有效期和使用方法等

证书的所有内容必须经由可信公钥授权方或者证书授权方签名后方可生效

知道公钥授权当局公开密钥的任何人都可以验证一个用户的公开密钥证书的有效性 

对于申请者A，管理员提供的证书为：

​	CA = EKRauth [T, IDA, KUa]

其他人读取并验证：

​	DKUauth[CA]=DKUauth [EKRauth [T, IDA, KUa]]=(T, IDA, KUa)

![image-20200113152201887](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211654.png)

#### 利用公钥密码分配对称加密的密钥

##### 具有保密性和真实性的密钥分配

为了准确得到会话密钥， 利用公钥密码分配传统密码体制的密钥  

![image-20200113152224937](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211655.png)

##### Diffie-Hellman算法

作用：允许两个用户可以安全交换【一个秘密信息】，用于后续的通讯工程

Diffie-Hellman密钥交换算法是一种公钥分发机制，它不是用来加密消息的，所生成的是通信双方共享的会话密钥，必须保密，其值取决于通信双方的私钥和公钥信息

安全性依赖：计算离散对数的难度

**素数的原始根**

假设原始根为a，则：

a mod p, a^2 mod p, …., a^(p - 1) mod p 是1, 2, 3, …., p - 1的一个置换

对于所有素数，其原根必定存在，即对于一个整数b和素数p的一个原根，可以找到唯一的指数i, 使得 b = a^i mod p, 其中 0<= i <= p-1指数i称为b的以a为基数的模p的离散对数或者指数。

![image-20200113152252058](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211656.png)

##### 中间人攻击

A选取x_0, 计算出来了X，发给B

X被我截获，我选取x_00，计算出来了X_改，发给B

B把我当成了A，接收到了X改，选取x_1，得到X_b，发给我

我再发给A，至此完成攻击

ps：我必须一直伪装，不然就会被发现 ps：我永远不知道真正的K，即a^x0∗x1

##### 防范中间人攻击

- 使用共享的对称密钥加密DH交换
- 使用公钥加密DH交换
- 使用私钥签名DH交换

#####  ElGamal加密方案

![image-20200113152318077](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211657.png)

#####  ElGamal加密方案计算

![image-20200113152339546](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211658.png)

#### 消息认证

【消息认证】：验证消息完整性的一种机制/服务，确保收到的数据和发送的时候是一样的，不被篡改，而且发送方的身份是真实有效的。主要关注保护消息完整性，验证发送人身份与消息源的不可否认。

##### 可能受到的攻击

```
泄密Disclosure，将消息透露给没有合法身份的第三方
传输分析Traffic analysis，分析双方通信模式
伪装Masquerade，欺诈源向网络中插入一条消息
内容篡改Content modification，对消息内容的修改
顺序篡改Sequence modification，对消息顺序的修改
计时篡改Timing modification，对消息的延时和重放
信源抵赖Source repudiation,发送方否认发送过某消息
信宿抵赖Destination repudiation，接收方否认接收过某消息
```

##### 消息认证方法

三种消息认证的方法：消息加密，消息认证码(MAC)，哈希函数

消息加密：比如使用对称加密，默认只有发送方拥有密钥，才能产生可以解密的密文。

消息认证码MAC：使用密钥产生短小的定长数据分组，附加在报文里。例如AB共享密钥K，A发送B报文M，A计算MAC=C(K)，夹在报文里发给B。B收到这个MAC后根据报文重新计算比并且对比一下就好了。要注意报文认证不提供保密，而且MAC不提供数字签名，所以双方必须共享密钥。

![1574586237896](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211659.png)

哈希函数：输入任意长度的消息M，输出一个固定长度的散列值，这个值称为消息摘要。它对所有的M的位都进行了错误检验，任何一位发送变化都会导致散列值的变化。

![1574586317884](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211700.png)

散列函数的要求：H能用于任何大小的分组，能产生定长的输出，能方便的计算，具有单向性，弱抗冲突性，强抗冲突性。

弱无碰撞：给定消息x属于X中，在计算上无法找到一个x’使得H(x) = H(x’)

强无碰撞：任何情况下，在计算上都无法找到一个x’使得H(x) = H(x’)，其中包含了弱无碰撞的所有情况

分类：带密钥的Hash函数散列值有且仅有双方知道的密钥K来控制，生成的散列值叫MAC。不带密钥的Hash函数散列值叫MDC

#### 数字签名

作用：数字签名是一种认证机制，它使得消息的产生者可以添加一个起签名作用的码字。通过计算消息的散列值并用产生者的私钥加密散列值来生成签名。使明文信息的接收者能够验证信息确实来自合法用户，以及确认信息发送者身份。签名保证了消息的来源和完整性。相互认证协议使得通信的各方对相互的身份感到放心，并交换会话密钥。

与消息认证的区别：消息认证主要是看消息有没有被修改过，但是无法解决双方有利害冲突中的纷争，需要更严格的手段，也就是数字签名

##### ElGamal签名方案

![1574586969793](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211701.png)

基本形式：1、对消息整体签字，也就是对消息整个处理后得到签字。2、对消息摘要签字，附在被签消息后面，嵌在消息后面或者某个特定地方

类别：1、确定性数字签名，明文和签名一一对应。2、概率性数字签名，一个明文能有多个合法签名，每次都不一样。

##### 直接数字签名DDS

要求：仅涉及两个通信方，通常先签名，再对消息和签名一起进行加密，安全性依赖私有密钥的安全性。

##### 仲裁数字签名

涉及到一个仲裁方(arbiter A)

签名方的签名报文首先送给仲裁者

仲裁者对报文和签名进行测试以检验出处和内容，然后注上日期和仲裁说明后发给接收方

要求仲裁方在一定程度上是可以信任的

可以用对称密码或公开密钥密码实现

仲裁方可以知道消息，也可以不知道消息

#### CA认证

##### Kerberos

Kerberos是一种设计用于分布式环境下的认证服务，Kerberos利用一个可信的第三方认证服务来完成客户端和服务器端的认证

l通过提供一个集中的授权服务器来负责用户对服务器的认证和服务器对用户的认证，而不是对每个服务器提供详细的认证协议

l允许用户通过网络访问分布的服务器

l不需要信任所有的工作站和服务器

l只要信任集中式的认证服务器即可

![1574587855600](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211702.png)

![1574587986789](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211703.png)

##### 认证过程

简单的认证会话过程可以类比于以下过程：

- 学生(C)要借教室(S)，于是要先把自己的ID和证明自己是学生的密码(PS)和要借的教室号(IDS)告诉保安(AS)
- 保安给了学生一个一次性的钥匙(Ticket)
- 学生通过一次性钥匙去打开了教室门(S)

所以如果证明自己是学生的密码被偷，或者保安不在的话，就会出问题

更安全的认证可以类比以下过程:

- 学生(C)要借教室(S), 于是要先把自己的ID和老师(TGS)的ID，和现在的时间告诉保安(AS)
- 保安给了学生一袋东西，里面有票据和这个学生和老师都知道的一个共享的钥匙(Ticket_tgs)，学生是不能打开这袋东西的
- 然后学生要把这袋东西给老师(TGS)，老师就能验证一下，用保安很久之前就给他的钥匙打开了这袋东西，得到了共享的密钥，验证了这个学生确实就是他派出去的学生，就可以把这袋东西里面换成真正的钥匙和一个票据，这个票据是老师和这个教室的锁共享的，别人不知道
- 学生来到教室把这袋东西给教室的锁，锁就把真正的钥匙拿了出来开了门，并且把时间+1，表示正常的开门了。时间+1的目的是这个真正的钥匙可能会有有效期，用过多少次就会失效

##### 证书的层次结构  

每一个用户信任他的父节点的证书 ，通过层次化的结构，可以使一个CA下的用户验证任何其他CA下的用户的公钥证书

![image-20200113152433550](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210407211704.png)

说白了就是里面的节点既可以当公证也可以当申请的人，A要查看B的话要走一条到B的路径，经过一系列的公证，写下来即可。