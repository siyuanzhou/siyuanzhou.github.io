---
layout: post
title: "MySQL复习"
date: 2021-03-10 10:36
toc: true
comments: true
categories: 技术学习
tags:
	- 基础
	- 复习 
---

### MySQL

#### MySQL基础

##### 常用操作数据库的命令

<!--more-->

```SQL
show databases; 查看所有的数据库
create database test; 创建一个叫test的数据库
drop database test;删除一个叫test的数据库
show tables; 在选中的数据库之中查看所有的表
use test;选中库 ,在建表之前必须要选择数据库
drop table 表名; 删除表
truncate table 表名;清空表
create table 表名 (字段1 类型, 字段2 类型 not null，primary key(字段1),foreign key(字段2) references 表2[on delete cascade],check(字段1>0));创建表
default 0;默认值
desc 表名;查看所在的表的字段
show create table 表名; 查看创建表的详细信息
show create databases 库名;查看创建库的详细信息
```

![image-20210414105457070](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105510.png)

##### MySQL数据类型

![image-20200223175524201](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105511.png)

```
date '2001-04-25'
time '09:30:00'
timestamp '2001-04-25 10:29:01.45'
```

##### 改表 ：DDL 数据定义语言

```SQL
修改字段类型 alter table 表名 modify 字段 字段类型;
添加新的字段 alter table 表名 add 字段 字段类型
添加字段并指定位置  alter table 表名 add 字段 字段类型   after 字段;
删除表字段  alter table 表名 drop 字段名;
修改指定的字段  alter table 表名 change 原字段名字  新的字段名字 字段类型
```

##### 完整select

```SQL
SELECT select_expr [,select_expr,...] [      
      FROM tb_name
      [WHERE 条件判断]
      [GROUP BY {col_name | postion} [ASC | DESC], ...] 
      [HAVING WHERE 条件判断]
      [ORDER BY {col_name|expr|postion} [ASC | DESC], ...]
      [ LIMIT {[offset,]rowcount | row_count OFFSET offset}]
]
执行顺序为：
    from 表名
    where ....
    group by ...
    select distinct *
    having ...
    order by ...
    limit start,count
```

##### 数据操作：DQL数据查询语言 && DML数据操纵语言

```SQL
1.增加数据(insert)3种方式 
insert into 表名 values(值1，值2，...)(很少用)
insert into 表名(字段1，字段2...) values(值1，值2，....);（较常用）
insert into 表名(字段1，字段2...) values(值1，值2，....)，(值1，值2，....)，(值1，值2，....);

2.删除数据(delete) 
delete from 表名 where 条件 注意：where 条件必须加，否则数据会被全部删除

3.更新数据(update) 
update 表名 set 字段1 = 值1, 字段2 = 值2 where 条件

3.筛选重复值的字段    
select distinct 字段 from 表名
注意：where 必须加，否则数据全部修改

4.查询数据(select)
1.查询表中的所有数据   select * from 表名
2.指定数据查询    select [distinct] 字段 from 表名 
字符串函数 串联（||）,upper(s),trim(s),lower（s）,escape “\” 定义转义字符
集合 id [not] in(1,2)  模糊查询  ：like '%a%';%任意子串，_任意一个字符

4.根据条件查询出来的数据  select 字段 from 表名 where 条件 (最常用的)
where 条件后面跟的条件
 关系：>,<,>=,<=,!=  
 逻辑：or, and 
 区间：id between 4 and 6 ;闭区间，包含边界
 集合运算 并集 union [all],  交集 intersect, 补集 except
 >some 集合 :至少比一个大；>all 集合 比所有都大
 
5.结果集排序
    1, 通过字段来排序
    例如 ：select * from star orser by money desc, age asc; 
    select 字段 from 表 order by 字段  排序关键词(desc | asc)
    排序关键词 desc 降序 asc 升序(默认)
    2, 多字段排序
    select 字段 from 表 order by 字段1  desc |asc,...字段n desc| asc;

6.限制结果集
select  字段 from 表 limit 数量;
例如:select sum(id) from star                                                         
select * from 表名  limit 偏移量,数量
说明:
1.不写偏移量的话就是默认的为0
2.实现分页的时候必须写偏移量
  偏移量怎么计算？:
    limit (n-1)*数量 ,数量 
    
7.常用的统计函数
sum，avg，count，max,min
只分组:select * from 表 group by 字段
例子: select count(sex) as re,sex from star group by sex having re > 3;
分组统计: select count(sex) from star group by sex;
```

##### 多表联合查询

```SQL
1，内连接
隐式内连接 select username,name from user,goods where user.gid=gods.gid;
显示内连接
select username,from user inner join goods on user.gid=goods.gid;
select * from user left join goods on user.gid=goods.gid;
2.外链接
左连接 包含所有的左边表中的记录以及右边表中没有和他匹配的记录
右连接 
select * from user where gid in(select gid from goods);
select * from user right join goods on user.gid=goods.gid;
子嵌套查询
数据联合查询
select * from user left join goods on user.gid=goods.gid union select * from user right join goods on user.gid=goods.gid;
两个表同时更新
update user u, goods g set u.gid=12,g.price=1 where u.id=2 and u.gid=g.gid;
```

##### DCL 数据控制语言

```SQL
创建用户:create user'xiaoming'@'localhost' identified by '666666';
授权用户:grant all on test.* to 'xiaoming'@'localhost';
刷新权限:flush privileges;
取消授权:revoke all on test.* from 'xiaoming'@'localhost';
删除用户: drop user 'xiaoming'@'localhost';
```

##### DTL 数据事务语言

如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

```SQL
开启事务：set autocommit=0;
操作回滚：rollback;
提交事务：commit;
```

##### 视图

通俗的讲，视图就是一条SELECT语句执行后返回的结果集。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；视图一般不能插入。

```SQL
定义视图 建议以v_开头
create view 视图名称 as select语句;
查看表会将所有的视图也列出来
show tables;
视图的用途就是查询
select * from v_stu_score;
删除视图
drop view 视图名称; eg：drop view v_stu_sco;
```

##### JDBC

```java
//1. 导入驱动jar包
//2.注册驱动
Class.forName("com.mysql.jdbc.Driver");
//3.获取数据库连接对象
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "root");
//4.定义sql语句
String sql = "update account set balance = 500 where id = 1";
//5.获取执行sql的对象 Statement
Statement stmt = conn.createStatement();
//6.执行sql
int count = stmt.executeUpdate(sql);
String sql2 = "update account set balance = balance + ? where id = ?";
pstmt2 = conn.prepareStatement(sql2);
//4. 设置参数
pstmt2.setDouble(1, 500);
pstmt2.setInt(2, 2);
pstmt2.executeUpdate();
//7.处理结果
System.out.println(count);
//8.释放资源
stmt.close();
conn.close();
```

##### 数据库连接池

```
1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。
	    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。

2. 好处：
	1. 节约资源
	2. 用户访问高效

3. 实现：
	1. 标准接口：DataSource   javax.sql包下的
		1. 方法：
			* 获取连接：getConnection()
			* 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接

	2. 一般我们不去实现它，有数据库厂商来实现
		1. C3P0：数据库连接池技术
		2. Druid：数据库连接池实现技术，由阿里巴巴提供的
```

##### C3P0和Druid

```java
4. C3P0：数据库连接池技术
	* 步骤：
		1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，
			* 不要忘记导入数据库驱动jar包
		2. 定义配置文件：
			* 名称： c3p0.properties 或者 c3p0-config.xml
			* 路径：直接将文件放在src目录下即可。
			  	<!--  连接参数 -->
                <property name="driverClass">com.mysql.jdbc.Driver</property>
                <property name="jdbcUrl">jdbc:mysql://localhost:3306/day25</property>
                <property name="user">root</property>
                <property name="password">root</property>   
                <!-- 连接池参数 -->
                <property name="initialPoolSize">5</property>
                <property name="maxPoolSize">10</property>
                <property name="checkoutTimeout">3000</property>
		3. 创建核心对象 数据库连接池对象 ComboPooledDataSource
		4. 获取连接： getConnection
	* 代码：
		 //1.创建数据库连接池对象
        DataSource ds  = new ComboPooledDataSource();
        //2. 获取连接对象
        Connection conn = ds.getConnection();
5. Druid：数据库连接池实现技术，由阿里巴巴提供的
	1. 步骤：
		1. 导入jar包 druid-1.0.9.jar
		2. 定义配置文件：
			* 是properties形式的
			* 可以叫任意名称，可以放在任意目录下
			driverClassName=com.mysql.jdbc.Driver
            url=jdbc:mysql:///db3
            username=root
            password=root
            initialSize=5
            maxActive=10
            maxWait=3000
		3. 加载配置文件。Properties
		4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory
		5. 获取连接：getConnection
	* 代码：
		 //3.加载配置文件
        Properties pro = new Properties();
        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");
        pro.load(is);
        //4.获取连接池对象
        DataSource ds = DruidDataSourceFactory.createDataSource(pro);
        //5.获取连接
        Connection conn = ds.getConnection();
```

##### JDBCTemplate

```java
* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发
* 步骤：
	1. 导入jar包
	2. 创建JdbcTemplate对象。依赖于数据源DataSource
		* JdbcTemplate template = new JdbcTemplate(ds);

	3. 调用JdbcTemplate的方法来完成CRUD的操作
		* update():执行DML语句。增、删、改语句
		* queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合
			* 注意：这个方法查询的结果集长度只能是1
		* queryForList():查询结果将结果集封装为list集合
			* 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中
		* query():查询结果，将结果封装为JavaBean对象
			* query的参数：RowMapper
				* 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装
				* new BeanPropertyRowMapper<类型>(类型.class)
		* queryForObject：查询结果，将结果封装为对象
			* 一般用于聚合函数的查询

```

```java
public class JdbcTemplateDemo2 {
    //1. 获取JDBCTemplate对象
    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
    /**
     * 1. 修改1号数据的 salary 为 10000
     */
    @Test
    public void test1(){
        //2. 定义sql
        String sql = "update emp set salary = 10000 where id = 1001";
        //3. 执行sql
        int count = template.update(sql);
        System.out.println(count);
    }

    /**
     * 2. 添加一条记录
     */
    @Test
    public void test2(){
        String sql = "insert into emp(id,ename,dept_id) values(?,?,?)";
        int count = template.update(sql, 1015, "郭靖", 10);
        System.out.println(count);

    }

    /**
     * 3.删除刚才添加的记录
     */
    @Test
    public void test3(){
        String sql = "delete from emp where id = ?";
        int count = template.update(sql, 1015);
        System.out.println(count);
    }

    /**
     * 4.查询id为1001的记录，将其封装为Map集合
     * 注意：这个方法查询的结果集长度只能是1
     */
    @Test
    public void test4(){
        String sql = "select * from emp where id = ? or id = ?";
        Map<String, Object> map = template.queryForMap(sql, 1001,1002);
        System.out.println(map);
        //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}

    }

    /**
     * 5. 查询所有记录，将其封装为List
     */
    @Test
    public void test5(){
        String sql = "select * from emp";
        List<Map<String, Object>> list = template.queryForList(sql);

        for (Map<String, Object> stringObjectMap : list) {
            System.out.println(stringObjectMap);
        }
    }

    /**
     * 6. 查询所有记录，将其封装为Emp对象的List集合
     */
    @Test
    public void test6(){
        String sql = "select * from emp";
        List<Emp> list = template.query(sql, new RowMapper<Emp>() {

            @Override
            public Emp mapRow(ResultSet rs, int i) throws SQLException {
                Emp emp = new Emp();
                int id = rs.getInt("id");
                String ename = rs.getString("ename");
                int job_id = rs.getInt("job_id");
                int mgr = rs.getInt("mgr");
                Date joindate = rs.getDate("joindate");
                double salary = rs.getDouble("salary");
                double bonus = rs.getDouble("bonus");
                int dept_id = rs.getInt("dept_id");

                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setJoindate(joindate);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                return emp;
            }
        });
        for (Emp emp : list) {
            System.out.println(emp);
        }
    }

    /**
     * 6. 查询所有记录，将其封装为Emp对象的List集合
     */
    @Test
    public void test6_2(){
        String sql = "select * from emp";
        List<Emp> list = template.query(sql, new BeanPropertyRowMapper<Emp>(Emp.class));
        for (Emp emp : list) {
            System.out.println(emp);
        }
    }

    /**
     * 7. 查询总记录数
     */
    @Test
    public void test7(){
        String sql = "select count(id) from emp";
        Long total = template.queryForObject(sql, Long.class);
        System.out.println(total);
    }
}
```

##### 数据库三大范式

1、码：能唯一确定一条记录的一个/多个属性。码包括主码和候选码。任意一个候选码也能作为主键。其中主码/候选码的任意一个真子集都不能确定一条记录。

2、主属性：构成**主码**或**候选码**的属性都叫主属性！千万不要误认为候选码的属性不是主属性！

3、非主属性：除了主属性以外的属性都为非主属性。

4、传递依赖：如果存在A → B → C的决定关系，则C传递函数依赖于A。(学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)有如下传递依赖(学号) → (所在学院) → (学院地点, 学院电话)

5、部分依赖：（学号和身份证）->姓名，姓名部分函数依赖于(学号和身份证)

第一范式：数据库的字段是单一属性，不可再分

第二范式：每个非主属性都完全函数依赖于主键，目的是去除**非主属性**对**码**的部分依赖。（学号和身份证）->姓名

第三范式：非关键字字段必须直接依赖任一侯选关键字，目的是去除**非主属性**对**码**的传递依赖。(学号) → (所在学院) → (学院地点)

BC范式：消除主属性对码的传递和函数依赖，消除（仓库名，管理员，物品名）->数量中仓库名 → 管理员主属性部分依赖

#### 索引

```SQL
查看索引
show index from 表名;
创建索引
如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致
字段类型如果不是字符串，可以不填写长度部分
create index 索引名称 on 表名(字段名称(长度))
删除索引：
drop index 索引名称 on 表名;
```

##### 索引特点和优缺点

![image-20210307222031035](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105512.png)

##### 在哪里建索引

![image-20210308105225087](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105513.png)

##### 索引建立原则

（id，name) where id=1 and name='xxx'

```
1.最左前缀匹配原则，mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，范围查询会导致组合索引半生效。比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，c 可以用到索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。where范围查询要放在最后 （这不绝对，但可以利用一部分索引）。
2. 特别注意：and 之间的部分可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。where 字句有 or 出现还是会遍历全表。
3. 尽量选择区分度高的字段作为索引,某字段的区分度的公式是 count(distinctcol)/count(*)，表示字段不重复的比例，比例越大，我们扫描的记录数越少，查找匹配的时候可以过滤更多的行， 唯一索引的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0。
4. 不在索引列做运算或者使用函数。
5. 尽量扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
6. Where 子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。
7. like 模糊查询中，右模糊查询（321%）会使用索引，而%321 和%321%会放弃索引而使用全局扫描。
```

##### 索引分类

![image-20210308141645229](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105514.png)

#### InnoDB

innoDB 的数据保存在表空间中，表空间又包含各种段，其中有数据段，索引段，回滚段。InnoDB中数据以B+Tree的数据结构存储的，非叶子节点既是索引，叶子节点既是数据行，回滚段用于存储undoLog，undoLog中记录的就是多版本数据，用于快照读和事务失败后的数据回滚,MySQL在合适的时机会清理undoLog。

![img](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105515.webp)

#### InnoDB与MyISAM

![image-20210308105617479](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105516.png)

![image-20210308141746008](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105517.png)

![image-20210308105654476](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105518.png)

##### 自增主键删除

一张表,里面有 ID 自增主键,当 insert 了 17 条记录之后,删除了第 15,16,17 条记录,再把 Mysql 重启,再 insert 一
条记录,这条记录的 ID 是 18 还是 15 ？
如果表的类型是 MyISAM， 那么是 18。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里， 重启MySQL自增主键的最大 ID 也不会丢失。
如果表的类型是 InnoDB， 那么是 15。InnoDB 表只是把自增主键的最大 ID 记录到内存中， 所以重启数据库会导
致最大 ID 丢失。

#### MVCC

MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。

如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读者，**在某个瞬间看到的是数据库的一个快照**，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于**其他的读者来说是不可见**的。

一句话讲，MVCC就是用 **同一份数据临时保留多版本的方式** 的方式，实现并发控制。

什么是多版本并发控制呢 ？其实就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，而每一个事务在启动的时候，都有一个唯一的递增的版本号。
1、在插入操作时 ： 记录的创建版本号就是事务版本号。
比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。

![image-20210408163551921](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105519.png)

2、在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新
的记录的方式。
比如，针对上面那行记录，事务Id为2 要把name字段更新
update table set name= 'new_value' where id=1;

![image-20210408163628472](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105520.png)

3、删除操作的时候，就把事务版本号作为删除版本号。比如
delete from table where id=1;

![image-20210408163653776](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105521.png)

4、查询操作：
从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：
1）InnoDB只查找**版本早于当前事务版本**的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，只么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2）行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删
除。
这样就保证了各个事务互不影响。从这里也可以体会到一种提高系统性能的思路，就是：
**通过版本号来减少锁的争用**。

#### 事务

##### 事务的四大特征

```
1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
3. 隔离性：并发的事务之间不会互相影响，相互独立。
4. 一致性：事务操作前后，数据总量不变
```

##### 并发事务带来的问题

**丢失更新**
如果两个事务都要更新数据库一个字段X，x=100

![image-20210408162727975](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105522.png)

两个不同事物同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务更新会被后提交事务的
更新给覆盖掉，这种情况事务A的更新就被覆盖掉了、丢失了。
**脏读（未提交读）**
防止一个事务读到另一个事务还没有提交的记录。 如：

![image-20210408162746429](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105523.png)

事务读取了未提交的数据，事务B的回滚，导致了事务A的数据不一致，导致了事务A的脏读 ！
**不可重复读**
一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的；如果不一致，
就说明为不可重复读。 还是用上面的例子

![image-20210408162804468](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105524.png)


这种情况事务A多次读取x的结果出现了不一致，即为不可重复读 。
**幻读（Phantom Read）**
事务A读的时候读出了15条记录，事务B在事务A执行的过程中 增加 了1条，事务A再读的时候就变成了 16 条，这
种情况就叫做幻影读。 不可重复读说明了做数据库读操作的时候可能会出现的问题。

##### 事务隔离级别（恶果：脏读、 不可重复读、幻读 ）

![image-20210307222230326](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105525.png)

![image-20210308105723199](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105526.png)

```
read uncommited ：读到未提交数据 A线程读到B未submit的数据
read committed：脏读，不可重复读  A线程读到B submit的数据，两次查询不同
repeatable read：可重读  A线程读到B insert的数据，第一次没有，第二次有了
serializable ：串行事物
```

##### 封锁协议（解决脏读不可重复读）

**一级封锁协议 （对应 read uncommited）**
一级封锁协议是：事务 在对需要修改的数据上面（就是在发生修改的瞬间） 对其加共享锁（其他事务不能更改，
但是可以读取-导致“脏读”），直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。
一级封锁协议不能避免 丢失更新，脏读，不可重复读，幻读！

##### GAP 锁（间隙锁解决幻读）

在索引记录的间隙上加锁，禁止插入，这样就避免了幻读

![image-20210308154325058](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105527.png)

#####  next-key 锁

![image-20210308154445909](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105528.png)

##### 分布式事务

指事务的资源分别位于不同的分布式系统的不同节点上的事务，需要保证事务的 ACID 特性。

![image-20210408121957422](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105529.png)

**产生原因**

* 数据库分库分表

* 业务服务化

  业务按照面向服务（SOA）的架构拆分整个网站系统：如金融网站拆分为交易系统、账务系统等。

分布式事务用于在分布式系统中保证不同节点之间的数据一致性。分布式事务的实现有很多种，最具有代表性的是
由Oracle Tuxedo系统提出的XA分布式事务协议。
XA协议包含**两阶段提交（2PC）和三阶段提交（3PC）**两种实现

##### 事务两阶段提交（2PC）

在XA协议中包含着两个角色：事务协调者和事务参与者。

![image-20210408122202911](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105530.png)

在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。
在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。
当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。

![image-20210408122223925](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105531.png)

在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。
接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。
当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。
以上所描述的是XA两阶段提交的正向流程，接下来我们看一看失败情况的处理流程：

![image-20210408122438925](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105532.png)

在XA的第一阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。
于是在第二阶段，事务协调节点向所有的事务参与者发送Abort请求。接收到Abort请求之后，各个事务参与者节点
需要在本地进行事务的回滚操作，回滚操作依照Undo Log来进行。
以上就是XA两阶段提交协议的详细过程。

##### XA两阶段提交的不足

XA两阶段提交究竟有哪些不足呢？
**1.性能问题 同步阻塞**
XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。
**2.协调者单点故障问题**
事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。
**3.丢失消息导致的不一致问题。**
在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。

**4 太过保守**

任意一个节点失败就会导致整个事务失败，没有完善的容错机制。

##### XA三阶段提交（3PC）

XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。

##### MQ事务

利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。

##### TCC事务

TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于XA两阶段提交，但是实现方式是在代码层面来人为实现。

![image-20210408123158032](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105533.png)

##### 柔性事务

单数据库事务完全遵循 ACID 规范，属于刚性事务，分布式事务要完全遵循 ACID 规范比较困难，属于柔性事务，满足 **BASE** 理论。

* **BA：Basic Availability** 基本业务可用性

* **S：Soft state** 柔性状态

* **E：Eventual consistency** 最终一致性

柔性事务对 ACID 的支持：

1. 原子性：严格遵循
2. 一致性：事务完成后的一致性严格遵循，事务中的一致性可适当放宽
3. 隔离性：并行事务间不可影响，事务中间结果可见性允许安全放宽
4. 持久性：严格遵循

**分类**

1. **两阶段型**

   XA、JTA/JTS 属于该类型，为分布式环境下事务处理的典型模式。

2. **补偿型**

   TCC 可以归为该类型，其思路为：尽早释放锁，在 Try 成功的情况下如果事务要回滚，则 Cancel 将作为补偿机制回滚 Try 操作。

3. **异步确保型**

   将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用；比如消息事务机制。

4. **最大努力通知型**

   通过通知服务器（消息通知）进行，允许失败，有补充机制；

#### Sql 优化

![image-20210308142154220](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105534.png)

![image-20210308142212180](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105535.png)

#### 分库分表

![image-20210308142549375](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105536.png)

#### 数据库锁

![image-20210308142652289](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105537.png)

![image-20210308142707570](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105538.png)

##### 封锁协议（解决脏读不可重复读）

![image-20210308142817068](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105539.png)

![image-20210308142833910](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105540.png)

![image-20210308142845141](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105541.png)

![image-20210308143011980](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105542.png)

##### 死锁活锁

![image-20210308145752680](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105543.png)

![image-20210308145808709](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105544.png)

##### 两阶段协议

![image-20210308145850964](https://cdn.jsdelivr.net/gh/siyuanzhou/pic/img/20210414105545.png)

